// ==UserScript==
// @name         Toolasha
// @namespace    http://tampermonkey.net/
// @version      0.26.0
// @downloadURL  https://greasyfork.org/scripts/562662-toolasha/code/Toolasha.user.js
// @updateURL    https://greasyfork.org/scripts/562662-toolasha/code/Toolasha.meta.js
// @description  Toolasha - Enhanced tools for Milky Way Idle.
// @author       Celasha and Claude, thank you to bot7420, DrDucky, Frotty, Truth_Light, AlphB, qu, and sentientmilk, for providing the basis for a lot of this. Thank you to Miku, Orvel, Jigglymoose, Incinarator, Knerd, and others for their time and help. Thank you to Steez for testing and helping me figure out where I'm wrong! Thank you to Tib for his generous contribution of the Character Cards. Thank you to Sapnas for -deeply- testing and singlehandedly help me improve performance. Special thanks to Zaeter for the name.
// @license      CC-BY-NC-SA-4.0
// @run-at       document-start
// @match        https://www.milkywayidle.com/*
// @match        https://test.milkywayidle.com/*
// @match        https://shykai.github.io/MWICombatSimulatorTest/dist/*
// @grant        GM_addStyle
// @grant        GM.xmlHttpRequest
// @grant        GM_xmlhttpRequest
// @grant        GM_notification
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        unsafeWindow
// ==/UserScript==
// Note: Combat Sim auto-import requires Tampermonkey for cross-domain storage. Not available on Steam (use manual clipboard copy/paste instead).


// ===== VENDORED LIBRARIES (mathjs, chart.js, chartjs-plugin-datalabels) =====
/*! For license information please see math.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.math=t():e.math=t()}(this,(()=>(()=>{var e={5716:function(e,t){var r;!function(n){"use strict";var i=Math.cosh||function(e){return Math.abs(e)<1e-9?1-e:.5*(Math.exp(e)+Math.exp(-e))},a=Math.sinh||function(e){return Math.abs(e)<1e-9?e:.5*(Math.exp(e)-Math.exp(-e))},o=function(){throw SyntaxError("Invalid Param")};function u(e,t){var r=Math.abs(e),n=Math.abs(t);return 0===e?Math.log(n):0===t?Math.log(r):r<3e3&&n<3e3?.5*Math.log(e*e+t*t):(e/=2,t/=2,.5*Math.log(e*e+t*t)+Math.LN2)}function s(e,t){if(!(this instanceof s))return new s(e,t);var r=function(e,t){var r={re:0,im:0};if(null==e)r.re=r.im=0;else if(void 0!==t)r.re=e,r.im=t;else switch(typeof e){case"object":if("im"in e&&"re"in e)r.re=e.re,r.im=e.im;else if("abs"in e&&"arg"in e){if(!Number.isFinite(e.abs)&&Number.isFinite(e.arg))return s.INFINITY;r.re=e.abs*Math.cos(e.arg),r.im=e.abs*Math.sin(e.arg)}else if("r"in e&&"phi"in e){if(!Number.isFinite(e.r)&&Number.isFinite(e.phi))return s.INFINITY;r.re=e.r*Math.cos(e.phi),r.im=e.r*Math.sin(e.phi)}else 2===e.length?(r.re=e[0],r.im=e[1]):o();break;case"string":r.im=r.re=0;var n=e.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g),i=1,a=0;null===n&&o();for(var u=0;u<n.length;u++){var c=n[u];" "===c||"\t"===c||"\n"===c||("+"===c?i++:"-"===c?a++:"i"===c||"I"===c?(i+a===0&&o()," "===n[u+1]||isNaN(n[u+1])?r.im+=parseFloat((a%2?"-":"")+"1"):(r.im+=parseFloat((a%2?"-":"")+n[u+1]),u++),i=a=0):((i+a===0||isNaN(c))&&o(),"i"===n[u+1]||"I"===n[u+1]?(r.im+=parseFloat((a%2?"-":"")+c),u++):r.re+=parseFloat((a%2?"-":"")+c),i=a=0))}i+a>0&&o();break;case"number":r.im=0,r.re=e;break;default:o()}return isNaN(r.re)||isNaN(r.im),r}(e,t);this.re=r.re,this.im=r.im}s.prototype={re:0,im:0,sign:function(){var e=this.abs();return new s(this.re/e,this.im/e)},add:function(e,t){var r=new s(e,t);return this.isInfinite()&&r.isInfinite()?s.NAN:this.isInfinite()||r.isInfinite()?s.INFINITY:new s(this.re+r.re,this.im+r.im)},sub:function(e,t){var r=new s(e,t);return this.isInfinite()&&r.isInfinite()?s.NAN:this.isInfinite()||r.isInfinite()?s.INFINITY:new s(this.re-r.re,this.im-r.im)},mul:function(e,t){var r=new s(e,t);return this.isInfinite()&&r.isZero()||this.isZero()&&r.isInfinite()?s.NAN:this.isInfinite()||r.isInfinite()?s.INFINITY:0===r.im&&0===this.im?new s(this.re*r.re,0):new s(this.re*r.re-this.im*r.im,this.re*r.im+this.im*r.re)},div:function(e,t){var r=new s(e,t);if(this.isZero()&&r.isZero()||this.isInfinite()&&r.isInfinite())return s.NAN;if(this.isInfinite()||r.isZero())return s.INFINITY;if(this.isZero()||r.isInfinite())return s.ZERO;e=this.re,t=this.im;var n,i,a=r.re,o=r.im;return 0===o?new s(e/a,t/a):Math.abs(a)<Math.abs(o)?new s((e*(i=a/o)+t)/(n=a*i+o),(t*i-e)/n):new s((e+t*(i=o/a))/(n=o*i+a),(t-e*i)/n)},pow:function(e,t){var r=new s(e,t);if(e=this.re,t=this.im,r.isZero())return s.ONE;if(0===r.im){if(0===t&&e>0)return new s(Math.pow(e,r.re),0);if(0===e)switch((r.re%4+4)%4){case 0:return new s(Math.pow(t,r.re),0);case 1:return new s(0,Math.pow(t,r.re));case 2:return new s(-Math.pow(t,r.re),0);case 3:return new s(0,-Math.pow(t,r.re))}}if(0===e&&0===t&&r.re>0&&r.im>=0)return s.ZERO;var n=Math.atan2(t,e),i=u(e,t);return e=Math.exp(r.re*i-r.im*n),t=r.im*i+r.re*n,new s(e*Math.cos(t),e*Math.sin(t))},sqrt:function(){var e,t,r=this.re,n=this.im,i=this.abs();if(r>=0){if(0===n)return new s(Math.sqrt(r),0);e=.5*Math.sqrt(2*(i+r))}else e=Math.abs(n)/Math.sqrt(2*(i-r));return t=r<=0?.5*Math.sqrt(2*(i-r)):Math.abs(n)/Math.sqrt(2*(i+r)),new s(e,n<0?-t:t)},exp:function(){var e=Math.exp(this.re);return this.im,new s(e*Math.cos(this.im),e*Math.sin(this.im))},expm1:function(){var e=this.re,t=this.im;return new s(Math.expm1(e)*Math.cos(t)+function(e){var t=Math.PI/4;if(-t>e||e>t)return Math.cos(e)-1;var r=e*e;return r*(r*(r*(r*(r*(r*(r*(r/20922789888e3-1/87178291200)+1/479001600)-1/3628800)+1/40320)-1/720)+1/24)-.5)}(t),Math.exp(e)*Math.sin(t))},log:function(){var e=this.re,t=this.im;return new s(u(e,t),Math.atan2(t,e))},abs:function(){return e=this.re,t=this.im,r=Math.abs(e),n=Math.abs(t),r<3e3&&n<3e3?Math.sqrt(r*r+n*n):(r<n?(r=n,n=e/t):n=t/e,r*Math.sqrt(1+n*n));var e,t,r,n},arg:function(){return Math.atan2(this.im,this.re)},sin:function(){var e=this.re,t=this.im;return new s(Math.sin(e)*i(t),Math.cos(e)*a(t))},cos:function(){var e=this.re,t=this.im;return new s(Math.cos(e)*i(t),-Math.sin(e)*a(t))},tan:function(){var e=2*this.re,t=2*this.im,r=Math.cos(e)+i(t);return new s(Math.sin(e)/r,a(t)/r)},cot:function(){var e=2*this.re,t=2*this.im,r=Math.cos(e)-i(t);return new s(-Math.sin(e)/r,a(t)/r)},sec:function(){var e=this.re,t=this.im,r=.5*i(2*t)+.5*Math.cos(2*e);return new s(Math.cos(e)*i(t)/r,Math.sin(e)*a(t)/r)},csc:function(){var e=this.re,t=this.im,r=.5*i(2*t)-.5*Math.cos(2*e);return new s(Math.sin(e)*i(t)/r,-Math.cos(e)*a(t)/r)},asin:function(){var e=this.re,t=this.im,r=new s(t*t-e*e+1,-2*e*t).sqrt(),n=new s(r.re-t,r.im+e).log();return new s(n.im,-n.re)},acos:function(){var e=this.re,t=this.im,r=new s(t*t-e*e+1,-2*e*t).sqrt(),n=new s(r.re-t,r.im+e).log();return new s(Math.PI/2-n.im,n.re)},atan:function(){var e=this.re,t=this.im;if(0===e){if(1===t)return new s(0,1/0);if(-1===t)return new s(0,-1/0)}var r=e*e+(1-t)*(1-t),n=new s((1-t*t-e*e)/r,-2*e/r).log();return new s(-.5*n.im,.5*n.re)},acot:function(){var e=this.re,t=this.im;if(0===t)return new s(Math.atan2(1,e),0);var r=e*e+t*t;return 0!==r?new s(e/r,-t/r).atan():new s(0!==e?e/0:0,0!==t?-t/0:0).atan()},asec:function(){var e=this.re,t=this.im;if(0===e&&0===t)return new s(0,1/0);var r=e*e+t*t;return 0!==r?new s(e/r,-t/r).acos():new s(0!==e?e/0:0,0!==t?-t/0:0).acos()},acsc:function(){var e=this.re,t=this.im;if(0===e&&0===t)return new s(Math.PI/2,1/0);var r=e*e+t*t;return 0!==r?new s(e/r,-t/r).asin():new s(0!==e?e/0:0,0!==t?-t/0:0).asin()},sinh:function(){var e=this.re,t=this.im;return new s(a(e)*Math.cos(t),i(e)*Math.sin(t))},cosh:function(){var e=this.re,t=this.im;return new s(i(e)*Math.cos(t),a(e)*Math.sin(t))},tanh:function(){var e=2*this.re,t=2*this.im,r=i(e)+Math.cos(t);return new s(a(e)/r,Math.sin(t)/r)},coth:function(){var e=2*this.re,t=2*this.im,r=i(e)-Math.cos(t);return new s(a(e)/r,-Math.sin(t)/r)},csch:function(){var e=this.re,t=this.im,r=Math.cos(2*t)-i(2*e);return new s(-2*a(e)*Math.cos(t)/r,2*i(e)*Math.sin(t)/r)},sech:function(){var e=this.re,t=this.im,r=Math.cos(2*t)+i(2*e);return new s(2*i(e)*Math.cos(t)/r,-2*a(e)*Math.sin(t)/r)},asinh:function(){var e=this.im;this.im=-this.re,this.re=e;var t=this.asin();return this.re=-this.im,this.im=e,e=t.re,t.re=-t.im,t.im=e,t},acosh:function(){var e=this.acos();if(e.im<=0){var t=e.re;e.re=-e.im,e.im=t}else t=e.im,e.im=-e.re,e.re=t;return e},atanh:function(){var e=this.re,t=this.im,r=e>1&&0===t,n=1-e,i=1+e,a=n*n+t*t,o=0!==a?new s((i*n-t*t)/a,(t*n+i*t)/a):new s(-1!==e?e/0:0,0!==t?t/0:0),c=o.re;return o.re=u(o.re,o.im)/2,o.im=Math.atan2(o.im,c)/2,r&&(o.im=-o.im),o},acoth:function(){var e=this.re,t=this.im;if(0===e&&0===t)return new s(0,Math.PI/2);var r=e*e+t*t;return 0!==r?new s(e/r,-t/r).atanh():new s(0!==e?e/0:0,0!==t?-t/0:0).atanh()},acsch:function(){var e=this.re,t=this.im;if(0===t)return new s(0!==e?Math.log(e+Math.sqrt(e*e+1)):1/0,0);var r=e*e+t*t;return 0!==r?new s(e/r,-t/r).asinh():new s(0!==e?e/0:0,0!==t?-t/0:0).asinh()},asech:function(){var e=this.re,t=this.im;if(this.isZero())return s.INFINITY;var r=e*e+t*t;return 0!==r?new s(e/r,-t/r).acosh():new s(0!==e?e/0:0,0!==t?-t/0:0).acosh()},inverse:function(){if(this.isZero())return s.INFINITY;if(this.isInfinite())return s.ZERO;var e=this.re,t=this.im,r=e*e+t*t;return new s(e/r,-t/r)},conjugate:function(){return new s(this.re,-this.im)},neg:function(){return new s(-this.re,-this.im)},ceil:function(e){return e=Math.pow(10,e||0),new s(Math.ceil(this.re*e)/e,Math.ceil(this.im*e)/e)},floor:function(e){return e=Math.pow(10,e||0),new s(Math.floor(this.re*e)/e,Math.floor(this.im*e)/e)},round:function(e){return e=Math.pow(10,e||0),new s(Math.round(this.re*e)/e,Math.round(this.im*e)/e)},equals:function(e,t){var r=new s(e,t);return Math.abs(r.re-this.re)<=s.EPSILON&&Math.abs(r.im-this.im)<=s.EPSILON},clone:function(){return new s(this.re,this.im)},toString:function(){var e=this.re,t=this.im,r="";return this.isNaN()?"NaN":this.isInfinite()?"Infinity":(Math.abs(e)<s.EPSILON&&(e=0),Math.abs(t)<s.EPSILON&&(t=0),0===t?r+e:(0!==e?(r+=e,r+=" ",t<0?(t=-t,r+="-"):r+="+",r+=" "):t<0&&(t=-t,r+="-"),1!==t&&(r+=t),r+"i"))},toVector:function(){return[this.re,this.im]},valueOf:function(){return 0===this.im?this.re:null},isNaN:function(){return isNaN(this.re)||isNaN(this.im)},isZero:function(){return 0===this.im&&0===this.re},isFinite:function(){return isFinite(this.re)&&isFinite(this.im)},isInfinite:function(){return!(this.isNaN()||this.isFinite())}},s.ZERO=new s(0,0),s.ONE=new s(1,0),s.I=new s(0,1),s.PI=new s(Math.PI,0),s.E=new s(Math.E,0),s.INFINITY=new s(1/0,1/0),s.NAN=new s(NaN,NaN),s.EPSILON=1e-15,void 0===(r=function(){return s}.apply(t,[]))||(e.exports=r)}()},3144:e=>{"use strict";var t=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},r={"{":"\\{","}":"\\}","\\":"\\textbackslash{}","#":"\\#",$:"\\$","%":"\\%","&":"\\&","^":"\\textasciicircum{}",_:"\\_","~":"\\textasciitilde{}"},n={"–":"\\--","—":"\\---"," ":"~","\t":"\\qquad{}","\r\n":"\\newline{}","\n":"\\newline{}"},i=function(e,r){return t({},e,r)};e.exports=function(e){for(var a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=a.preserveFormatting,u=void 0!==o&&o,s=a.escapeMapFn,c=void 0===s?i:s,f=String(e),l="",p=c(t({},r),u?t({},n):{}),m=Object.keys(p),h=function(){var e=!1;m.forEach((function(t,r){e||f.length>=t.length&&f.slice(0,t.length)===t&&(l+=p[m[r]],f=f.slice(t.length,f.length),e=!0)})),e||(l+=f.slice(0,1),f=f.slice(1,f.length))};f;)h();return l}},3996:function(e){!function(t){"use strict";var r={s:1,n:0,d:1};function n(e,t){if(isNaN(e=parseInt(e,10)))throw f();return e*t}function i(e,t){if(0===t)throw c();var r=Object.create(s.prototype);r.s=e<0?-1:1;var n=u(e=e<0?-e:e,t);return r.n=e/n,r.d=t/n,r}function a(e){for(var t={},r=e,n=2,i=4;i<=r;){for(;r%n==0;)r/=n,t[n]=(t[n]||0)+1;i+=1+2*n++}return r!==e?r>1&&(t[r]=(t[r]||0)+1):t[e]=(t[e]||0)+1,t}var o=function(e,t){var i,a=0,o=1,u=1,s=0,p=0,m=0,h=1,d=1,v=0,y=1,g=1,x=1,b=1e7;if(null==e);else if(void 0!==t){if(u=(a=e)*(o=t),a%1!=0||o%1!=0)throw l()}else switch(typeof e){case"object":if("d"in e&&"n"in e)a=e.n,o=e.d,"s"in e&&(a*=e.s);else{if(!(0 in e))throw f();a=e[0],1 in e&&(o=e[1])}u=a*o;break;case"number":if(e<0&&(u=e,e=-e),e%1==0)a=e;else if(e>0){for(e>=1&&(e/=d=Math.pow(10,Math.floor(1+Math.log(e)/Math.LN10)));y<=b&&x<=b;){if(e===(i=(v+g)/(y+x))){y+x<=b?(a=v+g,o=y+x):x>y?(a=g,o=x):(a=v,o=y);break}e>i?(v+=g,y+=x):(g+=v,x+=y),y>b?(a=g,o=x):(a=v,o=y)}a*=d}else(isNaN(e)||isNaN(t))&&(o=a=NaN);break;case"string":if(null===(y=e.match(/\d+|./g)))throw f();if("-"===y[v]?(u=-1,v++):"+"===y[v]&&v++,y.length===v+1?p=n(y[v++],u):"."===y[v+1]||"."===y[v]?("."!==y[v]&&(s=n(y[v++],u)),(1+ ++v===y.length||"("===y[v+1]&&")"===y[v+3]||"'"===y[v+1]&&"'"===y[v+3])&&(p=n(y[v],u),h=Math.pow(10,y[v].length),v++),("("===y[v]&&")"===y[v+2]||"'"===y[v]&&"'"===y[v+2])&&(m=n(y[v+1],u),d=Math.pow(10,y[v+1].length)-1,v+=3)):"/"===y[v+1]||":"===y[v+1]?(p=n(y[v],u),h=n(y[v+2],1),v+=3):"/"===y[v+3]&&" "===y[v+1]&&(s=n(y[v],u),p=n(y[v+2],u),h=n(y[v+4],1),v+=5),y.length<=v){u=a=m+(o=h*d)*s+d*p;break}default:throw f()}if(0===o)throw c();r.s=u<0?-1:1,r.n=Math.abs(a),r.d=Math.abs(o)};function u(e,t){if(!e)return t;if(!t)return e;for(;;){if(!(e%=t))return t;if(!(t%=e))return e}}function s(e,t){if(o(e,t),!(this instanceof s))return i(r.s*r.n,r.d);e=u(r.d,r.n),this.s=r.s,this.n=r.n/e,this.d=r.d/e}var c=function(){return new Error("Division by Zero")},f=function(){return new Error("Invalid argument")},l=function(){return new Error("Parameters must be integer")};s.prototype={s:1,n:0,d:1,abs:function(){return i(this.n,this.d)},neg:function(){return i(-this.s*this.n,this.d)},add:function(e,t){return o(e,t),i(this.s*this.n*r.d+r.s*this.d*r.n,this.d*r.d)},sub:function(e,t){return o(e,t),i(this.s*this.n*r.d-r.s*this.d*r.n,this.d*r.d)},mul:function(e,t){return o(e,t),i(this.s*r.s*this.n*r.n,this.d*r.d)},div:function(e,t){return o(e,t),i(this.s*r.s*this.n*r.d,this.d*r.n)},clone:function(){return i(this.s*this.n,this.d)},mod:function(e,t){if(isNaN(this.n)||isNaN(this.d))return new s(NaN);if(void 0===e)return i(this.s*this.n%this.d,1);if(o(e,t),0===r.n&&0===this.d)throw c();return i(this.s*(r.d*this.n)%(r.n*this.d),r.d*this.d)},gcd:function(e,t){return o(e,t),i(u(r.n,this.n)*u(r.d,this.d),r.d*this.d)},lcm:function(e,t){return o(e,t),0===r.n&&0===this.n?i(0,1):i(r.n*this.n,u(r.n,this.n)*u(r.d,this.d))},ceil:function(e){return e=Math.pow(10,e||0),isNaN(this.n)||isNaN(this.d)?new s(NaN):i(Math.ceil(e*this.s*this.n/this.d),e)},floor:function(e){return e=Math.pow(10,e||0),isNaN(this.n)||isNaN(this.d)?new s(NaN):i(Math.floor(e*this.s*this.n/this.d),e)},round:function(e){return e=Math.pow(10,e||0),isNaN(this.n)||isNaN(this.d)?new s(NaN):i(Math.round(e*this.s*this.n/this.d),e)},inverse:function(){return i(this.s*this.d,this.n)},pow:function(e,t){if(o(e,t),1===r.d)return r.s<0?i(Math.pow(this.s*this.d,r.n),Math.pow(this.n,r.n)):i(Math.pow(this.s*this.n,r.n),Math.pow(this.d,r.n));if(this.s<0)return null;var n=a(this.n),u=a(this.d),s=1,c=1;for(var f in n)if("1"!==f){if("0"===f){s=0;break}if(n[f]*=r.n,n[f]%r.d!=0)return null;n[f]/=r.d,s*=Math.pow(f,n[f])}for(var f in u)if("1"!==f){if(u[f]*=r.n,u[f]%r.d!=0)return null;u[f]/=r.d,c*=Math.pow(f,u[f])}return r.s<0?i(c,s):i(s,c)},equals:function(e,t){return o(e,t),this.s*this.n*r.d==r.s*r.n*this.d},compare:function(e,t){o(e,t);var n=this.s*this.n*r.d-r.s*r.n*this.d;return(0<n)-(n<0)},simplify:function(e){if(isNaN(this.n)||isNaN(this.d))return this;e=e||.001;for(var t=this.abs(),r=t.toContinued(),n=1;n<r.length;n++){for(var a=i(r[n-1],1),o=n-2;o>=0;o--)a=a.inverse().add(r[o]);if(Math.abs(a.sub(t).valueOf())<e)return a.mul(this.s)}return this},divisible:function(e,t){return o(e,t),!(!(r.n*this.d)||this.n*r.d%(r.n*this.d))},valueOf:function(){return this.s*this.n/this.d},toFraction:function(e){var t,r="",n=this.n,i=this.d;return this.s<0&&(r+="-"),1===i?r+=n:(e&&(t=Math.floor(n/i))>0&&(r+=t,r+=" ",n%=i),r+=n,r+="/",r+=i),r},toLatex:function(e){var t,r="",n=this.n,i=this.d;return this.s<0&&(r+="-"),1===i?r+=n:(e&&(t=Math.floor(n/i))>0&&(r+=t,n%=i),r+="\\frac{",r+=n,r+="}{",r+=i,r+="}"),r},toContinued:function(){var e,t=this.n,r=this.d,n=[];if(isNaN(t)||isNaN(r))return n;do{n.push(Math.floor(t/r)),e=t%r,t=r,r=e}while(1!==t);return n},toString:function(e){var t=this.n,r=this.d;if(isNaN(t)||isNaN(r))return"NaN";e=e||15;var n=function(e,t){for(;t%2==0;t/=2);for(;t%5==0;t/=5);if(1===t)return 0;for(var r=10%t,n=1;1!==r;n++)if(r=10*r%t,n>2e3)return 0;return n}(0,r),i=function(e,t,r){for(var n=1,i=function(e,t,r){for(var n=1;t>0;e=e*e%r,t>>=1)1&t&&(n=n*e%r);return n}(10,r,t),a=0;a<300;a++){if(n===i)return a;n=10*n%t,i=10*i%t}return 0}(0,r,n),a=this.s<0?"-":"";if(a+=t/r|0,t%=r,(t*=10)&&(a+="."),n){for(var o=i;o--;)a+=t/r|0,t%=r,t*=10;for(a+="(",o=n;o--;)a+=t/r|0,t%=r,t*=10;a+=")"}else for(o=e;t&&o--;)a+=t/r|0,t%=r,t*=10;return a}},Object.defineProperty(s,"__esModule",{value:!0}),s.default=s,s.Fraction=s,e.exports=s}()},1880:e=>{e.exports=function e(t,r){"use strict";var n,i,a=/(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,o=/(^[ ]*|[ ]*$)/g,u=/(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,s=/^0x[0-9a-f]+$/i,c=/^0/,f=function(t){return e.insensitive&&(""+t).toLowerCase()||""+t},l=f(t).replace(o,"")||"",p=f(r).replace(o,"")||"",m=l.replace(a,"\0$1\0").replace(/\0$/,"").replace(/^\0/,"").split("\0"),h=p.replace(a,"\0$1\0").replace(/\0$/,"").replace(/^\0/,"").split("\0"),d=parseInt(l.match(s),16)||1!==m.length&&l.match(u)&&Date.parse(l),v=parseInt(p.match(s),16)||d&&p.match(u)&&Date.parse(p)||null;if(v){if(d<v)return-1;if(d>v)return 1}for(var y=0,g=Math.max(m.length,h.length);y<g;y++){if(n=!(m[y]||"").match(c)&&parseFloat(m[y])||m[y]||0,i=!(h[y]||"").match(c)&&parseFloat(h[y])||h[y]||0,isNaN(n)!==isNaN(i))return isNaN(n)?1:-1;if(typeof n!=typeof i&&(n+="",i+=""),n<i)return-1;if(n>i)return 1}return 0}},7391:(e,t,r)=>{var n=r(7180),i=r(3181),a=r(3031),o=r(9067),u=r(6833),s=r(6098),c=r(4801);c.alea=n,c.xor128=i,c.xorwow=a,c.xorshift7=o,c.xor4096=u,c.tychei=s,e.exports=c},7180:function(e,t,r){var n;!function(e,i,a){function o(e){var t,r=this,n=(t=4022871197,function(e){e=String(e);for(var r=0;r<e.length;r++){var n=.02519603282416938*(t+=e.charCodeAt(r));n-=t=n>>>0,t=(n*=t)>>>0,t+=4294967296*(n-=t)}return 2.3283064365386963e-10*(t>>>0)});r.next=function(){var e=2091639*r.s0+2.3283064365386963e-10*r.c;return r.s0=r.s1,r.s1=r.s2,r.s2=e-(r.c=0|e)},r.c=1,r.s0=n(" "),r.s1=n(" "),r.s2=n(" "),r.s0-=n(e),r.s0<0&&(r.s0+=1),r.s1-=n(e),r.s1<0&&(r.s1+=1),r.s2-=n(e),r.s2<0&&(r.s2+=1),n=null}function u(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var r=new o(e),n=t&&t.state,i=r.next;return i.int32=function(){return 4294967296*r.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,n&&("object"==typeof n&&u(n,r),i.state=function(){return u(r,{})}),i}i&&i.exports?i.exports=s:r.amdD&&r.amdO?void 0===(n=function(){return s}.call(t,r,t,i))||(i.exports=n):this.alea=s}(0,e=r.nmd(e),r.amdD)},6098:function(e,t,r){var n;!function(e,i,a){function o(e){var t=this,r="";t.next=function(){var e=t.b,r=t.c,n=t.d,i=t.a;return e=e<<25^e>>>7^r,r=r-n|0,n=n<<24^n>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^r,t.c=r=r-n|0,t.d=n<<16^r>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):r+=e;for(var n=0;n<r.length+20;n++)t.b^=0|r.charCodeAt(n),t.next()}function u(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var r=new o(e),n=t&&t.state,i=function(){return(r.next()>>>0)/4294967296};return i.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=r.next,i.quick=i,n&&("object"==typeof n&&u(n,r),i.state=function(){return u(r,{})}),i}i&&i.exports?i.exports=s:r.amdD&&r.amdO?void 0===(n=function(){return s}.call(t,r,t,i))||(i.exports=n):this.tychei=s}(0,e=r.nmd(e),r.amdD)},3181:function(e,t,r){var n;!function(e,i,a){function o(e){var t=this,r="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:r+=e;for(var n=0;n<r.length+64;n++)t.x^=0|r.charCodeAt(n),t.next()}function u(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var r=new o(e),n=t&&t.state,i=function(){return(r.next()>>>0)/4294967296};return i.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=r.next,i.quick=i,n&&("object"==typeof n&&u(n,r),i.state=function(){return u(r,{})}),i}i&&i.exports?i.exports=s:r.amdD&&r.amdO?void 0===(n=function(){return s}.call(t,r,t,i))||(i.exports=n):this.xor128=s}(0,e=r.nmd(e),r.amdD)},6833:function(e,t,r){var n;!function(e,i,a){function o(e){var t=this;t.next=function(){var e,r,n=t.w,i=t.X,a=t.i;return t.w=n=n+1640531527|0,r=i[a+34&127],e=i[a=a+1&127],r^=r<<13,e^=e<<17,r^=r>>>15,e^=e>>>12,r=i[a]=r^e,t.i=a,r+(n^n>>>16)|0},function(e,t){var r,n,i,a,o,u=[],s=128;for(t===(0|t)?(n=t,t=null):(t+="\0",n=0,s=Math.max(s,t.length)),i=0,a=-32;a<s;++a)t&&(n^=t.charCodeAt((a+32)%t.length)),0===a&&(o=n),n^=n<<10,n^=n>>>15,n^=n<<4,n^=n>>>13,a>=0&&(o=o+1640531527|0,i=0==(r=u[127&a]^=n+o)?i+1:0);for(i>=128&&(u[127&(t&&t.length||0)]=-1),i=127,a=512;a>0;--a)n=u[i+34&127],r=u[i=i+1&127],n^=n<<13,r^=r<<17,n^=n>>>15,r^=r>>>12,u[i]=n^r;e.w=o,e.X=u,e.i=i}(t,e)}function u(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var r=new o(e),n=t&&t.state,i=function(){return(r.next()>>>0)/4294967296};return i.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=r.next,i.quick=i,n&&(n.X&&u(n,r),i.state=function(){return u(r,{})}),i}i&&i.exports?i.exports=s:r.amdD&&r.amdO?void 0===(n=function(){return s}.call(t,r,t,i))||(i.exports=n):this.xor4096=s}(0,e=r.nmd(e),r.amdD)},9067:function(e,t,r){var n;!function(e,i,a){function o(e){var t=this;t.next=function(){var e,r,n=t.x,i=t.i;return e=n[i],r=(e^=e>>>7)^e<<24,r^=(e=n[i+1&7])^e>>>10,r^=(e=n[i+3&7])^e>>>3,r^=(e=n[i+4&7])^e<<7,e=n[i+7&7],r^=(e^=e<<13)^e<<9,n[i]=r,t.i=i+1&7,r},function(e,t){var r,n=[];if(t===(0|t))n[0]=t;else for(t=""+t,r=0;r<t.length;++r)n[7&r]=n[7&r]<<15^t.charCodeAt(r)+n[r+1&7]<<13;for(;n.length<8;)n.push(0);for(r=0;r<8&&0===n[r];++r);for(8==r?n[7]=-1:n[r],e.x=n,e.i=0,r=256;r>0;--r)e.next()}(t,e)}function u(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var r=new o(e),n=t&&t.state,i=function(){return(r.next()>>>0)/4294967296};return i.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=r.next,i.quick=i,n&&(n.x&&u(n,r),i.state=function(){return u(r,{})}),i}i&&i.exports?i.exports=s:r.amdD&&r.amdO?void 0===(n=function(){return s}.call(t,r,t,i))||(i.exports=n):this.xorshift7=s}(0,e=r.nmd(e),r.amdD)},3031:function(e,t,r){var n;!function(e,i,a){function o(e){var t=this,r="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:r+=e;for(var n=0;n<r.length+64;n++)t.x^=0|r.charCodeAt(n),n==r.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function u(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var r=new o(e),n=t&&t.state,i=function(){return(r.next()>>>0)/4294967296};return i.double=function(){do{var e=((r.next()>>>11)+(r.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=r.next,i.quick=i,n&&("object"==typeof n&&u(n,r),i.state=function(){return u(r,{})}),i}i&&i.exports?i.exports=s:r.amdD&&r.amdO?void 0===(n=function(){return s}.call(t,r,t,i))||(i.exports=n):this.xorwow=s}(0,e=r.nmd(e),r.amdD)},4801:function(e,t,r){var n;!function(i,a,o){var u,s=256,c=o.pow(s,6),f=o.pow(2,52),l=2*f,p=s-1;function m(e,t,r){var n=[],p=y(v((t=1==t?{entropy:!0}:t||{}).entropy?[e,g(a)]:null==e?function(){try{var e;return u&&(e=u.randomBytes)?e=e(s):(e=new Uint8Array(s),(i.crypto||i.msCrypto).getRandomValues(e)),g(e)}catch(e){var t=i.navigator,r=t&&t.plugins;return[+new Date,i,r,i.screen,g(a)]}}():e,3),n),m=new h(n),x=function(){for(var e=m.g(6),t=c,r=0;e<f;)e=(e+r)*s,t*=s,r=m.g(1);for(;e>=l;)e/=2,t/=2,r>>>=1;return(e+r)/t};return x.int32=function(){return 0|m.g(4)},x.quick=function(){return m.g(4)/4294967296},x.double=x,y(g(m.S),a),(t.pass||r||function(e,t,r,n){return n&&(n.S&&d(n,m),e.state=function(){return d(m,{})}),r?(o.random=e,t):e})(x,p,"global"in t?t.global:this==o,t.state)}function h(e){var t,r=e.length,n=this,i=0,a=n.i=n.j=0,o=n.S=[];for(r||(e=[r++]);i<s;)o[i]=i++;for(i=0;i<s;i++)o[i]=o[a=p&a+e[i%r]+(t=o[i])],o[a]=t;(n.g=function(e){for(var t,r=0,i=n.i,a=n.j,o=n.S;e--;)t=o[i=p&i+1],r=r*s+o[p&(o[i]=o[a=p&a+t])+(o[a]=t)];return n.i=i,n.j=a,r})(s)}function d(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function v(e,t){var r,n=[],i=typeof e;if(t&&"object"==i)for(r in e)try{n.push(v(e[r],t-1))}catch(e){}return n.length?n:"string"==i?e:e+"\0"}function y(e,t){for(var r,n=e+"",i=0;i<n.length;)t[p&i]=p&(r^=19*t[p&i])+n.charCodeAt(i++);return g(t)}function g(e){return String.fromCharCode.apply(0,e)}if(y(o.random(),a),e.exports){e.exports=m;try{u=r(1234)}catch(e){}}else void 0===(n=function(){return m}.call(t,r,t,e))||(e.exports=n)}("undefined"!=typeof self?self:this,[],Math)},1504:e=>{function t(){}t.prototype={on:function(e,t,r){var n=this.e||(this.e={});return(n[e]||(n[e]=[])).push({fn:t,ctx:r}),this},once:function(e,t,r){var n=this;function i(){n.off(e,i),t.apply(r,arguments)}return i._=t,this.on(e,i,r)},emit:function(e){for(var t=[].slice.call(arguments,1),r=((this.e||(this.e={}))[e]||[]).slice(),n=0,i=r.length;n<i;n++)r[n].fn.apply(r[n].ctx,t);return this},off:function(e,t){var r=this.e||(this.e={}),n=r[e],i=[];if(n&&t)for(var a=0,o=n.length;a<o;a++)n[a].fn!==t&&n[a].fn._!==t&&i.push(n[a]);return i.length?r[e]=i:delete r[e],this}},e.exports=t,e.exports.TinyEmitter=t},1234:()=>{},4633:(e,t,r)=>{var n=r(3738).default;function i(){"use strict";e.exports=i=function(){return r},e.exports.__esModule=!0,e.exports.default=e.exports;var t,r={},a=Object.prototype,o=a.hasOwnProperty,u=Object.defineProperty||function(e,t,r){e[t]=r.value},s="function"==typeof Symbol?Symbol:{},c=s.iterator||"@@iterator",f=s.asyncIterator||"@@asyncIterator",l=s.toStringTag||"@@toStringTag";function p(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{p({},"")}catch(t){p=function(e,t,r){return e[t]=r}}function m(e,t,r,n){var i=t&&t.prototype instanceof b?t:b,a=Object.create(i.prototype),o=new B(n||[]);return u(a,"_invoke",{value:F(e,r,o)}),a}function h(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}r.wrap=m;var d="suspendedStart",v="suspendedYield",y="executing",g="completed",x={};function b(){}function w(){}function D(){}var N={};p(N,c,(function(){return this}));var E=Object.getPrototypeOf,A=E&&E(E(k([])));A&&A!==a&&o.call(A,c)&&(N=A);var S=D.prototype=b.prototype=Object.create(N);function C(e){["next","throw","return"].forEach((function(t){p(e,t,(function(e){return this._invoke(t,e)}))}))}function M(e,t){function r(i,a,u,s){var c=h(e[i],e,a);if("throw"!==c.type){var f=c.arg,l=f.value;return l&&"object"==n(l)&&o.call(l,"__await")?t.resolve(l.__await).then((function(e){r("next",e,u,s)}),(function(e){r("throw",e,u,s)})):t.resolve(l).then((function(e){f.value=e,u(f)}),(function(e){return r("throw",e,u,s)}))}s(c.arg)}var i;u(this,"_invoke",{value:function(e,n){function a(){return new t((function(t,i){r(e,n,t,i)}))}return i=i?i.then(a,a):a()}})}function F(e,r,n){var i=d;return function(a,o){if(i===y)throw Error("Generator is already running");if(i===g){if("throw"===a)throw o;return{value:t,done:!0}}for(n.method=a,n.arg=o;;){var u=n.delegate;if(u){var s=O(u,n);if(s){if(s===x)continue;return s}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(i===d)throw i=g,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);i=y;var c=h(e,r,n);if("normal"===c.type){if(i=n.done?g:v,c.arg===x)continue;return{value:c.arg,done:n.done}}"throw"===c.type&&(i=g,n.method="throw",n.arg=c.arg)}}}function O(e,r){var n=r.method,i=e.iterator[n];if(i===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,O(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),x;var a=h(i,e.iterator,r.arg);if("throw"===a.type)return r.method="throw",r.arg=a.arg,r.delegate=null,x;var o=a.arg;return o?o.done?(r[e.resultName]=o.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,x):o:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,x)}function T(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function _(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function B(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(T,this),this.reset(!0)}function k(e){if(e||""===e){var r=e[c];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var i=-1,a=function r(){for(;++i<e.length;)if(o.call(e,i))return r.value=e[i],r.done=!1,r;return r.value=t,r.done=!0,r};return a.next=a}}throw new TypeError(n(e)+" is not iterable")}return w.prototype=D,u(S,"constructor",{value:D,configurable:!0}),u(D,"constructor",{value:w,configurable:!0}),w.displayName=p(D,l,"GeneratorFunction"),r.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===w||"GeneratorFunction"===(t.displayName||t.name))},r.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,D):(e.__proto__=D,p(e,l,"GeneratorFunction")),e.prototype=Object.create(S),e},r.awrap=function(e){return{__await:e}},C(M.prototype),p(M.prototype,f,(function(){return this})),r.AsyncIterator=M,r.async=function(e,t,n,i,a){void 0===a&&(a=Promise);var o=new M(m(e,t,n,i),a);return r.isGeneratorFunction(t)?o:o.next().then((function(e){return e.done?e.value:o.next()}))},C(S),p(S,l,"Generator"),p(S,c,(function(){return this})),p(S,"toString",(function(){return"[object Generator]"})),r.keys=function(e){var t=Object(e),r=[];for(var n in t)r.push(n);return r.reverse(),function e(){for(;r.length;){var n=r.pop();if(n in t)return e.value=n,e.done=!1,e}return e.done=!0,e}},r.values=k,B.prototype={constructor:B,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(_),!e)for(var r in this)"t"===r.charAt(0)&&o.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function n(n,i){return u.type="throw",u.arg=e,r.next=n,i&&(r.method="next",r.arg=t),!!i}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],u=a.completion;if("root"===a.tryLoc)return n("end");if(a.tryLoc<=this.prev){var s=o.call(a,"catchLoc"),c=o.call(a,"finallyLoc");if(s&&c){if(this.prev<a.catchLoc)return n(a.catchLoc,!0);if(this.prev<a.finallyLoc)return n(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return n(a.catchLoc,!0)}else{if(!c)throw Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return n(a.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&o.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var i=n;break}}i&&("break"===e||"continue"===e)&&i.tryLoc<=t&&t<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=e,a.arg=t,i?(this.method="next",this.next=i.finallyLoc,x):this.complete(a)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),x},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),_(r),x}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var i=n.arg;_(r)}return i}}throw Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:k(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),x}},r}e.exports=i,e.exports.__esModule=!0,e.exports.default=e.exports},3738:e=>{function t(r){return e.exports=t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},e.exports.__esModule=!0,e.exports.default=e.exports,t(r)}e.exports=t,e.exports.__esModule=!0,e.exports.default=e.exports},4756:(e,t,r)=>{var n=r(4633)();e.exports=n;try{regeneratorRuntime=n}catch(e){"object"==typeof globalThis?globalThis.regeneratorRuntime=n:Function("r","regeneratorRuntime = r")(n)}},9306:(e,t,r)=>{"use strict";var n=r(4901),i=r(6823),a=TypeError;e.exports=function(e){if(n(e))return e;throw new a(i(e)+" is not a function")}},5548:(e,t,r)=>{"use strict";var n=r(3517),i=r(6823),a=TypeError;e.exports=function(e){if(n(e))return e;throw new a(i(e)+" is not a constructor")}},3506:(e,t,r)=>{"use strict";var n=r(3925),i=String,a=TypeError;e.exports=function(e){if(n(e))return e;throw new a("Can't set "+i(e)+" as a prototype")}},6469:(e,t,r)=>{"use strict";var n=r(8227),i=r(2360),a=r(4913).f,o=n("unscopables"),u=Array.prototype;void 0===u[o]&&a(u,o,{configurable:!0,value:i(null)}),e.exports=function(e){u[o][e]=!0}},7829:(e,t,r)=>{"use strict";var n=r(8183).charAt;e.exports=function(e,t,r){return t+(r?n(e,t).length:1)}},679:(e,t,r)=>{"use strict";var n=r(1625),i=TypeError;e.exports=function(e,t){if(n(t,e))return e;throw new i("Incorrect invocation")}},8551:(e,t,r)=>{"use strict";var n=r(34),i=String,a=TypeError;e.exports=function(e){if(n(e))return e;throw new a(i(e)+" is not an object")}},5652:(e,t,r)=>{"use strict";var n=r(9039);e.exports=n((function(){if("function"==typeof ArrayBuffer){var e=new ArrayBuffer(8);Object.isExtensible(e)&&Object.defineProperty(e,"a",{value:8})}}))},4373:(e,t,r)=>{"use strict";var n=r(8981),i=r(5610),a=r(6198);e.exports=function(e){for(var t=n(this),r=a(t),o=arguments.length,u=i(o>1?arguments[1]:void 0,r),s=o>2?arguments[2]:void 0,c=void 0===s?r:i(s,r);c>u;)t[u++]=e;return t}},235:(e,t,r)=>{"use strict";var n=r(9213).forEach,i=r(4598)("forEach");e.exports=i?[].forEach:function(e){return n(this,e,arguments.length>1?arguments[1]:void 0)}},7916:(e,t,r)=>{"use strict";var n=r(6080),i=r(9565),a=r(8981),o=r(6319),u=r(4209),s=r(3517),c=r(6198),f=r(4659),l=r(81),p=r(851),m=Array;e.exports=function(e){var t=a(e),r=s(this),h=arguments.length,d=h>1?arguments[1]:void 0,v=void 0!==d;v&&(d=n(d,h>2?arguments[2]:void 0));var y,g,x,b,w,D,N=p(t),E=0;if(!N||this===m&&u(N))for(y=c(t),g=r?new this(y):m(y);y>E;E++)D=v?d(t[E],E):t[E],f(g,E,D);else for(g=r?new this:[],w=(b=l(t,N)).next;!(x=i(w,b)).done;E++)D=v?o(b,d,[x.value,E],!0):x.value,f(g,E,D);return g.length=E,g}},9617:(e,t,r)=>{"use strict";var n=r(5397),i=r(5610),a=r(6198),o=function(e){return function(t,r,o){var u=n(t),s=a(u);if(0===s)return!e&&-1;var c,f=i(o,s);if(e&&r!=r){for(;s>f;)if((c=u[f++])!=c)return!0}else for(;s>f;f++)if((e||f in u)&&u[f]===r)return e||f||0;return!e&&-1}};e.exports={includes:o(!0),indexOf:o(!1)}},9213:(e,t,r)=>{"use strict";var n=r(6080),i=r(9504),a=r(7055),o=r(8981),u=r(6198),s=r(1469),c=i([].push),f=function(e){var t=1===e,r=2===e,i=3===e,f=4===e,l=6===e,p=7===e,m=5===e||l;return function(h,d,v,y){for(var g,x,b=o(h),w=a(b),D=u(w),N=n(d,v),E=0,A=y||s,S=t?A(h,D):r||p?A(h,0):void 0;D>E;E++)if((m||E in w)&&(x=N(g=w[E],E,b),e))if(t)S[E]=x;else if(x)switch(e){case 3:return!0;case 5:return g;case 6:return E;case 2:c(S,g)}else switch(e){case 4:return!1;case 7:c(S,g)}return l?-1:i||f?f:S}};e.exports={forEach:f(0),map:f(1),filter:f(2),some:f(3),every:f(4),find:f(5),findIndex:f(6),filterReject:f(7)}},597:(e,t,r)=>{"use strict";var n=r(9039),i=r(8227),a=r(7388),o=i("species");e.exports=function(e){return a>=51||!n((function(){var t=[];return(t.constructor={})[o]=function(){return{foo:1}},1!==t[e](Boolean).foo}))}},4598:(e,t,r)=>{"use strict";var n=r(9039);e.exports=function(e,t){var r=[][e];return!!r&&n((function(){r.call(null,t||function(){return 1},1)}))}},926:(e,t,r)=>{"use strict";var n=r(9306),i=r(8981),a=r(7055),o=r(6198),u=TypeError,s="Reduce of empty array with no initial value",c=function(e){return function(t,r,c,f){var l=i(t),p=a(l),m=o(l);if(n(r),0===m&&c<2)throw new u(s);var h=e?m-1:0,d=e?-1:1;if(c<2)for(;;){if(h in p){f=p[h],h+=d;break}if(h+=d,e?h<0:m<=h)throw new u(s)}for(;e?h>=0:m>h;h+=d)h in p&&(f=r(f,p[h],h,l));return f}};e.exports={left:c(!1),right:c(!0)}},4527:(e,t,r)=>{"use strict";var n=r(3724),i=r(4376),a=TypeError,o=Object.getOwnPropertyDescriptor,u=n&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(e){return e instanceof TypeError}}();e.exports=u?function(e,t){if(i(e)&&!o(e,"length").writable)throw new a("Cannot set read only .length");return e.length=t}:function(e,t){return e.length=t}},7680:(e,t,r)=>{"use strict";var n=r(9504);e.exports=n([].slice)},4488:(e,t,r)=>{"use strict";var n=r(7680),i=Math.floor,a=function(e,t){var r=e.length;if(r<8)for(var o,u,s=1;s<r;){for(u=s,o=e[s];u&&t(e[u-1],o)>0;)e[u]=e[--u];u!==s++&&(e[u]=o)}else for(var c=i(r/2),f=a(n(e,0,c),t),l=a(n(e,c),t),p=f.length,m=l.length,h=0,d=0;h<p||d<m;)e[h+d]=h<p&&d<m?t(f[h],l[d])<=0?f[h++]:l[d++]:h<p?f[h++]:l[d++];return e};e.exports=a},7433:(e,t,r)=>{"use strict";var n=r(4376),i=r(3517),a=r(34),o=r(8227)("species"),u=Array;e.exports=function(e){var t;return n(e)&&(t=e.constructor,(i(t)&&(t===u||n(t.prototype))||a(t)&&null===(t=t[o]))&&(t=void 0)),void 0===t?u:t}},1469:(e,t,r)=>{"use strict";var n=r(7433);e.exports=function(e,t){return new(n(e))(0===t?0:t)}},6319:(e,t,r)=>{"use strict";var n=r(8551),i=r(9539);e.exports=function(e,t,r,a){try{return a?t(n(r)[0],r[1]):t(r)}catch(t){i(e,"throw",t)}}},4428:(e,t,r)=>{"use strict";var n=r(8227)("iterator"),i=!1;try{var a=0,o={next:function(){return{done:!!a++}},return:function(){i=!0}};o[n]=function(){return this},Array.from(o,(function(){throw 2}))}catch(e){}e.exports=function(e,t){try{if(!t&&!i)return!1}catch(e){return!1}var r=!1;try{var a={};a[n]=function(){return{next:function(){return{done:r=!0}}}},e(a)}catch(e){}return r}},4576:(e,t,r)=>{"use strict";var n=r(9504),i=n({}.toString),a=n("".slice);e.exports=function(e){return a(i(e),8,-1)}},6955:(e,t,r)=>{"use strict";var n=r(2140),i=r(4901),a=r(4576),o=r(8227)("toStringTag"),u=Object,s="Arguments"===a(function(){return arguments}());e.exports=n?a:function(e){var t,r,n;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(r=function(e,t){try{return e[t]}catch(e){}}(t=u(e),o))?r:s?a(t):"Object"===(n=a(t))&&i(t.callee)?"Arguments":n}},6938:(e,t,r)=>{"use strict";var n=r(2360),i=r(2106),a=r(6279),o=r(6080),u=r(679),s=r(4117),c=r(2652),f=r(1088),l=r(2529),p=r(7633),m=r(3724),h=r(3451).fastKey,d=r(1181),v=d.set,y=d.getterFor;e.exports={getConstructor:function(e,t,r,f){var l=e((function(e,i){u(e,p),v(e,{type:t,index:n(null),first:void 0,last:void 0,size:0}),m||(e.size=0),s(i)||c(i,e[f],{that:e,AS_ENTRIES:r})})),p=l.prototype,d=y(t),g=function(e,t,r){var n,i,a=d(e),o=x(e,t);return o?o.value=r:(a.last=o={index:i=h(t,!0),key:t,value:r,previous:n=a.last,next:void 0,removed:!1},a.first||(a.first=o),n&&(n.next=o),m?a.size++:e.size++,"F"!==i&&(a.index[i]=o)),e},x=function(e,t){var r,n=d(e),i=h(t);if("F"!==i)return n.index[i];for(r=n.first;r;r=r.next)if(r.key===t)return r};return a(p,{clear:function(){for(var e=d(this),t=e.first;t;)t.removed=!0,t.previous&&(t.previous=t.previous.next=void 0),t=t.next;e.first=e.last=void 0,e.index=n(null),m?e.size=0:this.size=0},delete:function(e){var t=this,r=d(t),n=x(t,e);if(n){var i=n.next,a=n.previous;delete r.index[n.index],n.removed=!0,a&&(a.next=i),i&&(i.previous=a),r.first===n&&(r.first=i),r.last===n&&(r.last=a),m?r.size--:t.size--}return!!n},forEach:function(e){for(var t,r=d(this),n=o(e,arguments.length>1?arguments[1]:void 0);t=t?t.next:r.first;)for(n(t.value,t.key,this);t&&t.removed;)t=t.previous},has:function(e){return!!x(this,e)}}),a(p,r?{get:function(e){var t=x(this,e);return t&&t.value},set:function(e,t){return g(this,0===e?0:e,t)}}:{add:function(e){return g(this,e=0===e?0:e,e)}}),m&&i(p,"size",{configurable:!0,get:function(){return d(this).size}}),l},setStrong:function(e,t,r){var n=t+" Iterator",i=y(t),a=y(n);f(e,t,(function(e,t){v(this,{type:n,target:e,state:i(e),kind:t,last:void 0})}),(function(){for(var e=a(this),t=e.kind,r=e.last;r&&r.removed;)r=r.previous;return e.target&&(e.last=r=r?r.next:e.state.first)?l("keys"===t?r.key:"values"===t?r.value:[r.key,r.value],!1):(e.target=void 0,l(void 0,!0))}),r?"entries":"values",!r,!0),p(t)}}},6468:(e,t,r)=>{"use strict";var n=r(6518),i=r(4475),a=r(9504),o=r(2796),u=r(6840),s=r(3451),c=r(2652),f=r(679),l=r(4901),p=r(4117),m=r(34),h=r(9039),d=r(4428),v=r(687),y=r(3167);e.exports=function(e,t,r){var g=-1!==e.indexOf("Map"),x=-1!==e.indexOf("Weak"),b=g?"set":"add",w=i[e],D=w&&w.prototype,N=w,E={},A=function(e){var t=a(D[e]);u(D,e,"add"===e?function(e){return t(this,0===e?0:e),this}:"delete"===e?function(e){return!(x&&!m(e))&&t(this,0===e?0:e)}:"get"===e?function(e){return x&&!m(e)?void 0:t(this,0===e?0:e)}:"has"===e?function(e){return!(x&&!m(e))&&t(this,0===e?0:e)}:function(e,r){return t(this,0===e?0:e,r),this})};if(o(e,!l(w)||!(x||D.forEach&&!h((function(){(new w).entries().next()})))))N=r.getConstructor(t,e,g,b),s.enable();else if(o(e,!0)){var S=new N,C=S[b](x?{}:-0,1)!==S,M=h((function(){S.has(1)})),F=d((function(e){new w(e)})),O=!x&&h((function(){for(var e=new w,t=5;t--;)e[b](t,t);return!e.has(-0)}));F||((N=t((function(e,t){f(e,D);var r=y(new w,e,N);return p(t)||c(t,r[b],{that:r,AS_ENTRIES:g}),r}))).prototype=D,D.constructor=N),(M||O)&&(A("delete"),A("has"),g&&A("get")),(O||C)&&A(b),x&&D.clear&&delete D.clear}return E[e]=N,n({global:!0,constructor:!0,forced:N!==w},E),v(N,e),x||r.setStrong(N,e,g),N}},7740:(e,t,r)=>{"use strict";var n=r(9297),i=r(5031),a=r(7347),o=r(4913);e.exports=function(e,t,r){for(var u=i(t),s=o.f,c=a.f,f=0;f<u.length;f++){var l=u[f];n(e,l)||r&&n(r,l)||s(e,l,c(t,l))}}},1436:(e,t,r)=>{"use strict";var n=r(8227)("match");e.exports=function(e){var t=/./;try{"/./"[e](t)}catch(r){try{return t[n]=!1,"/./"[e](t)}catch(e){}}return!1}},2211:(e,t,r)=>{"use strict";var n=r(9039);e.exports=!n((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype}))},7240:(e,t,r)=>{"use strict";var n=r(9504),i=r(7750),a=r(655),o=/"/g,u=n("".replace);e.exports=function(e,t,r,n){var s=a(i(e)),c="<"+t;return""!==r&&(c+=" "+r+'="'+u(a(n),o,"&quot;")+'"'),c+">"+s+"</"+t+">"}},2529:e=>{"use strict";e.exports=function(e,t){return{value:e,done:t}}},6699:(e,t,r)=>{"use strict";var n=r(3724),i=r(4913),a=r(6980);e.exports=n?function(e,t,r){return i.f(e,t,a(1,r))}:function(e,t,r){return e[t]=r,e}},6980:e=>{"use strict";e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},4659:(e,t,r)=>{"use strict";var n=r(3724),i=r(4913),a=r(6980);e.exports=function(e,t,r){n?i.f(e,t,a(0,r)):e[t]=r}},2106:(e,t,r)=>{"use strict";var n=r(283),i=r(4913);e.exports=function(e,t,r){return r.get&&n(r.get,t,{getter:!0}),r.set&&n(r.set,t,{setter:!0}),i.f(e,t,r)}},6840:(e,t,r)=>{"use strict";var n=r(4901),i=r(4913),a=r(283),o=r(9433);e.exports=function(e,t,r,u){u||(u={});var s=u.enumerable,c=void 0!==u.name?u.name:t;if(n(r)&&a(r,c,u),u.global)s?e[t]=r:o(t,r);else{try{u.unsafe?e[t]&&(s=!0):delete e[t]}catch(e){}s?e[t]=r:i.f(e,t,{value:r,enumerable:!1,configurable:!u.nonConfigurable,writable:!u.nonWritable})}return e}},6279:(e,t,r)=>{"use strict";var n=r(6840);e.exports=function(e,t,r){for(var i in t)n(e,i,t[i],r);return e}},9433:(e,t,r)=>{"use strict";var n=r(4475),i=Object.defineProperty;e.exports=function(e,t){try{i(n,e,{value:t,configurable:!0,writable:!0})}catch(r){n[e]=t}return t}},4606:(e,t,r)=>{"use strict";var n=r(6823),i=TypeError;e.exports=function(e,t){if(!delete e[t])throw new i("Cannot delete property "+n(t)+" of "+n(e))}},3724:(e,t,r)=>{"use strict";var n=r(9039);e.exports=!n((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},4055:(e,t,r)=>{"use strict";var n=r(4475),i=r(34),a=n.document,o=i(a)&&i(a.createElement);e.exports=function(e){return o?a.createElement(e):{}}},6837:e=>{"use strict";var t=TypeError;e.exports=function(e){if(e>9007199254740991)throw t("Maximum allowed index exceeded");return e}},7400:e=>{"use strict";e.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},9296:(e,t,r)=>{"use strict";var n=r(4055)("span").classList,i=n&&n.constructor&&n.constructor.prototype;e.exports=i===Object.prototype?void 0:i},8834:(e,t,r)=>{"use strict";var n=r(9392).match(/firefox\/(\d+)/i);e.exports=!!n&&+n[1]},7290:(e,t,r)=>{"use strict";var n=r(516),i=r(9088);e.exports=!n&&!i&&"object"==typeof window&&"object"==typeof document},516:e=>{"use strict";e.exports="object"==typeof Deno&&Deno&&"object"==typeof Deno.version},3202:(e,t,r)=>{"use strict";var n=r(9392);e.exports=/MSIE|Trident/.test(n)},28:(e,t,r)=>{"use strict";var n=r(9392);e.exports=/ipad|iphone|ipod/i.test(n)&&"undefined"!=typeof Pebble},8119:(e,t,r)=>{"use strict";var n=r(9392);e.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(n)},9088:(e,t,r)=>{"use strict";var n=r(4475),i=r(4576);e.exports="process"===i(n.process)},6765:(e,t,r)=>{"use strict";var n=r(9392);e.exports=/web0s(?!.*chrome)/i.test(n)},9392:e=>{"use strict";e.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},7388:(e,t,r)=>{"use strict";var n,i,a=r(4475),o=r(9392),u=a.process,s=a.Deno,c=u&&u.versions||s&&s.version,f=c&&c.v8;f&&(i=(n=f.split("."))[0]>0&&n[0]<4?1:+(n[0]+n[1])),!i&&o&&(!(n=o.match(/Edge\/(\d+)/))||n[1]>=74)&&(n=o.match(/Chrome\/(\d+)/))&&(i=+n[1]),e.exports=i},9160:(e,t,r)=>{"use strict";var n=r(9392).match(/AppleWebKit\/(\d+)\./);e.exports=!!n&&+n[1]},8727:e=>{"use strict";e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},6518:(e,t,r)=>{"use strict";var n=r(4475),i=r(7347).f,a=r(6699),o=r(6840),u=r(9433),s=r(7740),c=r(2796);e.exports=function(e,t){var r,f,l,p,m,h=e.target,d=e.global,v=e.stat;if(r=d?n:v?n[h]||u(h,{}):n[h]&&n[h].prototype)for(f in t){if(p=t[f],l=e.dontCallGetSet?(m=i(r,f))&&m.value:r[f],!c(d?f:h+(v?".":"#")+f,e.forced)&&void 0!==l){if(typeof p==typeof l)continue;s(p,l)}(e.sham||l&&l.sham)&&a(p,"sham",!0),o(r,f,p,e)}}},9039:e=>{"use strict";e.exports=function(e){try{return!!e()}catch(e){return!0}}},9228:(e,t,r)=>{"use strict";r(7495);var n=r(9565),i=r(6840),a=r(7323),o=r(9039),u=r(8227),s=r(6699),c=u("species"),f=RegExp.prototype;e.exports=function(e,t,r,l){var p=u(e),m=!o((function(){var t={};return t[p]=function(){return 7},7!==""[e](t)})),h=m&&!o((function(){var t=!1,r=/a/;return"split"===e&&((r={}).constructor={},r.constructor[c]=function(){return r},r.flags="",r[p]=/./[p]),r.exec=function(){return t=!0,null},r[p](""),!t}));if(!m||!h||r){var d=/./[p],v=t(p,""[e],(function(e,t,r,i,o){var u=t.exec;return u===a||u===f.exec?m&&!o?{done:!0,value:n(d,t,r,i)}:{done:!0,value:n(e,r,t,i)}:{done:!1}}));i(String.prototype,e,v[0]),i(f,p,v[1])}l&&s(f[p],"sham",!0)}},2744:(e,t,r)=>{"use strict";var n=r(9039);e.exports=!n((function(){return Object.isExtensible(Object.preventExtensions({}))}))},8745:(e,t,r)=>{"use strict";var n=r(616),i=Function.prototype,a=i.apply,o=i.call;e.exports="object"==typeof Reflect&&Reflect.apply||(n?o.bind(a):function(){return o.apply(a,arguments)})},6080:(e,t,r)=>{"use strict";var n=r(7476),i=r(9306),a=r(616),o=n(n.bind);e.exports=function(e,t){return i(e),void 0===t?e:a?o(e,t):function(){return e.apply(t,arguments)}}},616:(e,t,r)=>{"use strict";var n=r(9039);e.exports=!n((function(){var e=function(){}.bind();return"function"!=typeof e||e.hasOwnProperty("prototype")}))},566:(e,t,r)=>{"use strict";var n=r(9504),i=r(9306),a=r(34),o=r(9297),u=r(7680),s=r(616),c=Function,f=n([].concat),l=n([].join),p={};e.exports=s?c.bind:function(e){var t=i(this),r=t.prototype,n=u(arguments,1),s=function(){var r=f(n,u(arguments));return this instanceof s?function(e,t,r){if(!o(p,t)){for(var n=[],i=0;i<t;i++)n[i]="a["+i+"]";p[t]=c("C,a","return new C("+l(n,",")+")")}return p[t](e,r)}(t,r.length,r):t.apply(e,r)};return a(r)&&(s.prototype=r),s}},9565:(e,t,r)=>{"use strict";var n=r(616),i=Function.prototype.call;e.exports=n?i.bind(i):function(){return i.apply(i,arguments)}},350:(e,t,r)=>{"use strict";var n=r(3724),i=r(9297),a=Function.prototype,o=n&&Object.getOwnPropertyDescriptor,u=i(a,"name"),s=u&&"something"===function(){}.name,c=u&&(!n||n&&o(a,"name").configurable);e.exports={EXISTS:u,PROPER:s,CONFIGURABLE:c}},6706:(e,t,r)=>{"use strict";var n=r(9504),i=r(9306);e.exports=function(e,t,r){try{return n(i(Object.getOwnPropertyDescriptor(e,t)[r]))}catch(e){}}},7476:(e,t,r)=>{"use strict";var n=r(4576),i=r(9504);e.exports=function(e){if("Function"===n(e))return i(e)}},9504:(e,t,r)=>{"use strict";var n=r(616),i=Function.prototype,a=i.call,o=n&&i.bind.bind(a,a);e.exports=n?o:function(e){return function(){return a.apply(e,arguments)}}},7751:(e,t,r)=>{"use strict";var n=r(4475),i=r(4901);e.exports=function(e,t){return arguments.length<2?(r=n[e],i(r)?r:void 0):n[e]&&n[e][t];var r}},851:(e,t,r)=>{"use strict";var n=r(6955),i=r(5966),a=r(4117),o=r(6269),u=r(8227)("iterator");e.exports=function(e){if(!a(e))return i(e,u)||i(e,"@@iterator")||o[n(e)]}},81:(e,t,r)=>{"use strict";var n=r(9565),i=r(9306),a=r(8551),o=r(6823),u=r(851),s=TypeError;e.exports=function(e,t){var r=arguments.length<2?u(e):t;if(i(r))return a(n(r,e));throw new s(o(e)+" is not iterable")}},6933:(e,t,r)=>{"use strict";var n=r(9504),i=r(4376),a=r(4901),o=r(4576),u=r(655),s=n([].push);e.exports=function(e){if(a(e))return e;if(i(e)){for(var t=e.length,r=[],n=0;n<t;n++){var c=e[n];"string"==typeof c?s(r,c):"number"!=typeof c&&"Number"!==o(c)&&"String"!==o(c)||s(r,u(c))}var f=r.length,l=!0;return function(e,t){if(l)return l=!1,t;if(i(this))return t;for(var n=0;n<f;n++)if(r[n]===e)return t}}}},5966:(e,t,r)=>{"use strict";var n=r(9306),i=r(4117);e.exports=function(e,t){var r=e[t];return i(r)?void 0:n(r)}},2478:(e,t,r)=>{"use strict";var n=r(9504),i=r(8981),a=Math.floor,o=n("".charAt),u=n("".replace),s=n("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,f=/\$([$&'`]|\d{1,2})/g;e.exports=function(e,t,r,n,l,p){var m=r+e.length,h=n.length,d=f;return void 0!==l&&(l=i(l),d=c),u(p,d,(function(i,u){var c;switch(o(u,0)){case"$":return"$";case"&":return e;case"`":return s(t,0,r);case"'":return s(t,m);case"<":c=l[s(u,1,-1)];break;default:var f=+u;if(0===f)return i;if(f>h){var p=a(f/10);return 0===p?i:p<=h?void 0===n[p-1]?o(u,1):n[p-1]+o(u,1):i}c=n[f-1]}return void 0===c?"":c}))}},4475:function(e){"use strict";var t=function(e){return e&&e.Math===Math&&e};e.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||t("object"==typeof this&&this)||function(){return this}()||Function("return this")()},9297:(e,t,r)=>{"use strict";var n=r(9504),i=r(8981),a=n({}.hasOwnProperty);e.exports=Object.hasOwn||function(e,t){return a(i(e),t)}},421:e=>{"use strict";e.exports={}},3138:e=>{"use strict";e.exports=function(e,t){try{1===arguments.length?console.error(e):console.error(e,t)}catch(e){}}},397:(e,t,r)=>{"use strict";var n=r(7751);e.exports=n("document","documentElement")},5917:(e,t,r)=>{"use strict";var n=r(3724),i=r(9039),a=r(4055);e.exports=!n&&!i((function(){return 7!==Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},7055:(e,t,r)=>{"use strict";var n=r(9504),i=r(9039),a=r(4576),o=Object,u=n("".split);e.exports=i((function(){return!o("z").propertyIsEnumerable(0)}))?function(e){return"String"===a(e)?u(e,""):o(e)}:o},3167:(e,t,r)=>{"use strict";var n=r(4901),i=r(34),a=r(2967);e.exports=function(e,t,r){var o,u;return a&&n(o=t.constructor)&&o!==r&&i(u=o.prototype)&&u!==r.prototype&&a(e,u),e}},3706:(e,t,r)=>{"use strict";var n=r(9504),i=r(4901),a=r(7629),o=n(Function.toString);i(a.inspectSource)||(a.inspectSource=function(e){return o(e)}),e.exports=a.inspectSource},3451:(e,t,r)=>{"use strict";var n=r(6518),i=r(9504),a=r(421),o=r(34),u=r(9297),s=r(4913).f,c=r(8480),f=r(298),l=r(4124),p=r(3392),m=r(2744),h=!1,d=p("meta"),v=0,y=function(e){s(e,d,{value:{objectID:"O"+v++,weakData:{}}})},g=e.exports={enable:function(){g.enable=function(){},h=!0;var e=c.f,t=i([].splice),r={};r[d]=1,e(r).length&&(c.f=function(r){for(var n=e(r),i=0,a=n.length;i<a;i++)if(n[i]===d){t(n,i,1);break}return n},n({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:f.f}))},fastKey:function(e,t){if(!o(e))return"symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!u(e,d)){if(!l(e))return"F";if(!t)return"E";y(e)}return e[d].objectID},getWeakData:function(e,t){if(!u(e,d)){if(!l(e))return!0;if(!t)return!1;y(e)}return e[d].weakData},onFreeze:function(e){return m&&h&&l(e)&&!u(e,d)&&y(e),e}};a[d]=!0},1181:(e,t,r)=>{"use strict";var n,i,a,o=r(8622),u=r(4475),s=r(34),c=r(6699),f=r(9297),l=r(7629),p=r(6119),m=r(421),h="Object already initialized",d=u.TypeError,v=u.WeakMap;if(o||l.state){var y=l.state||(l.state=new v);y.get=y.get,y.has=y.has,y.set=y.set,n=function(e,t){if(y.has(e))throw new d(h);return t.facade=e,y.set(e,t),t},i=function(e){return y.get(e)||{}},a=function(e){return y.has(e)}}else{var g=p("state");m[g]=!0,n=function(e,t){if(f(e,g))throw new d(h);return t.facade=e,c(e,g,t),t},i=function(e){return f(e,g)?e[g]:{}},a=function(e){return f(e,g)}}e.exports={set:n,get:i,has:a,enforce:function(e){return a(e)?i(e):n(e,{})},getterFor:function(e){return function(t){var r;if(!s(t)||(r=i(t)).type!==e)throw new d("Incompatible receiver, "+e+" required");return r}}}},4209:(e,t,r)=>{"use strict";var n=r(8227),i=r(6269),a=n("iterator"),o=Array.prototype;e.exports=function(e){return void 0!==e&&(i.Array===e||o[a]===e)}},4376:(e,t,r)=>{"use strict";var n=r(4576);e.exports=Array.isArray||function(e){return"Array"===n(e)}},4901:e=>{"use strict";var t="object"==typeof document&&document.all;e.exports=void 0===t&&void 0!==t?function(e){return"function"==typeof e||e===t}:function(e){return"function"==typeof e}},3517:(e,t,r)=>{"use strict";var n=r(9504),i=r(9039),a=r(4901),o=r(6955),u=r(7751),s=r(3706),c=function(){},f=u("Reflect","construct"),l=/^\s*(?:class|function)\b/,p=n(l.exec),m=!l.test(c),h=function(e){if(!a(e))return!1;try{return f(c,[],e),!0}catch(e){return!1}},d=function(e){if(!a(e))return!1;switch(o(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return m||!!p(l,s(e))}catch(e){return!0}};d.sham=!0,e.exports=!f||i((function(){var e;return h(h.call)||!h(Object)||!h((function(){e=!0}))||e}))?d:h},2796:(e,t,r)=>{"use strict";var n=r(9039),i=r(4901),a=/#|\.prototype\./,o=function(e,t){var r=s[u(e)];return r===f||r!==c&&(i(t)?n(t):!!t)},u=o.normalize=function(e){return String(e).replace(a,".").toLowerCase()},s=o.data={},c=o.NATIVE="N",f=o.POLYFILL="P";e.exports=o},4117:e=>{"use strict";e.exports=function(e){return null==e}},34:(e,t,r)=>{"use strict";var n=r(4901);e.exports=function(e){return"object"==typeof e?null!==e:n(e)}},3925:(e,t,r)=>{"use strict";var n=r(34);e.exports=function(e){return n(e)||null===e}},6395:e=>{"use strict";e.exports=!1},788:(e,t,r)=>{"use strict";var n=r(34),i=r(4576),a=r(8227)("match");e.exports=function(e){var t;return n(e)&&(void 0!==(t=e[a])?!!t:"RegExp"===i(e))}},757:(e,t,r)=>{"use strict";var n=r(7751),i=r(4901),a=r(1625),o=r(7040),u=Object;e.exports=o?function(e){return"symbol"==typeof e}:function(e){var t=n("Symbol");return i(t)&&a(t.prototype,u(e))}},2652:(e,t,r)=>{"use strict";var n=r(6080),i=r(9565),a=r(8551),o=r(6823),u=r(4209),s=r(6198),c=r(1625),f=r(81),l=r(851),p=r(9539),m=TypeError,h=function(e,t){this.stopped=e,this.result=t},d=h.prototype;e.exports=function(e,t,r){var v,y,g,x,b,w,D,N=r&&r.that,E=!(!r||!r.AS_ENTRIES),A=!(!r||!r.IS_RECORD),S=!(!r||!r.IS_ITERATOR),C=!(!r||!r.INTERRUPTED),M=n(t,N),F=function(e){return v&&p(v,"normal",e),new h(!0,e)},O=function(e){return E?(a(e),C?M(e[0],e[1],F):M(e[0],e[1])):C?M(e,F):M(e)};if(A)v=e.iterator;else if(S)v=e;else{if(!(y=l(e)))throw new m(o(e)+" is not iterable");if(u(y)){for(g=0,x=s(e);x>g;g++)if((b=O(e[g]))&&c(d,b))return b;return new h(!1)}v=f(e,y)}for(w=A?e.next:v.next;!(D=i(w,v)).done;){try{b=O(D.value)}catch(e){p(v,"throw",e)}if("object"==typeof b&&b&&c(d,b))return b}return new h(!1)}},9539:(e,t,r)=>{"use strict";var n=r(9565),i=r(8551),a=r(5966);e.exports=function(e,t,r){var o,u;i(e);try{if(!(o=a(e,"return"))){if("throw"===t)throw r;return r}o=n(o,e)}catch(e){u=!0,o=e}if("throw"===t)throw r;if(u)throw o;return i(o),r}},3994:(e,t,r)=>{"use strict";var n=r(7657).IteratorPrototype,i=r(2360),a=r(6980),o=r(687),u=r(6269),s=function(){return this};e.exports=function(e,t,r,c){var f=t+" Iterator";return e.prototype=i(n,{next:a(+!c,r)}),o(e,f,!1,!0),u[f]=s,e}},1088:(e,t,r)=>{"use strict";var n=r(6518),i=r(9565),a=r(6395),o=r(350),u=r(4901),s=r(3994),c=r(2787),f=r(2967),l=r(687),p=r(6699),m=r(6840),h=r(8227),d=r(6269),v=r(7657),y=o.PROPER,g=o.CONFIGURABLE,x=v.IteratorPrototype,b=v.BUGGY_SAFARI_ITERATORS,w=h("iterator"),D="keys",N="values",E="entries",A=function(){return this};e.exports=function(e,t,r,o,h,v,S){s(r,t,o);var C,M,F,O=function(e){if(e===h&&I)return I;if(!b&&e&&e in B)return B[e];switch(e){case D:case N:case E:return function(){return new r(this,e)}}return function(){return new r(this)}},T=t+" Iterator",_=!1,B=e.prototype,k=B[w]||B["@@iterator"]||h&&B[h],I=!b&&k||O(h),z="Array"===t&&B.entries||k;if(z&&(C=c(z.call(new e)))!==Object.prototype&&C.next&&(a||c(C)===x||(f?f(C,x):u(C[w])||m(C,w,A)),l(C,T,!0,!0),a&&(d[T]=A)),y&&h===N&&k&&k.name!==N&&(!a&&g?p(B,"name",N):(_=!0,I=function(){return i(k,this)})),h)if(M={values:O(N),keys:v?I:O(D),entries:O(E)},S)for(F in M)(b||_||!(F in B))&&m(B,F,M[F]);else n({target:t,proto:!0,forced:b||_},M);return a&&!S||B[w]===I||m(B,w,I,{name:h}),d[t]=I,M}},7657:(e,t,r)=>{"use strict";var n,i,a,o=r(9039),u=r(4901),s=r(34),c=r(2360),f=r(2787),l=r(6840),p=r(8227),m=r(6395),h=p("iterator"),d=!1;[].keys&&("next"in(a=[].keys())?(i=f(f(a)))!==Object.prototype&&(n=i):d=!0),!s(n)||o((function(){var e={};return n[h].call(e)!==e}))?n={}:m&&(n=c(n)),u(n[h])||l(n,h,(function(){return this})),e.exports={IteratorPrototype:n,BUGGY_SAFARI_ITERATORS:d}},6269:e=>{"use strict";e.exports={}},6198:(e,t,r)=>{"use strict";var n=r(8014);e.exports=function(e){return n(e.length)}},283:(e,t,r)=>{"use strict";var n=r(9504),i=r(9039),a=r(4901),o=r(9297),u=r(3724),s=r(350).CONFIGURABLE,c=r(3706),f=r(1181),l=f.enforce,p=f.get,m=String,h=Object.defineProperty,d=n("".slice),v=n("".replace),y=n([].join),g=u&&!i((function(){return 8!==h((function(){}),"length",{value:8}).length})),x=String(String).split("String"),b=e.exports=function(e,t,r){"Symbol("===d(m(t),0,7)&&(t="["+v(m(t),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),r&&r.getter&&(t="get "+t),r&&r.setter&&(t="set "+t),(!o(e,"name")||s&&e.name!==t)&&(u?h(e,"name",{value:t,configurable:!0}):e.name=t),g&&r&&o(r,"arity")&&e.length!==r.arity&&h(e,"length",{value:r.arity});try{r&&o(r,"constructor")&&r.constructor?u&&h(e,"prototype",{writable:!1}):e.prototype&&(e.prototype=void 0)}catch(e){}var n=l(e);return o(n,"source")||(n.source=y(x,"string"==typeof t?t:"")),e};Function.prototype.toString=b((function(){return a(this)&&p(this).source||c(this)}),"toString")},3250:e=>{"use strict";var t=Math.expm1,r=Math.exp;e.exports=!t||t(10)>22025.465794806718||t(10)<22025.465794806718||-2e-17!==t(-2e-17)?function(e){var t=+e;return 0===t?t:t>-1e-6&&t<1e-6?t+t*t/2:r(t)-1}:t},9340:e=>{"use strict";var t=Math.log,r=Math.LOG10E;e.exports=Math.log10||function(e){return t(e)*r}},5359:e=>{"use strict";var t=Math.log;e.exports=Math.log1p||function(e){var r=+e;return r>-1e-8&&r<1e-8?r-r*r/2:t(1+r)}},7782:e=>{"use strict";e.exports=Math.sign||function(e){var t=+e;return 0===t||t!=t?t:t<0?-1:1}},741:e=>{"use strict";var t=Math.ceil,r=Math.floor;e.exports=Math.trunc||function(e){var n=+e;return(n>0?r:t)(n)}},1955:(e,t,r)=>{"use strict";var n,i,a,o,u,s=r(4475),c=r(3389),f=r(6080),l=r(9225).set,p=r(8265),m=r(8119),h=r(28),d=r(6765),v=r(9088),y=s.MutationObserver||s.WebKitMutationObserver,g=s.document,x=s.process,b=s.Promise,w=c("queueMicrotask");if(!w){var D=new p,N=function(){var e,t;for(v&&(e=x.domain)&&e.exit();t=D.get();)try{t()}catch(e){throw D.head&&n(),e}e&&e.enter()};m||v||d||!y||!g?!h&&b&&b.resolve?((o=b.resolve(void 0)).constructor=b,u=f(o.then,o),n=function(){u(N)}):v?n=function(){x.nextTick(N)}:(l=f(l,s),n=function(){l(N)}):(i=!0,a=g.createTextNode(""),new y(N).observe(a,{characterData:!0}),n=function(){a.data=i=!i}),w=function(e){D.head||n(),D.add(e)}}e.exports=w},6043:(e,t,r)=>{"use strict";var n=r(9306),i=TypeError,a=function(e){var t,r;this.promise=new e((function(e,n){if(void 0!==t||void 0!==r)throw new i("Bad Promise constructor");t=e,r=n})),this.resolve=n(t),this.reject=n(r)};e.exports.f=function(e){return new a(e)}},511:(e,t,r)=>{"use strict";var n=r(788),i=TypeError;e.exports=function(e){if(n(e))throw new i("The method doesn't accept regular expressions");return e}},3904:(e,t,r)=>{"use strict";var n=r(4475),i=r(9039),a=r(9504),o=r(655),u=r(3802).trim,s=r(7452),c=a("".charAt),f=n.parseFloat,l=n.Symbol,p=l&&l.iterator,m=1/f(s+"-0")!=-1/0||p&&!i((function(){f(Object(p))}));e.exports=m?function(e){var t=u(o(e)),r=f(t);return 0===r&&"-"===c(t,0)?-0:r}:f},2703:(e,t,r)=>{"use strict";var n=r(4475),i=r(9039),a=r(9504),o=r(655),u=r(3802).trim,s=r(7452),c=n.parseInt,f=n.Symbol,l=f&&f.iterator,p=/^[+-]?0x/i,m=a(p.exec),h=8!==c(s+"08")||22!==c(s+"0x16")||l&&!i((function(){c(Object(l))}));e.exports=h?function(e,t){var r=u(o(e));return c(r,t>>>0||(m(p,r)?16:10))}:c},2360:(e,t,r)=>{"use strict";var n,i=r(8551),a=r(6801),o=r(8727),u=r(421),s=r(397),c=r(4055),f=r(6119),l="prototype",p="script",m=f("IE_PROTO"),h=function(){},d=function(e){return"<"+p+">"+e+"</"+p+">"},v=function(e){e.write(d("")),e.close();var t=e.parentWindow.Object;return e=null,t},y=function(){try{n=new ActiveXObject("htmlfile")}catch(e){}var e,t,r;y="undefined"!=typeof document?document.domain&&n?v(n):(t=c("iframe"),r="java"+p+":",t.style.display="none",s.appendChild(t),t.src=String(r),(e=t.contentWindow.document).open(),e.write(d("document.F=Object")),e.close(),e.F):v(n);for(var i=o.length;i--;)delete y[l][o[i]];return y()};u[m]=!0,e.exports=Object.create||function(e,t){var r;return null!==e?(h[l]=i(e),r=new h,h[l]=null,r[m]=e):r=y(),void 0===t?r:a.f(r,t)}},6801:(e,t,r)=>{"use strict";var n=r(3724),i=r(8686),a=r(4913),o=r(8551),u=r(5397),s=r(1072);t.f=n&&!i?Object.defineProperties:function(e,t){o(e);for(var r,n=u(t),i=s(t),c=i.length,f=0;c>f;)a.f(e,r=i[f++],n[r]);return e}},4913:(e,t,r)=>{"use strict";var n=r(3724),i=r(5917),a=r(8686),o=r(8551),u=r(6969),s=TypeError,c=Object.defineProperty,f=Object.getOwnPropertyDescriptor,l="enumerable",p="configurable",m="writable";t.f=n?a?function(e,t,r){if(o(e),t=u(t),o(r),"function"==typeof e&&"prototype"===t&&"value"in r&&m in r&&!r[m]){var n=f(e,t);n&&n[m]&&(e[t]=r.value,r={configurable:p in r?r[p]:n[p],enumerable:l in r?r[l]:n[l],writable:!1})}return c(e,t,r)}:c:function(e,t,r){if(o(e),t=u(t),o(r),i)try{return c(e,t,r)}catch(e){}if("get"in r||"set"in r)throw new s("Accessors not supported");return"value"in r&&(e[t]=r.value),e}},7347:(e,t,r)=>{"use strict";var n=r(3724),i=r(9565),a=r(8773),o=r(6980),u=r(5397),s=r(6969),c=r(9297),f=r(5917),l=Object.getOwnPropertyDescriptor;t.f=n?l:function(e,t){if(e=u(e),t=s(t),f)try{return l(e,t)}catch(e){}if(c(e,t))return o(!i(a.f,e,t),e[t])}},298:(e,t,r)=>{"use strict";var n=r(4576),i=r(5397),a=r(8480).f,o=r(7680),u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];e.exports.f=function(e){return u&&"Window"===n(e)?function(e){try{return a(e)}catch(e){return o(u)}}(e):a(i(e))}},8480:(e,t,r)=>{"use strict";var n=r(1828),i=r(8727).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(e){return n(e,i)}},3717:(e,t)=>{"use strict";t.f=Object.getOwnPropertySymbols},2787:(e,t,r)=>{"use strict";var n=r(9297),i=r(4901),a=r(8981),o=r(6119),u=r(2211),s=o("IE_PROTO"),c=Object,f=c.prototype;e.exports=u?c.getPrototypeOf:function(e){var t=a(e);if(n(t,s))return t[s];var r=t.constructor;return i(r)&&t instanceof r?r.prototype:t instanceof c?f:null}},4124:(e,t,r)=>{"use strict";var n=r(9039),i=r(34),a=r(4576),o=r(5652),u=Object.isExtensible,s=n((function(){u(1)}));e.exports=s||o?function(e){return!!i(e)&&(!o||"ArrayBuffer"!==a(e))&&(!u||u(e))}:u},1625:(e,t,r)=>{"use strict";var n=r(9504);e.exports=n({}.isPrototypeOf)},1828:(e,t,r)=>{"use strict";var n=r(9504),i=r(9297),a=r(5397),o=r(9617).indexOf,u=r(421),s=n([].push);e.exports=function(e,t){var r,n=a(e),c=0,f=[];for(r in n)!i(u,r)&&i(n,r)&&s(f,r);for(;t.length>c;)i(n,r=t[c++])&&(~o(f,r)||s(f,r));return f}},1072:(e,t,r)=>{"use strict";var n=r(1828),i=r(8727);e.exports=Object.keys||function(e){return n(e,i)}},8773:(e,t)=>{"use strict";var r={}.propertyIsEnumerable,n=Object.getOwnPropertyDescriptor,i=n&&!r.call({1:2},1);t.f=i?function(e){var t=n(this,e);return!!t&&t.enumerable}:r},2967:(e,t,r)=>{"use strict";var n=r(6706),i=r(34),a=r(7750),o=r(3506);e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,r={};try{(e=n(Object.prototype,"__proto__","set"))(r,[]),t=r instanceof Array}catch(e){}return function(r,n){return a(r),o(n),i(r)?(t?e(r,n):r.__proto__=n,r):r}}():void 0)},2357:(e,t,r)=>{"use strict";var n=r(3724),i=r(9039),a=r(9504),o=r(2787),u=r(1072),s=r(5397),c=a(r(8773).f),f=a([].push),l=n&&i((function(){var e=Object.create(null);return e[2]=2,!c(e,2)})),p=function(e){return function(t){for(var r,i=s(t),a=u(i),p=l&&null===o(i),m=a.length,h=0,d=[];m>h;)r=a[h++],n&&!(p?r in i:c(i,r))||f(d,e?[r,i[r]]:i[r]);return d}};e.exports={entries:p(!0),values:p(!1)}},3179:(e,t,r)=>{"use strict";var n=r(2140),i=r(6955);e.exports=n?{}.toString:function(){return"[object "+i(this)+"]"}},4270:(e,t,r)=>{"use strict";var n=r(9565),i=r(4901),a=r(34),o=TypeError;e.exports=function(e,t){var r,u;if("string"===t&&i(r=e.toString)&&!a(u=n(r,e)))return u;if(i(r=e.valueOf)&&!a(u=n(r,e)))return u;if("string"!==t&&i(r=e.toString)&&!a(u=n(r,e)))return u;throw new o("Can't convert object to primitive value")}},5031:(e,t,r)=>{"use strict";var n=r(7751),i=r(9504),a=r(8480),o=r(3717),u=r(8551),s=i([].concat);e.exports=n("Reflect","ownKeys")||function(e){var t=a.f(u(e)),r=o.f;return r?s(t,r(e)):t}},9167:(e,t,r)=>{"use strict";var n=r(4475);e.exports=n},1103:e=>{"use strict";e.exports=function(e){try{return{error:!1,value:e()}}catch(e){return{error:!0,value:e}}}},916:(e,t,r)=>{"use strict";var n=r(4475),i=r(550),a=r(4901),o=r(2796),u=r(3706),s=r(8227),c=r(7290),f=r(516),l=r(6395),p=r(7388),m=i&&i.prototype,h=s("species"),d=!1,v=a(n.PromiseRejectionEvent),y=o("Promise",(function(){var e=u(i),t=e!==String(i);if(!t&&66===p)return!0;if(l&&(!m.catch||!m.finally))return!0;if(!p||p<51||!/native code/.test(e)){var r=new i((function(e){e(1)})),n=function(e){e((function(){}),(function(){}))};if((r.constructor={})[h]=n,!(d=r.then((function(){}))instanceof n))return!0}return!t&&(c||f)&&!v}));e.exports={CONSTRUCTOR:y,REJECTION_EVENT:v,SUBCLASSING:d}},550:(e,t,r)=>{"use strict";var n=r(4475);e.exports=n.Promise},3438:(e,t,r)=>{"use strict";var n=r(8551),i=r(34),a=r(6043);e.exports=function(e,t){if(n(e),i(t)&&t.constructor===e)return t;var r=a.f(e);return(0,r.resolve)(t),r.promise}},537:(e,t,r)=>{"use strict";var n=r(550),i=r(4428),a=r(916).CONSTRUCTOR;e.exports=a||!i((function(e){n.all(e).then(void 0,(function(){}))}))},1056:(e,t,r)=>{"use strict";var n=r(4913).f;e.exports=function(e,t,r){r in e||n(e,r,{configurable:!0,get:function(){return t[r]},set:function(e){t[r]=e}})}},8265:e=>{"use strict";var t=function(){this.head=null,this.tail=null};t.prototype={add:function(e){var t={item:e,next:null},r=this.tail;r?r.next=t:this.head=t,this.tail=t},get:function(){var e=this.head;if(e)return null===(this.head=e.next)&&(this.tail=null),e.item}},e.exports=t},6682:(e,t,r)=>{"use strict";var n=r(9565),i=r(8551),a=r(4901),o=r(4576),u=r(7323),s=TypeError;e.exports=function(e,t){var r=e.exec;if(a(r)){var c=n(r,e,t);return null!==c&&i(c),c}if("RegExp"===o(e))return n(u,e,t);throw new s("RegExp#exec called on incompatible receiver")}},7323:(e,t,r)=>{"use strict";var n,i,a=r(9565),o=r(9504),u=r(655),s=r(7979),c=r(8429),f=r(5745),l=r(2360),p=r(1181).get,m=r(3635),h=r(8814),d=f("native-string-replace",String.prototype.replace),v=RegExp.prototype.exec,y=v,g=o("".charAt),x=o("".indexOf),b=o("".replace),w=o("".slice),D=(i=/b*/g,a(v,n=/a/,"a"),a(v,i,"a"),0!==n.lastIndex||0!==i.lastIndex),N=c.BROKEN_CARET,E=void 0!==/()??/.exec("")[1];(D||E||N||m||h)&&(y=function(e){var t,r,n,i,o,c,f,m=this,h=p(m),A=u(e),S=h.raw;if(S)return S.lastIndex=m.lastIndex,t=a(y,S,A),m.lastIndex=S.lastIndex,t;var C=h.groups,M=N&&m.sticky,F=a(s,m),O=m.source,T=0,_=A;if(M&&(F=b(F,"y",""),-1===x(F,"g")&&(F+="g"),_=w(A,m.lastIndex),m.lastIndex>0&&(!m.multiline||m.multiline&&"\n"!==g(A,m.lastIndex-1))&&(O="(?: "+O+")",_=" "+_,T++),r=new RegExp("^(?:"+O+")",F)),E&&(r=new RegExp("^"+O+"$(?!\\s)",F)),D&&(n=m.lastIndex),i=a(v,M?r:m,_),M?i?(i.input=w(i.input,T),i[0]=w(i[0],T),i.index=m.lastIndex,m.lastIndex+=i[0].length):m.lastIndex=0:D&&i&&(m.lastIndex=m.global?i.index+i[0].length:n),E&&i&&i.length>1&&a(d,i[0],r,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(i[o]=void 0)})),i&&C)for(i.groups=c=l(null),o=0;o<C.length;o++)c[(f=C[o])[0]]=i[f[1]];return i}),e.exports=y},7979:(e,t,r)=>{"use strict";var n=r(8551);e.exports=function(){var e=n(this),t="";return e.hasIndices&&(t+="d"),e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.unicodeSets&&(t+="v"),e.sticky&&(t+="y"),t}},1034:(e,t,r)=>{"use strict";var n=r(9565),i=r(9297),a=r(1625),o=r(7979),u=RegExp.prototype;e.exports=function(e){var t=e.flags;return void 0!==t||"flags"in u||i(e,"flags")||!a(u,e)?t:n(o,e)}},8429:(e,t,r)=>{"use strict";var n=r(9039),i=r(4475).RegExp,a=n((function(){var e=i("a","y");return e.lastIndex=2,null!==e.exec("abcd")})),o=a||n((function(){return!i("a","y").sticky})),u=a||n((function(){var e=i("^r","gy");return e.lastIndex=2,null!==e.exec("str")}));e.exports={BROKEN_CARET:u,MISSED_STICKY:o,UNSUPPORTED_Y:a}},3635:(e,t,r)=>{"use strict";var n=r(9039),i=r(4475).RegExp;e.exports=n((function(){var e=i(".","s");return!(e.dotAll&&e.test("\n")&&"s"===e.flags)}))},8814:(e,t,r)=>{"use strict";var n=r(9039),i=r(4475).RegExp;e.exports=n((function(){var e=i("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")}))},7750:(e,t,r)=>{"use strict";var n=r(4117),i=TypeError;e.exports=function(e){if(n(e))throw new i("Can't call method on "+e);return e}},3389:(e,t,r)=>{"use strict";var n=r(4475),i=r(3724),a=Object.getOwnPropertyDescriptor;e.exports=function(e){if(!i)return n[e];var t=a(n,e);return t&&t.value}},7633:(e,t,r)=>{"use strict";var n=r(7751),i=r(2106),a=r(8227),o=r(3724),u=a("species");e.exports=function(e){var t=n(e);o&&t&&!t[u]&&i(t,u,{configurable:!0,get:function(){return this}})}},687:(e,t,r)=>{"use strict";var n=r(4913).f,i=r(9297),a=r(8227)("toStringTag");e.exports=function(e,t,r){e&&!r&&(e=e.prototype),e&&!i(e,a)&&n(e,a,{configurable:!0,value:t})}},6119:(e,t,r)=>{"use strict";var n=r(5745),i=r(3392),a=n("keys");e.exports=function(e){return a[e]||(a[e]=i(e))}},7629:(e,t,r)=>{"use strict";var n=r(6395),i=r(4475),a=r(9433),o="__core-js_shared__",u=e.exports=i[o]||a(o,{});(u.versions||(u.versions=[])).push({version:"3.37.0",mode:n?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.37.0/LICENSE",source:"https://github.com/zloirock/core-js"})},5745:(e,t,r)=>{"use strict";var n=r(7629);e.exports=function(e,t){return n[e]||(n[e]=t||{})}},2293:(e,t,r)=>{"use strict";var n=r(8551),i=r(5548),a=r(4117),o=r(8227)("species");e.exports=function(e,t){var r,u=n(e).constructor;return void 0===u||a(r=n(u)[o])?t:i(r)}},3061:(e,t,r)=>{"use strict";var n=r(9039);e.exports=function(e){return n((function(){var t=""[e]('"');return t!==t.toLowerCase()||t.split('"').length>3}))}},8183:(e,t,r)=>{"use strict";var n=r(9504),i=r(1291),a=r(655),o=r(7750),u=n("".charAt),s=n("".charCodeAt),c=n("".slice),f=function(e){return function(t,r){var n,f,l=a(o(t)),p=i(r),m=l.length;return p<0||p>=m?e?"":void 0:(n=s(l,p))<55296||n>56319||p+1===m||(f=s(l,p+1))<56320||f>57343?e?u(l,p):n:e?c(l,p,p+2):f-56320+(n-55296<<10)+65536}};e.exports={codeAt:f(!1),charAt:f(!0)}},2333:(e,t,r)=>{"use strict";var n=r(1291),i=r(655),a=r(7750),o=RangeError;e.exports=function(e){var t=i(a(this)),r="",u=n(e);if(u<0||u===1/0)throw new o("Wrong number of repetitions");for(;u>0;(u>>>=1)&&(t+=t))1&u&&(r+=t);return r}},706:(e,t,r)=>{"use strict";var n=r(350).PROPER,i=r(9039),a=r(7452);e.exports=function(e){return i((function(){return!!a[e]()||"​᠎"!=="​᠎"[e]()||n&&a[e].name!==e}))}},3802:(e,t,r)=>{"use strict";var n=r(9504),i=r(7750),a=r(655),o=r(7452),u=n("".replace),s=RegExp("^["+o+"]+"),c=RegExp("(^|[^"+o+"])["+o+"]+$"),f=function(e){return function(t){var r=a(i(t));return 1&e&&(r=u(r,s,"")),2&e&&(r=u(r,c,"$1")),r}};e.exports={start:f(1),end:f(2),trim:f(3)}},4495:(e,t,r)=>{"use strict";var n=r(7388),i=r(9039),a=r(4475).String;e.exports=!!Object.getOwnPropertySymbols&&!i((function(){var e=Symbol("symbol detection");return!a(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&n&&n<41}))},8242:(e,t,r)=>{"use strict";var n=r(9565),i=r(7751),a=r(8227),o=r(6840);e.exports=function(){var e=i("Symbol"),t=e&&e.prototype,r=t&&t.valueOf,u=a("toPrimitive");t&&!t[u]&&o(t,u,(function(e){return n(r,this)}),{arity:1})}},1296:(e,t,r)=>{"use strict";var n=r(4495);e.exports=n&&!!Symbol.for&&!!Symbol.keyFor},9225:(e,t,r)=>{"use strict";var n,i,a,o,u=r(4475),s=r(8745),c=r(6080),f=r(4901),l=r(9297),p=r(9039),m=r(397),h=r(7680),d=r(4055),v=r(2812),y=r(8119),g=r(9088),x=u.setImmediate,b=u.clearImmediate,w=u.process,D=u.Dispatch,N=u.Function,E=u.MessageChannel,A=u.String,S=0,C={},M="onreadystatechange";p((function(){n=u.location}));var F=function(e){if(l(C,e)){var t=C[e];delete C[e],t()}},O=function(e){return function(){F(e)}},T=function(e){F(e.data)},_=function(e){u.postMessage(A(e),n.protocol+"//"+n.host)};x&&b||(x=function(e){v(arguments.length,1);var t=f(e)?e:N(e),r=h(arguments,1);return C[++S]=function(){s(t,void 0,r)},i(S),S},b=function(e){delete C[e]},g?i=function(e){w.nextTick(O(e))}:D&&D.now?i=function(e){D.now(O(e))}:E&&!y?(o=(a=new E).port2,a.port1.onmessage=T,i=c(o.postMessage,o)):u.addEventListener&&f(u.postMessage)&&!u.importScripts&&n&&"file:"!==n.protocol&&!p(_)?(i=_,u.addEventListener("message",T,!1)):i=M in d("script")?function(e){m.appendChild(d("script"))[M]=function(){m.removeChild(this),F(e)}}:function(e){setTimeout(O(e),0)}),e.exports={set:x,clear:b}},1240:(e,t,r)=>{"use strict";var n=r(9504);e.exports=n(1..valueOf)},5610:(e,t,r)=>{"use strict";var n=r(1291),i=Math.max,a=Math.min;e.exports=function(e,t){var r=n(e);return r<0?i(r+t,0):a(r,t)}},5397:(e,t,r)=>{"use strict";var n=r(7055),i=r(7750);e.exports=function(e){return n(i(e))}},1291:(e,t,r)=>{"use strict";var n=r(741);e.exports=function(e){var t=+e;return t!=t||0===t?0:n(t)}},8014:(e,t,r)=>{"use strict";var n=r(1291),i=Math.min;e.exports=function(e){var t=n(e);return t>0?i(t,9007199254740991):0}},8981:(e,t,r)=>{"use strict";var n=r(7750),i=Object;e.exports=function(e){return i(n(e))}},2777:(e,t,r)=>{"use strict";var n=r(9565),i=r(34),a=r(757),o=r(5966),u=r(4270),s=r(8227),c=TypeError,f=s("toPrimitive");e.exports=function(e,t){if(!i(e)||a(e))return e;var r,s=o(e,f);if(s){if(void 0===t&&(t="default"),r=n(s,e,t),!i(r)||a(r))return r;throw new c("Can't convert object to primitive value")}return void 0===t&&(t="number"),u(e,t)}},6969:(e,t,r)=>{"use strict";var n=r(2777),i=r(757);e.exports=function(e){var t=n(e,"string");return i(t)?t:t+""}},2140:(e,t,r)=>{"use strict";var n={};n[r(8227)("toStringTag")]="z",e.exports="[object z]"===String(n)},655:(e,t,r)=>{"use strict";var n=r(6955),i=String;e.exports=function(e){if("Symbol"===n(e))throw new TypeError("Cannot convert a Symbol value to a string");return i(e)}},6823:e=>{"use strict";var t=String;e.exports=function(e){try{return t(e)}catch(e){return"Object"}}},3392:(e,t,r)=>{"use strict";var n=r(9504),i=0,a=Math.random(),o=n(1..toString);e.exports=function(e){return"Symbol("+(void 0===e?"":e)+")_"+o(++i+a,36)}},7040:(e,t,r)=>{"use strict";var n=r(4495);e.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},8686:(e,t,r)=>{"use strict";var n=r(3724),i=r(9039);e.exports=n&&i((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},2812:e=>{"use strict";var t=TypeError;e.exports=function(e,r){if(e<r)throw new t("Not enough arguments");return e}},8622:(e,t,r)=>{"use strict";var n=r(4475),i=r(4901),a=n.WeakMap;e.exports=i(a)&&/native code/.test(String(a))},5749:(e,t,r)=>{"use strict";var n=r(9167),i=r(9297),a=r(1951),o=r(4913).f;e.exports=function(e){var t=n.Symbol||(n.Symbol={});i(t,e)||o(t,e,{value:a.f(e)})}},1951:(e,t,r)=>{"use strict";var n=r(8227);t.f=n},8227:(e,t,r)=>{"use strict";var n=r(4475),i=r(5745),a=r(9297),o=r(3392),u=r(4495),s=r(7040),c=n.Symbol,f=i("wks"),l=s?c.for||c:c&&c.withoutSetter||o;e.exports=function(e){return a(f,e)||(f[e]=u&&a(c,e)?c[e]:l("Symbol."+e)),f[e]}},7452:e=>{"use strict";e.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},8706:(e,t,r)=>{"use strict";var n=r(6518),i=r(9039),a=r(4376),o=r(34),u=r(8981),s=r(6198),c=r(6837),f=r(4659),l=r(1469),p=r(597),m=r(8227),h=r(7388),d=m("isConcatSpreadable"),v=h>=51||!i((function(){var e=[];return e[d]=!1,e.concat()[0]!==e})),y=function(e){if(!o(e))return!1;var t=e[d];return void 0!==t?!!t:a(e)};n({target:"Array",proto:!0,arity:1,forced:!v||!p("concat")},{concat:function(e){var t,r,n,i,a,o=u(this),p=l(o,0),m=0;for(t=-1,n=arguments.length;t<n;t++)if(y(a=-1===t?o:arguments[t]))for(i=s(a),c(m+i),r=0;r<i;r++,m++)r in a&&f(p,m,a[r]);else c(m+1),f(p,m++,a);return p.length=m,p}})},8431:(e,t,r)=>{"use strict";var n=r(6518),i=r(9213).every;n({target:"Array",proto:!0,forced:!r(4598)("every")},{every:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}})},3771:(e,t,r)=>{"use strict";var n=r(6518),i=r(4373),a=r(6469);n({target:"Array",proto:!0},{fill:i}),a("fill")},2008:(e,t,r)=>{"use strict";var n=r(6518),i=r(9213).filter;n({target:"Array",proto:!0,forced:!r(597)("filter")},{filter:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}})},113:(e,t,r)=>{"use strict";var n=r(6518),i=r(9213).find,a=r(6469),o="find",u=!0;o in[]&&Array(1)[o]((function(){u=!1})),n({target:"Array",proto:!0,forced:u},{find:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}}),a(o)},1629:(e,t,r)=>{"use strict";var n=r(6518),i=r(235);n({target:"Array",proto:!0,forced:[].forEach!==i},{forEach:i})},3418:(e,t,r)=>{"use strict";var n=r(6518),i=r(7916);n({target:"Array",stat:!0,forced:!r(4428)((function(e){Array.from(e)}))},{from:i})},4423:(e,t,r)=>{"use strict";var n=r(6518),i=r(9617).includes,a=r(9039),o=r(6469);n({target:"Array",proto:!0,forced:a((function(){return!Array(1).includes()}))},{includes:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}}),o("includes")},5276:(e,t,r)=>{"use strict";var n=r(6518),i=r(7476),a=r(9617).indexOf,o=r(4598),u=i([].indexOf),s=!!u&&1/u([1],1,-0)<0;n({target:"Array",proto:!0,forced:s||!o("indexOf")},{indexOf:function(e){var t=arguments.length>1?arguments[1]:void 0;return s?u(this,e,t)||0:a(this,e,t)}})},4346:(e,t,r)=>{"use strict";r(6518)({target:"Array",stat:!0},{isArray:r(4376)})},3792:(e,t,r)=>{"use strict";var n=r(5397),i=r(6469),a=r(6269),o=r(1181),u=r(4913).f,s=r(1088),c=r(2529),f=r(6395),l=r(3724),p="Array Iterator",m=o.set,h=o.getterFor(p);e.exports=s(Array,"Array",(function(e,t){m(this,{type:p,target:n(e),index:0,kind:t})}),(function(){var e=h(this),t=e.target,r=e.index++;if(!t||r>=t.length)return e.target=void 0,c(void 0,!0);switch(e.kind){case"keys":return c(r,!1);case"values":return c(t[r],!1)}return c([r,t[r]],!1)}),"values");var d=a.Arguments=a.Array;if(i("keys"),i("values"),i("entries"),!f&&l&&"values"!==d.name)try{u(d,"name",{value:"values"})}catch(e){}},8598:(e,t,r)=>{"use strict";var n=r(6518),i=r(9504),a=r(7055),o=r(5397),u=r(4598),s=i([].join);n({target:"Array",proto:!0,forced:a!==Object||!u("join",",")},{join:function(e){return s(o(this),void 0===e?",":e)}})},2062:(e,t,r)=>{"use strict";var n=r(6518),i=r(9213).map;n({target:"Array",proto:!0,forced:!r(597)("map")},{map:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}})},2712:(e,t,r)=>{"use strict";var n=r(6518),i=r(926).left,a=r(4598),o=r(7388);n({target:"Array",proto:!0,forced:!r(9088)&&o>79&&o<83||!a("reduce")},{reduce:function(e){var t=arguments.length;return i(this,e,t,t>1?arguments[1]:void 0)}})},4490:(e,t,r)=>{"use strict";var n=r(6518),i=r(9504),a=r(4376),o=i([].reverse),u=[1,2];n({target:"Array",proto:!0,forced:String(u)===String(u.reverse())},{reverse:function(){return a(this)&&(this.length=this.length),o(this)}})},4782:(e,t,r)=>{"use strict";var n=r(6518),i=r(4376),a=r(3517),o=r(34),u=r(5610),s=r(6198),c=r(5397),f=r(4659),l=r(8227),p=r(597),m=r(7680),h=p("slice"),d=l("species"),v=Array,y=Math.max;n({target:"Array",proto:!0,forced:!h},{slice:function(e,t){var r,n,l,p=c(this),h=s(p),g=u(e,h),x=u(void 0===t?h:t,h);if(i(p)&&(r=p.constructor,(a(r)&&(r===v||i(r.prototype))||o(r)&&null===(r=r[d]))&&(r=void 0),r===v||void 0===r))return m(p,g,x);for(n=new(void 0===r?v:r)(y(x-g,0)),l=0;g<x;g++,l++)g in p&&f(n,l,p[g]);return n.length=l,n}})},5086:(e,t,r)=>{"use strict";var n=r(6518),i=r(9213).some;n({target:"Array",proto:!0,forced:!r(4598)("some")},{some:function(e){return i(this,e,arguments.length>1?arguments[1]:void 0)}})},6910:(e,t,r)=>{"use strict";var n=r(6518),i=r(9504),a=r(9306),o=r(8981),u=r(6198),s=r(4606),c=r(655),f=r(9039),l=r(4488),p=r(4598),m=r(8834),h=r(3202),d=r(7388),v=r(9160),y=[],g=i(y.sort),x=i(y.push),b=f((function(){y.sort(void 0)})),w=f((function(){y.sort(null)})),D=p("sort"),N=!f((function(){if(d)return d<70;if(!(m&&m>3)){if(h)return!0;if(v)return v<603;var e,t,r,n,i="";for(e=65;e<76;e++){switch(t=String.fromCharCode(e),e){case 66:case 69:case 70:case 72:r=3;break;case 68:case 71:r=4;break;default:r=2}for(n=0;n<47;n++)y.push({k:t+n,v:r})}for(y.sort((function(e,t){return t.v-e.v})),n=0;n<y.length;n++)t=y[n].k.charAt(0),i.charAt(i.length-1)!==t&&(i+=t);return"DGBEFHACIJK"!==i}}));n({target:"Array",proto:!0,forced:b||!w||!D||!N},{sort:function(e){void 0!==e&&a(e);var t=o(this);if(N)return void 0===e?g(t):g(t,e);var r,n,i=[],f=u(t);for(n=0;n<f;n++)n in t&&x(i,t[n]);for(l(i,function(e){return function(t,r){return void 0===r?-1:void 0===t?1:void 0!==e?+e(t,r)||0:c(t)>c(r)?1:-1}}(e)),r=u(i),n=0;n<r;)t[n]=i[n++];for(;n<f;)s(t,n++);return t}})},4554:(e,t,r)=>{"use strict";var n=r(6518),i=r(8981),a=r(5610),o=r(1291),u=r(6198),s=r(4527),c=r(6837),f=r(1469),l=r(4659),p=r(4606),m=r(597)("splice"),h=Math.max,d=Math.min;n({target:"Array",proto:!0,forced:!m},{splice:function(e,t){var r,n,m,v,y,g,x=i(this),b=u(x),w=a(e,b),D=arguments.length;for(0===D?r=n=0:1===D?(r=0,n=b-w):(r=D-2,n=d(h(o(t),0),b-w)),c(b+r-n),m=f(x,n),v=0;v<n;v++)(y=w+v)in x&&l(m,v,x[y]);if(m.length=n,r<n){for(v=w;v<b-n;v++)g=v+r,(y=v+n)in x?x[g]=x[y]:p(x,g);for(v=b;v>b-n+r;v--)p(x,v-1)}else if(r>n)for(v=b-n;v>w;v--)g=v+r-1,(y=v+n-1)in x?x[g]=x[y]:p(x,g);for(v=0;v<r;v++)x[v+w]=arguments[v+2];return s(x,b-n+r),m}})},9089:(e,t,r)=>{"use strict";var n=r(6518),i=r(9504),a=Date,o=i(a.prototype.getTime);n({target:"Date",stat:!0},{now:function(){return o(new a)}})},739:(e,t,r)=>{"use strict";var n=r(6518),i=r(9039),a=r(8981),o=r(2777);n({target:"Date",proto:!0,arity:1,forced:i((function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}))},{toJSON:function(e){var t=a(this),r=o(t,"number");return"number"!=typeof r||isFinite(r)?t.toISOString():null}})},3288:(e,t,r)=>{"use strict";var n=r(9504),i=r(6840),a=Date.prototype,o="Invalid Date",u="toString",s=n(a[u]),c=n(a.getTime);String(new Date(NaN))!==o&&i(a,u,(function(){var e=c(this);return e==e?s(this):o}))},4170:(e,t,r)=>{"use strict";var n=r(6518),i=r(566);n({target:"Function",proto:!0,forced:Function.bind!==i},{bind:i})},2010:(e,t,r)=>{"use strict";var n=r(3724),i=r(350).EXISTS,a=r(9504),o=r(2106),u=Function.prototype,s=a(u.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,f=a(c.exec);n&&!i&&o(u,"name",{configurable:!0,get:function(){try{return f(c,s(this))[1]}catch(e){return""}}})},3110:(e,t,r)=>{"use strict";var n=r(6518),i=r(7751),a=r(8745),o=r(9565),u=r(9504),s=r(9039),c=r(4901),f=r(757),l=r(7680),p=r(6933),m=r(4495),h=String,d=i("JSON","stringify"),v=u(/./.exec),y=u("".charAt),g=u("".charCodeAt),x=u("".replace),b=u(1..toString),w=/[\uD800-\uDFFF]/g,D=/^[\uD800-\uDBFF]$/,N=/^[\uDC00-\uDFFF]$/,E=!m||s((function(){var e=i("Symbol")("stringify detection");return"[null]"!==d([e])||"{}"!==d({a:e})||"{}"!==d(Object(e))})),A=s((function(){return'"\\udf06\\ud834"'!==d("\udf06\ud834")||'"\\udead"'!==d("\udead")})),S=function(e,t){var r=l(arguments),n=p(t);if(c(n)||void 0!==e&&!f(e))return r[1]=function(e,t){if(c(n)&&(t=o(n,this,h(e),t)),!f(t))return t},a(d,null,r)},C=function(e,t,r){var n=y(r,t-1),i=y(r,t+1);return v(D,e)&&!v(N,i)||v(N,e)&&!v(D,n)?"\\u"+b(g(e,0),16):e};d&&n({target:"JSON",stat:!0,arity:3,forced:E||A},{stringify:function(e,t,r){var n=l(arguments),i=a(E?S:d,null,n);return A&&"string"==typeof i?x(i,w,C):i}})},8523:(e,t,r)=>{"use strict";r(6468)("Map",(function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}}),r(6938))},6033:(e,t,r)=>{"use strict";r(8523)},3153:(e,t,r)=>{"use strict";var n=r(6518),i=r(5359),a=Math.acosh,o=Math.log,u=Math.sqrt,s=Math.LN2;n({target:"Math",stat:!0,forced:!a||710!==Math.floor(a(Number.MAX_VALUE))||a(1/0)!==1/0},{acosh:function(e){var t=+e;return t<1?NaN:t>94906265.62425156?o(t)+s:i(t-1+u(t-1)*u(t+1))}})},2326:(e,t,r)=>{"use strict";var n=r(6518),i=Math.asinh,a=Math.log,o=Math.sqrt;n({target:"Math",stat:!0,forced:!(i&&1/i(0)>0)},{asinh:function e(t){var r=+t;return isFinite(r)&&0!==r?r<0?-e(-r):a(r+o(r*r+1)):r}})},6389:(e,t,r)=>{"use strict";var n=r(6518),i=Math.atanh,a=Math.log;n({target:"Math",stat:!0,forced:!(i&&1/i(-0)<0)},{atanh:function(e){var t=+e;return 0===t?t:a((1+t)/(1-t))/2}})},4444:(e,t,r)=>{"use strict";var n=r(6518),i=r(7782),a=Math.abs,o=Math.pow;n({target:"Math",stat:!0},{cbrt:function(e){var t=+e;return i(t)*o(a(t),1/3)}})},7762:(e,t,r)=>{"use strict";var n=r(6518),i=r(3250),a=Math.cosh,o=Math.abs,u=Math.E;n({target:"Math",stat:!0,forced:!a||a(710)===1/0},{cosh:function(e){var t=i(o(e)-1)+1;return(t+1/(t*u*u))*(u/2)}})},5070:(e,t,r)=>{"use strict";var n=r(6518),i=r(3250);n({target:"Math",stat:!0,forced:i!==Math.expm1},{expm1:i})},5376:(e,t,r)=>{"use strict";r(6518)({target:"Math",stat:!0},{log10:r(9340)})},6624:(e,t,r)=>{"use strict";r(6518)({target:"Math",stat:!0},{log1p:r(5359)})},1367:(e,t,r)=>{"use strict";var n=r(6518),i=Math.log,a=Math.LN2;n({target:"Math",stat:!0},{log2:function(e){return i(e)/a}})},5914:(e,t,r)=>{"use strict";r(6518)({target:"Math",stat:!0},{sign:r(7782)})},8553:(e,t,r)=>{"use strict";var n=r(6518),i=r(9039),a=r(3250),o=Math.abs,u=Math.exp,s=Math.E;n({target:"Math",stat:!0,forced:i((function(){return-2e-17!==Math.sinh(-2e-17)}))},{sinh:function(e){var t=+e;return o(t)<1?(a(t)-a(-t))/2:(u(t-1)-u(-t-1))*(s/2)}})},8690:(e,t,r)=>{"use strict";var n=r(6518),i=r(3250),a=Math.exp;n({target:"Math",stat:!0},{tanh:function(e){var t=+e,r=i(t),n=i(-t);return r===1/0?1:n===1/0?-1:(r-n)/(a(t)+a(-t))}})},2892:(e,t,r)=>{"use strict";var n=r(6518),i=r(6395),a=r(3724),o=r(4475),u=r(9167),s=r(9504),c=r(2796),f=r(9297),l=r(3167),p=r(1625),m=r(757),h=r(2777),d=r(9039),v=r(8480).f,y=r(7347).f,g=r(4913).f,x=r(1240),b=r(3802).trim,w="Number",D=o[w],N=u[w],E=D.prototype,A=o.TypeError,S=s("".slice),C=s("".charCodeAt),M=c(w,!D(" 0o1")||!D("0b1")||D("+0x1")),F=function(e){var t,r=arguments.length<1?0:D(function(e){var t=h(e,"number");return"bigint"==typeof t?t:function(e){var t,r,n,i,a,o,u,s,c=h(e,"number");if(m(c))throw new A("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=b(c),43===(t=C(c,0))||45===t){if(88===(r=C(c,2))||120===r)return NaN}else if(48===t){switch(C(c,1)){case 66:case 98:n=2,i=49;break;case 79:case 111:n=8,i=55;break;default:return+c}for(o=(a=S(c,2)).length,u=0;u<o;u++)if((s=C(a,u))<48||s>i)return NaN;return parseInt(a,n)}return+c}(t)}(e));return p(E,t=this)&&d((function(){x(t)}))?l(Object(r),this,F):r};F.prototype=E,M&&!i&&(E.constructor=F),n({global:!0,constructor:!0,wrap:!0,forced:M},{Number:F});var O=function(e,t){for(var r,n=a?v(t):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),i=0;n.length>i;i++)f(t,r=n[i])&&!f(e,r)&&g(e,r,y(t,r))};i&&N&&O(u[w],N),(M||i)&&O(u[w],D)},5374:(e,t,r)=>{"use strict";r(6518)({target:"Number",stat:!0,nonConfigurable:!0,nonWritable:!0},{EPSILON:Math.pow(2,-52)})},150:(e,t,r)=>{"use strict";r(6518)({target:"Number",stat:!0},{isNaN:function(e){return e!=e}})},9868:(e,t,r)=>{"use strict";var n=r(6518),i=r(9504),a=r(1291),o=r(1240),u=r(2333),s=r(9039),c=RangeError,f=String,l=Math.floor,p=i(u),m=i("".slice),h=i(1..toFixed),d=function(e,t,r){return 0===t?r:t%2==1?d(e,t-1,r*e):d(e*e,t/2,r)},v=function(e,t,r){for(var n=-1,i=r;++n<6;)i+=t*e[n],e[n]=i%1e7,i=l(i/1e7)},y=function(e,t){for(var r=6,n=0;--r>=0;)n+=e[r],e[r]=l(n/t),n=n%t*1e7},g=function(e){for(var t=6,r="";--t>=0;)if(""!==r||0===t||0!==e[t]){var n=f(e[t]);r=""===r?n:r+p("0",7-n.length)+n}return r};n({target:"Number",proto:!0,forced:s((function(){return"0.000"!==h(8e-5,3)||"1"!==h(.9,0)||"1.25"!==h(1.255,2)||"1000000000000000128"!==h(0xde0b6b3a7640080,0)}))||!s((function(){h({})}))},{toFixed:function(e){var t,r,n,i,u=o(this),s=a(e),l=[0,0,0,0,0,0],h="",x="0";if(s<0||s>20)throw new c("Incorrect fraction digits");if(u!=u)return"NaN";if(u<=-1e21||u>=1e21)return f(u);if(u<0&&(h="-",u=-u),u>1e-21)if(r=(t=function(e){for(var t=0,r=e;r>=4096;)t+=12,r/=4096;for(;r>=2;)t+=1,r/=2;return t}(u*d(2,69,1))-69)<0?u*d(2,-t,1):u/d(2,t,1),r*=4503599627370496,(t=52-t)>0){for(v(l,0,r),n=s;n>=7;)v(l,1e7,0),n-=7;for(v(l,d(10,n,1),0),n=t-1;n>=23;)y(l,1<<23),n-=23;y(l,1<<n),v(l,1,1),y(l,2),x=g(l)}else v(l,0,r),v(l,1<<-t,0),x=g(l)+p("0",s);return s>0?h+((i=x.length)<=s?"0."+p("0",s-i)+x:m(x,0,i-s)+"."+m(x,i-s)):h+x}})},630:(e,t,r)=>{"use strict";var n=r(6518),i=r(9504),a=r(9039),o=r(1240),u=i(1..toPrecision);n({target:"Number",proto:!0,forced:a((function(){return"1"!==u(1,void 0)}))||!a((function(){u({})}))},{toPrecision:function(e){return void 0===e?u(o(this)):u(o(this),e)}})},9904:(e,t,r)=>{"use strict";r(6518)({target:"Object",stat:!0,sham:!r(3724)},{create:r(2360)})},7945:(e,t,r)=>{"use strict";var n=r(6518),i=r(3724),a=r(6801).f;n({target:"Object",stat:!0,forced:Object.defineProperties!==a,sham:!i},{defineProperties:a})},4185:(e,t,r)=>{"use strict";var n=r(6518),i=r(3724),a=r(4913).f;n({target:"Object",stat:!0,forced:Object.defineProperty!==a,sham:!i},{defineProperty:a})},3851:(e,t,r)=>{"use strict";var n=r(6518),i=r(9039),a=r(5397),o=r(7347).f,u=r(3724);n({target:"Object",stat:!0,forced:!u||i((function(){o(1)})),sham:!u},{getOwnPropertyDescriptor:function(e,t){return o(a(e),t)}})},1278:(e,t,r)=>{"use strict";var n=r(6518),i=r(3724),a=r(5031),o=r(5397),u=r(7347),s=r(4659);n({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(e){for(var t,r,n=o(e),i=u.f,c=a(n),f={},l=0;c.length>l;)void 0!==(r=i(n,t=c[l++]))&&s(f,t,r);return f}})},9773:(e,t,r)=>{"use strict";var n=r(6518),i=r(4495),a=r(9039),o=r(3717),u=r(8981);n({target:"Object",stat:!0,forced:!i||a((function(){o.f(1)}))},{getOwnPropertySymbols:function(e){var t=o.f;return t?t(u(e)):[]}})},875:(e,t,r)=>{"use strict";var n=r(6518),i=r(9039),a=r(8981),o=r(2787),u=r(2211);n({target:"Object",stat:!0,forced:i((function(){o(1)})),sham:!u},{getPrototypeOf:function(e){return o(a(e))}})},9432:(e,t,r)=>{"use strict";var n=r(6518),i=r(8981),a=r(1072);n({target:"Object",stat:!0,forced:r(9039)((function(){a(1)}))},{keys:function(e){return a(i(e))}})},6099:(e,t,r)=>{"use strict";var n=r(2140),i=r(6840),a=r(3179);n||i(Object.prototype,"toString",a,{unsafe:!0})},6034:(e,t,r)=>{"use strict";var n=r(6518),i=r(2357).values;n({target:"Object",stat:!0},{values:function(e){return i(e)}})},8459:(e,t,r)=>{"use strict";var n=r(6518),i=r(3904);n({global:!0,forced:parseFloat!==i},{parseFloat:i})},8940:(e,t,r)=>{"use strict";var n=r(6518),i=r(2703);n({global:!0,forced:parseInt!==i},{parseInt:i})},6499:(e,t,r)=>{"use strict";var n=r(6518),i=r(9565),a=r(9306),o=r(6043),u=r(1103),s=r(2652);n({target:"Promise",stat:!0,forced:r(537)},{all:function(e){var t=this,r=o.f(t),n=r.resolve,c=r.reject,f=u((function(){var r=a(t.resolve),o=[],u=0,f=1;s(e,(function(e){var a=u++,s=!1;f++,i(r,t,e).then((function(e){s||(s=!0,o[a]=e,--f||n(o))}),c)})),--f||n(o)}));return f.error&&c(f.value),r.promise}})},2003:(e,t,r)=>{"use strict";var n=r(6518),i=r(6395),a=r(916).CONSTRUCTOR,o=r(550),u=r(7751),s=r(4901),c=r(6840),f=o&&o.prototype;if(n({target:"Promise",proto:!0,forced:a,real:!0},{catch:function(e){return this.then(void 0,e)}}),!i&&s(o)){var l=u("Promise").prototype.catch;f.catch!==l&&c(f,"catch",l,{unsafe:!0})}},436:(e,t,r)=>{"use strict";var n,i,a,o=r(6518),u=r(6395),s=r(9088),c=r(4475),f=r(9565),l=r(6840),p=r(2967),m=r(687),h=r(7633),d=r(9306),v=r(4901),y=r(34),g=r(679),x=r(2293),b=r(9225).set,w=r(1955),D=r(3138),N=r(1103),E=r(8265),A=r(1181),S=r(550),C=r(916),M=r(6043),F="Promise",O=C.CONSTRUCTOR,T=C.REJECTION_EVENT,_=C.SUBCLASSING,B=A.getterFor(F),k=A.set,I=S&&S.prototype,z=S,R=I,q=c.TypeError,j=c.document,P=c.process,L=M.f,U=L,$=!!(j&&j.createEvent&&c.dispatchEvent),H="unhandledrejection",G=function(e){var t;return!(!y(e)||!v(t=e.then))&&t},V=function(e,t){var r,n,i,a=t.value,o=1===t.state,u=o?e.ok:e.fail,s=e.resolve,c=e.reject,l=e.domain;try{u?(o||(2===t.rejection&&X(t),t.rejection=1),!0===u?r=a:(l&&l.enter(),r=u(a),l&&(l.exit(),i=!0)),r===e.promise?c(new q("Promise-chain cycle")):(n=G(r))?f(n,r,s,c):s(r)):c(a)}catch(e){l&&!i&&l.exit(),c(e)}},Z=function(e,t){e.notified||(e.notified=!0,w((function(){for(var r,n=e.reactions;r=n.get();)V(r,e);e.notified=!1,t&&!e.rejection&&Y(e)})))},W=function(e,t,r){var n,i;$?((n=j.createEvent("Event")).promise=t,n.reason=r,n.initEvent(e,!1,!0),c.dispatchEvent(n)):n={promise:t,reason:r},!T&&(i=c["on"+e])?i(n):e===H&&D("Unhandled promise rejection",r)},Y=function(e){f(b,c,(function(){var t,r=e.facade,n=e.value;if(J(e)&&(t=N((function(){s?P.emit("unhandledRejection",n,r):W(H,r,n)})),e.rejection=s||J(e)?2:1,t.error))throw t.value}))},J=function(e){return 1!==e.rejection&&!e.parent},X=function(e){f(b,c,(function(){var t=e.facade;s?P.emit("rejectionHandled",t):W("rejectionhandled",t,e.value)}))},Q=function(e,t,r){return function(n){e(t,n,r)}},K=function(e,t,r){e.done||(e.done=!0,r&&(e=r),e.value=t,e.state=2,Z(e,!0))},ee=function(e,t,r){if(!e.done){e.done=!0,r&&(e=r);try{if(e.facade===t)throw new q("Promise can't be resolved itself");var n=G(t);n?w((function(){var r={done:!1};try{f(n,t,Q(ee,r,e),Q(K,r,e))}catch(t){K(r,t,e)}})):(e.value=t,e.state=1,Z(e,!1))}catch(t){K({done:!1},t,e)}}};if(O&&(R=(z=function(e){g(this,R),d(e),f(n,this);var t=B(this);try{e(Q(ee,t),Q(K,t))}catch(e){K(t,e)}}).prototype,(n=function(e){k(this,{type:F,done:!1,notified:!1,parent:!1,reactions:new E,rejection:!1,state:0,value:void 0})}).prototype=l(R,"then",(function(e,t){var r=B(this),n=L(x(this,z));return r.parent=!0,n.ok=!v(e)||e,n.fail=v(t)&&t,n.domain=s?P.domain:void 0,0===r.state?r.reactions.add(n):w((function(){V(n,r)})),n.promise})),i=function(){var e=new n,t=B(e);this.promise=e,this.resolve=Q(ee,t),this.reject=Q(K,t)},M.f=L=function(e){return e===z||void 0===e?new i(e):U(e)},!u&&v(S)&&I!==Object.prototype)){a=I.then,_||l(I,"then",(function(e,t){var r=this;return new z((function(e,t){f(a,r,e,t)})).then(e,t)}),{unsafe:!0});try{delete I.constructor}catch(e){}p&&p(I,R)}o({global:!0,constructor:!0,wrap:!0,forced:O},{Promise:z}),m(z,F,!1,!0),h(F)},3362:(e,t,r)=>{"use strict";r(436),r(6499),r(2003),r(7743),r(1481),r(280)},7743:(e,t,r)=>{"use strict";var n=r(6518),i=r(9565),a=r(9306),o=r(6043),u=r(1103),s=r(2652);n({target:"Promise",stat:!0,forced:r(537)},{race:function(e){var t=this,r=o.f(t),n=r.reject,c=u((function(){var o=a(t.resolve);s(e,(function(e){i(o,t,e).then(r.resolve,n)}))}));return c.error&&n(c.value),r.promise}})},1481:(e,t,r)=>{"use strict";var n=r(6518),i=r(6043);n({target:"Promise",stat:!0,forced:r(916).CONSTRUCTOR},{reject:function(e){var t=i.f(this);return(0,t.reject)(e),t.promise}})},280:(e,t,r)=>{"use strict";var n=r(6518),i=r(7751),a=r(6395),o=r(550),u=r(916).CONSTRUCTOR,s=r(3438),c=i("Promise"),f=a&&!u;n({target:"Promise",stat:!0,forced:a||u},{resolve:function(e){return s(f&&this===c?o:this,e)}})},825:(e,t,r)=>{"use strict";var n=r(6518),i=r(7751),a=r(8745),o=r(566),u=r(5548),s=r(8551),c=r(34),f=r(2360),l=r(9039),p=i("Reflect","construct"),m=Object.prototype,h=[].push,d=l((function(){function e(){}return!(p((function(){}),[],e)instanceof e)})),v=!l((function(){p((function(){}))})),y=d||v;n({target:"Reflect",stat:!0,forced:y,sham:y},{construct:function(e,t){u(e),s(t);var r=arguments.length<3?e:u(arguments[2]);if(v&&!d)return p(e,t,r);if(e===r){switch(t.length){case 0:return new e;case 1:return new e(t[0]);case 2:return new e(t[0],t[1]);case 3:return new e(t[0],t[1],t[2]);case 4:return new e(t[0],t[1],t[2],t[3])}var n=[null];return a(h,n,t),new(a(o,e,n))}var i=r.prototype,l=f(c(i)?i:m),y=a(e,l,t);return c(y)?y:l}})},4864:(e,t,r)=>{"use strict";var n=r(3724),i=r(4475),a=r(9504),o=r(2796),u=r(3167),s=r(6699),c=r(2360),f=r(8480).f,l=r(1625),p=r(788),m=r(655),h=r(1034),d=r(8429),v=r(1056),y=r(6840),g=r(9039),x=r(9297),b=r(1181).enforce,w=r(7633),D=r(8227),N=r(3635),E=r(8814),A=D("match"),S=i.RegExp,C=S.prototype,M=i.SyntaxError,F=a(C.exec),O=a("".charAt),T=a("".replace),_=a("".indexOf),B=a("".slice),k=/^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,I=/a/g,z=/a/g,R=new S(I)!==I,q=d.MISSED_STICKY,j=d.UNSUPPORTED_Y;if(o("RegExp",n&&(!R||q||N||E||g((function(){return z[A]=!1,S(I)!==I||S(z)===z||"/a/i"!==String(S(I,"i"))}))))){for(var P=function(e,t){var r,n,i,a,o,f,d=l(C,this),v=p(e),y=void 0===t,g=[],w=e;if(!d&&v&&y&&e.constructor===P)return e;if((v||l(C,e))&&(e=e.source,y&&(t=h(w))),e=void 0===e?"":m(e),t=void 0===t?"":m(t),w=e,N&&"dotAll"in I&&(n=!!t&&_(t,"s")>-1)&&(t=T(t,/s/g,"")),r=t,q&&"sticky"in I&&(i=!!t&&_(t,"y")>-1)&&j&&(t=T(t,/y/g,"")),E&&(a=function(e){for(var t,r=e.length,n=0,i="",a=[],o=c(null),u=!1,s=!1,f=0,l="";n<=r;n++){if("\\"===(t=O(e,n)))t+=O(e,++n);else if("]"===t)u=!1;else if(!u)switch(!0){case"["===t:u=!0;break;case"("===t:F(k,B(e,n+1))&&(n+=2,s=!0),i+=t,f++;continue;case">"===t&&s:if(""===l||x(o,l))throw new M("Invalid capture group name");o[l]=!0,a[a.length]=[l,f],s=!1,l="";continue}s?l+=t:i+=t}return[i,a]}(e),e=a[0],g=a[1]),o=u(S(e,t),d?this:C,P),(n||i||g.length)&&(f=b(o),n&&(f.dotAll=!0,f.raw=P(function(e){for(var t,r=e.length,n=0,i="",a=!1;n<=r;n++)"\\"!==(t=O(e,n))?a||"."!==t?("["===t?a=!0:"]"===t&&(a=!1),i+=t):i+="[\\s\\S]":i+=t+O(e,++n);return i}(e),r)),i&&(f.sticky=!0),g.length&&(f.groups=g)),e!==w)try{s(o,"source",""===w?"(?:)":w)}catch(e){}return o},L=f(S),U=0;L.length>U;)v(P,S,L[U++]);C.constructor=P,P.prototype=C,y(i,"RegExp",P,{constructor:!0})}w("RegExp")},7465:(e,t,r)=>{"use strict";var n=r(3724),i=r(3635),a=r(4576),o=r(2106),u=r(1181).get,s=RegExp.prototype,c=TypeError;n&&i&&o(s,"dotAll",{configurable:!0,get:function(){if(this!==s){if("RegExp"===a(this))return!!u(this).dotAll;throw new c("Incompatible receiver, RegExp required")}}})},7495:(e,t,r)=>{"use strict";var n=r(6518),i=r(7323);n({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},7745:(e,t,r)=>{"use strict";var n=r(3724),i=r(8429).MISSED_STICKY,a=r(4576),o=r(2106),u=r(1181).get,s=RegExp.prototype,c=TypeError;n&&i&&o(s,"sticky",{configurable:!0,get:function(){if(this!==s){if("RegExp"===a(this))return!!u(this).sticky;throw new c("Incompatible receiver, RegExp required")}}})},906:(e,t,r)=>{"use strict";r(7495);var n,i,a=r(6518),o=r(9565),u=r(4901),s=r(8551),c=r(655),f=(n=!1,(i=/[ac]/).exec=function(){return n=!0,/./.exec.apply(this,arguments)},!0===i.test("abc")&&n),l=/./.test;a({target:"RegExp",proto:!0,forced:!f},{test:function(e){var t=s(this),r=c(e),n=t.exec;if(!u(n))return o(l,t,r);var i=o(n,t,r);return null!==i&&(s(i),!0)}})},8781:(e,t,r)=>{"use strict";var n=r(350).PROPER,i=r(6840),a=r(8551),o=r(655),u=r(9039),s=r(1034),c="toString",f=RegExp.prototype,l=f[c],p=u((function(){return"/a/b"!==l.call({source:"a",flags:"b"})})),m=n&&l.name!==c;(p||m)&&i(f,c,(function(){var e=a(this);return"/"+o(e.source)+"/"+o(s(e))}),{unsafe:!0})},2405:(e,t,r)=>{"use strict";r(6468)("Set",(function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}}),r(6938))},1415:(e,t,r)=>{"use strict";r(2405)},1699:(e,t,r)=>{"use strict";var n=r(6518),i=r(9504),a=r(511),o=r(7750),u=r(655),s=r(1436),c=i("".indexOf);n({target:"String",proto:!0,forced:!s("includes")},{includes:function(e){return!!~c(u(o(this)),u(a(e)),arguments.length>1?arguments[1]:void 0)}})},7764:(e,t,r)=>{"use strict";var n=r(8183).charAt,i=r(655),a=r(1181),o=r(1088),u=r(2529),s="String Iterator",c=a.set,f=a.getterFor(s);o(String,"String",(function(e){c(this,{type:s,string:i(e),index:0})}),(function(){var e,t=f(this),r=t.string,i=t.index;return i>=r.length?u(void 0,!0):(e=n(r,i),t.index+=e.length,u(e,!1))}))},1761:(e,t,r)=>{"use strict";var n=r(9565),i=r(9228),a=r(8551),o=r(4117),u=r(8014),s=r(655),c=r(7750),f=r(5966),l=r(7829),p=r(6682);i("match",(function(e,t,r){return[function(t){var r=c(this),i=o(t)?void 0:f(t,e);return i?n(i,t,r):new RegExp(t)[e](s(r))},function(e){var n=a(this),i=s(e),o=r(t,n,i);if(o.done)return o.value;if(!n.global)return p(n,i);var c=n.unicode;n.lastIndex=0;for(var f,m=[],h=0;null!==(f=p(n,i));){var d=s(f[0]);m[h]=d,""===d&&(n.lastIndex=l(i,u(n.lastIndex),c)),h++}return 0===h?null:m}]}))},2781:(e,t,r)=>{"use strict";r(6518)({target:"String",proto:!0},{repeat:r(2333)})},5440:(e,t,r)=>{"use strict";var n=r(8745),i=r(9565),a=r(9504),o=r(9228),u=r(9039),s=r(8551),c=r(4901),f=r(4117),l=r(1291),p=r(8014),m=r(655),h=r(7750),d=r(7829),v=r(5966),y=r(2478),g=r(6682),x=r(8227)("replace"),b=Math.max,w=Math.min,D=a([].concat),N=a([].push),E=a("".indexOf),A=a("".slice),S="$0"==="a".replace(/./,"$0"),C=!!/./[x]&&""===/./[x]("a","$0");o("replace",(function(e,t,r){var a=C?"$":"$0";return[function(e,r){var n=h(this),a=f(e)?void 0:v(e,x);return a?i(a,e,n,r):i(t,m(n),e,r)},function(e,i){var o=s(this),u=m(e);if("string"==typeof i&&-1===E(i,a)&&-1===E(i,"$<")){var f=r(t,o,u,i);if(f.done)return f.value}var h=c(i);h||(i=m(i));var v,x=o.global;x&&(v=o.unicode,o.lastIndex=0);for(var S,C=[];null!==(S=g(o,u))&&(N(C,S),x);)""===m(S[0])&&(o.lastIndex=d(u,p(o.lastIndex),v));for(var M,F="",O=0,T=0;T<C.length;T++){for(var _,B=m((S=C[T])[0]),k=b(w(l(S.index),u.length),0),I=[],z=1;z<S.length;z++)N(I,void 0===(M=S[z])?M:String(M));var R=S.groups;if(h){var q=D([B],I,k,u);void 0!==R&&N(q,R),_=m(n(i,void 0,q))}else _=y(B,u,k,I,R,i);k>=O&&(F+=A(u,O,k)+_,O=k+B.length)}return F+A(u,O)}]}),!!u((function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")}))||!S||C)},8718:(e,t,r)=>{"use strict";var n=r(6518),i=r(7240);n({target:"String",proto:!0,forced:r(3061)("sub")},{sub:function(){return i(this,"sub","","")}})},375:(e,t,r)=>{"use strict";var n=r(6518),i=r(9504),a=r(7750),o=r(1291),u=r(655),s=i("".slice),c=Math.max,f=Math.min;n({target:"String",proto:!0,forced:!"".substr||"b"!=="ab".substr(-1)},{substr:function(e,t){var r,n,i=u(a(this)),l=i.length,p=o(e);return p===1/0&&(p=0),p<0&&(p=c(l+p,0)),(r=void 0===t?l:o(t))<=0||r===1/0||p>=(n=f(p+r,l))?"":s(i,p,n)}})},2762:(e,t,r)=>{"use strict";var n=r(6518),i=r(3802).trim;n({target:"String",proto:!0,forced:r(706)("trim")},{trim:function(){return i(this)}})},6761:(e,t,r)=>{"use strict";var n=r(6518),i=r(4475),a=r(9565),o=r(9504),u=r(6395),s=r(3724),c=r(4495),f=r(9039),l=r(9297),p=r(1625),m=r(8551),h=r(5397),d=r(6969),v=r(655),y=r(6980),g=r(2360),x=r(1072),b=r(8480),w=r(298),D=r(3717),N=r(7347),E=r(4913),A=r(6801),S=r(8773),C=r(6840),M=r(2106),F=r(5745),O=r(6119),T=r(421),_=r(3392),B=r(8227),k=r(1951),I=r(5749),z=r(8242),R=r(687),q=r(1181),j=r(9213).forEach,P=O("hidden"),L="Symbol",U="prototype",$=q.set,H=q.getterFor(L),G=Object[U],V=i.Symbol,Z=V&&V[U],W=i.RangeError,Y=i.TypeError,J=i.QObject,X=N.f,Q=E.f,K=w.f,ee=S.f,te=o([].push),re=F("symbols"),ne=F("op-symbols"),ie=F("wks"),ae=!J||!J[U]||!J[U].findChild,oe=function(e,t,r){var n=X(G,t);n&&delete G[t],Q(e,t,r),n&&e!==G&&Q(G,t,n)},ue=s&&f((function(){return 7!==g(Q({},"a",{get:function(){return Q(this,"a",{value:7}).a}})).a}))?oe:Q,se=function(e,t){var r=re[e]=g(Z);return $(r,{type:L,tag:e,description:t}),s||(r.description=t),r},ce=function(e,t,r){e===G&&ce(ne,t,r),m(e);var n=d(t);return m(r),l(re,n)?(r.enumerable?(l(e,P)&&e[P][n]&&(e[P][n]=!1),r=g(r,{enumerable:y(0,!1)})):(l(e,P)||Q(e,P,y(1,g(null))),e[P][n]=!0),ue(e,n,r)):Q(e,n,r)},fe=function(e,t){m(e);var r=h(t),n=x(r).concat(he(r));return j(n,(function(t){s&&!a(le,r,t)||ce(e,t,r[t])})),e},le=function(e){var t=d(e),r=a(ee,this,t);return!(this===G&&l(re,t)&&!l(ne,t))&&(!(r||!l(this,t)||!l(re,t)||l(this,P)&&this[P][t])||r)},pe=function(e,t){var r=h(e),n=d(t);if(r!==G||!l(re,n)||l(ne,n)){var i=X(r,n);return!i||!l(re,n)||l(r,P)&&r[P][n]||(i.enumerable=!0),i}},me=function(e){var t=K(h(e)),r=[];return j(t,(function(e){l(re,e)||l(T,e)||te(r,e)})),r},he=function(e){var t=e===G,r=K(t?ne:h(e)),n=[];return j(r,(function(e){!l(re,e)||t&&!l(G,e)||te(n,re[e])})),n};c||(C(Z=(V=function(){if(p(Z,this))throw new Y("Symbol is not a constructor");var e=arguments.length&&void 0!==arguments[0]?v(arguments[0]):void 0,t=_(e),r=function(e){var n=void 0===this?i:this;n===G&&a(r,ne,e),l(n,P)&&l(n[P],t)&&(n[P][t]=!1);var o=y(1,e);try{ue(n,t,o)}catch(e){if(!(e instanceof W))throw e;oe(n,t,o)}};return s&&ae&&ue(G,t,{configurable:!0,set:r}),se(t,e)})[U],"toString",(function(){return H(this).tag})),C(V,"withoutSetter",(function(e){return se(_(e),e)})),S.f=le,E.f=ce,A.f=fe,N.f=pe,b.f=w.f=me,D.f=he,k.f=function(e){return se(B(e),e)},s&&(M(Z,"description",{configurable:!0,get:function(){return H(this).description}}),u||C(G,"propertyIsEnumerable",le,{unsafe:!0}))),n({global:!0,constructor:!0,wrap:!0,forced:!c,sham:!c},{Symbol:V}),j(x(ie),(function(e){I(e)})),n({target:L,stat:!0,forced:!c},{useSetter:function(){ae=!0},useSimple:function(){ae=!1}}),n({target:"Object",stat:!0,forced:!c,sham:!s},{create:function(e,t){return void 0===t?g(e):fe(g(e),t)},defineProperty:ce,defineProperties:fe,getOwnPropertyDescriptor:pe}),n({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:me}),z(),R(V,L),T[P]=!0},9463:(e,t,r)=>{"use strict";var n=r(6518),i=r(3724),a=r(4475),o=r(9504),u=r(9297),s=r(4901),c=r(1625),f=r(655),l=r(2106),p=r(7740),m=a.Symbol,h=m&&m.prototype;if(i&&s(m)&&(!("description"in h)||void 0!==m().description)){var d={},v=function(){var e=arguments.length<1||void 0===arguments[0]?void 0:f(arguments[0]),t=c(h,this)?new m(e):void 0===e?m():m(e);return""===e&&(d[t]=!0),t};p(v,m),v.prototype=h,h.constructor=v;var y="Symbol(description detection)"===String(m("description detection")),g=o(h.valueOf),x=o(h.toString),b=/^Symbol\((.*)\)[^)]+$/,w=o("".replace),D=o("".slice);l(h,"description",{configurable:!0,get:function(){var e=g(this);if(u(d,e))return"";var t=x(e),r=y?D(t,7,-1):w(t,b,"$1");return""===r?void 0:r}}),n({global:!0,constructor:!0,forced:!0},{Symbol:v})}},1510:(e,t,r)=>{"use strict";var n=r(6518),i=r(7751),a=r(9297),o=r(655),u=r(5745),s=r(1296),c=u("string-to-symbol-registry"),f=u("symbol-to-string-registry");n({target:"Symbol",stat:!0,forced:!s},{for:function(e){var t=o(e);if(a(c,t))return c[t];var r=i("Symbol")(t);return c[t]=r,f[r]=t,r}})},2259:(e,t,r)=>{"use strict";r(5749)("iterator")},2675:(e,t,r)=>{"use strict";r(6761),r(1510),r(7812),r(3110),r(9773)},7812:(e,t,r)=>{"use strict";var n=r(6518),i=r(9297),a=r(757),o=r(6823),u=r(5745),s=r(1296),c=u("symbol-to-string-registry");n({target:"Symbol",stat:!0,forced:!s},{keyFor:function(e){if(!a(e))throw new TypeError(o(e)+" is not a symbol");if(i(c,e))return c[e]}})},3500:(e,t,r)=>{"use strict";var n=r(4475),i=r(7400),a=r(9296),o=r(235),u=r(6699),s=function(e){if(e&&e.forEach!==o)try{u(e,"forEach",o)}catch(t){e.forEach=o}};for(var c in i)i[c]&&s(n[c]&&n[c].prototype);s(a)},2953:(e,t,r)=>{"use strict";var n=r(4475),i=r(7400),a=r(9296),o=r(3792),u=r(6699),s=r(687),c=r(8227)("iterator"),f=o.values,l=function(e,t){if(e){if(e[c]!==f)try{u(e,c,f)}catch(t){e[c]=f}if(s(e,t,!0),i[t])for(var r in o)if(e[r]!==o[r])try{u(e,r,o[r])}catch(t){e[r]=o[r]}}};for(var p in i)l(n[p]&&n[p].prototype,p);l(a,"DOMTokenList")},2369:function(e){e.exports=function(){"use strict";function e(){return!0}function t(){return!1}function r(){}const n="Argument is not a typed-function.";return function i(){function a(e){return"object"==typeof e&&null!==e&&e.constructor===Object}const o=[{name:"number",test:function(e){return"number"==typeof e}},{name:"string",test:function(e){return"string"==typeof e}},{name:"boolean",test:function(e){return"boolean"==typeof e}},{name:"Function",test:function(e){return"function"==typeof e}},{name:"Array",test:Array.isArray},{name:"Date",test:function(e){return e instanceof Date}},{name:"RegExp",test:function(e){return e instanceof RegExp}},{name:"Object",test:a},{name:"null",test:function(e){return null===e}},{name:"undefined",test:function(e){return void 0===e}}],u={name:"any",test:e,isAny:!0};let s,c,f=0,l={createCount:0};function p(e){const t=s.get(e);if(t)return t;let r='Unknown type "'+e+'"';const n=e.toLowerCase();let i;for(i of c)if(i.toLowerCase()===n){r+='. Did you mean "'+i+'" ?';break}throw new TypeError(r)}function m(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"any";const r=t?p(t).index:c.length,n=[];for(let t=0;t<e.length;++t){if(!e[t]||"string"!=typeof e[t].name||"function"!=typeof e[t].test)throw new TypeError("Object with properties {name: string, test: function} expected");const i=e[t].name;if(s.has(i))throw new TypeError('Duplicate type name "'+i+'"');n.push(i),s.set(i,{name:i,test:e[t].test,isAny:e[t].isAny,index:r+t,conversionsTo:[]})}const i=c.slice(r);c=c.slice(0,r).concat(n).concat(i);for(let e=r+n.length;e<c.length;++e)s.get(c[e]).index=e}function h(){s=new Map,c=[],f=0,m([u],!1)}function d(e){const t=c.filter((t=>{const r=s.get(t);return!r.isAny&&r.test(e)}));return t.length?t:["any"]}function v(e){return e&&"function"==typeof e&&"_typedFunctionData"in e}function y(e,t,r){if(!v(e))throw new TypeError(n);const i=r&&r.exact,a=D(Array.isArray(t)?t.join(","):t),o=g(a);if(!i||o in e.signatures){const t=e._typedFunctionData.signatureMap.get(o);if(t)return t}const u=a.length;let s,c;if(i){let t;for(t in s=[],e.signatures)s.push(e._typedFunctionData.signatureMap.get(t))}else s=e._typedFunctionData.signatures;for(let e=0;e<u;++e){const t=a[e],r=[];let n;for(n of s){const i=S(n.params,e);if(i&&(!t.restParam||i.restParam)){if(!i.hasAny){const e=w(i);if(t.types.some((t=>!e.has(t.name))))continue}r.push(n)}}if(s=r,0===s.length)break}for(c of s)if(c.params.length<=u)return c;throw new TypeError("Signature not found (signature: "+(e.name||"unnamed")+"("+g(a,", ")+"))")}function g(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:",";return e.map((e=>e.name)).join(t)}function x(e){const t=0===e.indexOf("..."),r=(t?e.length>3?e.slice(3):"any":e).split("|").map((e=>p(e.trim())));let n=!1,i=t?"...":"";return{types:r.map((function(e){return n=e.isAny||n,i+=e.name+"|",{name:e.name,typeIndex:e.index,test:e.test,isAny:e.isAny,conversion:null,conversionIndex:-1}})),name:i.slice(0,-1),hasAny:n,hasConversion:!1,restParam:t}}function b(e){const t=function(e){if(0===e.length)return[];const t=e.map(p);e.length>1&&t.sort(((e,t)=>e.index-t.index));let r=t[0].conversionsTo;if(1===e.length)return r;r=r.concat([]);const n=new Set(e);for(let e=1;e<t.length;++e){let i;for(i of t[e].conversionsTo)n.has(i.from)||(r.push(i),n.add(i.from))}return r}(e.types.map((e=>e.name)));let r=e.hasAny,n=e.name;const i=t.map((function(e){const t=p(e.from);return r=t.isAny||r,n+="|"+e.from,{name:e.from,typeIndex:t.index,test:t.test,isAny:t.isAny,conversion:e,conversionIndex:e.index}}));return{types:e.types.concat(i),name:n,hasAny:r,hasConversion:i.length>0,restParam:e.restParam}}function w(e){return e.typeSet||(e.typeSet=new Set,e.types.forEach((t=>e.typeSet.add(t.name)))),e.typeSet}function D(e){const t=[];if("string"!=typeof e)throw new TypeError("Signatures must be strings");const r=e.trim();if(""===r)return t;const n=r.split(",");for(let e=0;e<n.length;++e){const r=x(n[e].trim());if(r.restParam&&e!==n.length-1)throw new SyntaxError('Unexpected rest parameter "'+n[e]+'": only allowed for the last parameter');if(0===r.types.length)return null;t.push(r)}return t}function N(e){const t=H(e);return!!t&&t.restParam}function E(t){if(t&&0!==t.types.length){if(1===t.types.length)return p(t.types[0].name).test;if(2===t.types.length){const e=p(t.types[0].name).test,r=p(t.types[1].name).test;return function(t){return e(t)||r(t)}}{const e=t.types.map((function(e){return p(e.name).test}));return function(t){for(let r=0;r<e.length;r++)if(e[r](t))return!0;return!1}}}return e}function A(e){let t,r,n;if(N(e)){t=$(e).map(E);const r=t.length,n=E(H(e)),i=function(e){for(let t=r;t<e.length;t++)if(!n(e[t]))return!1;return!0};return function(e){for(let r=0;r<t.length;r++)if(!t[r](e[r]))return!1;return i(e)&&e.length>=r+1}}return 0===e.length?function(e){return 0===e.length}:1===e.length?(r=E(e[0]),function(e){return r(e[0])&&1===e.length}):2===e.length?(r=E(e[0]),n=E(e[1]),function(e){return r(e[0])&&n(e[1])&&2===e.length}):(t=e.map(E),function(e){for(let r=0;r<t.length;r++)if(!t[r](e[r]))return!1;return e.length===t.length})}function S(e,t){return t<e.length?e[t]:N(e)?H(e):null}function C(e,t){const r=S(e,t);return r?w(r):new Set}function M(e){return null===e.conversion||void 0===e.conversion}function F(e,t){const r=new Set;return e.forEach((e=>{const n=C(e.params,t);let i;for(i of n)r.add(i)})),r.has("any")?["any"]:Array.from(r)}function O(e,t,r){let n,i;const a=e||"unnamed";let o,u=r;for(o=0;o<t.length;o++){const e=[];if(u.forEach((r=>{const n=E(S(r.params,o));(o<r.params.length||N(r.params))&&n(t[o])&&e.push(r)})),0===e.length){if(i=F(u,o),i.length>0){const e=d(t[o]);return n=new TypeError("Unexpected type of argument in function "+a+" (expected: "+i.join(" or ")+", actual: "+e.join(" | ")+", index: "+o+")"),n.data={category:"wrongType",fn:a,index:o,actual:e,expected:i},n}}else u=e}const s=u.map((function(e){return N(e.params)?1/0:e.params.length}));if(t.length<Math.min.apply(null,s))return i=F(u,o),n=new TypeError("Too few arguments in function "+a+" (expected: "+i.join(" or ")+", index: "+t.length+")"),n.data={category:"tooFewArgs",fn:a,index:t.length,expected:i},n;const c=Math.max.apply(null,s);if(t.length>c)return n=new TypeError("Too many arguments in function "+a+" (expected: "+c+", actual: "+t.length+")"),n.data={category:"tooManyArgs",fn:a,index:t.length,expectedLength:c},n;const f=[];for(let e=0;e<t.length;++e)f.push(d(t[e]).join("|"));return n=new TypeError('Arguments of type "'+f.join(", ")+'" do not match any of the defined signatures of function '+a+"."),n.data={category:"mismatch",actual:f},n}function T(e){let t=c.length+1;for(let r=0;r<e.types.length;r++)M(e.types[r])&&(t=Math.min(t,e.types[r].typeIndex));return t}function _(e){let t=f+1;for(let r=0;r<e.types.length;r++)M(e.types[r])||(t=Math.min(t,e.types[r].conversionIndex));return t}function B(e,t){if(e.hasAny){if(!t.hasAny)return 1}else if(t.hasAny)return-1;if(e.restParam){if(!t.restParam)return 1}else if(t.restParam)return-1;if(e.hasConversion){if(!t.hasConversion)return 1}else if(t.hasConversion)return-1;const r=T(e)-T(t);if(r<0)return-1;if(r>0)return 1;const n=_(e)-_(t);return n<0?-1:n>0?1:0}function k(e,t){const r=e.params,n=t.params,i=H(r),a=H(n),o=N(r),u=N(n);if(o&&i.hasAny){if(!u||!a.hasAny)return 1}else if(u&&a.hasAny)return-1;let s,c=0,f=0;for(s of r)s.hasAny&&++c,s.hasConversion&&++f;let l=0,p=0;for(s of n)s.hasAny&&++l,s.hasConversion&&++p;if(c!==l)return c-l;if(o&&i.hasConversion){if(!u||!a.hasConversion)return 1}else if(u&&a.hasConversion)return-1;if(f!==p)return f-p;if(o){if(!u)return 1}else if(u)return-1;const m=(r.length-n.length)*(o?-1:1);if(0!==m)return m;const h=[];let d,v=0;for(let e=0;e<r.length;++e){const t=B(r[e],n[e]);h.push(t),v+=t}if(0!==v)return v;for(d of h)if(0!==d)return d;return 0}function I(e,t){let r=t;if(e.some((e=>e.hasConversion))){const n=N(e),i=e.map(z);r=function(){const e=[],r=n?arguments.length-1:arguments.length;for(let t=0;t<r;t++)e[t]=i[t](arguments[t]);return n&&(e[r]=arguments[r].map(i[r])),t.apply(this,e)}}let n=r;if(N(e)){const t=e.length-1;n=function(){return r.apply(this,G(arguments,0,t).concat([G(arguments,t)]))}}return n}function z(e){let t,r,n,i;const a=[],o=[];switch(e.types.forEach((function(e){e.conversion&&(a.push(p(e.conversion.from).test),o.push(e.conversion.convert))})),o.length){case 0:return function(e){return e};case 1:return t=a[0],n=o[0],function(e){return t(e)?n(e):e};case 2:return t=a[0],r=a[1],n=o[0],i=o[1],function(e){return t(e)?n(e):r(e)?i(e):e};default:return function(e){for(let t=0;t<o.length;t++)if(a[t](e))return o[t](e);return e}}}function R(e){return function e(t,r,n){if(r<t.length){const o=t[r];let u=[];if(o.restParam){const e=o.types.filter(M);e.length<o.types.length&&u.push({types:e,name:"..."+e.map((e=>e.name)).join("|"),hasAny:e.some((e=>e.isAny)),hasConversion:!1,restParam:!0}),u.push(o)}else u=o.types.map((function(e){return{types:[e],name:e.name,hasAny:e.isAny,hasConversion:e.conversion,restParam:!1}}));return i=u,a=function(i){return e(t,r+1,n.concat([i]))},Array.prototype.concat.apply([],i.map(a))}var i,a;return[n]}(e,0,[])}function q(e,t){const r=Math.max(e.length,t.length);for(let n=0;n<r;n++){const r=C(e,n),i=C(t,n);let a,o=!1;for(a of i)if(r.has(a)){o=!0;break}if(!o)return!1}const n=e.length,i=t.length,a=N(e),o=N(t);return a?o?n===i:i>=n:o?n>=i:n===i}function j(e,t,r){const n=[];let i;for(i of e){let e=r[i];if("number"!=typeof e)throw new TypeError('No definition for referenced signature "'+i+'"');if(e=t[e],"function"!=typeof e)return!1;n.push(e)}return n}function P(e,t,r){const n=function(e){return e.map((e=>Y(e)?Z(e.referToSelf.callback):W(e)?V(e.referTo.references,e.referTo.callback):e))}(e),i=new Array(n.length).fill(!1);let a=!0;for(;a;){a=!1;let e=!0;for(let o=0;o<n.length;++o){if(i[o])continue;const u=n[o];if(Y(u))n[o]=u.referToSelf.callback(r),n[o].referToSelf=u.referToSelf,i[o]=!0,e=!1;else if(W(u)){const r=j(u.referTo.references,n,t);r?(n[o]=u.referTo.callback.apply(this,r),n[o].referTo=u.referTo,i[o]=!0,e=!1):a=!0}}if(e&&a)throw new SyntaxError("Circular reference detected in resolving typed.referTo")}return n}function L(e,n){if(l.createCount++,0===Object.keys(n).length)throw new SyntaxError("No signatures provided");l.warnAgainstDeprecatedThis&&function(e){const t=/\bthis(\(|\.signatures\b)/;Object.keys(e).forEach((r=>{const n=e[r];if(t.test(n.toString()))throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.")}))}(n);const i=[],a=[],o={},u=[];let s;for(s in n){if(!Object.prototype.hasOwnProperty.call(n,s))continue;const e=D(s);if(!e)continue;i.forEach((function(t){if(q(t,e))throw new TypeError('Conflicting signatures "'+g(t)+'" and "'+g(e)+'".')})),i.push(e);const t=a.length;a.push(n[s]);const r=e.map(b);let c;for(c of R(r)){const e=g(c);u.push({params:c,name:e,fn:t}),c.every((e=>!e.hasConversion))&&(o[e]=t)}}u.sort(k);const c=P(a,o,ue);let f;for(f in o)Object.prototype.hasOwnProperty.call(o,f)&&(o[f]=c[o[f]]);const p=[],m=new Map;for(f of u)m.has(f.name)||(f.fn=c[f.fn],p.push(f),m.set(f.name,f));const h=p[0]&&p[0].params.length<=2&&!N(p[0].params),d=p[1]&&p[1].params.length<=2&&!N(p[1].params),v=p[2]&&p[2].params.length<=2&&!N(p[2].params),y=p[3]&&p[3].params.length<=2&&!N(p[3].params),x=p[4]&&p[4].params.length<=2&&!N(p[4].params),w=p[5]&&p[5].params.length<=2&&!N(p[5].params),S=h&&d&&v&&y&&x&&w;for(let e=0;e<p.length;++e)p[e].test=A(p[e].params);const C=h?E(p[0].params[0]):t,M=d?E(p[1].params[0]):t,F=v?E(p[2].params[0]):t,O=y?E(p[3].params[0]):t,T=x?E(p[4].params[0]):t,_=w?E(p[5].params[0]):t,B=h?E(p[0].params[1]):t,z=d?E(p[1].params[1]):t,j=v?E(p[2].params[1]):t,L=y?E(p[3].params[1]):t,U=x?E(p[4].params[1]):t,$=w?E(p[5].params[1]):t;for(let e=0;e<p.length;++e)p[e].implementation=I(p[e].params,p[e].fn);const H=h?p[0].implementation:r,G=d?p[1].implementation:r,V=v?p[2].implementation:r,Z=y?p[3].implementation:r,W=x?p[4].implementation:r,Y=w?p[5].implementation:r,J=h?p[0].params.length:-1,X=d?p[1].params.length:-1,Q=v?p[2].params.length:-1,K=y?p[3].params.length:-1,ee=x?p[4].params.length:-1,te=w?p[5].params.length:-1,re=S?6:0,ne=p.length,ie=p.map((e=>e.test)),ae=p.map((e=>e.implementation)),oe=function(){for(let e=re;e<ne;e++)if(ie[e](arguments))return ae[e].apply(this,arguments);return l.onMismatch(e,arguments,p)};function ue(e,t){return arguments.length===J&&C(e)&&B(t)?H.apply(this,arguments):arguments.length===X&&M(e)&&z(t)?G.apply(this,arguments):arguments.length===Q&&F(e)&&j(t)?V.apply(this,arguments):arguments.length===K&&O(e)&&L(t)?Z.apply(this,arguments):arguments.length===ee&&T(e)&&U(t)?W.apply(this,arguments):arguments.length===te&&_(e)&&$(t)?Y.apply(this,arguments):oe.apply(this,arguments)}try{Object.defineProperty(ue,"name",{value:e})}catch(e){}return ue.signatures=o,ue._typedFunctionData={signatures:p,signatureMap:m},ue}function U(e,t,r){throw O(e,t,r)}function $(e){return G(e,0,e.length-1)}function H(e){return e[e.length-1]}function G(e,t,r){return Array.prototype.slice.call(e,t,r)}function V(e,t){return{referTo:{references:e,callback:t}}}function Z(e){if("function"!=typeof e)throw new TypeError("Callback function expected as first argument");return{referToSelf:{callback:e}}}function W(e){return e&&"object"==typeof e.referTo&&Array.isArray(e.referTo.references)&&"function"==typeof e.referTo.callback}function Y(e){return e&&"object"==typeof e.referToSelf&&"function"==typeof e.referToSelf.callback}function J(e,t){if(!e)return t;if(t&&t!==e){const r=new Error("Function names do not match (expected: "+e+", actual: "+t+")");throw r.data={actual:t,expected:e},r}return e}function X(e){let t;for(const r in e)Object.prototype.hasOwnProperty.call(e,r)&&(v(e[r])||"string"==typeof e[r].signature)&&(t=J(t,e[r].name));return t}function Q(e,t){let r;for(r in t)if(Object.prototype.hasOwnProperty.call(t,r)){if(r in e&&t[r]!==e[r]){const n=new Error('Signature "'+r+'" is defined twice');throw n.data={signature:r,sourceFunction:t[r],destFunction:e[r]},n}e[r]=t[r]}}h(),m(o);const K=l;function ee(e){if(!e||"string"!=typeof e.from||"string"!=typeof e.to||"function"!=typeof e.convert)throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");if(e.to===e.from)throw new SyntaxError('Illegal to define conversion from "'+e.from+'" to itself.')}return l=function(e){const t="string"==typeof e;let r=t?e:"";const n={};for(let e=t?1:0;e<arguments.length;++e){const i=arguments[e];let o,u={};if("function"==typeof i?(o=i.name,"string"==typeof i.signature?u[i.signature]=i:v(i)&&(u=i.signatures)):a(i)&&(u=i,t||(o=X(i))),0===Object.keys(u).length){const t=new TypeError("Argument to 'typed' at index "+e+" is not a (typed) function, nor an object with signatures as keys and functions as values.");throw t.data={index:e,argument:i},t}t||(r=J(r,o)),Q(n,u)}return L(r||"",n)},l.create=i,l.createCount=K.createCount,l.onMismatch=U,l.throwMismatchError=U,l.createError=O,l.clear=h,l.clearConversions=function(){let e;for(e of c)s.get(e).conversionsTo=[];f=0},l.addTypes=m,l._findType=p,l.referTo=function(){const e=$(arguments).map((e=>g(D(e)))),t=H(arguments);if("function"!=typeof t)throw new TypeError("Callback function expected as last argument");return V(e,t)},l.referToSelf=Z,l.convert=function(e,t){const r=p(t);if(r.test(e))return e;const n=r.conversionsTo;if(0===n.length)throw new Error("There are no conversions to "+t+" defined.");for(let t=0;t<n.length;t++)if(p(n[t].from).test(e))return n[t].convert(e);throw new Error("Cannot convert "+e+" to "+t)},l.findSignature=y,l.find=function(e,t,r){return y(e,t,r).implementation},l.isTypedFunction=v,l.warnAgainstDeprecatedThis=!0,l.addType=function(e,t){let r="any";!1!==t&&s.has("Object")&&(r="Object"),l.addTypes([e],r)},l.addConversion=function(e){ee(e);const t=p(e.to);if(!t.conversionsTo.every((function(t){return t.from!==e.from})))throw new Error('There is already a conversion from "'+e.from+'" to "'+t.name+'"');t.conversionsTo.push({from:e.from,convert:e.convert,index:f++})},l.addConversions=function(e){e.forEach(l.addConversion)},l.removeConversion=function(e){ee(e);const t=p(e.to),r=function(e,t){for(let r=0;r<e.length;r++)if(t(e[r]))return e[r]}(t.conversionsTo,(t=>t.from===e.from));if(!r)throw new Error("Attempt to remove nonexistent conversion from "+e.from+" to "+e.to);if(r.convert!==e.convert)throw new Error("Conversion to remove does not match existing conversion");const n=t.conversionsTo.indexOf(r);t.conversionsTo.splice(n,1)},l.resolve=function(e,t){if(!v(e))throw new TypeError(n);const r=e._typedFunctionData.signatures;for(let e=0;e<r.length;++e)if(r[e].test(t))return r[e];return null},l}()}()}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var a=t[n]={id:n,loaded:!1,exports:{}};return e[n].call(a.exports,a,a.exports,r),a.loaded=!0,a.exports}r.amdD=function(){throw new Error("define cannot be used indirect")},r.amdO={},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.nmd=e=>(e.paths=[],e.children||(e.children=[]),e);var n={};return(()=>{"use strict";r.d(n,{default:()=>kg});var e={};function t(e){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},t(e)}function i(e){return"number"==typeof e}function a(e){return!(!e||"object"!==t(e)||"function"!=typeof e.constructor)&&(!0===e.isBigNumber&&"object"===t(e.constructor.prototype)&&!0===e.constructor.prototype.isBigNumber||"function"==typeof e.constructor.isDecimal&&!0===e.constructor.isDecimal(e))}function o(e){return e&&"object"===t(e)&&!0===Object.getPrototypeOf(e).isComplex||!1}function u(e){return e&&"object"===t(e)&&!0===Object.getPrototypeOf(e).isFraction||!1}function s(e){return e&&!0===e.constructor.prototype.isUnit||!1}function c(e){return"string"==typeof e}r.r(e),r.d(e,{createAbs:()=>da,createAccessorNode:()=>Cp,createAcos:()=>Rf,createAcosh:()=>rl,createAcot:()=>il,createAcoth:()=>ol,createAcsc:()=>sl,createAcsch:()=>fl,createAdd:()=>up,createAddScalar:()=>ba,createAnd:()=>_c,createAndTransform:()=>Eg,createApply:()=>ya,createApplyTransform:()=>Jy,createArg:()=>ou,createArrayNode:()=>Tp,createAsec:()=>pl,createAsech:()=>hl,createAsin:()=>vl,createAsinh:()=>yl,createAssignmentNode:()=>Lp,createAtan:()=>gl,createAtan2:()=>bl,createAtanh:()=>Dl,createAtomicMass:()=>Cy,createAvogadro:()=>My,createBellNumbers:()=>Qd,createBigNumberClass:()=>Lr,createBignumber:()=>Fi,createBin:()=>$s,createBitAnd:()=>Qo,createBitAndTransform:()=>Sg,createBitNot:()=>eu,createBitOr:()=>ru,createBitOrTransform:()=>Cg,createBitXor:()=>au,createBlockNode:()=>Gp,createBohrMagneton:()=>uy,createBohrRadius:()=>my,createBoltzmann:()=>Fy,createBoolean:()=>Mi,createCatalan:()=>ev,createCbrt:()=>Ea,createCeil:()=>_a,createChain:()=>Mh,createChainClass:()=>wh,createClassicalElectronRadius:()=>hy,createClone:()=>Hn,createColumn:()=>Du,createColumnTransform:()=>Xy,createCombinations:()=>dd,createCombinationsWithRep:()=>gd,createCompare:()=>kc,createCompareNatural:()=>qc,createCompareText:()=>Lc,createCompile:()=>Wm,createComplex:()=>Oi,createComplexClass:()=>$r,createComposition:()=>rv,createConcat:()=>bu,createConcatTransform:()=>pg,createConditionalNode:()=>Yp,createConductanceQuantum:()=>sy,createConj:()=>su,createConstantNode:()=>om,createCorr:()=>ld,createCos:()=>El,createCosh:()=>Sl,createCot:()=>Cl,createCoth:()=>Fl,createCoulomb:()=>ay,createCount:()=>Eu,createCreateUnit:()=>If,createCross:()=>Su,createCsc:()=>Ol,createCsch:()=>_l,createCtranspose:()=>bs,createCube:()=>ka,createCumSum:()=>Qh,createCumSumTransform:()=>xg,createDeepEqual:()=>uf,createDenseMatrixClass:()=>Un,createDerivative:()=>bv,createDet:()=>Fh,createDeuteronMass:()=>by,createDiag:()=>Mu,createDiff:()=>Vu,createDiffTransform:()=>hg,createDistance:()=>Wh,createDivide:()=>Vh,createDivideScalar:()=>tc,createDot:()=>pp,createDotDivide:()=>hc,createDotMultiply:()=>ko,createDotPow:()=>pc,createE:()=>jv,createEfimovFactor:()=>Sy,createEigs:()=>Ih,createElectricConstant:()=>ny,createElectronMass:()=>dy,createElementaryCharge:()=>oy,createEqual:()=>$c,createEqualScalar:()=>Di,createEqualText:()=>Vc,createErf:()=>Ms,createEvaluate:()=>Jm,createExp:()=>Ia,createExpm:()=>Rh,createExpm1:()=>Ra,createFactorial:()=>Td,createFalse:()=>Bv,createFaraday:()=>Oy,createFermiCoupling:()=>vy,createFft:()=>Ns,createFibonacciHeapClass:()=>bf,createFilter:()=>Ou,createFilterTransform:()=>Ky,createFineStructure:()=>yy,createFirstRadiation:()=>Ty,createFix:()=>La,createFlatten:()=>Bu,createFloor:()=>Ga,createForEach:()=>Iu,createForEachTransform:()=>tg,createFormat:()=>Us,createFraction:()=>Ti,createFractionClass:()=>Gr,createFreqz:()=>Sv,createFunctionAssignmentNode:()=>lm,createFunctionNode:()=>Hm,createGamma:()=>Cd,createGasConstant:()=>By,createGcd:()=>so,createGetMatrixDataType:()=>qu,createGravitationConstant:()=>Kv,createGravity:()=>Uy,createHartreeEnergy:()=>gy,createHasNumericValue:()=>fi,createHelp:()=>Sh,createHelpClass:()=>bh,createHex:()=>Gs,createHypot:()=>cp,createI:()=>Zv,createIdentity:()=>Pu,createIfft:()=>As,createIm:()=>cu,createImmutableDenseMatrixClass:()=>yf,createIndex:()=>dp,createIndexClass:()=>gf,createIndexNode:()=>dm,createIndexTransform:()=>rg,createInfinity:()=>Iv,createIntersect:()=>Yh,createInv:()=>Oh,createInverseConductanceQuantum:()=>cy,createInvmod:()=>To,createIsInteger:()=>Kn,createIsNaN:()=>vi,createIsNegative:()=>oi,createIsNumeric:()=>si,createIsPositive:()=>pi,createIsPrime:()=>Qs,createIsZero:()=>hi,createKldivergence:()=>Bd,createKlitzing:()=>py,createKron:()=>Uu,createLN10:()=>Uv,createLN2:()=>Lv,createLOG10E:()=>Hv,createLOG2E:()=>$v,createLarger:()=>ef,createLargerEq:()=>nf,createLcm:()=>fo,createLeafCount:()=>iv,createLeftShift:()=>Cc,createLgamma:()=>Fd,createLog:()=>oc,createLog10:()=>po,createLog1p:()=>sc,createLog2:()=>ho,createLoschmidt:()=>_y,createLsolve:()=>yc,createLsolveAll:()=>wc,createLup:()=>eh,createLusolve:()=>yh,createLyap:()=>Gh,createMad:()=>nd,createMagneticConstant:()=>ry,createMagneticFluxQuantum:()=>fy,createMap:()=>$u,createMapTransform:()=>ng,createMatrix:()=>Bi,createMatrixClass:()=>Zr,createMatrixFromColumns:()=>Li,createMatrixFromFunction:()=>Ii,createMatrixFromRows:()=>qi,createMax:()=>df,createMaxTransform:()=>og,createMean:()=>ed,createMeanTransform:()=>ug,createMedian:()=>rd,createMin:()=>vf,createMinTransform:()=>sg,createMod:()=>Ka,createMode:()=>Rs,createMolarMass:()=>Py,createMolarMassC12:()=>Ly,createMolarPlanckConstant:()=>ky,createMolarVolume:()=>Iy,createMultinomial:()=>Id,createMultiply:()=>go,createMultiplyScalar:()=>vo,createNaN:()=>zv,createNeutronMass:()=>wy,createNode:()=>yp,createNorm:()=>lp,createNot:()=>vu,createNthRoot:()=>bo,createNthRoots:()=>fc,createNuclearMagneton:()=>ly,createNull:()=>kv,createNumber:()=>Ei,createNumeric:()=>Ks,createObjectNode:()=>xm,createOct:()=>Hs,createOnes:()=>Zu,createOperatorNode:()=>Em,createOr:()=>yu,createOrTransform:()=>Ag,createParenthesisNode:()=>Mm,createParse:()=>Vm,createParser:()=>Km,createParserClass:()=>Xm,createPartitionSelect:()=>pf,createPermutations:()=>Rd,createPhi:()=>Pv,createPi:()=>Rv,createPickRandom:()=>$d,createPinv:()=>_h,createPlanckCharge:()=>Vy,createPlanckConstant:()=>ey,createPlanckLength:()=>$y,createPlanckMass:()=>Hy,createPlanckTemperature:()=>Zy,createPlanckTime:()=>Gy,createPolynomialRoot:()=>xh,createPow:()=>rc,createPrint:()=>Ws,createPrintTransform:()=>Ng,createProd:()=>Ps,createProtonMass:()=>xy,createQr:()=>th,createQuantileSeq:()=>sd,createQuantileSeqTransform:()=>yg,createQuantumOfCirculation:()=>Dy,createRandom:()=>Vd,createRandomInt:()=>Wd,createRange:()=>Qu,createRangeClass:()=>Vr,createRangeNode:()=>_m,createRangeTransform:()=>cg,createRationalize:()=>Dv,createRe:()=>fu,createReducedPlanckConstant:()=>ty,createRelationalNode:()=>zm,createReplacer:()=>Mv,createReshape:()=>es,createResize:()=>ts,createResolve:()=>vv,createResultSet:()=>it,createReviver:()=>Cv,createRightArithShift:()=>Fc,createRightLogShift:()=>Tc,createRotate:()=>ns,createRotationMatrix:()=>as,createRound:()=>ac,createRow:()=>os,createRowTransform:()=>fg,createRydberg:()=>Ny,createSQRT1_2:()=>Gv,createSQRT2:()=>Vv,createSackurTetrode:()=>zy,createSchur:()=>$h,createSec:()=>Bl,createSech:()=>Il,createSecondRadiation:()=>Ry,createSetCartesian:()=>Ul,createSetDifference:()=>Hl,createSetDistinct:()=>Vl,createSetIntersect:()=>Wl,createSetIsSubset:()=>Jl,createSetMultiplicity:()=>Ql,createSetPowerset:()=>ep,createSetSize:()=>rp,createSetSymDifference:()=>ip,createSetUnion:()=>op,createSign:()=>Do,createSimplify:()=>fv,createSimplifyConstant:()=>mv,createSimplifyCore:()=>dv,createSin:()=>zl,createSinh:()=>ql,createSize:()=>ss,createSlu:()=>hh,createSmaller:()=>Wc,createSmallerEq:()=>Xc,createSolveODE:()=>Cs,createSort:()=>hf,createSpaClass:()=>wf,createSparse:()=>Bf,createSparseMatrixClass:()=>Ni,createSpeedOfLight:()=>Qv,createSplitUnit:()=>$i,createSqrt:()=>No,createSqrtm:()=>jh,createSquare:()=>Ao,createSqueeze:()=>fs,createStd:()=>cd,createStdTransform:()=>dg,createStefanBoltzmann:()=>qy,createStirlingS2:()=>Jd,createString:()=>Si,createSubset:()=>ps,createSubsetTransform:()=>lg,createSubtract:()=>Co,createSubtractScalar:()=>Da,createSum:()=>Jh,createSumTransform:()=>vg,createSylvester:()=>Lh,createSymbolNode:()=>jm,createSymbolicEqual:()=>gv,createTan:()=>jl,createTanh:()=>Pl,createTau:()=>qv,createThomsonCrossSection:()=>Ey,createTo:()=>Js,createTrace:()=>mp,createTranspose:()=>gs,createTrue:()=>_v,createTypeOf:()=>gi,createTyped:()=>Qe,createUnaryMinus:()=>pa,createUnaryPlus:()=>ha,createUnequal:()=>cf,createUnitClass:()=>Ff,createUnitFunction:()=>Tf,createUppercaseE:()=>Yv,createUppercasePi:()=>Wv,createUsolve:()=>xc,createUsolveAll:()=>Nc,createVacuumImpedance:()=>iy,createVariance:()=>od,createVarianceTransform:()=>wg,createVersion:()=>Jv,createWeakMixingAngle:()=>Ay,createWienDisplacement:()=>jy,createXgcd:()=>Fo,createXor:()=>gu,createZeros:()=>Ds,createZeta:()=>Is,createZpk2tf:()=>Ev}),r(4423),r(5086),r(2892),r(6099),r(7495),r(906),r(1699),r(4346),r(3288),r(2010),r(875),r(4864),r(7465),r(7745),r(8781);var f=Array.isArray;function l(e){return e&&!0===e.constructor.prototype.isMatrix||!1}function p(e){return Array.isArray(e)||l(e)}function m(e){return e&&e.isDenseMatrix&&!0===e.constructor.prototype.isMatrix||!1}function h(e){return e&&e.isSparseMatrix&&!0===e.constructor.prototype.isMatrix||!1}function d(e){return e&&!0===e.constructor.prototype.isRange||!1}function v(e){return e&&!0===e.constructor.prototype.isIndex||!1}function y(e){return"boolean"==typeof e}function g(e){return e&&!0===e.constructor.prototype.isResultSet||!1}function x(e){return e&&!0===e.constructor.prototype.isHelp||!1}function b(e){return"function"==typeof e}function w(e){return e instanceof Date}function D(e){return e instanceof RegExp}function N(e){return!(!e||"object"!==t(e)||e.constructor!==Object||o(e)||u(e))}function E(e){return null===e}function A(e){return void 0===e}function S(e){return e&&!0===e.isAccessorNode&&!0===e.constructor.prototype.isNode||!1}function C(e){return e&&!0===e.isArrayNode&&!0===e.constructor.prototype.isNode||!1}function M(e){return e&&!0===e.isAssignmentNode&&!0===e.constructor.prototype.isNode||!1}function F(e){return e&&!0===e.isBlockNode&&!0===e.constructor.prototype.isNode||!1}function O(e){return e&&!0===e.isConditionalNode&&!0===e.constructor.prototype.isNode||!1}function T(e){return e&&!0===e.isConstantNode&&!0===e.constructor.prototype.isNode||!1}function _(e){return T(e)||q(e)&&1===e.args.length&&T(e.args[0])&&"-+~".includes(e.op)}function B(e){return e&&!0===e.isFunctionAssignmentNode&&!0===e.constructor.prototype.isNode||!1}function k(e){return e&&!0===e.isFunctionNode&&!0===e.constructor.prototype.isNode||!1}function I(e){return e&&!0===e.isIndexNode&&!0===e.constructor.prototype.isNode||!1}function z(e){return e&&!0===e.isNode&&!0===e.constructor.prototype.isNode||!1}function R(e){return e&&!0===e.isObjectNode&&!0===e.constructor.prototype.isNode||!1}function q(e){return e&&!0===e.isOperatorNode&&!0===e.constructor.prototype.isNode||!1}function j(e){return e&&!0===e.isParenthesisNode&&!0===e.constructor.prototype.isNode||!1}function P(e){return e&&!0===e.isRangeNode&&!0===e.constructor.prototype.isNode||!1}function L(e){return e&&!0===e.isRelationalNode&&!0===e.constructor.prototype.isNode||!1}function U(e){return e&&!0===e.isSymbolNode&&!0===e.constructor.prototype.isNode||!1}function $(e){return e&&!0===e.constructor.prototype.isChain||!1}function H(e){var r=t(e);return"object"===r?null===e?"null":a(e)?"BigNumber":e.constructor&&e.constructor.name?e.constructor.name:"Object":r}var G=r(2369);function V(e){return"boolean"==typeof e||!!isFinite(e)&&e===Math.round(e)}r(8706),r(5276),r(8598),r(2062),r(4782),r(4554),r(3153),r(2326),r(6389),r(4444),r(7762),r(5070),r(5376),r(6624),r(1367),r(5914),r(8553),r(8690),r(5374),r(8459),r(8940),r(1761),r(5440);var Z=Math.sign||function(e){return e>0?1:e<0?-1:0},W=Math.log2||function(e){return Math.log(e)/Math.LN2},Y=Math.log10||function(e){return Math.log(e)/Math.LN10},J=Math.log1p||function(e){return Math.log(e+1)},X=Math.cbrt||function(e){if(0===e)return e;var t,r=e<0;return r&&(e=-e),t=isFinite(e)?(e/((t=Math.exp(Math.log(e)/3))*t)+2*t)/3:e,r?-t:t},Q=Math.expm1||function(e){return e>=2e-4||e<=-2e-4?Math.exp(e)-1:e+e*e/2+e*e*e/6};function K(e,t,r){var n={2:"0b",8:"0o",16:"0x"}[t],i="";if(r){if(r<1)throw new Error("size must be in greater than 0");if(!V(r))throw new Error("size must be an integer");if(e>Math.pow(2,r-1)-1||e<-Math.pow(2,r-1))throw new Error("Value must be in range [-2^".concat(r-1,", 2^").concat(r-1,"-1]"));if(!V(e))throw new Error("Value must be an integer");e<0&&(e+=Math.pow(2,r)),i="i".concat(r)}var a="";return e<0&&(e=-e,a="-"),"".concat(a).concat(n).concat(e.toString(t)).concat(i)}function ee(e,t){if("function"==typeof t)return t(e);if(e===1/0)return"Infinity";if(e===-1/0)return"-Infinity";if(isNaN(e))return"NaN";var r=te(t),n=r.notation,a=r.precision,o=r.wordSize;switch(n){case"fixed":return ne(e,a);case"exponential":return ie(e,a);case"engineering":return function(e,t){if(isNaN(e)||!isFinite(e))return String(e);var r=ae(re(e),t),n=r.exponent,a=r.coefficients,o=n%3==0?n:n<0?n-3-n%3:n-n%3;if(i(t))for(;t>a.length||n-o+1>a.length;)a.push(0);else for(var u=Math.abs(n-o)-(a.length-1),s=0;s<u;s++)a.push(0);for(var c=Math.abs(n-o),f=1;c>0;)f++,c--;var l=a.slice(f).join(""),p=i(t)&&l.length||l.match(/[1-9]/)?"."+l:"",m=a.slice(0,f).join("")+p+"e"+(n>=0?"+":"")+o.toString();return r.sign+m}(e,a);case"bin":return K(e,2,o);case"oct":return K(e,8,o);case"hex":return K(e,16,o);case"auto":return function(e,t,r){if(isNaN(e)||!isFinite(e))return String(e);var n=ve(null==r?void 0:r.lowerExp,-3),i=ve(null==r?void 0:r.upperExp,5),a=re(e),o=t?ae(a,t):a;if(o.exponent<n||o.exponent>=i)return ie(e,t);var u=o.coefficients,s=o.exponent;u.length<t&&(u=u.concat(oe(t-u.length))),u=u.concat(oe(s-u.length+1+(u.length<t?t-u.length:0)));var c=s>0?s:0;return c<(u=oe(-s).concat(u)).length-1&&u.splice(c+1,0,"."),o.sign+u.join("")}(e,a,t).replace(/((\.\d*?)(0+))($|e)/,(function(){var e=arguments[2],t=arguments[4];return"."!==e?e+t:t}));default:throw new Error('Unknown notation "'+n+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function te(e){var t,r,n="auto";if(void 0!==e)if(i(e))t=e;else if(a(e))t=e.toNumber();else{if(!N(e))throw new Error("Unsupported type of options, number, BigNumber, or object expected");void 0!==e.precision&&(t=de(e.precision,(function(){throw new Error('Option "precision" must be a number or BigNumber')}))),void 0!==e.wordSize&&(r=de(e.wordSize,(function(){throw new Error('Option "wordSize" must be a number or BigNumber')}))),e.notation&&(n=e.notation)}return{notation:n,precision:t,wordSize:r}}function re(e){var t=String(e).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);if(!t)throw new SyntaxError("Invalid number "+e);var r=t[1],n=t[2],i=parseFloat(t[4]||"0"),a=n.indexOf(".");i+=-1!==a?a-1:n.length-1;var o=n.replace(".","").replace(/^0*/,(function(e){return i-=e.length,""})).replace(/0*$/,"").split("").map((function(e){return parseInt(e)}));return 0===o.length&&(o.push(0),i++),{sign:r,coefficients:o,exponent:i}}function ne(e,t){if(isNaN(e)||!isFinite(e))return String(e);var r=re(e),n="number"==typeof t?ae(r,r.exponent+1+t):r,i=n.coefficients,a=n.exponent+1,o=a+(t||0);return i.length<o&&(i=i.concat(oe(o-i.length))),a<0&&(i=oe(1-a).concat(i),a=1),a<i.length&&i.splice(a,0,0===a?"0.":"."),n.sign+i.join("")}function ie(e,t){if(isNaN(e)||!isFinite(e))return String(e);var r=re(e),n=t?ae(r,t):r,i=n.coefficients,a=n.exponent;i.length<t&&(i=i.concat(oe(t-i.length)));var o=i.shift();return n.sign+o+(i.length>0?"."+i.join(""):"")+"e"+(a>=0?"+":"")+a}function ae(e,t){for(var r={sign:e.sign,coefficients:e.coefficients,exponent:e.exponent},n=r.coefficients;t<=0;)n.unshift(0),r.exponent++,t++;if(n.length>t&&n.splice(t,n.length-t)[0]>=5){var i=t-1;for(n[i]++;10===n[i];)n.pop(),0===i&&(n.unshift(0),r.exponent++,i++),n[--i]++}return r}function oe(e){for(var t=[],r=0;r<e;r++)t.push(0);return t}var ue=Number.EPSILON||2220446049250313e-31;function se(e,t,r){if(null==r)return e===t;if(e===t)return!0;if(isNaN(e)||isNaN(t))return!1;if(isFinite(e)&&isFinite(t)){var n=Math.abs(e-t);return n<=ue||n<=Math.max(Math.abs(e),Math.abs(t))*r}return!1}var ce=Math.acosh||function(e){return Math.log(Math.sqrt(e*e-1)+e)},fe=Math.asinh||function(e){return Math.log(Math.sqrt(e*e+1)+e)},le=Math.atanh||function(e){return Math.log((1+e)/(1-e))/2},pe=Math.cosh||function(e){return(Math.exp(e)+Math.exp(-e))/2},me=Math.sinh||function(e){return(Math.exp(e)-Math.exp(-e))/2},he=Math.tanh||function(e){var t=Math.exp(2*e);return(t-1)/(t+1)};function de(e,t){return i(e)?e:a(e)?e.toNumber():void t()}function ve(e,t){return i(e)?e:a(e)?e.toNumber():t}function ye(e){var r=t(e);if("number"===r||"string"===r||"boolean"===r||null==e)return e;if("function"==typeof e.clone)return e.clone();if(Array.isArray(e))return e.map((function(e){return ye(e)}));if(e instanceof Date)return new Date(e.valueOf());if(a(e))return e;if(N(e))return ge(e,ye);throw new TypeError("Cannot clone: unknown type of value (value: ".concat(e,")"))}function ge(e,t){var r={};for(var n in e)Ae(e,n)&&(r[n]=t(e[n]));return r}function xe(e,t){for(var r in t)Ae(t,r)&&(e[r]=t[r]);return e}function be(e,t){if(Array.isArray(t))throw new TypeError("Arrays are not supported by deepExtend");for(var r in t)if(Ae(t,r)&&!(r in Object.prototype)&&!(r in Function.prototype))if(t[r]&&t[r].constructor===Object)void 0===e[r]&&(e[r]={}),e[r]&&e[r].constructor===Object?be(e[r],t[r]):e[r]=t[r];else{if(Array.isArray(t[r]))throw new TypeError("Arrays are not supported by deepExtend");e[r]=t[r]}return e}function we(e,t){var r,n,i;if(Array.isArray(e)){if(!Array.isArray(t))return!1;if(e.length!==t.length)return!1;for(n=0,i=e.length;n<i;n++)if(!we(e[n],t[n]))return!1;return!0}if("function"==typeof e)return e===t;if(e instanceof Object){if(Array.isArray(t)||!(t instanceof Object))return!1;for(r in e)if(!(r in t)||!we(e[r],t[r]))return!1;for(r in t)if(!(r in e))return!1;return!0}return e===t}function De(e){var t={};return Ne(e,t),t}function Ne(e,r){for(var n in e)if(Ae(e,n)){var i=e[n];"object"===t(i)&&null!==i?Ne(i,r):r[n]=i}}function Ee(e,t,r){var n,i=!0;Object.defineProperty(e,t,{get:function(){return i&&(n=r(),i=!1),n},set:function(e){n=e,i=!1},configurable:!0,enumerable:!0})}function Ae(e,t){return e&&Object.hasOwnProperty.call(e,t)}function Se(e,t,r,n){function i(n){var i=function(e,t){for(var r={},n=0;n<t.length;n++){var i=t[n],a=e[i];void 0!==a&&(r[i]=a)}return r}(n,t.map(Me));return function(e,t,r){if(!t.filter((function(e){return!function(e){return e&&"?"===e[0]}(e)})).every((function(e){return void 0!==r[e]}))){var n=t.filter((function(e){return void 0===r[e]}));throw new Error('Cannot create function "'.concat(e,'", ')+"some dependencies are missing: ".concat(n.map((function(e){return'"'.concat(e,'"')})).join(", "),"."))}}(e,t,n),r(i)}return i.isFactory=!0,i.fn=e,i.dependencies=t.slice().sort(),n&&(i.meta=n),i}function Ce(e){return"function"==typeof e&&"string"==typeof e.fn&&Array.isArray(e.dependencies)}function Me(e){return e&&"?"===e[0]?e.slice(1):e}function Fe(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function Oe(e,t){if(e){if("string"==typeof e)return Fe(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Fe(e,t):void 0}}function Te(e){return function(e){if(Array.isArray(e))return Fe(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||Oe(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _e(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Be(e){var r=function(e,r){if("object"!=t(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var i=n.call(e,"string");if("object"!=t(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==t(r)?r:r+""}function ke(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,Be(n.key),n)}}function Ie(e,t,r){return t&&ke(e.prototype,t),r&&ke(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}function ze(e,t){if(Pe(e)&&qe(e,t))return e[t];if("function"==typeof e[t]&&je(e,t))throw new Error('Cannot access method "'+t+'" as a property');throw new Error('No access to property "'+t+'"')}function Re(e,t,r){if(Pe(e)&&qe(e,t))return e[t]=r,r;throw new Error('No access to property "'+t+'"')}function qe(e,r){return!(!e||"object"!==t(e)||!Ae(Le,r)&&(r in Object.prototype||r in Function.prototype))}function je(e,t){return!(null==e||"function"!=typeof e[t]||Ae(e,t)&&Object.getPrototypeOf&&t in Object.getPrototypeOf(e)||!Ae(Ue,t)&&(t in Object.prototype||t in Function.prototype))}function Pe(e){return"object"===t(e)&&e&&e.constructor===Object}r(8431),r(2008),r(1629),r(6910),r(3500),r(4185),r(2675),r(9463),r(2259),r(3418),r(3792),r(6033),r(9432),r(1415),r(7764),r(2953);var Le={length:!0,name:!0},Ue={toString:!0,valueOf:!0,toLocaleString:!0};function $e(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return He(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?He(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,o=!0,u=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return o=e.done,e},e:function(e){u=!0,a=e},f:function(){try{o||null==r.return||r.return()}finally{if(u)throw a}}}}function He(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var Ge=function(){return Ie((function e(t){_e(this,e),this.wrappedObject=t,this[Symbol.iterator]=this.entries}),[{key:"keys",value:function(){return Object.keys(this.wrappedObject).values()}},{key:"get",value:function(e){return ze(this.wrappedObject,e)}},{key:"set",value:function(e,t){return Re(this.wrappedObject,e,t),this}},{key:"has",value:function(e){return e in this.wrappedObject}},{key:"entries",value:function(){var e=this;return Ze(this.keys(),(function(t){return[t,e.get(t)]}))}},{key:"forEach",value:function(e){var t,r=$e(this.keys());try{for(r.s();!(t=r.n()).done;){var n=t.value;e(this.get(n),n,this)}}catch(e){r.e(e)}finally{r.f()}}},{key:"delete",value:function(e){delete this.wrappedObject[e]}},{key:"clear",value:function(){var e,t=$e(this.keys());try{for(t.s();!(e=t.n()).done;){var r=e.value;this.delete(r)}}catch(e){t.e(e)}finally{t.f()}}},{key:"size",get:function(){return Object.keys(this.wrappedObject).length}}])}(),Ve=function(){return Ie((function e(t,r,n){_e(this,e),this.a=t,this.b=r,this.bKeys=n,this[Symbol.iterator]=this.entries}),[{key:"get",value:function(e){return this.bKeys.has(e)?this.b.get(e):this.a.get(e)}},{key:"set",value:function(e,t){return this.bKeys.has(e)?this.b.set(e,t):this.a.set(e,t),this}},{key:"has",value:function(e){return this.b.has(e)||this.a.has(e)}},{key:"keys",value:function(){return new Set([].concat(Te(this.a.keys()),Te(this.b.keys())))[Symbol.iterator]()}},{key:"entries",value:function(){var e=this;return Ze(this.keys(),(function(t){return[t,e.get(t)]}))}},{key:"forEach",value:function(e){var t,r=$e(this.keys());try{for(r.s();!(t=r.n()).done;){var n=t.value;e(this.get(n),n,this)}}catch(e){r.e(e)}finally{r.f()}}},{key:"delete",value:function(e){return this.bKeys.has(e)?this.b.delete(e):this.a.delete(e)}},{key:"clear",value:function(){this.a.clear(),this.b.clear()}},{key:"size",get:function(){return Te(this.keys()).length}}])}();function Ze(e,t){return{next:function(){var r=e.next();return r.done?r:{value:t(r.value),done:!1}}}}function We(){return new Map}function Ye(e){if(!e)return We();if(Je(e))return e;if(N(e))return new Ge(e);throw new Error("createMap can create maps from objects or Maps")}function Je(e){return!!e&&(e instanceof Map||e instanceof Ge||"function"==typeof e.set&&"function"==typeof e.get&&"function"==typeof e.keys&&"function"==typeof e.has)}var Xe=function(){return Xe=G.create,G},Qe=Se("typed",["?BigNumber","?Complex","?DenseMatrix","?Fraction"],(function(e){var t=e.BigNumber,r=e.Complex,n=e.DenseMatrix,_=e.Fraction,H=Xe();return H.clear(),H.addTypes([{name:"number",test:i},{name:"Complex",test:o},{name:"BigNumber",test:a},{name:"Fraction",test:u},{name:"Unit",test:s},{name:"identifier",test:function(e){return c&&/^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(e)}},{name:"string",test:c},{name:"Chain",test:$},{name:"Array",test:f},{name:"Matrix",test:l},{name:"DenseMatrix",test:m},{name:"SparseMatrix",test:h},{name:"Range",test:d},{name:"Index",test:v},{name:"boolean",test:y},{name:"ResultSet",test:g},{name:"Help",test:x},{name:"function",test:b},{name:"Date",test:w},{name:"RegExp",test:D},{name:"null",test:E},{name:"undefined",test:A},{name:"AccessorNode",test:S},{name:"ArrayNode",test:C},{name:"AssignmentNode",test:M},{name:"BlockNode",test:F},{name:"ConditionalNode",test:O},{name:"ConstantNode",test:T},{name:"FunctionNode",test:k},{name:"FunctionAssignmentNode",test:B},{name:"IndexNode",test:I},{name:"Node",test:z},{name:"ObjectNode",test:R},{name:"OperatorNode",test:q},{name:"ParenthesisNode",test:j},{name:"RangeNode",test:P},{name:"RelationalNode",test:L},{name:"SymbolNode",test:U},{name:"Map",test:Je},{name:"Object",test:N}]),H.addConversions([{from:"number",to:"BigNumber",convert:function(e){if(t||Ke(e),e.toExponential().replace(/e.*$/,"").replace(/^0\.?0*|\./,"").length>15)throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: "+e+"). Use function bignumber(x) to convert to BigNumber.");return new t(e)}},{from:"number",to:"Complex",convert:function(e){return r||et(e),new r(e,0)}},{from:"BigNumber",to:"Complex",convert:function(e){return r||et(e),new r(e.toNumber(),0)}},{from:"Fraction",to:"BigNumber",convert:function(e){throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.")}},{from:"Fraction",to:"Complex",convert:function(e){return r||et(e),new r(e.valueOf(),0)}},{from:"number",to:"Fraction",convert:function(e){_||tt(e);var t=new _(e);if(t.valueOf()!==e)throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: "+e+"). Use function fraction(x) to convert to Fraction.");return t}},{from:"string",to:"number",convert:function(e){var t=Number(e);if(isNaN(t))throw new Error('Cannot convert "'+e+'" to a number');return t}},{from:"string",to:"BigNumber",convert:function(e){t||Ke(e);try{return new t(e)}catch(t){throw new Error('Cannot convert "'+e+'" to BigNumber')}}},{from:"string",to:"Fraction",convert:function(e){_||tt(e);try{return new _(e)}catch(t){throw new Error('Cannot convert "'+e+'" to Fraction')}}},{from:"string",to:"Complex",convert:function(e){r||et(e);try{return new r(e)}catch(t){throw new Error('Cannot convert "'+e+'" to Complex')}}},{from:"boolean",to:"number",convert:function(e){return+e}},{from:"boolean",to:"BigNumber",convert:function(e){return t||Ke(e),new t(+e)}},{from:"boolean",to:"Fraction",convert:function(e){return _||tt(e),new _(+e)}},{from:"boolean",to:"string",convert:function(e){return String(e)}},{from:"Array",to:"Matrix",convert:function(e){return n||function(){throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided")}(),new n(e)}},{from:"Matrix",to:"Array",convert:function(e){return e.valueOf()}}]),H.onMismatch=function(e,t,r){var n=H.createError(e,t,r);if(["wrongType","mismatch"].includes(n.data.category)&&1===t.length&&p(t[0])&&r.some((function(e){return!e.params.includes(",")}))){var i=new TypeError("Function '".concat(e,"' doesn't apply to matrices. To call it ")+"elementwise on a matrix 'M', try 'map(M, ".concat(e,")'."));throw i.data=n.data,i}throw n},H.onMismatch=function(e,t,r){var n=H.createError(e,t,r);if(["wrongType","mismatch"].includes(n.data.category)&&1===t.length&&p(t[0])&&r.some((function(e){return!e.params.includes(",")}))){var i=new TypeError("Function '".concat(e,"' doesn't apply to matrices. To call it ")+"elementwise on a matrix 'M', try 'map(M, ".concat(e,")'."));throw i.data=n.data,i}throw n},H}));function Ke(e){throw new Error("Cannot convert value ".concat(e," into a BigNumber: no class 'BigNumber' provided"))}function et(e){throw new Error("Cannot convert value ".concat(e," into a Complex number: no class 'Complex' provided"))}function tt(e){throw new Error("Cannot convert value ".concat(e," into a Fraction, no class 'Fraction' provided."))}r(739);var rt,nt,it=Se("ResultSet",[],(function(){function e(t){if(!(this instanceof e))throw new SyntaxError("Constructor must be called with the new operator");this.entries=t||[]}return e.prototype.type="ResultSet",e.prototype.isResultSet=!0,e.prototype.valueOf=function(){return this.entries},e.prototype.toString=function(){return"["+this.entries.join(", ")+"]"},e.prototype.toJSON=function(){return{mathjs:"ResultSet",entries:this.entries}},e.fromJSON=function(t){return new e(t.entries)},e}),{isClass:!0}),at=(r(9904),9e15),ot=1e9,ut="0123456789abcdef",st="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",ct="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",ft={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-at,maxE:at,crypto:!1},lt=!0,pt="[DecimalError] ",mt=pt+"Invalid argument: ",ht=pt+"Precision limit exceeded",dt=pt+"crypto unavailable",vt="[object Decimal]",yt=Math.floor,gt=Math.pow,xt=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,bt=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,wt=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,Dt=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,Nt=1e7,Et=7,At=st.length-1,St=ct.length-1,Ct={toStringTag:vt};function Mt(e){var t,r,n,i=e.length-1,a="",o=e[0];if(i>0){for(a+=o,t=1;t<i;t++)n=e[t]+"",(r=Et-n.length)&&(a+=jt(r)),a+=n;o=e[t],(r=Et-(n=o+"").length)&&(a+=jt(r))}else if(0===o)return"0";for(;o%10==0;)o/=10;return a+o}function Ft(e,t,r){if(e!==~~e||e<t||e>r)throw Error(mt+e)}function Ot(e,t,r,n){var i,a,o,u;for(a=e[0];a>=10;a/=10)--t;return--t<0?(t+=Et,i=0):(i=Math.ceil((t+1)/Et),t%=Et),a=gt(10,Et-t),u=e[i]%a|0,null==n?t<3?(0==t?u=u/100|0:1==t&&(u=u/10|0),o=r<4&&99999==u||r>3&&49999==u||5e4==u||0==u):o=(r<4&&u+1==a||r>3&&u+1==a/2)&&(e[i+1]/a/100|0)==gt(10,t-2)-1||(u==a/2||0==u)&&0==(e[i+1]/a/100|0):t<4?(0==t?u=u/1e3|0:1==t?u=u/100|0:2==t&&(u=u/10|0),o=(n||r<4)&&9999==u||!n&&r>3&&4999==u):o=((n||r<4)&&u+1==a||!n&&r>3&&u+1==a/2)&&(e[i+1]/a/1e3|0)==gt(10,t-3)-1,o}function Tt(e,t,r){for(var n,i,a=[0],o=0,u=e.length;o<u;){for(i=a.length;i--;)a[i]*=t;for(a[0]+=ut.indexOf(e.charAt(o++)),n=0;n<a.length;n++)a[n]>r-1&&(void 0===a[n+1]&&(a[n+1]=0),a[n+1]+=a[n]/r|0,a[n]%=r)}return a.reverse()}Ct.absoluteValue=Ct.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),Bt(e)},Ct.ceil=function(){return Bt(new this.constructor(this),this.e+1,2)},Ct.clampedTo=Ct.clamp=function(e,t){var r=this,n=r.constructor;if(e=new n(e),t=new n(t),!e.s||!t.s)return new n(NaN);if(e.gt(t))throw Error(mt+t);return r.cmp(e)<0?e:r.cmp(t)>0?t:new n(r)},Ct.comparedTo=Ct.cmp=function(e){var t,r,n,i,a=this,o=a.d,u=(e=new a.constructor(e)).d,s=a.s,c=e.s;if(!o||!u)return s&&c?s!==c?s:o===u?0:!o^s<0?1:-1:NaN;if(!o[0]||!u[0])return o[0]?s:u[0]?-c:0;if(s!==c)return s;if(a.e!==e.e)return a.e>e.e^s<0?1:-1;for(t=0,r=(n=o.length)<(i=u.length)?n:i;t<r;++t)if(o[t]!==u[t])return o[t]>u[t]^s<0?1:-1;return n===i?0:n>i^s<0?1:-1},Ct.cosine=Ct.cos=function(){var e,t,r=this,n=r.constructor;return r.d?r.d[0]?(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+Et,n.rounding=1,r=function(e,t){var r,n,i;if(t.isZero())return t;(n=t.d.length)<32?i=(1/Yt(4,r=Math.ceil(n/3))).toString():(r=16,i="2.3283064365386962890625e-10"),e.precision+=r,t=Wt(e,1,t.times(i),new e(1));for(var a=r;a--;){var o=t.times(t);t=o.times(o).minus(o).times(8).plus(1)}return e.precision-=r,t}(n,Jt(n,r)),n.precision=e,n.rounding=t,Bt(2==nt||3==nt?r.neg():r,e,t,!0)):new n(1):new n(NaN)},Ct.cubeRoot=Ct.cbrt=function(){var e,t,r,n,i,a,o,u,s,c,f=this,l=f.constructor;if(!f.isFinite()||f.isZero())return new l(f);for(lt=!1,(a=f.s*gt(f.s*f,1/3))&&Math.abs(a)!=1/0?n=new l(a.toString()):(r=Mt(f.d),(a=((e=f.e)-r.length+1)%3)&&(r+=1==a||-2==a?"0":"00"),a=gt(r,1/3),e=yt((e+1)/3)-(e%3==(e<0?-1:2)),(n=new l(r=a==1/0?"5e"+e:(r=a.toExponential()).slice(0,r.indexOf("e")+1)+e)).s=f.s),o=(e=l.precision)+3;;)if(c=(s=(u=n).times(u).times(u)).plus(f),n=_t(c.plus(f).times(u),c.plus(s),o+2,1),Mt(u.d).slice(0,o)===(r=Mt(n.d)).slice(0,o)){if("9999"!=(r=r.slice(o-3,o+1))&&(i||"4999"!=r)){+r&&(+r.slice(1)||"5"!=r.charAt(0))||(Bt(n,e+1,1),t=!n.times(n).times(n).eq(f));break}if(!i&&(Bt(u,e+1,0),u.times(u).times(u).eq(f))){n=u;break}o+=4,i=1}return lt=!0,Bt(n,e,l.rounding,t)},Ct.decimalPlaces=Ct.dp=function(){var e,t=this.d,r=NaN;if(t){if(r=((e=t.length-1)-yt(this.e/Et))*Et,e=t[e])for(;e%10==0;e/=10)r--;r<0&&(r=0)}return r},Ct.dividedBy=Ct.div=function(e){return _t(this,new this.constructor(e))},Ct.dividedToIntegerBy=Ct.divToInt=function(e){var t=this.constructor;return Bt(_t(this,new t(e),0,1,1),t.precision,t.rounding)},Ct.equals=Ct.eq=function(e){return 0===this.cmp(e)},Ct.floor=function(){return Bt(new this.constructor(this),this.e+1,3)},Ct.greaterThan=Ct.gt=function(e){return this.cmp(e)>0},Ct.greaterThanOrEqualTo=Ct.gte=function(e){var t=this.cmp(e);return 1==t||0===t},Ct.hyperbolicCosine=Ct.cosh=function(){var e,t,r,n,i,a=this,o=a.constructor,u=new o(1);if(!a.isFinite())return new o(a.s?1/0:NaN);if(a.isZero())return u;r=o.precision,n=o.rounding,o.precision=r+Math.max(a.e,a.sd())+4,o.rounding=1,(i=a.d.length)<32?t=(1/Yt(4,e=Math.ceil(i/3))).toString():(e=16,t="2.3283064365386962890625e-10"),a=Wt(o,1,a.times(t),new o(1),!0);for(var s,c=e,f=new o(8);c--;)s=a.times(a),a=u.minus(s.times(f.minus(s.times(f))));return Bt(a,o.precision=r,o.rounding=n,!0)},Ct.hyperbolicSine=Ct.sinh=function(){var e,t,r,n,i=this,a=i.constructor;if(!i.isFinite()||i.isZero())return new a(i);if(t=a.precision,r=a.rounding,a.precision=t+Math.max(i.e,i.sd())+4,a.rounding=1,(n=i.d.length)<3)i=Wt(a,2,i,i,!0);else{e=(e=1.4*Math.sqrt(n))>16?16:0|e,i=Wt(a,2,i=i.times(1/Yt(5,e)),i,!0);for(var o,u=new a(5),s=new a(16),c=new a(20);e--;)o=i.times(i),i=i.times(u.plus(o.times(s.times(o).plus(c))))}return a.precision=t,a.rounding=r,Bt(i,t,r,!0)},Ct.hyperbolicTangent=Ct.tanh=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+7,n.rounding=1,_t(r.sinh(),r.cosh(),n.precision=e,n.rounding=t)):new n(r.s)},Ct.inverseCosine=Ct.acos=function(){var e,t=this,r=t.constructor,n=t.abs().cmp(1),i=r.precision,a=r.rounding;return-1!==n?0===n?t.isNeg()?Rt(r,i,a):new r(0):new r(NaN):t.isZero()?Rt(r,i+4,a).times(.5):(r.precision=i+6,r.rounding=1,t=t.asin(),e=Rt(r,i+4,a).times(.5),r.precision=i,r.rounding=a,e.minus(t))},Ct.inverseHyperbolicCosine=Ct.acosh=function(){var e,t,r=this,n=r.constructor;return r.lte(1)?new n(r.eq(1)?0:NaN):r.isFinite()?(e=n.precision,t=n.rounding,n.precision=e+Math.max(Math.abs(r.e),r.sd())+4,n.rounding=1,lt=!1,r=r.times(r).minus(1).sqrt().plus(r),lt=!0,n.precision=e,n.rounding=t,r.ln()):new n(r)},Ct.inverseHyperbolicSine=Ct.asinh=function(){var e,t,r=this,n=r.constructor;return!r.isFinite()||r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+2*Math.max(Math.abs(r.e),r.sd())+6,n.rounding=1,lt=!1,r=r.times(r).plus(1).sqrt().plus(r),lt=!0,n.precision=e,n.rounding=t,r.ln())},Ct.inverseHyperbolicTangent=Ct.atanh=function(){var e,t,r,n,i=this,a=i.constructor;return i.isFinite()?i.e>=0?new a(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=a.precision,t=a.rounding,n=i.sd(),Math.max(n,e)<2*-i.e-1?Bt(new a(i),e,t,!0):(a.precision=r=n-i.e,i=_t(i.plus(1),new a(1).minus(i),r+e,1),a.precision=e+4,a.rounding=1,i=i.ln(),a.precision=e,a.rounding=t,i.times(.5))):new a(NaN)},Ct.inverseSine=Ct.asin=function(){var e,t,r,n,i=this,a=i.constructor;return i.isZero()?new a(i):(t=i.abs().cmp(1),r=a.precision,n=a.rounding,-1!==t?0===t?((e=Rt(a,r+4,n).times(.5)).s=i.s,e):new a(NaN):(a.precision=r+6,a.rounding=1,i=i.div(new a(1).minus(i.times(i)).sqrt().plus(1)).atan(),a.precision=r,a.rounding=n,i.times(2)))},Ct.inverseTangent=Ct.atan=function(){var e,t,r,n,i,a,o,u,s,c=this,f=c.constructor,l=f.precision,p=f.rounding;if(c.isFinite()){if(c.isZero())return new f(c);if(c.abs().eq(1)&&l+4<=St)return(o=Rt(f,l+4,p).times(.25)).s=c.s,o}else{if(!c.s)return new f(NaN);if(l+4<=St)return(o=Rt(f,l+4,p).times(.5)).s=c.s,o}for(f.precision=u=l+10,f.rounding=1,e=r=Math.min(28,u/Et+2|0);e;--e)c=c.div(c.times(c).plus(1).sqrt().plus(1));for(lt=!1,t=Math.ceil(u/Et),n=1,s=c.times(c),o=new f(c),i=c;-1!==e;)if(i=i.times(s),a=o.minus(i.div(n+=2)),i=i.times(s),void 0!==(o=a.plus(i.div(n+=2))).d[t])for(e=t;o.d[e]===a.d[e]&&e--;);return r&&(o=o.times(2<<r-1)),lt=!0,Bt(o,f.precision=l,f.rounding=p,!0)},Ct.isFinite=function(){return!!this.d},Ct.isInteger=Ct.isInt=function(){return!!this.d&&yt(this.e/Et)>this.d.length-2},Ct.isNaN=function(){return!this.s},Ct.isNegative=Ct.isNeg=function(){return this.s<0},Ct.isPositive=Ct.isPos=function(){return this.s>0},Ct.isZero=function(){return!!this.d&&0===this.d[0]},Ct.lessThan=Ct.lt=function(e){return this.cmp(e)<0},Ct.lessThanOrEqualTo=Ct.lte=function(e){return this.cmp(e)<1},Ct.logarithm=Ct.log=function(e){var t,r,n,i,a,o,u,s,c=this,f=c.constructor,l=f.precision,p=f.rounding;if(null==e)e=new f(10),t=!0;else{if(r=(e=new f(e)).d,e.s<0||!r||!r[0]||e.eq(1))return new f(NaN);t=e.eq(10)}if(r=c.d,c.s<0||!r||!r[0]||c.eq(1))return new f(r&&!r[0]?-1/0:1!=c.s?NaN:r?0:1/0);if(t)if(r.length>1)a=!0;else{for(i=r[0];i%10==0;)i/=10;a=1!==i}if(lt=!1,o=Ht(c,u=l+5),n=t?zt(f,u+10):Ht(e,u),Ot((s=_t(o,n,u,1)).d,i=l,p))do{if(o=Ht(c,u+=10),n=t?zt(f,u+10):Ht(e,u),s=_t(o,n,u,1),!a){+Mt(s.d).slice(i+1,i+15)+1==1e14&&(s=Bt(s,l+1,0));break}}while(Ot(s.d,i+=10,p));return lt=!0,Bt(s,l,p)},Ct.minus=Ct.sub=function(e){var t,r,n,i,a,o,u,s,c,f,l,p,m=this,h=m.constructor;if(e=new h(e),!m.d||!e.d)return m.s&&e.s?m.d?e.s=-e.s:e=new h(e.d||m.s!==e.s?m:NaN):e=new h(NaN),e;if(m.s!=e.s)return e.s=-e.s,m.plus(e);if(c=m.d,p=e.d,u=h.precision,s=h.rounding,!c[0]||!p[0]){if(p[0])e.s=-e.s;else{if(!c[0])return new h(3===s?-0:0);e=new h(m)}return lt?Bt(e,u,s):e}if(r=yt(e.e/Et),f=yt(m.e/Et),c=c.slice(),a=f-r){for((l=a<0)?(t=c,a=-a,o=p.length):(t=p,r=f,o=c.length),a>(n=Math.max(Math.ceil(u/Et),o)+2)&&(a=n,t.length=1),t.reverse(),n=a;n--;)t.push(0);t.reverse()}else{for((l=(n=c.length)<(o=p.length))&&(o=n),n=0;n<o;n++)if(c[n]!=p[n]){l=c[n]<p[n];break}a=0}for(l&&(t=c,c=p,p=t,e.s=-e.s),o=c.length,n=p.length-o;n>0;--n)c[o++]=0;for(n=p.length;n>a;){if(c[--n]<p[n]){for(i=n;i&&0===c[--i];)c[i]=Nt-1;--c[i],c[n]+=Nt}c[n]-=p[n]}for(;0===c[--o];)c.pop();for(;0===c[0];c.shift())--r;return c[0]?(e.d=c,e.e=It(c,r),lt?Bt(e,u,s):e):new h(3===s?-0:0)},Ct.modulo=Ct.mod=function(e){var t,r=this,n=r.constructor;return e=new n(e),!r.d||!e.s||e.d&&!e.d[0]?new n(NaN):!e.d||r.d&&!r.d[0]?Bt(new n(r),n.precision,n.rounding):(lt=!1,9==n.modulo?(t=_t(r,e.abs(),0,3,1)).s*=e.s:t=_t(r,e,0,n.modulo,1),t=t.times(e),lt=!0,r.minus(t))},Ct.naturalExponential=Ct.exp=function(){return $t(this)},Ct.naturalLogarithm=Ct.ln=function(){return Ht(this)},Ct.negated=Ct.neg=function(){var e=new this.constructor(this);return e.s=-e.s,Bt(e)},Ct.plus=Ct.add=function(e){var t,r,n,i,a,o,u,s,c,f,l=this,p=l.constructor;if(e=new p(e),!l.d||!e.d)return l.s&&e.s?l.d||(e=new p(e.d||l.s===e.s?l:NaN)):e=new p(NaN),e;if(l.s!=e.s)return e.s=-e.s,l.minus(e);if(c=l.d,f=e.d,u=p.precision,s=p.rounding,!c[0]||!f[0])return f[0]||(e=new p(l)),lt?Bt(e,u,s):e;if(a=yt(l.e/Et),n=yt(e.e/Et),c=c.slice(),i=a-n){for(i<0?(r=c,i=-i,o=f.length):(r=f,n=a,o=c.length),i>(o=(a=Math.ceil(u/Et))>o?a+1:o+1)&&(i=o,r.length=1),r.reverse();i--;)r.push(0);r.reverse()}for((o=c.length)-(i=f.length)<0&&(i=o,r=f,f=c,c=r),t=0;i;)t=(c[--i]=c[i]+f[i]+t)/Nt|0,c[i]%=Nt;for(t&&(c.unshift(t),++n),o=c.length;0==c[--o];)c.pop();return e.d=c,e.e=It(c,n),lt?Bt(e,u,s):e},Ct.precision=Ct.sd=function(e){var t,r=this;if(void 0!==e&&e!==!!e&&1!==e&&0!==e)throw Error(mt+e);return r.d?(t=qt(r.d),e&&r.e+1>t&&(t=r.e+1)):t=NaN,t},Ct.round=function(){var e=this,t=e.constructor;return Bt(new t(e),e.e+1,t.rounding)},Ct.sine=Ct.sin=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+Et,n.rounding=1,r=function(e,t){var r,n=t.d.length;if(n<3)return t.isZero()?t:Wt(e,2,t,t);r=(r=1.4*Math.sqrt(n))>16?16:0|r,t=Wt(e,2,t=t.times(1/Yt(5,r)),t);for(var i,a=new e(5),o=new e(16),u=new e(20);r--;)i=t.times(t),t=t.times(a.plus(i.times(o.times(i).minus(u))));return t}(n,Jt(n,r)),n.precision=e,n.rounding=t,Bt(nt>2?r.neg():r,e,t,!0)):new n(NaN)},Ct.squareRoot=Ct.sqrt=function(){var e,t,r,n,i,a,o=this,u=o.d,s=o.e,c=o.s,f=o.constructor;if(1!==c||!u||!u[0])return new f(!c||c<0&&(!u||u[0])?NaN:u?o:1/0);for(lt=!1,0==(c=Math.sqrt(+o))||c==1/0?(((t=Mt(u)).length+s)%2==0&&(t+="0"),c=Math.sqrt(t),s=yt((s+1)/2)-(s<0||s%2),n=new f(t=c==1/0?"5e"+s:(t=c.toExponential()).slice(0,t.indexOf("e")+1)+s)):n=new f(c.toString()),r=(s=f.precision)+3;;)if(n=(a=n).plus(_t(o,a,r+2,1)).times(.5),Mt(a.d).slice(0,r)===(t=Mt(n.d)).slice(0,r)){if("9999"!=(t=t.slice(r-3,r+1))&&(i||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(Bt(n,s+1,1),e=!n.times(n).eq(o));break}if(!i&&(Bt(a,s+1,0),a.times(a).eq(o))){n=a;break}r+=4,i=1}return lt=!0,Bt(n,s,f.rounding,e)},Ct.tangent=Ct.tan=function(){var e,t,r=this,n=r.constructor;return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+10,n.rounding=1,(r=r.sin()).s=1,r=_t(r,new n(1).minus(r.times(r)).sqrt(),e+10,0),n.precision=e,n.rounding=t,Bt(2==nt||4==nt?r.neg():r,e,t,!0)):new n(NaN)},Ct.times=Ct.mul=function(e){var t,r,n,i,a,o,u,s,c,f=this,l=f.constructor,p=f.d,m=(e=new l(e)).d;if(e.s*=f.s,!(p&&p[0]&&m&&m[0]))return new l(!e.s||p&&!p[0]&&!m||m&&!m[0]&&!p?NaN:p&&m?0*e.s:e.s/0);for(r=yt(f.e/Et)+yt(e.e/Et),(s=p.length)<(c=m.length)&&(a=p,p=m,m=a,o=s,s=c,c=o),a=[],n=o=s+c;n--;)a.push(0);for(n=c;--n>=0;){for(t=0,i=s+n;i>n;)u=a[i]+m[n]*p[i-n-1]+t,a[i--]=u%Nt|0,t=u/Nt|0;a[i]=(a[i]+t)%Nt|0}for(;!a[--o];)a.pop();return t?++r:a.shift(),e.d=a,e.e=It(a,r),lt?Bt(e,l.precision,l.rounding):e},Ct.toBinary=function(e,t){return Xt(this,2,e,t)},Ct.toDecimalPlaces=Ct.toDP=function(e,t){var r=this,n=r.constructor;return r=new n(r),void 0===e?r:(Ft(e,0,ot),void 0===t?t=n.rounding:Ft(t,0,8),Bt(r,e+r.e+1,t))},Ct.toExponential=function(e,t){var r,n=this,i=n.constructor;return void 0===e?r=kt(n,!0):(Ft(e,0,ot),void 0===t?t=i.rounding:Ft(t,0,8),r=kt(n=Bt(new i(n),e+1,t),!0,e+1)),n.isNeg()&&!n.isZero()?"-"+r:r},Ct.toFixed=function(e,t){var r,n,i=this,a=i.constructor;return void 0===e?r=kt(i):(Ft(e,0,ot),void 0===t?t=a.rounding:Ft(t,0,8),r=kt(n=Bt(new a(i),e+i.e+1,t),!1,e+n.e+1)),i.isNeg()&&!i.isZero()?"-"+r:r},Ct.toFraction=function(e){var t,r,n,i,a,o,u,s,c,f,l,p,m=this,h=m.d,d=m.constructor;if(!h)return new d(m);if(c=r=new d(1),n=s=new d(0),o=(a=(t=new d(n)).e=qt(h)-m.e-1)%Et,t.d[0]=gt(10,o<0?Et+o:o),null==e)e=a>0?t:c;else{if(!(u=new d(e)).isInt()||u.lt(c))throw Error(mt+u);e=u.gt(t)?a>0?t:c:u}for(lt=!1,u=new d(Mt(h)),f=d.precision,d.precision=a=h.length*Et*2;l=_t(u,t,0,1,1),1!=(i=r.plus(l.times(n))).cmp(e);)r=n,n=i,i=c,c=s.plus(l.times(i)),s=i,i=t,t=u.minus(l.times(i)),u=i;return i=_t(e.minus(r),n,0,1,1),s=s.plus(i.times(c)),r=r.plus(i.times(n)),s.s=c.s=m.s,p=_t(c,n,a,1).minus(m).abs().cmp(_t(s,r,a,1).minus(m).abs())<1?[c,n]:[s,r],d.precision=f,lt=!0,p},Ct.toHexadecimal=Ct.toHex=function(e,t){return Xt(this,16,e,t)},Ct.toNearest=function(e,t){var r=this,n=r.constructor;if(r=new n(r),null==e){if(!r.d)return r;e=new n(1),t=n.rounding}else{if(e=new n(e),void 0===t?t=n.rounding:Ft(t,0,8),!r.d)return e.s?r:e;if(!e.d)return e.s&&(e.s=r.s),e}return e.d[0]?(lt=!1,r=_t(r,e,0,t,1).times(e),lt=!0,Bt(r)):(e.s=r.s,r=e),r},Ct.toNumber=function(){return+this},Ct.toOctal=function(e,t){return Xt(this,8,e,t)},Ct.toPower=Ct.pow=function(e){var t,r,n,i,a,o,u=this,s=u.constructor,c=+(e=new s(e));if(!(u.d&&e.d&&u.d[0]&&e.d[0]))return new s(gt(+u,c));if((u=new s(u)).eq(1))return u;if(n=s.precision,a=s.rounding,e.eq(1))return Bt(u,n,a);if((t=yt(e.e/Et))>=e.d.length-1&&(r=c<0?-c:c)<=9007199254740991)return i=Pt(s,u,r,n),e.s<0?new s(1).div(i):Bt(i,n,a);if((o=u.s)<0){if(t<e.d.length-1)return new s(NaN);if(0==(1&e.d[t])&&(o=1),0==u.e&&1==u.d[0]&&1==u.d.length)return u.s=o,u}return(t=0!=(r=gt(+u,c))&&isFinite(r)?new s(r+"").e:yt(c*(Math.log("0."+Mt(u.d))/Math.LN10+u.e+1)))>s.maxE+1||t<s.minE-1?new s(t>0?o/0:0):(lt=!1,s.rounding=u.s=1,r=Math.min(12,(t+"").length),(i=$t(e.times(Ht(u,n+r)),n)).d&&Ot((i=Bt(i,n+5,1)).d,n,a)&&(t=n+10,+Mt((i=Bt($t(e.times(Ht(u,t+r)),t),t+5,1)).d).slice(n+1,n+15)+1==1e14&&(i=Bt(i,n+1,0))),i.s=o,lt=!0,s.rounding=a,Bt(i,n,a))},Ct.toPrecision=function(e,t){var r,n=this,i=n.constructor;return void 0===e?r=kt(n,n.e<=i.toExpNeg||n.e>=i.toExpPos):(Ft(e,1,ot),void 0===t?t=i.rounding:Ft(t,0,8),r=kt(n=Bt(new i(n),e,t),e<=n.e||n.e<=i.toExpNeg,e)),n.isNeg()&&!n.isZero()?"-"+r:r},Ct.toSignificantDigits=Ct.toSD=function(e,t){var r=this.constructor;return void 0===e?(e=r.precision,t=r.rounding):(Ft(e,1,ot),void 0===t?t=r.rounding:Ft(t,0,8)),Bt(new r(this),e,t)},Ct.toString=function(){var e=this,t=e.constructor,r=kt(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()&&!e.isZero()?"-"+r:r},Ct.truncated=Ct.trunc=function(){return Bt(new this.constructor(this),this.e+1,1)},Ct.valueOf=Ct.toJSON=function(){var e=this,t=e.constructor,r=kt(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()?"-"+r:r};var _t=function(){function e(e,t,r){var n,i=0,a=e.length;for(e=e.slice();a--;)n=e[a]*t+i,e[a]=n%r|0,i=n/r|0;return i&&e.unshift(i),e}function t(e,t,r,n){var i,a;if(r!=n)a=r>n?1:-1;else for(i=a=0;i<r;i++)if(e[i]!=t[i]){a=e[i]>t[i]?1:-1;break}return a}function r(e,t,r,n){for(var i=0;r--;)e[r]-=i,i=e[r]<t[r]?1:0,e[r]=i*n+e[r]-t[r];for(;!e[0]&&e.length>1;)e.shift()}return function(n,i,a,o,u,s){var c,f,l,p,m,h,d,v,y,g,x,b,w,D,N,E,A,S,C,M,F=n.constructor,O=n.s==i.s?1:-1,T=n.d,_=i.d;if(!(T&&T[0]&&_&&_[0]))return new F(n.s&&i.s&&(T?!_||T[0]!=_[0]:_)?T&&0==T[0]||!_?0*O:O/0:NaN);for(s?(m=1,f=n.e-i.e):(s=Nt,m=Et,f=yt(n.e/m)-yt(i.e/m)),C=_.length,A=T.length,g=(y=new F(O)).d=[],l=0;_[l]==(T[l]||0);l++);if(_[l]>(T[l]||0)&&f--,null==a?(D=a=F.precision,o=F.rounding):D=u?a+(n.e-i.e)+1:a,D<0)g.push(1),h=!0;else{if(D=D/m+2|0,l=0,1==C){for(p=0,_=_[0],D++;(l<A||p)&&D--;l++)N=p*s+(T[l]||0),g[l]=N/_|0,p=N%_|0;h=p||l<A}else{for((p=s/(_[0]+1)|0)>1&&(_=e(_,p,s),T=e(T,p,s),C=_.length,A=T.length),E=C,b=(x=T.slice(0,C)).length;b<C;)x[b++]=0;(M=_.slice()).unshift(0),S=_[0],_[1]>=s/2&&++S;do{p=0,(c=t(_,x,C,b))<0?(w=x[0],C!=b&&(w=w*s+(x[1]||0)),(p=w/S|0)>1?(p>=s&&(p=s-1),1==(c=t(d=e(_,p,s),x,v=d.length,b=x.length))&&(p--,r(d,C<v?M:_,v,s))):(0==p&&(c=p=1),d=_.slice()),(v=d.length)<b&&d.unshift(0),r(x,d,b,s),-1==c&&(c=t(_,x,C,b=x.length))<1&&(p++,r(x,C<b?M:_,b,s)),b=x.length):0===c&&(p++,x=[0]),g[l++]=p,c&&x[0]?x[b++]=T[E]||0:(x=[T[E]],b=1)}while((E++<A||void 0!==x[0])&&D--);h=void 0!==x[0]}g[0]||g.shift()}if(1==m)y.e=f,rt=h;else{for(l=1,p=g[0];p>=10;p/=10)l++;y.e=l+f*m-1,Bt(y,u?a+y.e+1:a,o,h)}return y}}();function Bt(e,t,r,n){var i,a,o,u,s,c,f,l,p,m=e.constructor;e:if(null!=t){if(!(l=e.d))return e;for(i=1,u=l[0];u>=10;u/=10)i++;if((a=t-i)<0)a+=Et,o=t,s=(f=l[p=0])/gt(10,i-o-1)%10|0;else if((p=Math.ceil((a+1)/Et))>=(u=l.length)){if(!n)break e;for(;u++<=p;)l.push(0);f=s=0,i=1,o=(a%=Et)-Et+1}else{for(f=u=l[p],i=1;u>=10;u/=10)i++;s=(o=(a%=Et)-Et+i)<0?0:f/gt(10,i-o-1)%10|0}if(n=n||t<0||void 0!==l[p+1]||(o<0?f:f%gt(10,i-o-1)),c=r<4?(s||n)&&(0==r||r==(e.s<0?3:2)):s>5||5==s&&(4==r||n||6==r&&(a>0?o>0?f/gt(10,i-o):0:l[p-1])%10&1||r==(e.s<0?8:7)),t<1||!l[0])return l.length=0,c?(t-=e.e+1,l[0]=gt(10,(Et-t%Et)%Et),e.e=-t||0):l[0]=e.e=0,e;if(0==a?(l.length=p,u=1,p--):(l.length=p+1,u=gt(10,Et-a),l[p]=o>0?(f/gt(10,i-o)%gt(10,o)|0)*u:0),c)for(;;){if(0==p){for(a=1,o=l[0];o>=10;o/=10)a++;for(o=l[0]+=u,u=1;o>=10;o/=10)u++;a!=u&&(e.e++,l[0]==Nt&&(l[0]=1));break}if(l[p]+=u,l[p]!=Nt)break;l[p--]=0,u=1}for(a=l.length;0===l[--a];)l.pop()}return lt&&(e.e>m.maxE?(e.d=null,e.e=NaN):e.e<m.minE&&(e.e=0,e.d=[0])),e}function kt(e,t,r){if(!e.isFinite())return Gt(e);var n,i=e.e,a=Mt(e.d),o=a.length;return t?(r&&(n=r-o)>0?a=a.charAt(0)+"."+a.slice(1)+jt(n):o>1&&(a=a.charAt(0)+"."+a.slice(1)),a=a+(e.e<0?"e":"e+")+e.e):i<0?(a="0."+jt(-i-1)+a,r&&(n=r-o)>0&&(a+=jt(n))):i>=o?(a+=jt(i+1-o),r&&(n=r-i-1)>0&&(a=a+"."+jt(n))):((n=i+1)<o&&(a=a.slice(0,n)+"."+a.slice(n)),r&&(n=r-o)>0&&(i+1===o&&(a+="."),a+=jt(n))),a}function It(e,t){var r=e[0];for(t*=Et;r>=10;r/=10)t++;return t}function zt(e,t,r){if(t>At)throw lt=!0,r&&(e.precision=r),Error(ht);return Bt(new e(st),t,1,!0)}function Rt(e,t,r){if(t>St)throw Error(ht);return Bt(new e(ct),t,r,!0)}function qt(e){var t=e.length-1,r=t*Et+1;if(t=e[t]){for(;t%10==0;t/=10)r--;for(t=e[0];t>=10;t/=10)r++}return r}function jt(e){for(var t="";e--;)t+="0";return t}function Pt(e,t,r,n){var i,a=new e(1),o=Math.ceil(n/Et+4);for(lt=!1;;){if(r%2&&Qt((a=a.times(t)).d,o)&&(i=!0),0===(r=yt(r/2))){r=a.d.length-1,i&&0===a.d[r]&&++a.d[r];break}Qt((t=t.times(t)).d,o)}return lt=!0,a}function Lt(e){return 1&e.d[e.d.length-1]}function Ut(e,t,r){for(var n,i=new e(t[0]),a=0;++a<t.length;){if(!(n=new e(t[a])).s){i=n;break}i[r](n)&&(i=n)}return i}function $t(e,t){var r,n,i,a,o,u,s,c=0,f=0,l=0,p=e.constructor,m=p.rounding,h=p.precision;if(!e.d||!e.d[0]||e.e>17)return new p(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:NaN);for(null==t?(lt=!1,s=h):s=t,u=new p(.03125);e.e>-2;)e=e.times(u),l+=5;for(s+=n=Math.log(gt(2,l))/Math.LN10*2+5|0,r=a=o=new p(1),p.precision=s;;){if(a=Bt(a.times(e),s,1),r=r.times(++f),Mt((u=o.plus(_t(a,r,s,1))).d).slice(0,s)===Mt(o.d).slice(0,s)){for(i=l;i--;)o=Bt(o.times(o),s,1);if(null!=t)return p.precision=h,o;if(!(c<3&&Ot(o.d,s-n,m,c)))return Bt(o,p.precision=h,m,lt=!0);p.precision=s+=10,r=a=u=new p(1),f=0,c++}o=u}}function Ht(e,t){var r,n,i,a,o,u,s,c,f,l,p,m=1,h=e,d=h.d,v=h.constructor,y=v.rounding,g=v.precision;if(h.s<0||!d||!d[0]||!h.e&&1==d[0]&&1==d.length)return new v(d&&!d[0]?-1/0:1!=h.s?NaN:d?0:h);if(null==t?(lt=!1,f=g):f=t,v.precision=f+=10,n=(r=Mt(d)).charAt(0),!(Math.abs(a=h.e)<15e14))return c=zt(v,f+2,g).times(a+""),h=Ht(new v(n+"."+r.slice(1)),f-10).plus(c),v.precision=g,null==t?Bt(h,g,y,lt=!0):h;for(;n<7&&1!=n||1==n&&r.charAt(1)>3;)n=(r=Mt((h=h.times(e)).d)).charAt(0),m++;for(a=h.e,n>1?(h=new v("0."+r),a++):h=new v(n+"."+r.slice(1)),l=h,s=o=h=_t(h.minus(1),h.plus(1),f,1),p=Bt(h.times(h),f,1),i=3;;){if(o=Bt(o.times(p),f,1),Mt((c=s.plus(_t(o,new v(i),f,1))).d).slice(0,f)===Mt(s.d).slice(0,f)){if(s=s.times(2),0!==a&&(s=s.plus(zt(v,f+2,g).times(a+""))),s=_t(s,new v(m),f,1),null!=t)return v.precision=g,s;if(!Ot(s.d,f-10,y,u))return Bt(s,v.precision=g,y,lt=!0);v.precision=f+=10,c=o=h=_t(l.minus(1),l.plus(1),f,1),p=Bt(h.times(h),f,1),i=u=1}s=c,i+=2}}function Gt(e){return String(e.s*e.s/0)}function Vt(e,t){var r,n,i;for((r=t.indexOf("."))>-1&&(t=t.replace(".","")),(n=t.search(/e/i))>0?(r<0&&(r=n),r+=+t.slice(n+1),t=t.substring(0,n)):r<0&&(r=t.length),n=0;48===t.charCodeAt(n);n++);for(i=t.length;48===t.charCodeAt(i-1);--i);if(t=t.slice(n,i)){if(i-=n,e.e=r=r-n-1,e.d=[],n=(r+1)%Et,r<0&&(n+=Et),n<i){for(n&&e.d.push(+t.slice(0,n)),i-=Et;n<i;)e.d.push(+t.slice(n,n+=Et));t=t.slice(n),n=Et-t.length}else n-=i;for(;n--;)t+="0";e.d.push(+t),lt&&(e.e>e.constructor.maxE?(e.d=null,e.e=NaN):e.e<e.constructor.minE&&(e.e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function Zt(e,t){var r,n,i,a,o,u,s,c,f;if(t.indexOf("_")>-1){if(t=t.replace(/(\d)_(?=\d)/g,"$1"),Dt.test(t))return Vt(e,t)}else if("Infinity"===t||"NaN"===t)return+t||(e.s=NaN),e.e=NaN,e.d=null,e;if(bt.test(t))r=16,t=t.toLowerCase();else if(xt.test(t))r=2;else{if(!wt.test(t))throw Error(mt+t);r=8}for((a=t.search(/p/i))>0?(s=+t.slice(a+1),t=t.substring(2,a)):t=t.slice(2),o=(a=t.indexOf("."))>=0,n=e.constructor,o&&(a=(u=(t=t.replace(".","")).length)-a,i=Pt(n,new n(r),a,2*a)),a=f=(c=Tt(t,r,Nt)).length-1;0===c[a];--a)c.pop();return a<0?new n(0*e.s):(e.e=It(c,f),e.d=c,lt=!1,o&&(e=_t(e,i,4*u)),s&&(e=e.times(Math.abs(s)<54?gt(2,s):jr.pow(2,s))),lt=!0,e)}function Wt(e,t,r,n,i){var a,o,u,s,c=e.precision,f=Math.ceil(c/Et);for(lt=!1,s=r.times(r),u=new e(n);;){if(o=_t(u.times(s),new e(t++*t++),c,1),u=i?n.plus(o):n.minus(o),n=_t(o.times(s),new e(t++*t++),c,1),void 0!==(o=u.plus(n)).d[f]){for(a=f;o.d[a]===u.d[a]&&a--;);if(-1==a)break}a=u,u=n,n=o,o=a}return lt=!0,o.d.length=f+1,o}function Yt(e,t){for(var r=e;--t;)r*=e;return r}function Jt(e,t){var r,n=t.s<0,i=Rt(e,e.precision,1),a=i.times(.5);if((t=t.abs()).lte(a))return nt=n?4:1,t;if((r=t.divToInt(i)).isZero())nt=n?3:2;else{if((t=t.minus(r.times(i))).lte(a))return nt=Lt(r)?n?2:3:n?4:1,t;nt=Lt(r)?n?1:4:n?3:2}return t.minus(i).abs()}function Xt(e,t,r,n){var i,a,o,u,s,c,f,l,p,m=e.constructor,h=void 0!==r;if(h?(Ft(r,1,ot),void 0===n?n=m.rounding:Ft(n,0,8)):(r=m.precision,n=m.rounding),e.isFinite()){for(h?(i=2,16==t?r=4*r-3:8==t&&(r=3*r-2)):i=t,(o=(f=kt(e)).indexOf("."))>=0&&(f=f.replace(".",""),(p=new m(1)).e=f.length-o,p.d=Tt(kt(p),10,i),p.e=p.d.length),a=s=(l=Tt(f,10,i)).length;0==l[--s];)l.pop();if(l[0]){if(o<0?a--:((e=new m(e)).d=l,e.e=a,l=(e=_t(e,p,r,n,0,i)).d,a=e.e,c=rt),o=l[r],u=i/2,c=c||void 0!==l[r+1],c=n<4?(void 0!==o||c)&&(0===n||n===(e.s<0?3:2)):o>u||o===u&&(4===n||c||6===n&&1&l[r-1]||n===(e.s<0?8:7)),l.length=r,c)for(;++l[--r]>i-1;)l[r]=0,r||(++a,l.unshift(1));for(s=l.length;!l[s-1];--s);for(o=0,f="";o<s;o++)f+=ut.charAt(l[o]);if(h){if(s>1)if(16==t||8==t){for(o=16==t?4:3,--s;s%o;s++)f+="0";for(s=(l=Tt(f,i,t)).length;!l[s-1];--s);for(o=1,f="1.";o<s;o++)f+=ut.charAt(l[o])}else f=f.charAt(0)+"."+f.slice(1);f=f+(a<0?"p":"p+")+a}else if(a<0){for(;++a;)f="0"+f;f="0."+f}else if(++a>s)for(a-=s;a--;)f+="0";else a<s&&(f=f.slice(0,a)+"."+f.slice(a))}else f=h?"0p+0":"0";f=(16==t?"0x":2==t?"0b":8==t?"0o":"")+f}else f=Gt(e);return e.s<0?"-"+f:f}function Qt(e,t){if(e.length>t)return e.length=t,!0}function Kt(e){return new this(e).abs()}function er(e){return new this(e).acos()}function tr(e){return new this(e).acosh()}function rr(e,t){return new this(e).plus(t)}function nr(e){return new this(e).asin()}function ir(e){return new this(e).asinh()}function ar(e){return new this(e).atan()}function or(e){return new this(e).atanh()}function ur(e,t){e=new this(e),t=new this(t);var r,n=this.precision,i=this.rounding,a=n+4;return e.s&&t.s?e.d||t.d?!t.d||e.isZero()?(r=t.s<0?Rt(this,n,i):new this(0)).s=e.s:!e.d||t.isZero()?(r=Rt(this,a,1).times(.5)).s=e.s:t.s<0?(this.precision=a,this.rounding=1,r=this.atan(_t(e,t,a,1)),t=Rt(this,a,1),this.precision=n,this.rounding=i,r=e.s<0?r.minus(t):r.plus(t)):r=this.atan(_t(e,t,a,1)):(r=Rt(this,a,1).times(t.s>0?.25:.75)).s=e.s:r=new this(NaN),r}function sr(e){return new this(e).cbrt()}function cr(e){return Bt(e=new this(e),e.e+1,2)}function fr(e,t,r){return new this(e).clamp(t,r)}function lr(e){if(!e||"object"!=typeof e)throw Error(pt+"Object expected");var t,r,n,i=!0===e.defaults,a=["precision",1,ot,"rounding",0,8,"toExpNeg",-at,0,"toExpPos",0,at,"maxE",0,at,"minE",-at,0,"modulo",0,9];for(t=0;t<a.length;t+=3)if(r=a[t],i&&(this[r]=ft[r]),void 0!==(n=e[r])){if(!(yt(n)===n&&n>=a[t+1]&&n<=a[t+2]))throw Error(mt+r+": "+n);this[r]=n}if(r="crypto",i&&(this[r]=ft[r]),void 0!==(n=e[r])){if(!0!==n&&!1!==n&&0!==n&&1!==n)throw Error(mt+r+": "+n);if(n){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw Error(dt);this[r]=!0}else this[r]=!1}return this}function pr(e){return new this(e).cos()}function mr(e){return new this(e).cosh()}function hr(e,t){return new this(e).div(t)}function dr(e){return new this(e).exp()}function vr(e){return Bt(e=new this(e),e.e+1,3)}function yr(){var e,t,r=new this(0);for(lt=!1,e=0;e<arguments.length;)if((t=new this(arguments[e++])).d)r.d&&(r=r.plus(t.times(t)));else{if(t.s)return lt=!0,new this(1/0);r=t}return lt=!0,r.sqrt()}function gr(e){return e instanceof jr||e&&e.toStringTag===vt||!1}function xr(e){return new this(e).ln()}function br(e,t){return new this(e).log(t)}function wr(e){return new this(e).log(2)}function Dr(e){return new this(e).log(10)}function Nr(){return Ut(this,arguments,"lt")}function Er(){return Ut(this,arguments,"gt")}function Ar(e,t){return new this(e).mod(t)}function Sr(e,t){return new this(e).mul(t)}function Cr(e,t){return new this(e).pow(t)}function Mr(e){var t,r,n,i,a=0,o=new this(1),u=[];if(void 0===e?e=this.precision:Ft(e,1,ot),n=Math.ceil(e/Et),this.crypto)if(crypto.getRandomValues)for(t=crypto.getRandomValues(new Uint32Array(n));a<n;)(i=t[a])>=429e7?t[a]=crypto.getRandomValues(new Uint32Array(1))[0]:u[a++]=i%1e7;else{if(!crypto.randomBytes)throw Error(dt);for(t=crypto.randomBytes(n*=4);a<n;)(i=t[a]+(t[a+1]<<8)+(t[a+2]<<16)+((127&t[a+3])<<24))>=214e7?crypto.randomBytes(4).copy(t,a):(u.push(i%1e7),a+=4);a=n/4}else for(;a<n;)u[a++]=1e7*Math.random()|0;for(n=u[--a],e%=Et,n&&e&&(i=gt(10,Et-e),u[a]=(n/i|0)*i);0===u[a];a--)u.pop();if(a<0)r=0,u=[0];else{for(r=-1;0===u[0];r-=Et)u.shift();for(n=1,i=u[0];i>=10;i/=10)n++;n<Et&&(r-=Et-n)}return o.e=r,o.d=u,o}function Fr(e){return Bt(e=new this(e),e.e+1,this.rounding)}function Or(e){return(e=new this(e)).d?e.d[0]?e.s:0*e.s:e.s||NaN}function Tr(e){return new this(e).sin()}function _r(e){return new this(e).sinh()}function Br(e){return new this(e).sqrt()}function kr(e,t){return new this(e).sub(t)}function Ir(){var e=0,t=arguments,r=new this(t[e]);for(lt=!1;r.s&&++e<t.length;)r=r.plus(t[e]);return lt=!0,Bt(r,this.precision,this.rounding)}function zr(e){return new this(e).tan()}function Rr(e){return new this(e).tanh()}function qr(e){return Bt(e=new this(e),e.e+1,1)}Ct[Symbol.for("nodejs.util.inspect.custom")]=Ct.toString,Ct[Symbol.toStringTag]="Decimal";var jr=Ct.constructor=function e(t){var r,n,i;function a(e){var t,r,n,i=this;if(!(i instanceof a))return new a(e);if(i.constructor=a,gr(e))return i.s=e.s,void(lt?!e.d||e.e>a.maxE?(i.e=NaN,i.d=null):e.e<a.minE?(i.e=0,i.d=[0]):(i.e=e.e,i.d=e.d.slice()):(i.e=e.e,i.d=e.d?e.d.slice():e.d));if("number"==(n=typeof e)){if(0===e)return i.s=1/e<0?-1:1,i.e=0,void(i.d=[0]);if(e<0?(e=-e,i.s=-1):i.s=1,e===~~e&&e<1e7){for(t=0,r=e;r>=10;r/=10)t++;return void(lt?t>a.maxE?(i.e=NaN,i.d=null):t<a.minE?(i.e=0,i.d=[0]):(i.e=t,i.d=[e]):(i.e=t,i.d=[e]))}return 0*e!=0?(e||(i.s=NaN),i.e=NaN,void(i.d=null)):Vt(i,e.toString())}if("string"!==n)throw Error(mt+e);return 45===(r=e.charCodeAt(0))?(e=e.slice(1),i.s=-1):(43===r&&(e=e.slice(1)),i.s=1),Dt.test(e)?Vt(i,e):Zt(i,e)}if(a.prototype=Ct,a.ROUND_UP=0,a.ROUND_DOWN=1,a.ROUND_CEIL=2,a.ROUND_FLOOR=3,a.ROUND_HALF_UP=4,a.ROUND_HALF_DOWN=5,a.ROUND_HALF_EVEN=6,a.ROUND_HALF_CEIL=7,a.ROUND_HALF_FLOOR=8,a.EUCLID=9,a.config=a.set=lr,a.clone=e,a.isDecimal=gr,a.abs=Kt,a.acos=er,a.acosh=tr,a.add=rr,a.asin=nr,a.asinh=ir,a.atan=ar,a.atanh=or,a.atan2=ur,a.cbrt=sr,a.ceil=cr,a.clamp=fr,a.cos=pr,a.cosh=mr,a.div=hr,a.exp=dr,a.floor=vr,a.hypot=yr,a.ln=xr,a.log=br,a.log10=Dr,a.log2=wr,a.max=Nr,a.min=Er,a.mod=Ar,a.mul=Sr,a.pow=Cr,a.random=Mr,a.round=Fr,a.sign=Or,a.sin=Tr,a.sinh=_r,a.sqrt=Br,a.sub=kr,a.sum=Ir,a.tan=zr,a.tanh=Rr,a.trunc=qr,void 0===t&&(t={}),t&&!0!==t.defaults)for(i=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],r=0;r<i.length;)t.hasOwnProperty(n=i[r++])||(t[n]=this[n]);return a.config(t),a}(ft);st=new jr(st),ct=new jr(ct);const Pr=jr;var Lr=Se("BigNumber",["?on","config"],(function(e){var t=e.on,r=e.config,n=Pr.clone({precision:r.precision,modulo:Pr.EUCLID});return n.prototype=Object.create(n.prototype),n.prototype.type="BigNumber",n.prototype.isBigNumber=!0,n.prototype.toJSON=function(){return{mathjs:"BigNumber",value:this.toString()}},n.fromJSON=function(e){return new n(e.value)},t&&t("config",(function(e,t){e.precision!==t.precision&&n.config({precision:e.precision})})),n}),{isClass:!0}),Ur=r(5716),$r=Se("Complex",[],(function(){return Object.defineProperty(Ur,"name",{value:"Complex"}),Ur.prototype.constructor=Ur,Ur.prototype.type="Complex",Ur.prototype.isComplex=!0,Ur.prototype.toJSON=function(){return{mathjs:"Complex",re:this.re,im:this.im}},Ur.prototype.toPolar=function(){return{r:this.abs(),phi:this.arg()}},Ur.prototype.format=function(e){var t=this.im,r=this.re,n=ee(this.re,e),a=ee(this.im,e),o=i(e)?e:e?e.precision:null;if(null!==o){var u=Math.pow(10,-o);Math.abs(r/t)<u&&(r=0),Math.abs(t/r)<u&&(t=0)}return 0===t?n:0===r?1===t?"i":-1===t?"-i":a+"i":t<0?-1===t?n+" - i":n+" - "+a.substring(1)+"i":1===t?n+" + i":n+" + "+a+"i"},Ur.fromPolar=function(e){switch(arguments.length){case 1:var r=arguments[0];if("object"===t(r))return Ur(r);throw new TypeError("Input has to be an object with r and phi keys.");case 2:var n=arguments[0],a=arguments[1];if(i(n)){if(s(a)&&a.hasBase("ANGLE")&&(a=a.toNumber("rad")),i(a))return new Ur({r:n,phi:a});throw new TypeError("Phi is not a number nor an angle unit.")}throw new TypeError("Radius r is not a number.");default:throw new SyntaxError("Wrong number of arguments in function fromPolar")}},Ur.prototype.valueOf=Ur.prototype.toString,Ur.fromJSON=function(e){return new Ur(e)},Ur.compare=function(e,t){return e.re>t.re?1:e.re<t.re?-1:e.im>t.im?1:e.im<t.im?-1:0},Ur}),{isClass:!0}),Hr=r(3996),Gr=Se("Fraction",[],(function(){return Object.defineProperty(Hr,"name",{value:"Fraction"}),Hr.prototype.constructor=Hr,Hr.prototype.type="Fraction",Hr.prototype.isFraction=!0,Hr.prototype.toJSON=function(){return{mathjs:"Fraction",n:this.s*this.n,d:this.d}},Hr.fromJSON=function(e){return new Hr(e)},Hr}),{isClass:!0}),Vr=(r(3362),Se("Range",[],(function(){function e(t,r,n){if(!(this instanceof e))throw new SyntaxError("Constructor must be called with the new operator");var i=null!=t,o=null!=r,u=null!=n;if(i)if(a(t))t=t.toNumber();else if("number"!=typeof t)throw new TypeError("Parameter start must be a number");if(o)if(a(r))r=r.toNumber();else if("number"!=typeof r)throw new TypeError("Parameter end must be a number");if(u)if(a(n))n=n.toNumber();else if("number"!=typeof n)throw new TypeError("Parameter step must be a number");this.start=i?parseFloat(t):0,this.end=o?parseFloat(r):0,this.step=u?parseFloat(n):1}return e.prototype.type="Range",e.prototype.isRange=!0,e.parse=function(t){if("string"!=typeof t)return null;var r=t.split(":").map((function(e){return parseFloat(e)}));if(r.some((function(e){return isNaN(e)})))return null;switch(r.length){case 2:return new e(r[0],r[1]);case 3:return new e(r[0],r[2],r[1]);default:return null}},e.prototype.clone=function(){return new e(this.start,this.end,this.step)},e.prototype.size=function(){var e=0,t=this.start,r=this.step,n=this.end-t;return Z(r)===Z(n)?e=Math.ceil(n/r):0===n&&(e=0),isNaN(e)&&(e=0),[e]},e.prototype.min=function(){var e=this.size()[0];return e>0?this.step>0?this.start:this.start+(e-1)*this.step:void 0},e.prototype.max=function(){var e=this.size()[0];return e>0?this.step>0?this.start+(e-1)*this.step:this.start:void 0},e.prototype.forEach=function(e){var t=this.start,r=this.step,n=this.end,i=0;if(r>0)for(;t<n;)e(t,[i],this),t+=r,i++;else if(r<0)for(;t>n;)e(t,[i],this),t+=r,i++},e.prototype.map=function(e){var t=[];return this.forEach((function(r,n,i){t[n[0]]=e(r,n,i)})),t},e.prototype.toArray=function(){var e=[];return this.forEach((function(t,r){e[r[0]]=t})),e},e.prototype.valueOf=function(){return this.toArray()},e.prototype.format=function(e){var t=ee(this.start,e);return 1!==this.step&&(t+=":"+ee(this.step,e)),t+":"+ee(this.end,e)},e.prototype.toString=function(){return this.format()},e.prototype.toJSON=function(){return{mathjs:"Range",start:this.start,end:this.end,step:this.step}},e.fromJSON=function(t){return new e(t.start,t.end,t.step)},e}),{isClass:!0})),Zr=Se("Matrix",[],(function(){function e(){if(!(this instanceof e))throw new SyntaxError("Constructor must be called with the new operator")}return e.prototype.type="Matrix",e.prototype.isMatrix=!0,e.prototype.storage=function(){throw new Error("Cannot invoke storage on a Matrix interface")},e.prototype.datatype=function(){throw new Error("Cannot invoke datatype on a Matrix interface")},e.prototype.create=function(e,t){throw new Error("Cannot invoke create on a Matrix interface")},e.prototype.subset=function(e,t,r){throw new Error("Cannot invoke subset on a Matrix interface")},e.prototype.get=function(e){throw new Error("Cannot invoke get on a Matrix interface")},e.prototype.set=function(e,t,r){throw new Error("Cannot invoke set on a Matrix interface")},e.prototype.resize=function(e,t){throw new Error("Cannot invoke resize on a Matrix interface")},e.prototype.reshape=function(e,t){throw new Error("Cannot invoke reshape on a Matrix interface")},e.prototype.clone=function(){throw new Error("Cannot invoke clone on a Matrix interface")},e.prototype.size=function(){throw new Error("Cannot invoke size on a Matrix interface")},e.prototype.map=function(e,t){throw new Error("Cannot invoke map on a Matrix interface")},e.prototype.forEach=function(e){throw new Error("Cannot invoke forEach on a Matrix interface")},e.prototype[Symbol.iterator]=function(){throw new Error("Cannot iterate a Matrix interface")},e.prototype.toArray=function(){throw new Error("Cannot invoke toArray on a Matrix interface")},e.prototype.valueOf=function(){throw new Error("Cannot invoke valueOf on a Matrix interface")},e.prototype.format=function(e){throw new Error("Cannot invoke format on a Matrix interface")},e.prototype.toString=function(){throw new Error("Cannot invoke toString on a Matrix interface")},e}),{isClass:!0}),Wr=r(4756);function Yr(){return Yr=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},Yr.apply(this,arguments)}function Jr(e,t,r){var n=new(0,e.constructor)(2),i="";if(r){if(r<1)throw new Error("size must be in greater than 0");if(!V(r))throw new Error("size must be an integer");if(e.greaterThan(n.pow(r-1).sub(1))||e.lessThan(n.pow(r-1).mul(-1)))throw new Error("Value must be in range [-2^".concat(r-1,", 2^").concat(r-1,"-1]"));if(!e.isInteger())throw new Error("Value must be an integer");e.lessThan(0)&&(e=e.add(n.pow(r))),i="i".concat(r)}switch(t){case 2:return"".concat(e.toBinary()).concat(i);case 8:return"".concat(e.toOctal()).concat(i);case 16:return"".concat(e.toHexadecimal()).concat(i);default:throw new Error("Base ".concat(t," not supported "))}}function Xr(e,t){return void 0!==t?e.toExponential(t-1):e.toExponential()}function Qr(e,t){return i(e)?e:a(e)?e.toNumber():t}function Kr(e,t){var r=e.length-t.length,n=e.length;return e.substring(r,n)===t}function en(e,r){var n=function(e,r){return"number"==typeof e?ee(e,r):a(e)?function(e,t){if("function"==typeof t)return t(e);if(!e.isFinite())return e.isNaN()?"NaN":e.gt(0)?"Infinity":"-Infinity";var r=te(t),n=r.notation,i=r.precision,a=r.wordSize;switch(n){case"fixed":return function(e,t){return e.toFixed(t)}(e,i);case"exponential":return Xr(e,i);case"engineering":return function(e,t){var r=e.e,n=r%3==0?r:r<0?r-3-r%3:r-r%3,i=e.mul(Math.pow(10,-n)).toPrecision(t);return-1!==i.indexOf("e")&&(i=new(0,e.constructor)(i).toFixed()),i+"e"+(r>=0?"+":"")+n.toString()}(e,i);case"bin":return Jr(e,2,a);case"oct":return Jr(e,8,a);case"hex":return Jr(e,16,a);case"auto":var o=Qr(null==t?void 0:t.lowerExp,-3),u=Qr(null==t?void 0:t.upperExp,5);if(e.isZero())return"0";var s=e.toSignificantDigits(i),c=s.e;return(c>=o&&c<u?s.toFixed():Xr(e,i)).replace(/((\.\d*?)(0+))($|e)/,(function(){var e=arguments[2],t=arguments[4];return"."!==e?e+t:t}));default:throw new Error('Unknown notation "'+n+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}(e,r):function(e){return e&&"object"===t(e)&&"number"==typeof e.s&&"number"==typeof e.n&&"number"==typeof e.d||!1}(e)?r&&"decimal"===r.fraction?e.toString():e.s*e.n+"/"+e.d:Array.isArray(e)?an(e,r):c(e)?tn(e):"function"==typeof e?e.syntax?String(e.syntax):"function":e&&"object"===t(e)?"function"==typeof e.format?e.format(r):e&&e.toString(r)!=={}.toString()?e.toString(r):"{"+Object.keys(e).map((function(t){return tn(t)+": "+en(e[t],r)})).join(", ")+"}":String(e)}(e,r);return r&&"object"===t(r)&&"truncate"in r&&n.length>r.truncate?n.substring(0,r.truncate-3)+"...":n}function tn(e){for(var t=String(e),r="",n=0;n<t.length;){var i=t.charAt(n);r+=i in rn?rn[i]:i,n++}return'"'+r+'"'}r(2712),r(3771),r(9868),r(630),r(8718);var rn={'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"};function nn(e){var t=String(e);return t.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function an(e,t){if(Array.isArray(e)){for(var r="[",n=e.length,i=0;i<n;i++)0!==i&&(r+=", "),r+=an(e[i],t);return r+"]"}return en(e,t)}function on(e,t){if(!c(e))throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: "+H(e)+", index: 0)");if(!c(t))throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: "+H(t)+", index: 1)");return e===t?0:e>t?1:-1}function un(e,t,r){if(!(this instanceof un))throw new SyntaxError("Constructor must be called with the new operator");this.actual=e,this.expected=t,this.relation=r,this.message="Dimension mismatch ("+(Array.isArray(e)?"["+e.join(", ")+"]":e)+" "+(this.relation||"!=")+" "+(Array.isArray(t)?"["+t.join(", ")+"]":t)+")",this.stack=(new Error).stack}function sn(e,t,r){if(!(this instanceof sn))throw new SyntaxError("Constructor must be called with the new operator");this.index=e,arguments.length<3?(this.min=0,this.max=t):(this.min=t,this.max=r),void 0!==this.min&&this.index<this.min?this.message="Index out of range ("+this.index+" < "+this.min+")":void 0!==this.max&&this.index>=this.max?this.message="Index out of range ("+this.index+" > "+(this.max-1)+")":this.message="Index out of range ("+this.index+")",this.stack=(new Error).stack}function cn(e){for(var t=[];Array.isArray(e);)t.push(e.length),e=e[0];return t}function fn(e,t,r){var n,i=e.length;if(i!==t[r])throw new un(i,t[r]);if(r<t.length-1){var a=r+1;for(n=0;n<i;n++){var o=e[n];if(!Array.isArray(o))throw new un(t.length-1,t.length,"<");fn(e[n],t,a)}}else for(n=0;n<i;n++)if(Array.isArray(e[n]))throw new un(t.length+1,t.length,">")}function ln(e,t){if(0===t.length){if(Array.isArray(e))throw new un(e.length,0)}else fn(e,t,0)}function pn(e,t){var r=e.isMatrix?e._size:cn(e);t._sourceSize.forEach((function(e,t){if(null!==e&&e!==r[t])throw new un(e,r[t])}))}function mn(e,t){if(void 0!==e){if(!i(e)||!V(e))throw new TypeError("Index must be an integer (value: "+e+")");if(e<0||"number"==typeof t&&e>=t)throw new sn(e,t)}}function hn(e){for(var t=0;t<e._dimensions.length;++t){var r=e._dimensions[t];if(r._data&&f(r._data)){if(0===r._size[0])return!0}else if(r.isRange){if(r.start===r.end)return!0}else if(c(r)&&0===r.length)return!0}return!1}function dn(e,t,r){if(!Array.isArray(t))throw new TypeError("Array expected");if(0===t.length)throw new Error("Resizing to scalar is not supported");return t.forEach((function(e){if(!i(e)||!V(e)||e<0)throw new TypeError("Invalid size, must contain positive integers (size: "+en(t)+")")})),(i(e)||a(e))&&(e=[e]),vn(e,t,0,void 0!==r?r:0),e}function vn(e,t,r,n){var i,a,o=e.length,u=t[r],s=Math.min(o,u);if(e.length=u,r<t.length-1){var c=r+1;for(i=0;i<s;i++)a=e[i],Array.isArray(a)||(a=[a],e[i]=a),vn(a,t,c,n);for(i=s;i<u;i++)a=[],e[i]=a,vn(a,t,c,n)}else{for(i=0;i<s;i++)for(;Array.isArray(e[i]);)e[i]=e[i][0];for(i=s;i<u;i++)e[i]=n}}function yn(e,t){var r=En(e),n=r.length;if(!Array.isArray(e)||!Array.isArray(t))throw new TypeError("Array expected");if(0===t.length)throw new un(0,n,"!=");var i=xn(t=gn(t,n));if(n!==i)throw new un(i,n,"!=");try{return function(e,t){for(var r,n=e,i=t.length-1;i>0;i--){var a=t[i];r=[];for(var o=n.length/a,u=0;u<o;u++)r.push(n.slice(u*a,(u+1)*a));n=r}return n}(r,t)}catch(e){if(e instanceof un)throw new un(i,n,"!=");throw e}}function gn(e,t){var r=xn(e),n=e.slice(),i=e.indexOf(-1);if(e.indexOf(-1,i+1)>=0)throw new Error("More than one wildcard in sizes");if(i>=0){if(t%r!=0)throw new Error("Could not replace wildcard, since "+t+" is no multiple of "+-r);n[i]=-t/r}return n}function xn(e){return e.reduce((function(e,t){return e*t}),1)}function bn(e,t){for(var r=t||cn(e);Array.isArray(e)&&1===e.length;)e=e[0],r.shift();for(var n=r.length;1===r[n-1];)n--;return n<r.length&&(e=wn(e,n,0),r.length=n),e}function wn(e,t,r){var n,i;if(r<t){var a=r+1;for(n=0,i=e.length;n<i;n++)e[n]=wn(e[n],t,a)}else for(;Array.isArray(e);)e=e[0];return e}function Dn(e,t,r,n){var i=n||cn(e);if(r)for(var a=0;a<r;a++)e=[e],i.unshift(1);for(e=Nn(e,t,0);i.length<t;)i.push(1);return e}function Nn(e,t,r){var n,i;if(Array.isArray(e)){var a=r+1;for(n=0,i=e.length;n<i;n++)e[n]=Nn(e[n],t,a)}else for(var o=r;o<t;o++)e=[e];return e}function En(e){if(!Array.isArray(e))return e;var t=[];return e.forEach((function e(r){Array.isArray(r)?r.forEach(e):t.push(r)})),t}function An(e,t){return Array.prototype.map.call(e,t)}function Sn(e,t){Array.prototype.forEach.call(e,t)}function Cn(e,t){if(1!==cn(e).length)throw new Error("Only one dimensional matrices supported");return Array.prototype.filter.call(e,t)}function Mn(e,t){if(1!==cn(e).length)throw new Error("Only one dimensional matrices supported");return Array.prototype.filter.call(e,(function(e){return t.test(e)}))}function Fn(e,t){return Array.prototype.join.call(e,t)}function On(e){if(!Array.isArray(e))throw new TypeError("Array input expected");if(0===e.length)return e;var t=[],r=0;t[0]={value:e[0],identifier:0};for(var n=1;n<e.length;n++)e[n]===e[n-1]?r++:r=0,t.push({value:e[n],identifier:r});return t}function Tn(e){if(!Array.isArray(e))throw new TypeError("Array input expected");if(0===e.length)return e;for(var t=[],r=0;r<e.length;r++)t.push(e[r].value);return t}function _n(e,t){for(var r,n=0,i=0;i<e.length;i++){var a=e[i],o=Array.isArray(a);if(0===i&&o&&(n=a.length),o&&a.length!==n)return;var u=o?_n(a,t):t(a);if(void 0===r)r=u;else if(r!==u)return"mixed"}return r}function Bn(e,t){return-1!==e.indexOf(t)}function kn(e,t,r,n){if(n<r){if(e.length!==t.length)throw new un(e.length,t.length);for(var i=[],a=0;a<e.length;a++)i[a]=kn(e[a],t[a],r,n+1);return i}return e.concat(t)}function In(){var e=Array.prototype.slice.call(arguments,0,-1),t=Array.prototype.slice.call(arguments,-1);if(1===e.length)return e[0];if(e.length>1)return e.slice(1).reduce((function(e,r){return kn(e,r,t,0)}),e[0]);throw new Error("Wrong number of arguments in function concat")}function zn(e,t){for(var r=t.length,n=e.length,i=0;i<n;i++){var a=r-n+i;if(e[i]<t[a]&&e[i]>1||e[i]>t[a])throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(e,") not possible to broadcast dimension ").concat(n," with size ").concat(e[i]," to size ").concat(t[a]))}}function Rn(e,t){var r=cn(e);if(we(r,t))return e;zn(r,t);var n,i,a,o=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];for(var n=t.map((function(e){return e.length})),i=Math.max.apply(Math,Te(n)),a=new Array(i).fill(null),o=0;o<t.length;o++)for(var u=t[o],s=n[o],c=0;c<s;c++){var f=i-s+c;u[c]>a[f]&&(a[f]=u[c])}for(var l=0;l<t.length;l++)zn(t[l],a);return a}(r,t),u=o.length,s=[].concat(Te(Array(u-r.length).fill(1)),Te(r)),c=function(e){return Yr([],e)}(e);r.length<u&&(r=cn(c=yn(c,s)));for(var f=0;f<u;f++)r[f]<o[f]&&(n=c,i=o[f],a=f,r=cn(c=In.apply(void 0,Te(Array(i).fill(n)).concat([a]))));return c}function qn(e){var t=0,r=1,n=Object.create(null),i=Object.create(null),a=0,o=function(e){var o=i[e];if(o&&(delete n[o],delete i[e],--t,r===o)){if(!t)return a=0,void(r=1);for(;!Object.prototype.hasOwnProperty.call(n,++r););}};return e=Math.abs(e),{hit:function(u){var s=i[u],c=++a;if(n[c]=u,i[u]=c,!s){if(++t<=e)return;return u=n[r],o(u),u}if(delete n[s],r===s)for(;!Object.prototype.hasOwnProperty.call(n,++r););},delete:o,clear:function(){t=a=0,r=1,n=Object.create(null),i=Object.create(null)}}}function jn(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=r.hasher,i=r.limit;return i=null==i?Number.POSITIVE_INFINITY:i,n=null==n?JSON.stringify:n,function r(){"object"!==t(r.cache)&&(r.cache={values:new Map,lru:qn(i||Number.POSITIVE_INFINITY)});for(var a=[],o=0;o<arguments.length;o++)a[o]=arguments[o];var u=n(a);if(r.cache.values.has(u))return r.cache.lru.hit(u),r.cache.values.get(u);var s=e.apply(e,a);return r.cache.values.set(u,s),r.cache.values.delete(r.cache.lru.hit(u)),s}}function Pn(e){return Object.keys(e.signatures||{}).reduce((function(e,t){var r=(t.match(/,/g)||[]).length+1;return Math.max(e,r)}),-1)}function Ln(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}un.prototype=new RangeError,un.prototype.constructor=RangeError,un.prototype.name="DimensionError",un.prototype.isDimensionError=!0,sn.prototype=new RangeError,sn.prototype.constructor=RangeError,sn.prototype.name="IndexError",sn.prototype.isIndexError=!0,r(3110);var Un=Se("DenseMatrix",["Matrix"],(function(e){var t=e.Matrix;function r(e,t){if(!(this instanceof r))throw new SyntaxError("Constructor must be called with the new operator");if(t&&!c(t))throw new Error("Invalid datatype: "+t);if(l(e))"DenseMatrix"===e.type?(this._data=ye(e._data),this._size=ye(e._size),this._datatype=t||e._datatype):(this._data=e.toArray(),this._size=e.size(),this._datatype=t||e._datatype);else if(e&&f(e.data)&&f(e.size))this._data=e.data,this._size=e.size,ln(this._data,this._size),this._datatype=t||e.datatype;else if(f(e))this._data=m(e),this._size=cn(this._data),ln(this._data,this._size),this._datatype=t;else{if(e)throw new TypeError("Unsupported type of data ("+H(e)+")");this._data=[],this._size=[0],this._datatype=t}}function n(e,t,r,i){var a=i===r-1,o=t.dimension(i);return a?o.map((function(t){return mn(t,e.length),e[t]})).valueOf():o.map((function(a){return mn(a,e.length),n(e[a],t,r,i+1)})).valueOf()}function o(e,t,r,n,i){var a=i===n-1,u=t.dimension(i);a?u.forEach((function(t,n){mn(t),e[t]=r[n[0]]})):u.forEach((function(a,u){mn(a),o(e[a],t,r[u[0]],n,i+1)}))}function u(e,t,r){if(0===t.length){for(var n=e._data;f(n);)n=n[0];return n}return e._size=t.slice(0),e._data=dn(e._data,e._size,r),e}function s(e,t,r){for(var n=e._size.slice(0),i=!1;n.length<t.length;)n.push(0),i=!0;for(var a=0,o=t.length;a<o;a++)t[a]>n[a]&&(n[a]=t[a],i=!0);i&&u(e,n,r)}function m(e){return l(e)?m(e.valueOf()):f(e)?e.map(m):e}return r.prototype=new t,r.prototype.createDenseMatrix=function(e,t){return new r(e,t)},Object.defineProperty(r,"name",{value:"DenseMatrix"}),r.prototype.constructor=r,r.prototype.type="DenseMatrix",r.prototype.isDenseMatrix=!0,r.prototype.getDataType=function(){return _n(this._data,H)},r.prototype.storage=function(){return"dense"},r.prototype.datatype=function(){return this._datatype},r.prototype.create=function(e,t){return new r(e,t)},r.prototype.subset=function(e,t,i){switch(arguments.length){case 1:return function(e,t){if(!v(t))throw new TypeError("Invalid index");if(t.isScalar())return e.get(t.min());var i=t.size();if(i.length!==e._size.length)throw new un(i.length,e._size.length);for(var a=t.min(),o=t.max(),u=0,s=e._size.length;u<s;u++)mn(a[u],e._size[u]),mn(o[u],e._size[u]);return new r(n(e._data,t,i.length,0),e._datatype)}(this,e);case 2:case 3:return function(e,t,r,n){if(!t||!0!==t.isIndex)throw new TypeError("Invalid index");var i,a=t.size(),u=t.isScalar();if(l(r)?(i=r.size(),r=r.valueOf()):i=cn(r),u){if(0!==i.length)throw new TypeError("Scalar expected");e.set(t.min(),r,n)}else{if(!we(i,a))try{i=cn(r=0===i.length?Rn([r],a):Rn(r,a))}catch(e){}if(a.length<e._size.length)throw new un(a.length,e._size.length,"<");if(i.length<a.length){for(var c=0,f=0;1===a[c]&&1===i[c];)c++;for(;1===a[c];)f++,c++;r=Dn(r,a.length,f,i)}if(!we(a,i))throw new un(a,i,">");var p=t.max().map((function(e){return e+1}));s(e,p,n);var m=a.length;o(e._data,t,r,m,0)}return e}(this,e,t,i);default:throw new SyntaxError("Wrong number of arguments")}},r.prototype.get=function(e){if(!f(e))throw new TypeError("Array expected");if(e.length!==this._size.length)throw new un(e.length,this._size.length);for(var t=0;t<e.length;t++)mn(e[t],this._size[t]);for(var r=this._data,n=0,i=e.length;n<i;n++){var a=e[n];mn(a,r.length),r=r[a]}return r},r.prototype.set=function(e,t,r){if(!f(e))throw new TypeError("Array expected");if(e.length<this._size.length)throw new un(e.length,this._size.length,"<");var n,i,a,o=e.map((function(e){return e+1}));s(this,o,r);var u=this._data;for(n=0,i=e.length-1;n<i;n++)mn(a=e[n],u.length),u=u[a];return mn(a=e[e.length-1],u.length),u[a]=t,this},r.prototype.resize=function(e,t,r){if(!p(e))throw new TypeError("Array or Matrix expected");var n=e.valueOf().map((function(e){return Array.isArray(e)&&1===e.length?e[0]:e}));return u(r?this.clone():this,n,t)},r.prototype.reshape=function(e,t){var r=t?this.clone():this;r._data=yn(r._data,e);var n=r._size.reduce((function(e,t){return e*t}));return r._size=gn(e,n),r},r.prototype.clone=function(){return new r({data:ye(this._data),size:ye(this._size),datatype:this._datatype})},r.prototype.size=function(){return this._size.slice(0)},r.prototype.map=function(e){var t=this,n=Pn(e),i=function r(i,a){return f(i)?i.map((function(e,t){return r(e,a.concat(t))})):1===n?e(i):2===n?e(i,a):e(i,a,t)}(this._data,[]);return new r(i,void 0!==this._datatype?_n(i,H):void 0)},r.prototype.forEach=function(e){var t=this;!function r(n,i){f(n)?n.forEach((function(e,t){r(e,i.concat(t))})):e(n,i,t)}(this._data,[])},r.prototype[Symbol.iterator]=Wr.mark((function e(){var t;return Wr.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return t=Wr.mark((function e(t,r){var n;return Wr.wrap((function(i){for(;;)switch(i.prev=i.next){case 0:if(!f(t)){i.next=9;break}n=0;case 2:if(!(n<t.length)){i.next=7;break}return i.delegateYield(e(t[n],r.concat(n)),"t0",4);case 4:n++,i.next=2;break;case 7:i.next=11;break;case 9:return i.next=11,{value:t,index:r};case 11:case"end":return i.stop()}}),e)})),e.delegateYield(t(this._data,[]),"t0",2);case 2:case"end":return e.stop()}}),e,this)})),r.prototype.rows=function(){var e=[];if(2!==this.size().length)throw new TypeError("Rows can only be returned for a 2D matrix.");var t,n=function(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return Ln(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Ln(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,o=!0,u=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return o=e.done,e},e:function(e){u=!0,a=e},f:function(){try{o||null==r.return||r.return()}finally{if(u)throw a}}}}(this._data);try{for(n.s();!(t=n.n()).done;){var i=t.value;e.push(new r([i],this._datatype))}}catch(e){n.e(e)}finally{n.f()}return e},r.prototype.columns=function(){var e=this,t=[],n=this.size();if(2!==n.length)throw new TypeError("Rows can only be returned for a 2D matrix.");for(var i=this._data,a=function(n){var a=i.map((function(e){return[e[n]]}));t.push(new r(a,e._datatype))},o=0;o<n[1];o++)a(o);return t},r.prototype.toArray=function(){return ye(this._data)},r.prototype.valueOf=function(){return this._data},r.prototype.format=function(e){return en(this._data,e)},r.prototype.toString=function(){return en(this._data)},r.prototype.toJSON=function(){return{mathjs:"DenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},r.prototype.diagonal=function(e){if(e){if(a(e)&&(e=e.toNumber()),!i(e)||!V(e))throw new TypeError("The parameter k must be an integer number")}else e=0;for(var t=e>0?e:0,n=e<0?-e:0,o=this._size[0],u=this._size[1],s=Math.min(o-n,u-t),c=[],f=0;f<s;f++)c[f]=this._data[f+n][f+t];return new r({data:c,size:[s],datatype:this._datatype})},r.diagonal=function(e,t,n,o){if(!f(e))throw new TypeError("Array expected, size parameter");if(2!==e.length)throw new Error("Only two dimensions matrix are supported");if(e=e.map((function(e){if(a(e)&&(e=e.toNumber()),!i(e)||!V(e)||e<1)throw new Error("Size values must be positive integers");return e})),n){if(a(n)&&(n=n.toNumber()),!i(n)||!V(n))throw new TypeError("The parameter k must be an integer number")}else n=0;var u,s=n>0?n:0,c=n<0?-n:0,p=e[0],m=e[1],h=Math.min(p-c,m-s);if(f(t)){if(t.length!==h)throw new Error("Invalid value array length");u=function(e){return t[e]}}else if(l(t)){var d=t.size();if(1!==d.length||d[0]!==h)throw new Error("Invalid matrix length");u=function(e){return t.get([e])}}else u=function(){return t};o||(o=a(u(0))?u(0).mul(0):0);var v=[];if(e.length>0){v=dn(v,e,o);for(var y=0;y<h;y++)v[y+c][y+s]=u(y)}return new r({data:v,size:[p,m]})},r.fromJSON=function(e){return new r(e)},r.prototype.swapRows=function(e,t){if(!(i(e)&&V(e)&&i(t)&&V(t)))throw new Error("Row index must be positive integers");if(2!==this._size.length)throw new Error("Only two dimensional matrix is supported");return mn(e,this._size[0]),mn(t,this._size[0]),r._swapRows(e,t,this._data),this},r._swapRows=function(e,t,r){var n=r[e];r[e]=r[t],r[t]=n},r}),{isClass:!0}),$n="clone",Hn=Se($n,["typed"],(function(e){return(0,e.typed)($n,{any:ye})}));function Gn(e){var t,r,n=e.length,i=e[0].length,a=[];for(r=0;r<i;r++){var o=[];for(t=0;t<n;t++)o.push(e[t][r]);a.push(o)}return a}function Vn(e){for(var t=0;t<e.length;t++)if(p(e[t]))return!0;return!1}function Zn(e,t){l(e)&&(e=e.valueOf());for(var r=0,n=e.length;r<n;r++){var i=e[r];Array.isArray(i)?Zn(i,t):t(i)}}function Wn(e,t,r){return e&&"function"==typeof e.map?e.map((function(e){return Wn(e,t,r)})):t(e)}function Yn(e,t,r){var n=Array.isArray(e)?cn(e):e.size();if(t<0||t>=n.length)throw new sn(t,n.length);return l(e)?e.create(Jn(e.valueOf(),t,r)):Jn(e,t,r)}function Jn(e,t,r){var n,i,a,o;if(t<=0){if(Array.isArray(e[0])){for(o=Gn(e),i=[],n=0;n<o.length;n++)i[n]=Jn(o[n],t-1,r);return i}for(a=e[0],n=1;n<e.length;n++)a=r(a,e[n]);return a}for(i=[],n=0;n<e.length;n++)i[n]=Jn(e[n],t-1,r);return i}function Xn(e,t,r,n,i,a,o,u,s,c,f){var l,p,m,h,d=e._values,v=e._index,y=e._ptr;if(n)for(p=y[t],m=y[t+1],l=p;l<m;l++)r[h=v[l]]!==a?(r[h]=a,o.push(h),c?(n[h]=s?u(d[l],f):u(f,d[l]),i[h]=a):n[h]=d[l]):(n[h]=s?u(d[l],n[h]):u(n[h],d[l]),i[h]=a);else for(p=y[t],m=y[t+1],l=p;l<m;l++)r[h=v[l]]!==a?(r[h]=a,o.push(h)):i[h]=a}var Qn="isInteger",Kn=Se(Qn,["typed"],(function(e){var t=e.typed;return t(Qn,{number:V,BigNumber:function(e){return e.isInt()},Fraction:function(e){return 1===e.d&&isFinite(e.n)},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),ei=(r(113),r(150),"number");function ti(e){return e<0}function ri(e){return e>0}function ni(e){return 0===e}function ii(e){return Number.isNaN(e)}ti.signature=ei,ri.signature=ei,ni.signature=ei,ii.signature=ei;var ai="isNegative",oi=Se(ai,["typed"],(function(e){var t=e.typed;return t(ai,{number:ti,BigNumber:function(e){return e.isNeg()&&!e.isZero()&&!e.isNaN()},Fraction:function(e){return e.s<0},Unit:t.referToSelf((function(e){return function(r){return t.find(e,r.valueType())(r.value)}})),"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),ui="isNumeric",si=Se(ui,["typed"],(function(e){var t=e.typed;return t(ui,{"number | BigNumber | Fraction | boolean":function(){return!0},"Complex | Unit | string | null | undefined | Node":function(){return!1},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),ci=(r(2762),"hasNumericValue"),fi=Se(ci,["typed","isNumeric"],(function(e){var t=e.typed,r=e.isNumeric;return t(ci,{boolean:function(){return!0},string:function(e){return e.trim().length>0&&!isNaN(Number(e))},any:function(e){return r(e)}})})),li="isPositive",pi=Se(li,["typed"],(function(e){var t=e.typed;return t(li,{number:ri,BigNumber:function(e){return!e.isNeg()&&!e.isZero()&&!e.isNaN()},Fraction:function(e){return e.s>0&&e.n>0},Unit:t.referToSelf((function(e){return function(r){return t.find(e,r.valueType())(r.value)}})),"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),mi="isZero",hi=Se(mi,["typed"],(function(e){var t=e.typed;return t(mi,{number:ni,BigNumber:function(e){return e.isZero()},Complex:function(e){return 0===e.re&&0===e.im},Fraction:function(e){return 1===e.d&&0===e.n},Unit:t.referToSelf((function(e){return function(r){return t.find(e,r.valueType())(r.value)}})),"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),di="isNaN",vi=Se(di,["typed"],(function(e){var t=e.typed;return t(di,{number:ii,BigNumber:function(e){return e.isNaN()},Fraction:function(e){return!1},Complex:function(e){return e.isNaN()},Unit:function(e){return Number.isNaN(e.value)},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),yi="typeOf",gi=Se(yi,["typed"],(function(e){return(0,e.typed)(yi,{any:H})}));function xi(e,t,r){if(null==r)return e.eq(t);if(e.eq(t))return!0;if(e.isNaN()||t.isNaN())return!1;if(e.isFinite()&&t.isFinite()){var n=e.minus(t).abs();if(n.isZero())return!0;var i=e.constructor.max(e.abs(),t.abs());return n.lte(i.times(r))}return!1}var bi=Se("compareUnits",["typed"],(function(e){var t=e.typed;return{"Unit, Unit":t.referToSelf((function(e){return function(r,n){if(!r.equalBase(n))throw new Error("Cannot compare units with different base");return t.find(e,[r.valueType(),n.valueType()])(r.value,n.value)}}))}})),wi="equalScalar",Di=Se(wi,["typed","config"],(function(e){var t=e.typed,r=e.config,n=bi({typed:t});return t(wi,{"boolean, boolean":function(e,t){return e===t},"number, number":function(e,t){return se(e,t,r.epsilon)},"BigNumber, BigNumber":function(e,t){return e.eq(t)||xi(e,t,r.epsilon)},"Fraction, Fraction":function(e,t){return e.equals(t)},"Complex, Complex":function(e,t){return function(e,t,r){return se(e.re,t.re,r)&&se(e.im,t.im,r)}(e,t,r.epsilon)}},n)})),Ni=(Se(wi,["typed","config"],(function(e){var t=e.typed,r=e.config;return t(wi,{"number, number":function(e,t){return se(e,t,r.epsilon)}})})),Se("SparseMatrix",["typed","equalScalar","Matrix"],(function(e){var t=e.typed,r=e.equalScalar,n=e.Matrix;function o(e,t){if(!(this instanceof o))throw new SyntaxError("Constructor must be called with the new operator");if(t&&!c(t))throw new Error("Invalid datatype: "+t);if(l(e))!function(e,t,r){"SparseMatrix"===t.type?(e._values=t._values?ye(t._values):void 0,e._index=ye(t._index),e._ptr=ye(t._ptr),e._size=ye(t._size),e._datatype=r||t._datatype):u(e,t.valueOf(),r||t._datatype)}(this,e,t);else if(e&&f(e.index)&&f(e.ptr)&&f(e.size))this._values=e.values,this._index=e.index,this._ptr=e.ptr,this._size=e.size,this._datatype=t||e.datatype;else if(f(e))u(this,e,t);else{if(e)throw new TypeError("Unsupported type of data ("+H(e)+")");this._values=[],this._index=[],this._ptr=[0],this._size=[0,0],this._datatype=t}}function u(e,n,i){e._values=[],e._index=[],e._ptr=[],e._datatype=i;var a=n.length,o=0,u=r,s=0;if(c(i)&&(u=t.find(r,[i,i])||r,s=t.convert(0,i)),a>0){var l=0;do{e._ptr.push(e._index.length);for(var p=0;p<a;p++){var m=n[p];if(f(m)){if(0===l&&o<m.length&&(o=m.length),l<m.length){var h=m[l];u(h,s)||(e._values.push(h),e._index.push(p))}}else 0===l&&o<1&&(o=1),u(m,s)||(e._values.push(m),e._index.push(p))}l++}while(l<o)}e._ptr.push(e._index.length),e._size=[a,o]}function s(e,t,r,n){if(r-t==0)return r;for(var i=t;i<r;i++)if(n[i]===e)return i;return t}function m(e,t,r,n,i,a,o){i.splice(e,0,n),a.splice(e,0,t);for(var u=r+1;u<o.length;u++)o[u]++}function h(e,n,i,a){var o=a||0,u=r,s=0;c(e._datatype)&&(u=t.find(r,[e._datatype,e._datatype])||r,s=t.convert(0,e._datatype),o=t.convert(o,e._datatype));var f,l,p,m=!u(o,s),h=e._size[0],d=e._size[1];if(i>d){for(l=d;l<i;l++)if(e._ptr[l]=e._values.length,m)for(f=0;f<h;f++)e._values.push(o),e._index.push(f);e._ptr[i]=e._values.length}else i<d&&(e._ptr.splice(i+1,d-i),e._values.splice(e._ptr[i],e._values.length),e._index.splice(e._ptr[i],e._index.length));if(d=i,n>h){if(m){var v=0;for(l=0;l<d;l++){e._ptr[l]=e._ptr[l]+v,p=e._ptr[l+1]+v;var y=0;for(f=h;f<n;f++,y++)e._values.splice(p+y,0,o),e._index.splice(p+y,0,f),v++}e._ptr[d]=e._values.length}}else if(n<h){var g=0;for(l=0;l<d;l++){e._ptr[l]=e._ptr[l]-g;var x=e._ptr[l],b=e._ptr[l+1]-g;for(p=x;p<b;p++)(f=e._index[p])>n-1&&(e._values.splice(p,1),e._index.splice(p,1),g++)}e._ptr[l]=e._values.length}return e._size[0]=n,e._size[1]=i,e}function d(e,t,r,n,i){var a,o,u=n[0],s=n[1],c=[];for(a=0;a<u;a++)for(c[a]=[],o=0;o<s;o++)c[a][o]=0;for(o=0;o<s;o++)for(var f=r[o],l=r[o+1],p=f;p<l;p++)c[a=t[p]][o]=e?i?ye(e[p]):e[p]:1;return c}return o.prototype=new n,o.prototype.createSparseMatrix=function(e,t){return new o(e,t)},Object.defineProperty(o,"name",{value:"SparseMatrix"}),o.prototype.constructor=o,o.prototype.type="SparseMatrix",o.prototype.isSparseMatrix=!0,o.prototype.getDataType=function(){return _n(this._values,H)},o.prototype.storage=function(){return"sparse"},o.prototype.datatype=function(){return this._datatype},o.prototype.create=function(e,t){return new o(e,t)},o.prototype.density=function(){var e=this._size[0],t=this._size[1];return 0!==e&&0!==t?this._index.length/(e*t):0},o.prototype.subset=function(e,t,r){if(!this._values)throw new Error("Cannot invoke subset on a Pattern only matrix");switch(arguments.length){case 1:return function(e,t){if(!v(t))throw new TypeError("Invalid index");if(t.isScalar())return e.get(t.min());var r,n,i,a,u=t.size();if(u.length!==e._size.length)throw new un(u.length,e._size.length);var s=t.min(),c=t.max();for(r=0,n=e._size.length;r<n;r++)mn(s[r],e._size[r]),mn(c[r],e._size[r]);var f=e._values,l=e._index,p=e._ptr,m=t.dimension(0),h=t.dimension(1),d=[],y=[];m.forEach((function(e,t){y[e]=t[0],d[e]=!0}));var g=f?[]:void 0,x=[],b=[];return h.forEach((function(e){for(b.push(x.length),i=p[e],a=p[e+1];i<a;i++)r=l[i],!0===d[r]&&(x.push(y[r]),g&&g.push(f[i]))})),b.push(x.length),new o({values:g,index:x,ptr:b,size:u,datatype:e._datatype})}(this,e);case 2:case 3:return function(e,t,r,n){if(!t||!0!==t.isIndex)throw new TypeError("Invalid index");var i,a=t.size(),o=t.isScalar();if(l(r)?(i=r.size(),r=r.toArray()):i=cn(r),o){if(0!==i.length)throw new TypeError("Scalar expected");e.set(t.min(),r,n)}else{if(1!==a.length&&2!==a.length)throw new un(a.length,e._size.length,"<");if(i.length<a.length){for(var u=0,s=0;1===a[u]&&1===i[u];)u++;for(;1===a[u];)s++,u++;r=Dn(r,a.length,s,i)}if(!we(a,i))throw new un(a,i,">");if(1===a.length)t.dimension(0).forEach((function(t,i){mn(t),e.set([t,0],r[i[0]],n)}));else{var c=t.dimension(0),f=t.dimension(1);c.forEach((function(t,i){mn(t),f.forEach((function(a,o){mn(a),e.set([t,a],r[i[0]][o[0]],n)}))}))}}return e}(this,e,t,r);default:throw new SyntaxError("Wrong number of arguments")}},o.prototype.get=function(e){if(!f(e))throw new TypeError("Array expected");if(e.length!==this._size.length)throw new un(e.length,this._size.length);if(!this._values)throw new Error("Cannot invoke get on a Pattern only matrix");var t=e[0],r=e[1];mn(t,this._size[0]),mn(r,this._size[1]);var n=s(t,this._ptr[r],this._ptr[r+1],this._index);return n<this._ptr[r+1]&&this._index[n]===t?this._values[n]:0},o.prototype.set=function(e,n,i){if(!f(e))throw new TypeError("Array expected");if(e.length!==this._size.length)throw new un(e.length,this._size.length);if(!this._values)throw new Error("Cannot invoke set on a Pattern only matrix");var a=e[0],o=e[1],u=this._size[0],l=this._size[1],p=r,d=0;c(this._datatype)&&(p=t.find(r,[this._datatype,this._datatype])||r,d=t.convert(0,this._datatype)),(a>u-1||o>l-1)&&(h(this,Math.max(a+1,u),Math.max(o+1,l),i),u=this._size[0],l=this._size[1]),mn(a,u),mn(o,l);var v=s(a,this._ptr[o],this._ptr[o+1],this._index);return v<this._ptr[o+1]&&this._index[v]===a?p(n,d)?function(e,t,r,n,i){r.splice(e,1),n.splice(e,1);for(var a=t+1;a<i.length;a++)i[a]--}(v,o,this._values,this._index,this._ptr):this._values[v]=n:p(n,d)||m(v,a,o,n,this._values,this._index,this._ptr),this},o.prototype.resize=function(e,t,r){if(!p(e))throw new TypeError("Array or Matrix expected");var n=e.valueOf().map((function(e){return Array.isArray(e)&&1===e.length?e[0]:e}));if(2!==n.length)throw new Error("Only two dimensions matrix are supported");return n.forEach((function(e){if(!i(e)||!V(e)||e<0)throw new TypeError("Invalid size, must contain positive integers (size: "+en(n)+")")})),h(r?this.clone():this,n[0],n[1],t)},o.prototype.reshape=function(e,t){if(!f(e))throw new TypeError("Array expected");if(2!==e.length)throw new Error("Sparse matrices can only be reshaped in two dimensions");e.forEach((function(t){if(!i(t)||!V(t)||t<=-2||0===t)throw new TypeError("Invalid size, must contain positive integers or -1 (size: "+en(e)+")")}));var r=this._size[0]*this._size[1];if(r!==(e=gn(e,r))[0]*e[1])throw new Error("Reshaping sparse matrix will result in the wrong number of elements");var n=t?this.clone():this;if(this._size[0]===e[0]&&this._size[1]===e[1])return n;for(var a=[],o=0;o<n._ptr.length;o++)for(var u=0;u<n._ptr[o+1]-n._ptr[o];u++)a.push(o);for(var c=n._values.slice(),l=n._index.slice(),p=0;p<n._index.length;p++){var h=l[p],d=a[p],v=h*n._size[1]+d;a[p]=v%e[1],l[p]=Math.floor(v/e[1])}n._values.length=0,n._index.length=0,n._ptr.length=e[1]+1,n._size=e.slice();for(var y=0;y<n._ptr.length;y++)n._ptr[y]=0;for(var g=0;g<c.length;g++){var x=l[g],b=a[g],w=c[g];m(s(x,n._ptr[b],n._ptr[b+1],n._index),x,b,w,n._values,n._index,n._ptr)}return n},o.prototype.clone=function(){return new o({values:this._values?ye(this._values):void 0,index:ye(this._index),ptr:ye(this._ptr),size:ye(this._size),datatype:this._datatype})},o.prototype.size=function(){return this._size.slice(0)},o.prototype.map=function(e,n){if(!this._values)throw new Error("Cannot invoke map on a Pattern only matrix");var i=this,a=this._size[0],u=this._size[1],s=Pn(e);return function(e,n,i,a,u,s,f){var l=[],p=[],m=[],h=r,d=0;c(e._datatype)&&(h=t.find(r,[e._datatype,e._datatype])||r,d=t.convert(0,e._datatype));for(var v=function(e,t,r){e=s(e,t,r),h(e,d)||(l.push(e),p.push(t))},y=0;y<=u;y++){m.push(l.length);var g=e._ptr[y],x=e._ptr[y+1];if(f)for(var b=g;b<x;b++){var w=e._index[b];w>=0&&w<=i&&v(e._values[b],w-0,y-0)}else{for(var D={},N=g;N<x;N++)D[e._index[N]]=e._values[N];for(var E=0;E<=i;E++)v(E in D?D[E]:0,E-0,y-0)}}return m.push(l.length),new o({values:l,index:p,ptr:m,size:[i-0+1,u-0+1]})}(this,0,a-1,0,u-1,(function(t,r,n){return 1===s?e(t):2===s?e(t,[r,n]):e(t,[r,n],i)}),n)},o.prototype.forEach=function(e,t){if(!this._values)throw new Error("Cannot invoke forEach on a Pattern only matrix");for(var r=this._size[0],n=this._size[1],i=0;i<n;i++){var a=this._ptr[i],o=this._ptr[i+1];if(t)for(var u=a;u<o;u++){var s=this._index[u];e(this._values[u],[s,i],this)}else{for(var c={},f=a;f<o;f++)c[this._index[f]]=this._values[f];for(var l=0;l<r;l++)e(l in c?c[l]:0,[l,i],this)}}},o.prototype[Symbol.iterator]=Wr.mark((function e(){var t,r,n,i,a,o;return Wr.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(this._values){e.next=2;break}throw new Error("Cannot iterate a Pattern only matrix");case 2:t=this._size[1],r=0;case 4:if(!(r<t)){e.next=18;break}n=this._ptr[r],i=this._ptr[r+1],a=n;case 8:if(!(a<i)){e.next=15;break}return o=this._index[a],e.next=12,{value:this._values[a],index:[o,r]};case 12:a++,e.next=8;break;case 15:r++,e.next=4;break;case 18:case"end":return e.stop()}}),e,this)})),o.prototype.toArray=function(){return d(this._values,this._index,this._ptr,this._size,!0)},o.prototype.valueOf=function(){return d(this._values,this._index,this._ptr,this._size,!1)},o.prototype.format=function(e){for(var t=this._size[0],r=this._size[1],n=this.density(),i="Sparse Matrix ["+en(t,e)+" x "+en(r,e)+"] density: "+en(n,e)+"\n",a=0;a<r;a++)for(var o=this._ptr[a],u=this._ptr[a+1],s=o;s<u;s++)i+="\n    ("+en(this._index[s],e)+", "+en(a,e)+") ==> "+(this._values?en(this._values[s],e):"X");return i},o.prototype.toString=function(){return en(this.toArray())},o.prototype.toJSON=function(){return{mathjs:"SparseMatrix",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}},o.prototype.diagonal=function(e){if(e){if(a(e)&&(e=e.toNumber()),!i(e)||!V(e))throw new TypeError("The parameter k must be an integer number")}else e=0;var t=e>0?e:0,r=e<0?-e:0,n=this._size[0],u=this._size[1],s=Math.min(n-r,u-t),c=[],f=[],l=[];l[0]=0;for(var p=t;p<u&&c.length<s;p++)for(var m=this._ptr[p],h=this._ptr[p+1],d=m;d<h;d++){var v=this._index[d];if(v===p-t+r){c.push(this._values[d]),f[c.length-1]=v-r;break}}return l.push(c.length),new o({values:c,index:f,ptr:l,size:[s,1]})},o.fromJSON=function(e){return new o(e)},o.diagonal=function(e,n,u,s,p){if(!f(e))throw new TypeError("Array expected, size parameter");if(2!==e.length)throw new Error("Only two dimensions matrix are supported");if(e=e.map((function(e){if(a(e)&&(e=e.toNumber()),!i(e)||!V(e)||e<1)throw new Error("Size values must be positive integers");return e})),u){if(a(u)&&(u=u.toNumber()),!i(u)||!V(u))throw new TypeError("The parameter k must be an integer number")}else u=0;var m=r,h=0;c(p)&&(m=t.find(r,[p,p])||r,h=t.convert(0,p));var d,v=u>0?u:0,y=u<0?-u:0,g=e[0],x=e[1],b=Math.min(g-y,x-v);if(f(n)){if(n.length!==b)throw new Error("Invalid value array length");d=function(e){return n[e]}}else if(l(n)){var w=n.size();if(1!==w.length||w[0]!==b)throw new Error("Invalid matrix length");d=function(e){return n.get([e])}}else d=function(){return n};for(var D=[],N=[],E=[],A=0;A<x;A++){E.push(D.length);var S=A-v;if(S>=0&&S<b){var C=d(S);m(C,h)||(N.push(S+y),D.push(C))}}return E.push(D.length),new o({values:D,index:N,ptr:E,size:[g,x]})},o.prototype.swapRows=function(e,t){if(!(i(e)&&V(e)&&i(t)&&V(t)))throw new Error("Row index must be positive integers");if(2!==this._size.length)throw new Error("Only two dimensional matrix is supported");return mn(e,this._size[0]),mn(t,this._size[0]),o._swapRows(e,t,this._size[1],this._values,this._index,this._ptr),this},o._forEachRow=function(e,t,r,n,i){for(var a=n[e],o=n[e+1],u=a;u<o;u++)i(r[u],t[u])},o._swapRows=function(e,t,r,n,i,a){for(var o=0;o<r;o++){var u=a[o],c=a[o+1],f=s(e,u,c,i),l=s(t,u,c,i);if(f<c&&l<c&&i[f]===e&&i[l]===t){if(n){var p=n[f];n[f]=n[l],n[l]=p}}else if(f<c&&i[f]===e&&(l>=c||i[l]!==t)){var m=n?n[f]:void 0;i.splice(l,0,t),n&&n.splice(l,0,m),i.splice(l<=f?f+1:f,1),n&&n.splice(l<=f?f+1:f,1)}else if(l<c&&i[l]===t&&(f>=c||i[f]!==e)){var h=n?n[l]:void 0;i.splice(f,0,e),n&&n.splice(f,0,h),i.splice(f<=l?l+1:l,1),n&&n.splice(f<=l?l+1:l,1)}}},o}),{isClass:!0})),Ei=Se("number",["typed"],(function(e){var t=e.typed,r=t("number",{"":function(){return 0},number:function(e){return e},string:function(e){if("NaN"===e)return NaN;var t,r,n=(r=(t=e).match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/))?{input:t,radix:{"0b":2,"0o":8,"0x":16}[r[1]],integerPart:r[2],fractionalPart:r[3]}:null;if(n)return function(e){for(var t=parseInt(e.integerPart,e.radix),r=0,n=0;n<e.fractionalPart.length;n++)r+=parseInt(e.fractionalPart[n],e.radix)/Math.pow(e.radix,n+1);var i=t+r;if(isNaN(i))throw new SyntaxError('String "'+e.input+'" is not a valid number');return i}(n);var i=0,a=e.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);a&&(i=Number(a[2]),e=a[1]);var o=Number(e);if(isNaN(o))throw new SyntaxError('String "'+e+'" is not a valid number');if(a){if(o>Math.pow(2,i)-1)throw new SyntaxError('String "'.concat(e,'" is out of range'));o>=Math.pow(2,i-1)&&(o-=Math.pow(2,i))}return o},BigNumber:function(e){return e.toNumber()},Fraction:function(e){return e.valueOf()},Unit:t.referToSelf((function(e){return function(t){var r=t.clone();return r.value=e(t.value),r}})),null:function(e){return 0},"Unit, string | Unit":function(e,t){return e.toNumber(t)},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))});return r.fromJSON=function(e){return parseFloat(e.value)},r})),Ai="string",Si=Se(Ai,["typed"],(function(e){var t=e.typed;return t(Ai,{"":function(){return""},number:ee,null:function(e){return"null"},boolean:function(e){return e+""},string:function(e){return e},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}})),any:function(e){return String(e)}})})),Ci="boolean",Mi=Se(Ci,["typed"],(function(e){var t=e.typed;return t(Ci,{"":function(){return!1},boolean:function(e){return e},number:function(e){return!!e},null:function(e){return!1},BigNumber:function(e){return!e.isZero()},string:function(e){var t=e.toLowerCase();if("true"===t)return!0;if("false"===t)return!1;var r=Number(e);if(""!==e&&!isNaN(r))return!!r;throw new Error('Cannot convert "'+e+'" to a boolean')},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),Fi=Se("bignumber",["typed","BigNumber"],(function(e){var t=e.typed,r=e.BigNumber;return t("bignumber",{"":function(){return new r(0)},number:function(e){return new r(e+"")},string:function(e){var t=e.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);if(t){var n=t[2],i=r(t[1]),a=new r(2).pow(Number(n));if(i.gt(a.sub(1)))throw new SyntaxError('String "'.concat(e,'" is out of range'));var o=new r(2).pow(Number(n)-1);return i.gte(o)?i.sub(a):i}return new r(e)},BigNumber:function(e){return e},Unit:t.referToSelf((function(e){return function(t){var r=t.clone();return r.value=e(t.value),r}})),Fraction:function(e){return new r(e.n).div(e.d).times(e.s)},null:function(e){return new r(0)},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),Oi=Se("complex",["typed","Complex"],(function(e){var t=e.typed,r=e.Complex;return t("complex",{"":function(){return r.ZERO},number:function(e){return new r(e,0)},"number, number":function(e,t){return new r(e,t)},"BigNumber, BigNumber":function(e,t){return new r(e.toNumber(),t.toNumber())},Fraction:function(e){return new r(e.valueOf(),0)},Complex:function(e){return e.clone()},string:function(e){return r(e)},null:function(e){return r(0)},Object:function(e){if("re"in e&&"im"in e)return new r(e.re,e.im);if("r"in e&&"phi"in e||"abs"in e&&"arg"in e)return new r(e);throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)")},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),Ti=Se("fraction",["typed","Fraction"],(function(e){var t=e.typed,r=e.Fraction;return t("fraction",{number:function(e){if(!isFinite(e)||isNaN(e))throw new Error(e+" cannot be represented as a fraction");return new r(e)},string:function(e){return new r(e)},"number, number":function(e,t){return new r(e,t)},null:function(e){return new r(0)},BigNumber:function(e){return new r(e.toString())},Fraction:function(e){return e},Unit:t.referToSelf((function(e){return function(t){var r=t.clone();return r.value=e(t.value),r}})),Object:function(e){return new r(e)},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),_i="matrix",Bi=Se(_i,["typed","Matrix","DenseMatrix","SparseMatrix"],(function(e){var t=e.typed,r=(e.Matrix,e.DenseMatrix),n=e.SparseMatrix;return t(_i,{"":function(){return i([])},string:function(e){return i([],e)},"string, string":function(e,t){return i([],e,t)},Array:function(e){return i(e)},Matrix:function(e){return i(e,e.storage())},"Array | Matrix, string":i,"Array | Matrix, string, string":i});function i(e,t,i){if("dense"===t||"default"===t||void 0===t)return new r(e,i);if("sparse"===t)return new n(e,i);throw new TypeError("Unknown matrix type "+JSON.stringify(t)+".")}})),ki="matrixFromFunction",Ii=Se(ki,["typed","matrix","isZero"],(function(e){var t=e.typed,r=e.matrix,n=e.isZero;return t(ki,{"Array | Matrix, function, string, string":function(e,t,r,n){return i(e,t,r,n)},"Array | Matrix, function, string":function(e,t,r){return i(e,t,r)},"Matrix, function":function(e,t){return i(e,t,"dense")},"Array, function":function(e,t){return i(e,t,"dense").toArray()},"Array | Matrix, string, function":function(e,t,r){return i(e,r,t)},"Array | Matrix, string, string, function":function(e,t,r,n){return i(e,n,t,r)}});function i(e,t,i,a){var o;return(o=void 0!==a?r(i,a):r(i)).resize(e),o.forEach((function(e,r){var i=t(r);n(i)||o.set(r,i)})),o}}));function zi(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var Ri="matrixFromRows",qi=Se(Ri,["typed","matrix","flatten","size"],(function(e){var t=e.typed,r=e.matrix,n=e.flatten,i=e.size;return t(Ri,{"...Array":function(e){return a(e)},"...Matrix":function(e){return r(a(e.map((function(e){return e.toArray()}))))}});function a(e){if(0===e.length)throw new TypeError("At least one row is needed to construct a matrix.");var t,r=o(e[0]),i=[],a=function(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return zi(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?zi(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,o=!0,u=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return o=e.done,e},e:function(e){u=!0,a=e},f:function(){try{o||null==r.return||r.return()}finally{if(u)throw a}}}}(e);try{for(a.s();!(t=a.n()).done;){var u=t.value,s=o(u);if(s!==r)throw new TypeError("The vectors had different length: "+(0|r)+" ≠ "+(0|s));i.push(n(u))}}catch(e){a.e(e)}finally{a.f()}return i}function o(e){var t=i(e);if(1===t.length)return t[0];if(2===t.length){if(1===t[0])return t[1];if(1===t[1])return t[0];throw new TypeError("At least one of the arguments is not a vector.")}throw new TypeError("Only one- or two-dimensional vectors are supported.")}}));function ji(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var Pi="matrixFromColumns",Li=Se(Pi,["typed","matrix","flatten","size"],(function(e){var t=e.typed,r=e.matrix,n=e.flatten,i=e.size;return t(Pi,{"...Array":function(e){return a(e)},"...Matrix":function(e){return r(a(e.map((function(e){return e.toArray()}))))}});function a(e){if(0===e.length)throw new TypeError("At least one column is needed to construct a matrix.");for(var t=o(e[0]),r=[],i=0;i<t;i++)r[i]=[];var a,u=function(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return ji(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?ji(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,o=!0,u=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return o=e.done,e},e:function(e){u=!0,a=e},f:function(){try{o||null==r.return||r.return()}finally{if(u)throw a}}}}(e);try{for(u.s();!(a=u.n()).done;){var s=a.value,c=o(s);if(c!==t)throw new TypeError("The vectors had different length: "+(0|t)+" ≠ "+(0|c));for(var f=n(s),l=0;l<t;l++)r[l].push(f[l])}}catch(e){u.e(e)}finally{u.f()}return r}function o(e){var t=i(e);if(1===t.length)return t[0];if(2===t.length){if(1===t[0])return t[1];if(1===t[1])return t[0];throw new TypeError("At least one of the arguments is not a vector.")}throw new TypeError("Only one- or two-dimensional vectors are supported.")}})),Ui="splitUnit",$i=Se(Ui,["typed"],(function(e){return(0,e.typed)(Ui,{"Unit, Array":function(e,t){return e.splitUnit(t)}})})),Hi="number",Gi="number, number";function Vi(e){return Math.abs(e)}function Zi(e,t){return e+t}function Wi(e,t){return e-t}function Yi(e,t){return e*t}function Ji(e){return-e}function Xi(e){return e}function Qi(e){return X(e)}function Ki(e){return e*e*e}function ea(e){return Math.exp(e)}function ta(e){return Q(e)}function ra(e,t){if(!V(e)||!V(t))throw new Error("Parameters in function lcm must be integer numbers");if(0===e||0===t)return 0;for(var r,n=e*t;0!==t;)t=e%(r=t),e=r;return Math.abs(n/e)}function na(e){return Y(e)}function ia(e){return W(e)}function aa(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,r=t<0;if(r&&(t=-t),0===t)throw new Error("Root must be non-zero");if(e<0&&Math.abs(t)%2!=1)throw new Error("Root must be odd when a is negative.");if(0===e)return r?1/0:0;if(!isFinite(e))return r?0:e;var n=Math.pow(Math.abs(e),1/t);return n=e<0?-n:n,r?1/n:n}function oa(e){return Z(e)}function ua(e){return e*e}function sa(e,t){var r,n,i,a=0,o=1,u=1,s=0;if(!V(e)||!V(t))throw new Error("Parameters in function xgcd must be integer numbers");for(;t;)i=e-(n=Math.floor(e/t))*t,r=a,a=o-n*a,o=r,r=u,u=s-n*u,s=r,e=t,t=i;return e<0?[-e,-o,-s]:[e,e?o:0,s]}function ca(e,t){return e*e<1&&t===1/0||e*e>1&&t===-1/0?0:Math.pow(e,t)}function fa(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!V(t)||t<0||t>15)throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");return parseFloat(ne(e,t))}Vi.signature=Hi,Zi.signature=Gi,Wi.signature=Gi,Yi.signature=Gi,Ji.signature=Hi,Xi.signature=Hi,Qi.signature=Hi,Ki.signature=Hi,ea.signature=Hi,ta.signature=Hi,ra.signature=Gi,na.signature=Hi,ia.signature=Hi,oa.signature=Hi,ua.signature=Hi,sa.signature=Gi,ca.signature=Gi;var la="unaryMinus",pa=Se(la,["typed"],(function(e){var t=e.typed;return t(la,{number:Ji,"Complex | BigNumber | Fraction":function(e){return e.neg()},Unit:t.referToSelf((function(e){return function(r){var n=r.clone();return n.value=t.find(e,n.valueType())(r.value),n}})),"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e,!0)}}))})})),ma="unaryPlus",ha=Se(ma,["typed","config","BigNumber"],(function(e){var t=e.typed,r=e.config,n=e.BigNumber;return t(ma,{number:Xi,Complex:function(e){return e},BigNumber:function(e){return e},Fraction:function(e){return e},Unit:function(e){return e.clone()},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e,!0)}})),"boolean | string":function(e){return"BigNumber"===r.number?new n(+e):+e}})})),da=Se("abs",["typed"],(function(e){var t=e.typed;return t("abs",{number:Vi,"Complex | BigNumber | Fraction | Unit":function(e){return e.abs()},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e,!0)}}))})})),va="apply",ya=Se(va,["typed","isInteger"],(function(e){var t=e.typed,r=e.isInteger;return t(va,{"Array | Matrix, number | BigNumber, function":function(e,t,n){if(!r(t))throw new TypeError("Integer number expected for dimension");var i=Array.isArray(e)?cn(e):e.size();if(t<0||t>=i.length)throw new sn(t,i.length);return l(e)?e.create(ga(e.valueOf(),t,n)):ga(e,t,n)}})}));function ga(e,t,r){var n,i,a;if(t<=0){if(Array.isArray(e[0])){for(a=function(e){var t,r,n=e.length,i=e[0].length,a=[];for(r=0;r<i;r++){var o=[];for(t=0;t<n;t++)o.push(e[t][r]);a.push(o)}return a}(e),i=[],n=0;n<a.length;n++)i[n]=ga(a[n],t-1,r);return i}return r(e)}for(i=[],n=0;n<e.length;n++)i[n]=ga(e[n],t-1,r);return i}var xa="addScalar",ba=Se(xa,["typed"],(function(e){var t=e.typed;return t(xa,{"number, number":Zi,"Complex, Complex":function(e,t){return e.add(t)},"BigNumber, BigNumber":function(e,t){return e.plus(t)},"Fraction, Fraction":function(e,t){return e.add(t)},"Unit, Unit":t.referToSelf((function(e){return function(r,n){if(null===r.value||void 0===r.value)throw new Error("Parameter x contains a unit with undefined value");if(null===n.value||void 0===n.value)throw new Error("Parameter y contains a unit with undefined value");if(!r.equalBase(n))throw new Error("Units do not match");var i=r.clone();return i.value=t.find(e,[i.valueType(),n.valueType()])(i.value,n.value),i.fixPrefix=!1,i}}))})})),wa="subtractScalar",Da=Se(wa,["typed"],(function(e){var t=e.typed;return t(wa,{"number, number":Wi,"Complex, Complex":function(e,t){return e.sub(t)},"BigNumber, BigNumber":function(e,t){return e.minus(t)},"Fraction, Fraction":function(e,t){return e.sub(t)},"Unit, Unit":t.referToSelf((function(e){return function(r,n){if(null===r.value||void 0===r.value)throw new Error("Parameter x contains a unit with undefined value");if(null===n.value||void 0===n.value)throw new Error("Parameter y contains a unit with undefined value");if(!r.equalBase(n))throw new Error("Units do not match");var i=r.clone();return i.value=t.find(e,[i.valueType(),n.valueType()])(i.value,n.value),i.fixPrefix=!1,i}}))})})),Na="cbrt",Ea=Se(Na,["config","typed","isNegative","unaryMinus","matrix","Complex","BigNumber","Fraction"],(function(e){var t=e.config,r=e.typed,n=e.isNegative,i=e.unaryMinus,s=e.matrix,c=e.Complex,f=e.BigNumber,l=e.Fraction;return r(Na,{number:Qi,Complex:p,"Complex, boolean":p,BigNumber:function(e){return e.cbrt()},Unit:function(e){if(e.value&&o(e.value)){var t=e.clone();return t.value=1,(t=t.pow(1/3)).value=p(e.value),t}var r,s=n(e.value);s&&(e.value=i(e.value)),r=a(e.value)?new f(1).div(3):u(e.value)?new l(1,3):1/3;var c=e.pow(r);return s&&(c.value=i(c.value)),c}});function p(e,r){var n=e.arg()/3,i=e.abs(),a=new c(Qi(i),0).mul(new c(0,n).exp());if(r){var o=[a,new c(Qi(i),0).mul(new c(0,n+2*Math.PI/3).exp()),new c(Qi(i),0).mul(new c(0,n-2*Math.PI/3).exp())];return"Array"===t.matrix?o:s(o)}return a}}));function Aa(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var n,i,a,o,u=[],s=!0,c=!1;try{if(a=(r=r.call(e)).next,0===t){if(Object(r)!==r)return;s=!1}else for(;!(s=(n=a.call(r)).done)&&(u.push(n.value),u.length!==t);s=!0);}catch(e){c=!0,i=e}finally{try{if(!s&&null!=r.return&&(o=r.return(),Object(o)!==o))return}finally{if(c)throw i}}return u}}(e,t)||Oe(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var Sa=Se("matAlgo11xS0s",["typed","equalScalar"],(function(e){var t=e.typed,r=e.equalScalar;return function(e,n,i,a){var o=e._values,u=e._index,s=e._ptr,c=e._size,f=e._datatype;if(!o)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var l,p=c[0],m=c[1],h=r,d=0,v=i;"string"==typeof f&&(l=f,h=t.find(r,[l,l]),d=t.convert(0,l),n=t.convert(n,l),v=t.find(i,[l,l]));for(var y=[],g=[],x=[],b=0;b<m;b++){x[b]=g.length;for(var w=s[b],D=s[b+1],N=w;N<D;N++){var E=u[N],A=a?v(n,o[N]):v(o[N],n);h(A,d)||(g.push(E),y.push(A))}}return x[m]=g.length,e.createSparseMatrix({values:y,index:g,ptr:x,size:[p,m],datatype:l})}})),Ca=Se("matAlgo12xSfs",["typed","DenseMatrix"],(function(e){var t=e.typed,r=e.DenseMatrix;return function(e,n,i,a){var o=e._values,u=e._index,s=e._ptr,c=e._size,f=e._datatype;if(!o)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var l,p=c[0],m=c[1],h=i;"string"==typeof f&&(l=f,n=t.convert(n,l),h=t.find(i,[l,l]));for(var d=[],v=[],y=[],g=0;g<m;g++){for(var x=g+1,b=s[g],w=s[g+1],D=b;D<w;D++){var N=u[D];v[N]=o[D],y[N]=x}for(var E=0;E<p;E++)0===g&&(d[E]=[]),y[E]===x?d[E][g]=a?h(n,v[E]):h(v[E],n):d[E][g]=a?h(n,0):h(0,n)}return new r({data:d,size:[p,m],datatype:l})}})),Ma=Se("matAlgo14xDs",["typed"],(function(e){var t=e.typed;return function(e,n,i,a){var o,u=e._data,s=e._size,c=e._datatype,f=i;"string"==typeof c&&(o=c,n=t.convert(n,o),f=t.find(i,[o,o]));var l=s.length>0?r(f,0,s,s[0],u,n,a):[];return e.createDenseMatrix({data:l,size:ye(s),datatype:o})};function r(e,t,n,i,a,o,u){var s=[];if(t===n.length-1)for(var c=0;c<i;c++)s[c]=u?e(o,a[c]):e(a[c],o);else for(var f=0;f<i;f++)s[f]=r(e,t+1,n,n[t+1],a[f],o,u);return s}})),Fa="ceil",Oa=["typed","config","round","matrix","equalScalar","zeros","DenseMatrix"],Ta=Se(Fa,["typed","config","round"],(function(e){var t=e.typed,r=e.config,n=e.round;return t(Fa,{number:function(e){return se(e,n(e),r.epsilon)?n(e):Math.ceil(e)},"number, number":function(e,t){if(se(e,n(e,t),r.epsilon))return n(e,t);var i=Aa("".concat(e,"e").split("e"),2),a=i[0],o=i[1],u=Math.ceil(Number("".concat(a,"e").concat(Number(o)+t))),s=Aa("".concat(u,"e").split("e"),2);return a=s[0],o=s[1],Number("".concat(a,"e").concat(Number(o)-t))}})})),_a=Se(Fa,Oa,(function(e){var t=e.typed,r=e.config,n=e.round,i=e.matrix,a=e.equalScalar,o=e.zeros,u=e.DenseMatrix,s=Sa({typed:t,equalScalar:a}),c=Ca({typed:t,DenseMatrix:u}),f=Ma({typed:t}),l=Ta({typed:t,config:r,round:n});return t("ceil",{number:l.signatures.number,"number,number":l.signatures["number,number"],Complex:function(e){return e.ceil()},"Complex, number":function(e,t){return e.ceil(t)},"Complex, BigNumber":function(e,t){return e.ceil(t.toNumber())},BigNumber:function(e){return xi(e,n(e),r.epsilon)?n(e):e.ceil()},"BigNumber, BigNumber":function(e,t){return xi(e,n(e,t),r.epsilon)?n(e,t):e.toDecimalPlaces(t.toNumber(),Pr.ROUND_CEIL)},Fraction:function(e){return e.ceil()},"Fraction, number":function(e,t){return e.ceil(t)},"Fraction, BigNumber":function(e,t){return e.ceil(t.toNumber())},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e,!0)}})),"Array, number | BigNumber":t.referToSelf((function(e){return function(t,r){return Wn(t,(function(t){return e(t,r)}),!0)}})),"SparseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return s(t,r,e,!1)}})),"DenseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return f(t,r,e,!1)}})),"number | Complex | Fraction | BigNumber, Array":t.referToSelf((function(e){return function(t,r){return f(i(r),t,e,!0).valueOf()}})),"number | Complex | Fraction | BigNumber, Matrix":t.referToSelf((function(e){return function(t,r){return a(t,0)?o(r.size(),r.storage()):"dense"===r.storage()?f(r,t,e,!0):c(r,t,e,!0)}}))})})),Ba="cube",ka=Se(Ba,["typed"],(function(e){return(0,e.typed)(Ba,{number:Ki,Complex:function(e){return e.mul(e).mul(e)},BigNumber:function(e){return e.times(e).times(e)},Fraction:function(e){return e.pow(3)},Unit:function(e){return e.pow(3)}})})),Ia=Se("exp",["typed"],(function(e){return(0,e.typed)("exp",{number:ea,Complex:function(e){return e.exp()},BigNumber:function(e){return e.exp()}})})),za="expm1",Ra=Se(za,["typed","Complex"],(function(e){var t=e.typed,r=e.Complex;return t(za,{number:ta,Complex:function(e){var t=Math.exp(e.re);return new r(t*Math.cos(e.im)-1,t*Math.sin(e.im))},BigNumber:function(e){return e.exp().minus(1)}})})),qa="fix",ja=["typed","Complex","matrix","ceil","floor","equalScalar","zeros","DenseMatrix"],Pa=Se(qa,["typed","ceil","floor"],(function(e){var t=e.typed,r=e.ceil,n=e.floor;return t(qa,{number:function(e){return e>0?n(e):r(e)},"number, number":function(e,t){return e>0?n(e,t):r(e,t)}})})),La=Se(qa,ja,(function(e){var t=e.typed,r=e.Complex,n=e.matrix,i=e.ceil,a=e.floor,o=e.equalScalar,u=e.zeros,s=e.DenseMatrix,c=Ca({typed:t,DenseMatrix:s}),f=Ma({typed:t}),l=Pa({typed:t,ceil:i,floor:a});return t("fix",{number:l.signatures.number,"number, number | BigNumber":l.signatures["number,number"],Complex:function(e){return new r(e.re>0?Math.floor(e.re):Math.ceil(e.re),e.im>0?Math.floor(e.im):Math.ceil(e.im))},"Complex, number":function(e,t){return new r(e.re>0?a(e.re,t):i(e.re,t),e.im>0?a(e.im,t):i(e.im,t))},"Complex, BigNumber":function(e,t){var n=t.toNumber();return new r(e.re>0?a(e.re,n):i(e.re,n),e.im>0?a(e.im,n):i(e.im,n))},BigNumber:function(e){return e.isNegative()?i(e):a(e)},"BigNumber, number | BigNumber":function(e,t){return e.isNegative()?i(e,t):a(e,t)},Fraction:function(e){return e.s<0?e.ceil():e.floor()},"Fraction, number | BigNumber":function(e,t){return e.s<0?i(e,t):a(e,t)},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e,!0)}})),"Array | Matrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return Wn(t,(function(t){return e(t,r)}),!0)}})),"number | Complex | Fraction | BigNumber, Array":t.referToSelf((function(e){return function(t,r){return f(n(r),t,e,!0).valueOf()}})),"number | Complex | Fraction | BigNumber, Matrix":t.referToSelf((function(e){return function(t,r){return o(t,0)?u(r.size(),r.storage()):"dense"===r.storage()?f(r,t,e,!0):c(r,t,e,!0)}}))})})),Ua="floor",$a=["typed","config","round","matrix","equalScalar","zeros","DenseMatrix"],Ha=Se(Ua,["typed","config","round"],(function(e){var t=e.typed,r=e.config,n=e.round;return t(Ua,{number:function(e){return se(e,n(e),r.epsilon)?n(e):Math.floor(e)},"number, number":function(e,t){if(se(e,n(e,t),r.epsilon))return n(e,t);var i=Aa("".concat(e,"e").split("e"),2),a=i[0],o=i[1],u=Math.floor(Number("".concat(a,"e").concat(Number(o)+t))),s=Aa("".concat(u,"e").split("e"),2);return a=s[0],o=s[1],Number("".concat(a,"e").concat(Number(o)-t))}})})),Ga=Se(Ua,$a,(function(e){var t=e.typed,r=e.config,n=e.round,i=e.matrix,a=e.equalScalar,o=e.zeros,u=e.DenseMatrix,s=Sa({typed:t,equalScalar:a}),c=Ca({typed:t,DenseMatrix:u}),f=Ma({typed:t}),l=Ha({typed:t,config:r,round:n});return t("floor",{number:l.signatures.number,"number,number":l.signatures["number,number"],Complex:function(e){return e.floor()},"Complex, number":function(e,t){return e.floor(t)},"Complex, BigNumber":function(e,t){return e.floor(t.toNumber())},BigNumber:function(e){return xi(e,n(e),r.epsilon)?n(e):e.floor()},"BigNumber, BigNumber":function(e,t){return xi(e,n(e,t),r.epsilon)?n(e,t):e.toDecimalPlaces(t.toNumber(),Pr.ROUND_FLOOR)},Fraction:function(e){return e.floor()},"Fraction, number":function(e,t){return e.floor(t)},"Fraction, BigNumber":function(e,t){return e.floor(t.toNumber())},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e,!0)}})),"Array, number | BigNumber":t.referToSelf((function(e){return function(t,r){return Wn(t,(function(t){return e(t,r)}),!0)}})),"SparseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return s(t,r,e,!1)}})),"DenseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return f(t,r,e,!1)}})),"number | Complex | Fraction | BigNumber, Array":t.referToSelf((function(e){return function(t,r){return f(i(r),t,e,!0).valueOf()}})),"number | Complex | Fraction | BigNumber, Matrix":t.referToSelf((function(e){return function(t,r){return a(t,0)?o(r.size(),r.storage()):"dense"===r.storage()?f(r,t,e,!0):c(r,t,e,!0)}}))})}));function Va(e,t,r){return(t=Be(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var Za=Se("matAlgo02xDS0",["typed","equalScalar"],(function(e){var t=e.typed,r=e.equalScalar;return function(e,n,i,a){var o=e._data,u=e._size,s=e._datatype||e.getDataType(),c=n._values,f=n._index,l=n._ptr,p=n._size,m=n._datatype||void 0===n._data?n._datatype:n.getDataType();if(u.length!==p.length)throw new un(u.length,p.length);if(u[0]!==p[0]||u[1]!==p[1])throw new RangeError("Dimension mismatch. Matrix A ("+u+") must match Matrix B ("+p+")");if(!c)throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var h,d=u[0],v=u[1],y=r,g=0,x=i;"string"==typeof s&&s===m&&"mixed"!==s&&(h=s,y=t.find(r,[h,h]),g=t.convert(0,h),x=t.find(i,[h,h]));for(var b=[],w=[],D=[],N=0;N<v;N++){D[N]=w.length;for(var E=l[N],A=l[N+1],S=E;S<A;S++){var C=f[S],M=a?x(c[S],o[C][N]):x(o[C][N],c[S]);y(M,g)||(w.push(C),b.push(M))}}return D[v]=w.length,n.createSparseMatrix({values:b,index:w,ptr:D,size:[d,v],datatype:s===e._datatype&&m===n._datatype?h:void 0})}})),Wa=Se("matAlgo03xDSf",["typed"],(function(e){var t=e.typed;return function(e,r,n,i){var a=e._data,o=e._size,u=e._datatype||e.getDataType(),s=r._values,c=r._index,f=r._ptr,l=r._size,p=r._datatype||void 0===r._data?r._datatype:r.getDataType();if(o.length!==l.length)throw new un(o.length,l.length);if(o[0]!==l[0]||o[1]!==l[1])throw new RangeError("Dimension mismatch. Matrix A ("+o+") must match Matrix B ("+l+")");if(!s)throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var m,h=o[0],d=o[1],v=0,y=n;"string"==typeof u&&u===p&&"mixed"!==u&&(m=u,v=t.convert(0,m),y=t.find(n,[m,m]));for(var g=[],x=0;x<h;x++)g[x]=[];for(var b=[],w=[],D=0;D<d;D++){for(var N=D+1,E=f[D],A=f[D+1],S=E;S<A;S++){var C=c[S];b[C]=i?y(s[S],a[C][D]):y(a[C][D],s[S]),w[C]=N}for(var M=0;M<h;M++)w[M]===N?g[M][D]=b[M]:g[M][D]=i?y(v,a[M][D]):y(a[M][D],v)}return e.createDenseMatrix({data:g,size:[h,d],datatype:u===e._datatype&&p===r._datatype?m:void 0})}})),Ya=Se("matAlgo05xSfSf",["typed","equalScalar"],(function(e){var t=e.typed,r=e.equalScalar;return function(e,n,i){var a=e._values,o=e._index,u=e._ptr,s=e._size,c=e._datatype||void 0===e._data?e._datatype:e.getDataType(),f=n._values,l=n._index,p=n._ptr,m=n._size,h=n._datatype||void 0===n._data?n._datatype:n.getDataType();if(s.length!==m.length)throw new un(s.length,m.length);if(s[0]!==m[0]||s[1]!==m[1])throw new RangeError("Dimension mismatch. Matrix A ("+s+") must match Matrix B ("+m+")");var d,v=s[0],y=s[1],g=r,x=0,b=i;"string"==typeof c&&c===h&&"mixed"!==c&&(d=c,g=t.find(r,[d,d]),x=t.convert(0,d),b=t.find(i,[d,d]));var w,D,N,E,A=a&&f?[]:void 0,S=[],C=[],M=A?[]:void 0,F=A?[]:void 0,O=[],T=[];for(D=0;D<y;D++){C[D]=S.length;var _=D+1;for(N=u[D],E=u[D+1];N<E;N++)w=o[N],S.push(w),O[w]=_,M&&(M[w]=a[N]);for(N=p[D],E=p[D+1];N<E;N++)O[w=l[N]]!==_&&S.push(w),T[w]=_,F&&(F[w]=f[N]);if(A)for(N=C[D];N<S.length;){var B=O[w=S[N]],k=T[w];if(B===_||k===_){var I=b(B===_?M[w]:x,k===_?F[w]:x);g(I,x)?S.splice(N,1):(A.push(I),N++)}}}return C[y]=S.length,e.createSparseMatrix({values:A,index:S,ptr:C,size:[v,y],datatype:c===e._datatype&&h===n._datatype?d:void 0})}})),Ja=Se("matAlgo13xDD",["typed"],(function(e){var t=e.typed;return function(e,n,i){var a,o=e._data,u=e._size,s=e._datatype,c=n._data,f=n._size,l=n._datatype,p=[];if(u.length!==f.length)throw new un(u.length,f.length);for(var m=0;m<u.length;m++){if(u[m]!==f[m])throw new RangeError("Dimension mismatch. Matrix A ("+u+") must match Matrix B ("+f+")");p[m]=u[m]}var h=i;"string"==typeof s&&s===l&&(a=s,h=t.find(i,[a,a]));var d=p.length>0?r(h,0,p,p[0],o,c):[];return e.createDenseMatrix({data:d,size:p,datatype:a})};function r(e,t,n,i,a,o){var u=[];if(t===n.length-1)for(var s=0;s<i;s++)u[s]=e(a[s],o[s]);else for(var c=0;c<i;c++)u[c]=r(e,t+1,n,n[t+1],a[c],o[c]);return u}})),Xa=Se("broadcast",["concat"],(function(e){var t=e.concat;return function(e,t){var i=Math.max(e._size.length,t._size.length);if(e._size.length===t._size.length&&e._size.every((function(e,r){return e===t._size[r]})))return[e,t];for(var a=r(e._size,i,0),o=r(t._size,i,0),u=[],s=0;s<i;s++)u[s]=Math.max(a[s],o[s]);zn(a,u),zn(o,u);var c=e.clone(),f=t.clone();c._size.length<i?c.reshape(r(c._size,i,1)):f._size.length<i&&f.reshape(r(f._size,i,1));for(var l=0;l<i;l++)c._size[l]<u[l]&&(c=n(c,u[l],l)),f._size[l]<u[l]&&(f=n(f,u[l],l));return[c,f]};function r(e,t,r){return[].concat(Te(Array(t-e.length).fill(r)),Te(e))}function n(e,r,n){return t.apply(void 0,Te(Array(r).fill(e)).concat([n]))}})),Qa=Se("matrixAlgorithmSuite",["typed","matrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.concat,i=Ja({typed:t}),a=Ma({typed:t}),o=Xa({concat:n});return function(e){var n,u=e.elop,s=e.SD||e.DS;u?(n={"DenseMatrix, DenseMatrix":function(e,t){return i.apply(void 0,Te(o(e,t)).concat([u]))},"Array, Array":function(e,t){return i.apply(void 0,Te(o(r(e),r(t))).concat([u])).valueOf()},"Array, DenseMatrix":function(e,t){return i.apply(void 0,Te(o(r(e),t)).concat([u]))},"DenseMatrix, Array":function(e,t){return i.apply(void 0,Te(o(e,r(t))).concat([u]))}},e.SS&&(n["SparseMatrix, SparseMatrix"]=function(t,r){return e.SS.apply(e,Te(o(t,r)).concat([u,!1]))}),e.DS&&(n["DenseMatrix, SparseMatrix"]=function(t,r){return e.DS.apply(e,Te(o(t,r)).concat([u,!1]))},n["Array, SparseMatrix"]=function(t,n){return e.DS.apply(e,Te(o(r(t),n)).concat([u,!1]))}),s&&(n["SparseMatrix, DenseMatrix"]=function(e,t){return s.apply(void 0,Te(o(t,e)).concat([u,!0]))},n["SparseMatrix, Array"]=function(e,t){return s.apply(void 0,Te(o(r(t),e)).concat([u,!0]))})):(n={"DenseMatrix, DenseMatrix":t.referToSelf((function(e){return function(t,r){return i.apply(void 0,Te(o(t,r)).concat([e]))}})),"Array, Array":t.referToSelf((function(e){return function(t,n){return i.apply(void 0,Te(o(r(t),r(n))).concat([e])).valueOf()}})),"Array, DenseMatrix":t.referToSelf((function(e){return function(t,n){return i.apply(void 0,Te(o(r(t),n)).concat([e]))}})),"DenseMatrix, Array":t.referToSelf((function(e){return function(t,n){return i.apply(void 0,Te(o(t,r(n))).concat([e]))}}))},e.SS&&(n["SparseMatrix, SparseMatrix"]=t.referToSelf((function(t){return function(r,n){return e.SS.apply(e,Te(o(r,n)).concat([t,!1]))}}))),e.DS&&(n["DenseMatrix, SparseMatrix"]=t.referToSelf((function(t){return function(r,n){return e.DS.apply(e,Te(o(r,n)).concat([t,!1]))}})),n["Array, SparseMatrix"]=t.referToSelf((function(t){return function(n,i){return e.DS.apply(e,Te(o(r(n),i)).concat([t,!1]))}}))),s&&(n["SparseMatrix, DenseMatrix"]=t.referToSelf((function(e){return function(t,r){return s.apply(void 0,Te(o(r,t)).concat([e,!0]))}})),n["SparseMatrix, Array"]=t.referToSelf((function(e){return function(t,n){return s.apply(void 0,Te(o(r(n),t)).concat([e,!0]))}}))));var c=e.scalar||"any";(e.Ds||e.Ss)&&(u?(n["DenseMatrix,"+c]=function(e,t){return a(e,t,u,!1)},n[c+", DenseMatrix"]=function(e,t){return a(t,e,u,!0)},n["Array,"+c]=function(e,t){return a(r(e),t,u,!1).valueOf()},n[c+", Array"]=function(e,t){return a(r(t),e,u,!0).valueOf()}):(n["DenseMatrix,"+c]=t.referToSelf((function(e){return function(t,r){return a(t,r,e,!1)}})),n[c+", DenseMatrix"]=t.referToSelf((function(e){return function(t,r){return a(r,t,e,!0)}})),n["Array,"+c]=t.referToSelf((function(e){return function(t,n){return a(r(t),n,e,!1).valueOf()}})),n[c+", Array"]=t.referToSelf((function(e){return function(t,n){return a(r(n),t,e,!0).valueOf()}}))));var f=void 0!==e.sS?e.sS:e.Ss;return u?(e.Ss&&(n["SparseMatrix,"+c]=function(t,r){return e.Ss(t,r,u,!1)}),f&&(n[c+", SparseMatrix"]=function(e,t){return f(t,e,u,!0)})):(e.Ss&&(n["SparseMatrix,"+c]=t.referToSelf((function(t){return function(r,n){return e.Ss(r,n,t,!1)}}))),f&&(n[c+", SparseMatrix"]=t.referToSelf((function(e){return function(t,r){return f(r,t,e,!0)}})))),u&&u.signatures&&xe(n,u.signatures),n}})),Ka=Se("mod",["typed","config","round","matrix","equalScalar","zeros","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.config,n=e.round,i=e.matrix,a=e.equalScalar,o=e.zeros,u=e.DenseMatrix,s=e.concat,c=Ga({typed:t,config:r,round:n,matrix:i,equalScalar:a,zeros:o,DenseMatrix:u}),f=Za({typed:t,equalScalar:a}),l=Wa({typed:t}),p=Ya({typed:t,equalScalar:a}),m=Sa({typed:t,equalScalar:a}),h=Ca({typed:t,DenseMatrix:u});return t("mod",{"number, number":function(e,t){return 0===t?e:e-t*c(e/t)},"BigNumber, BigNumber":function(e,t){return t.isZero()?e:e.sub(t.mul(c(e.div(t))))},"Fraction, Fraction":function(e,t){return t.equals(0)?e:e.sub(t.mul(c(e.div(t))))}},Qa({typed:t,matrix:i,concat:s})({SS:p,DS:l,SD:f,Ss:m,sS:h}))})),eo=Se("matAlgo01xDSid",["typed"],(function(e){var t=e.typed;return function(e,r,n,i){var a=e._data,o=e._size,u=e._datatype||e.getDataType(),s=r._values,c=r._index,f=r._ptr,l=r._size,p=r._datatype||void 0===r._data?r._datatype:r.getDataType();if(o.length!==l.length)throw new un(o.length,l.length);if(o[0]!==l[0]||o[1]!==l[1])throw new RangeError("Dimension mismatch. Matrix A ("+o+") must match Matrix B ("+l+")");if(!s)throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var m,h,d=o[0],v=o[1],y="string"==typeof u&&"mixed"!==u&&u===p?u:void 0,g=y?t.find(n,[y,y]):n,x=[];for(m=0;m<d;m++)x[m]=[];var b=[],w=[];for(h=0;h<v;h++){for(var D=h+1,N=f[h],E=f[h+1],A=N;A<E;A++)b[m=c[A]]=i?g(s[A],a[m][h]):g(a[m][h],s[A]),w[m]=D;for(m=0;m<d;m++)w[m]===D?x[m][h]=b[m]:x[m][h]=a[m][h]}return e.createDenseMatrix({data:x,size:[d,v],datatype:u===e._datatype&&p===r._datatype?y:void 0})}})),to=Se("matAlgo04xSidSid",["typed","equalScalar"],(function(e){var t=e.typed,r=e.equalScalar;return function(e,n,i){var a=e._values,o=e._index,u=e._ptr,s=e._size,c=e._datatype||void 0===e._data?e._datatype:e.getDataType(),f=n._values,l=n._index,p=n._ptr,m=n._size,h=n._datatype||void 0===n._data?n._datatype:n.getDataType();if(s.length!==m.length)throw new un(s.length,m.length);if(s[0]!==m[0]||s[1]!==m[1])throw new RangeError("Dimension mismatch. Matrix A ("+s+") must match Matrix B ("+m+")");var d,v=s[0],y=s[1],g=r,x=0,b=i;"string"==typeof c&&c===h&&"mixed"!==c&&(d=c,g=t.find(r,[d,d]),x=t.convert(0,d),b=t.find(i,[d,d]));var w,D,N,E,A,S=a&&f?[]:void 0,C=[],M=[],F=a&&f?[]:void 0,O=a&&f?[]:void 0,T=[],_=[];for(D=0;D<y;D++){M[D]=C.length;var B=D+1;for(E=u[D],A=u[D+1],N=E;N<A;N++)w=o[N],C.push(w),T[w]=B,F&&(F[w]=a[N]);for(E=p[D],A=p[D+1],N=E;N<A;N++)if(T[w=l[N]]===B){if(F){var k=b(F[w],f[N]);g(k,x)?T[w]=null:F[w]=k}}else C.push(w),_[w]=B,O&&(O[w]=f[N]);if(F&&O)for(N=M[D];N<C.length;)T[w=C[N]]===B?(S[N]=F[w],N++):_[w]===B?(S[N]=O[w],N++):C.splice(N,1)}return M[y]=C.length,e.createSparseMatrix({values:S,index:C,ptr:M,size:[v,y],datatype:c===e._datatype&&h===n._datatype?d:void 0})}})),ro=Se("matAlgo10xSids",["typed","DenseMatrix"],(function(e){var t=e.typed,r=e.DenseMatrix;return function(e,n,i,a){var o=e._values,u=e._index,s=e._ptr,c=e._size,f=e._datatype;if(!o)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var l,p=c[0],m=c[1],h=i;"string"==typeof f&&(l=f,n=t.convert(n,l),h=t.find(i,[l,l]));for(var d=[],v=[],y=[],g=0;g<m;g++){for(var x=g+1,b=s[g],w=s[g+1],D=b;D<w;D++){var N=u[D];v[N]=o[D],y[N]=x}for(var E=0;E<p;E++)0===g&&(d[E]=[]),y[E]===x?d[E][g]=a?h(n,v[E]):h(v[E],n):d[E][g]=n}return new r({data:d,size:[p,m],datatype:l})}}));function no(e,t,r,n){if(!(this instanceof no))throw new SyntaxError("Constructor must be called with the new operator");this.fn=e,this.count=t,this.min=r,this.max=n,this.message="Wrong number of arguments in function "+e+" ("+t+" provided, "+r+(null!=n?"-"+n:"")+" expected)",this.stack=(new Error).stack}no.prototype=new Error,no.prototype.constructor=Error,no.prototype.name="ArgumentsError",no.prototype.isArgumentsError=!0;var io=["typed","config","round","matrix","equalScalar","zeros","BigNumber","DenseMatrix","concat"],ao="number | BigNumber | Fraction | Matrix | Array",oo="".concat(ao,", ").concat(ao,", ...").concat(ao);function uo(e){return!e.some((function(e){return Array.isArray(e)}))}var so=Se("gcd",io,(function(e){var t=e.typed,r=e.matrix,n=e.config,i=e.round,a=e.equalScalar,o=e.zeros,u=e.BigNumber,s=e.DenseMatrix,c=e.concat,f=Ka({typed:t,config:n,round:i,matrix:r,equalScalar:a,zeros:o,DenseMatrix:s,concat:c}),l=eo({typed:t}),p=to({typed:t,equalScalar:a}),m=ro({typed:t,DenseMatrix:s});return t("gcd",{"number, number":function(e,t){if(!V(e)||!V(t))throw new Error("Parameters in function gcd must be integer numbers");for(var r;0!==t;)r=f(e,t),e=t,t=r;return e<0?-e:e},"BigNumber, BigNumber":function(e,t){if(!e.isInt()||!t.isInt())throw new Error("Parameters in function gcd must be integer numbers");for(var r=new u(0);!t.isZero();){var n=f(e,t);e=t,t=n}return e.lt(r)?e.neg():e},"Fraction, Fraction":function(e,t){return e.gcd(t)}},Qa({typed:t,matrix:r,concat:c})({SS:p,DS:l,Ss:m}),Va(Va(Va({},oo,t.referToSelf((function(e){return function(t,r,n){for(var i=e(t,r),a=0;a<n.length;a++)i=e(i,n[a]);return i}}))),"Array",t.referToSelf((function(e){return function(t){if(1===t.length&&Array.isArray(t[0])&&uo(t[0]))return e.apply(void 0,Te(t[0]));if(uo(t))return e.apply(void 0,Te(t));throw new no("gcd() supports only 1d matrices!")}}))),"Matrix",t.referToSelf((function(e){return function(t){return e(t.toArray())}}))))})),co=Se("matAlgo06xS0S0",["typed","equalScalar"],(function(e){var t=e.typed,r=e.equalScalar;return function(e,n,i){var a=e._values,o=e._size,u=e._datatype||void 0===e._data?e._datatype:e.getDataType(),s=n._values,c=n._size,f=n._datatype||void 0===n._data?n._datatype:n.getDataType();if(o.length!==c.length)throw new un(o.length,c.length);if(o[0]!==c[0]||o[1]!==c[1])throw new RangeError("Dimension mismatch. Matrix A ("+o+") must match Matrix B ("+c+")");var l,p=o[0],m=o[1],h=r,d=0,v=i;"string"==typeof u&&u===f&&"mixed"!==u&&(l=u,h=t.find(r,[l,l]),d=t.convert(0,l),v=t.find(i,[l,l]));for(var y=a&&s?[]:void 0,g=[],x=[],b=y?[]:void 0,w=[],D=[],N=0;N<m;N++){x[N]=g.length;var E=N+1;if(Xn(e,N,w,b,D,E,g,v),Xn(n,N,w,b,D,E,g,v),b)for(var A=x[N];A<g.length;){var S=g[A];if(D[S]===E){var C=b[S];h(C,d)?g.splice(A,1):(y.push(C),A++)}else g.splice(A,1)}else for(var M=x[N];M<g.length;)D[g[M]]!==E?g.splice(M,1):M++}return x[m]=g.length,e.createSparseMatrix({values:y,index:g,ptr:x,size:[p,m],datatype:u===e._datatype&&f===n._datatype?l:void 0})}})),fo=Se("lcm",["typed","matrix","equalScalar","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.concat,a=Za({typed:t,equalScalar:n}),o=co({typed:t,equalScalar:n}),u=Sa({typed:t,equalScalar:n}),s=Qa({typed:t,matrix:r,concat:i}),c="number | BigNumber | Fraction | Matrix | Array",f={};return f["".concat(c,", ").concat(c,", ...").concat(c)]=t.referToSelf((function(e){return function(t,r,n){for(var i=e(t,r),a=0;a<n.length;a++)i=e(i,n[a]);return i}})),t("lcm",{"number, number":ra,"BigNumber, BigNumber":function(e,t){if(!e.isInt()||!t.isInt())throw new Error("Parameters in function lcm must be integer numbers");if(e.isZero())return e;if(t.isZero())return t;for(var r=e.times(t);!t.isZero();){var n=t;t=e.mod(n),e=n}return r.div(e).abs()},"Fraction, Fraction":function(e,t){return e.lcm(t)}},s({SS:o,DS:a,Ss:u}),f)})),lo="log10",po=Se(lo,["typed","config","Complex"],(function(e){var t=e.typed,r=e.config,n=e.Complex;return t(lo,{number:function(e){return e>=0||r.predictable?na(e):new n(e,0).log().div(Math.LN10)},Complex:function(e){return new n(e).log().div(Math.LN10)},BigNumber:function(e){return!e.isNegative()||r.predictable?e.log():new n(e.toNumber(),0).log().div(Math.LN10)},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),mo="log2",ho=Se(mo,["typed","config","Complex"],(function(e){var t=e.typed,r=e.config,n=e.Complex;return t(mo,{number:function(e){return e>=0||r.predictable?ia(e):i(new n(e,0))},Complex:i,BigNumber:function(e){return!e.isNegative()||r.predictable?e.log(2):i(new n(e.toNumber(),0))},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))});function i(e){var t=Math.sqrt(e.re*e.re+e.im*e.im);return new n(Math.log2?Math.log2(t):Math.log(t)/Math.LN2,Math.atan2(e.im,e.re)/Math.LN2)}})),vo=Se("multiplyScalar",["typed"],(function(e){return(0,e.typed)("multiplyScalar",{"number, number":Yi,"Complex, Complex":function(e,t){return e.mul(t)},"BigNumber, BigNumber":function(e,t){return e.times(t)},"Fraction, Fraction":function(e,t){return e.mul(t)},"number | Fraction | BigNumber | Complex, Unit":function(e,t){return t.multiply(e)},"Unit, number | Fraction | BigNumber | Complex | Unit":function(e,t){return e.multiply(t)}})})),yo="multiply",go=Se(yo,["typed","matrix","addScalar","multiplyScalar","equalScalar","dot"],(function(e){var t=e.typed,r=e.matrix,n=e.addScalar,i=e.multiplyScalar,a=e.equalScalar,o=e.dot,u=Sa({typed:t,equalScalar:a}),s=Ma({typed:t});function c(e,t){switch(e.length){case 1:switch(t.length){case 1:if(e[0]!==t[0])throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");break;case 2:if(e[0]!==t[0])throw new RangeError("Dimension mismatch in multiplication. Vector length ("+e[0]+") must match Matrix rows ("+t[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+t.length+" dimensions)")}break;case 2:switch(t.length){case 1:if(e[1]!==t[0])throw new RangeError("Dimension mismatch in multiplication. Matrix columns ("+e[1]+") must match Vector length ("+t[0]+")");break;case 2:if(e[1]!==t[0])throw new RangeError("Dimension mismatch in multiplication. Matrix A columns ("+e[1]+") must match Matrix B rows ("+t[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+t.length+" dimensions)")}break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has "+e.length+" dimensions)")}}var f=t("_multiplyMatrixVector",{"DenseMatrix, any":function(e,r){var a,o=e._data,u=e._size,s=e._datatype||e.getDataType(),c=r._data,f=r._datatype||r.getDataType(),l=u[0],p=u[1],m=n,h=i;s&&f&&s===f&&"string"==typeof s&&"mixed"!==s&&(a=s,m=t.find(n,[a,a]),h=t.find(i,[a,a]));for(var d=[],v=0;v<l;v++){for(var y=o[v],g=h(y[0],c[0]),x=1;x<p;x++)g=m(g,h(y[x],c[x]));d[v]=g}return e.createDenseMatrix({data:d,size:[l],datatype:s===e._datatype&&f===r._datatype?a:void 0})},"SparseMatrix, any":function(e,r){var o=e._values,u=e._index,s=e._ptr,c=e._datatype||void 0===e._data?e._datatype:e.getDataType();if(!o)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var f,l=r._data,p=r._datatype||r.getDataType(),m=e._size[0],h=r._size[0],d=[],v=[],y=[],g=n,x=i,b=a,w=0;c&&p&&c===p&&"string"==typeof c&&"mixed"!==c&&(f=c,g=t.find(n,[f,f]),x=t.find(i,[f,f]),b=t.find(a,[f,f]),w=t.convert(0,f));var D=[],N=[];y[0]=0;for(var E=0;E<h;E++){var A=l[E];if(!b(A,w))for(var S=s[E],C=s[E+1],M=S;M<C;M++){var F=u[M];N[F]?D[F]=g(D[F],x(A,o[M])):(N[F]=!0,v.push(F),D[F]=x(A,o[M]))}}for(var O=v.length,T=0;T<O;T++){var _=v[T];d[T]=D[_]}return y[1]=v.length,e.createSparseMatrix({values:d,index:v,ptr:y,size:[m,1],datatype:c===e._datatype&&p===r._datatype?f:void 0})}}),p=t("_multiplyMatrixMatrix",{"DenseMatrix, DenseMatrix":function(e,r){var a,o=e._data,u=e._size,s=e._datatype||e.getDataType(),c=r._data,f=r._size,l=r._datatype||r.getDataType(),p=u[0],m=u[1],h=f[1],d=n,v=i;s&&l&&s===l&&"string"==typeof s&&"mixed"!==s&&"mixed"!==s&&(a=s,d=t.find(n,[a,a]),v=t.find(i,[a,a]));for(var y=[],g=0;g<p;g++){var x=o[g];y[g]=[];for(var b=0;b<h;b++){for(var w=v(x[0],c[0][b]),D=1;D<m;D++)w=d(w,v(x[D],c[D][b]));y[g][b]=w}}return e.createDenseMatrix({data:y,size:[p,h],datatype:s===e._datatype&&l===r._datatype?a:void 0})},"DenseMatrix, SparseMatrix":function(e,r){var o=e._data,u=e._size,s=e._datatype||e.getDataType(),c=r._values,f=r._index,l=r._ptr,p=r._size,m=r._datatype||void 0===r._data?r._datatype:r.getDataType();if(!c)throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");var h,d=u[0],v=p[1],y=n,g=i,x=a,b=0;s&&m&&s===m&&"string"==typeof s&&"mixed"!==s&&(h=s,y=t.find(n,[h,h]),g=t.find(i,[h,h]),x=t.find(a,[h,h]),b=t.convert(0,h));for(var w=[],D=[],N=[],E=r.createSparseMatrix({values:w,index:D,ptr:N,size:[d,v],datatype:s===e._datatype&&m===r._datatype?h:void 0}),A=0;A<v;A++){N[A]=D.length;var S=l[A],C=l[A+1];if(C>S)for(var M=0,F=0;F<d;F++){for(var O=F+1,T=void 0,_=S;_<C;_++){var B=f[_];M!==O?(T=g(o[F][B],c[_]),M=O):T=y(T,g(o[F][B],c[_]))}M!==O||x(T,b)||(D.push(F),w.push(T))}}return N[v]=D.length,E},"SparseMatrix, DenseMatrix":function(e,r){var o=e._values,u=e._index,s=e._ptr,c=e._datatype||void 0===e._data?e._datatype:e.getDataType();if(!o)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var f,l=r._data,p=r._datatype||r.getDataType(),m=e._size[0],h=r._size[0],d=r._size[1],v=n,y=i,g=a,x=0;c&&p&&c===p&&"string"==typeof c&&"mixed"!==c&&(f=c,v=t.find(n,[f,f]),y=t.find(i,[f,f]),g=t.find(a,[f,f]),x=t.convert(0,f));for(var b=[],w=[],D=[],N=e.createSparseMatrix({values:b,index:w,ptr:D,size:[m,d],datatype:c===e._datatype&&p===r._datatype?f:void 0}),E=[],A=[],S=0;S<d;S++){D[S]=w.length;for(var C=S+1,M=0;M<h;M++){var F=l[M][S];if(!g(F,x))for(var O=s[M],T=s[M+1],_=O;_<T;_++){var B=u[_];A[B]!==C?(A[B]=C,w.push(B),E[B]=y(F,o[_])):E[B]=v(E[B],y(F,o[_]))}}for(var k=D[S],I=w.length,z=k;z<I;z++){var R=w[z];b[z]=E[R]}}return D[d]=w.length,N},"SparseMatrix, SparseMatrix":function(e,r){var a,o=e._values,u=e._index,s=e._ptr,c=e._datatype||void 0===e._data?e._datatype:e.getDataType(),f=r._values,l=r._index,p=r._ptr,m=r._datatype||void 0===r._data?r._datatype:r.getDataType(),h=e._size[0],d=r._size[1],v=o&&f,y=n,g=i;c&&m&&c===m&&"string"==typeof c&&"mixed"!==c&&(a=c,y=t.find(n,[a,a]),g=t.find(i,[a,a]));for(var x,b,w,D,N,E,A,S,C=v?[]:void 0,M=[],F=[],O=e.createSparseMatrix({values:C,index:M,ptr:F,size:[h,d],datatype:c===e._datatype&&m===r._datatype?a:void 0}),T=v?[]:void 0,_=[],B=0;B<d;B++){F[B]=M.length;var k=B+1;for(N=p[B],E=p[B+1],D=N;D<E;D++)if(S=l[D],v)for(b=s[S],w=s[S+1],x=b;x<w;x++)_[A=u[x]]!==k?(_[A]=k,M.push(A),T[A]=g(f[D],o[x])):T[A]=y(T[A],g(f[D],o[x]));else for(b=s[S],w=s[S+1],x=b;x<w;x++)_[A=u[x]]!==k&&(_[A]=k,M.push(A));if(v)for(var I=F[B],z=M.length,R=I;R<z;R++){var q=M[R];C[R]=T[q]}}return F[d]=M.length,O}});return t(yo,i,{"Array, Array":t.referTo("Matrix, Matrix",(function(e){return function(t,n){c(cn(t),cn(n));var i=e(r(t),r(n));return l(i)?i.valueOf():i}})),"Matrix, Matrix":function(e,r){var a=e.size(),u=r.size();return c(a,u),1===a.length?1===u.length?function(e,t,r){if(0===r)throw new Error("Cannot multiply two empty vectors");return o(e,t)}(e,r,a[0]):function(e,r){if("dense"!==r.storage())throw new Error("Support for SparseMatrix not implemented");return function(e,r){var a,o=e._data,u=e._size,s=e._datatype||e.getDataType(),c=r._data,f=r._size,l=r._datatype||r.getDataType(),p=u[0],m=f[1],h=n,d=i;s&&l&&s===l&&"string"==typeof s&&"mixed"!==s&&(a=s,h=t.find(n,[a,a]),d=t.find(i,[a,a]));for(var v=[],y=0;y<m;y++){for(var g=d(o[0],c[0][y]),x=1;x<p;x++)g=h(g,d(o[x],c[x][y]));v[y]=g}return e.createDenseMatrix({data:v,size:[m],datatype:s===e._datatype&&l===r._datatype?a:void 0})}(e,r)}(e,r):1===u.length?f(e,r):p(e,r)},"Matrix, Array":t.referTo("Matrix,Matrix",(function(e){return function(t,n){return e(t,r(n))}})),"Array, Matrix":t.referToSelf((function(e){return function(t,n){return e(r(t,n.storage()),n)}})),"SparseMatrix, any":function(e,t){return u(e,t,i,!1)},"DenseMatrix, any":function(e,t){return s(e,t,i,!1)},"any, SparseMatrix":function(e,t){return u(t,e,i,!0)},"any, DenseMatrix":function(e,t){return s(t,e,i,!0)},"Array, any":function(e,t){return s(r(e),t,i,!1).valueOf()},"any, Array":function(e,t){return s(r(t),e,i,!0).valueOf()},"any, any":i,"any, any, ...any":t.referToSelf((function(e){return function(t,r,n){for(var i=e(t,r),a=0;a<n.length;a++)i=e(i,n[a]);return i}}))})})),xo="nthRoot",bo=Se(xo,["typed","matrix","equalScalar","BigNumber","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.BigNumber,a=e.concat,o=eo({typed:t}),u=Za({typed:t,equalScalar:n}),s=co({typed:t,equalScalar:n}),c=Sa({typed:t,equalScalar:n}),f=Qa({typed:t,matrix:r,concat:a});function l(){throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.")}return t(xo,{number:aa,"number, number":aa,BigNumber:function(e){return p(e,new i(2))},"BigNumber, BigNumber":p,Complex:l,"Complex, number":l,Array:t.referTo("DenseMatrix,number",(function(e){return function(t){return e(r(t),2).valueOf()}})),DenseMatrix:t.referTo("DenseMatrix,number",(function(e){return function(t){return e(t,2)}})),SparseMatrix:t.referTo("SparseMatrix,number",(function(e){return function(t){return e(t,2)}})),"SparseMatrix, SparseMatrix":t.referToSelf((function(e){return function(t,r){if(1===r.density())return s(t,r,e);throw new Error("Root must be non-zero")}})),"DenseMatrix, SparseMatrix":t.referToSelf((function(e){return function(t,r){if(1===r.density())return o(t,r,e,!1);throw new Error("Root must be non-zero")}})),"Array, SparseMatrix":t.referTo("DenseMatrix,SparseMatrix",(function(e){return function(t,n){return e(r(t),n)}})),"number | BigNumber, SparseMatrix":t.referToSelf((function(e){return function(t,r){if(1===r.density())return c(r,t,e,!0);throw new Error("Root must be non-zero")}}))},f({scalar:"number | BigNumber",SD:u,Ss:c,sS:!1}));function p(e,t){var r=i.precision,n=i.clone({precision:r+2}),a=new i(0),o=new n(1),u=t.isNegative();if(u&&(t=t.neg()),t.isZero())throw new Error("Root must be non-zero");if(e.isNegative()&&!t.abs().mod(2).equals(1))throw new Error("Root must be odd when a is negative.");if(e.isZero())return u?new n(1/0):0;if(!e.isFinite())return u?a:e;var s=e.abs().pow(o.div(t));return s=e.isNeg()?s.neg():s,new i((u?o.div(s):s).toPrecision(r))}})),wo="sign",Do=Se(wo,["typed","BigNumber","Fraction","complex"],(function(e){var t=e.typed,r=e.BigNumber,n=e.complex,i=e.Fraction;return t(wo,{number:oa,Complex:function(e){return 0===e.im?n(oa(e.re)):e.sign()},BigNumber:function(e){return new r(e.cmp(0))},Fraction:function(e){return new i(e.s,1)},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e,!0)}})),Unit:t.referToSelf((function(e){return function(r){if(!r._isDerived()&&0!==r.units[0].unit.offset)throw new TypeError("sign is ambiguous for units with offset");return t.find(e,r.valueType())(r.value)}}))})})),No=Se("sqrt",["config","typed","Complex"],(function(e){var t=e.config,r=e.typed,n=e.Complex;return r("sqrt",{number:i,Complex:function(e){return e.sqrt()},BigNumber:function(e){return!e.isNegative()||t.predictable?e.sqrt():i(e.toNumber())},Unit:function(e){return e.pow(.5)}});function i(e){return isNaN(e)?NaN:e>=0||t.predictable?Math.sqrt(e):new n(e,0).sqrt()}})),Eo="square",Ao=Se(Eo,["typed"],(function(e){return(0,e.typed)(Eo,{number:ua,Complex:function(e){return e.mul(e)},BigNumber:function(e){return e.times(e)},Fraction:function(e){return e.mul(e)},Unit:function(e){return e.pow(2)}})})),So="subtract",Co=Se(So,["typed","matrix","equalScalar","subtractScalar","unaryMinus","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.subtractScalar,a=(e.unaryMinus,e.DenseMatrix),o=e.concat,u=eo({typed:t}),s=Wa({typed:t}),c=Ya({typed:t,equalScalar:n}),f=ro({typed:t,DenseMatrix:a}),l=Ca({typed:t,DenseMatrix:a}),p=Qa({typed:t,matrix:r,concat:o});return t(So,{"any, any":i},p({elop:i,SS:c,DS:u,SD:s,Ss:l,sS:f}))})),Mo="xgcd",Fo=Se(Mo,["typed","config","matrix","BigNumber"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.BigNumber;return t(Mo,{"number, number":function(e,t){var i=sa(e,t);return"Array"===r.matrix?i:n(i)},"BigNumber, BigNumber":function(e,t){var a,o,u,s,c=new i(0),f=new i(1),l=c,p=f,m=f,h=c;if(!e.isInt()||!t.isInt())throw new Error("Parameters in function xgcd must be integer numbers");for(;!t.isZero();)o=e.div(t).floor(),u=e.mod(t),a=l,l=p.minus(o.times(l)),p=a,a=m,m=h.minus(o.times(m)),h=a,e=t,t=u;return s=e.lt(c)?[e.neg(),p.neg(),h.neg()]:[e,e.isZero()?0:p,h],"Array"===r.matrix?s:n(s)}})})),Oo="invmod",To=Se(Oo,["typed","config","BigNumber","xgcd","equal","smaller","mod","add","isInteger"],(function(e){var t=e.typed,r=(e.config,e.BigNumber),n=e.xgcd,i=e.equal,a=e.smaller,o=e.mod,u=e.add,s=e.isInteger;return t(Oo,{"number, number":c,"BigNumber, BigNumber":c});function c(e,t){if(!s(e)||!s(t))throw new Error("Parameters in function invmod must be integer numbers");if(e=o(e,t),i(t,0))throw new Error("Divisor must be non zero");var c=n(e,t),f=Aa(c=c.valueOf(),2),l=f[0],p=f[1];return i(l,r(1))?(p=o(p,t),a(p,r(0))&&(p=u(p,t)),p):NaN}})),_o=Se("matAlgo09xS0Sf",["typed","equalScalar"],(function(e){var t=e.typed,r=e.equalScalar;return function(e,n,i){var a=e._values,o=e._index,u=e._ptr,s=e._size,c=e._datatype||void 0===e._data?e._datatype:e.getDataType(),f=n._values,l=n._index,p=n._ptr,m=n._size,h=n._datatype||void 0===n._data?n._datatype:n.getDataType();if(s.length!==m.length)throw new un(s.length,m.length);if(s[0]!==m[0]||s[1]!==m[1])throw new RangeError("Dimension mismatch. Matrix A ("+s+") must match Matrix B ("+m+")");var d,v=s[0],y=s[1],g=r,x=0,b=i;"string"==typeof c&&c===h&&"mixed"!==c&&(d=c,g=t.find(r,[d,d]),x=t.convert(0,d),b=t.find(i,[d,d]));var w,D,N,E,A,S=a&&f?[]:void 0,C=[],M=[],F=S?[]:void 0,O=[];for(D=0;D<y;D++){M[D]=C.length;var T=D+1;if(F)for(E=p[D],A=p[D+1],N=E;N<A;N++)O[w=l[N]]=T,F[w]=f[N];for(E=u[D],A=u[D+1],N=E;N<A;N++)if(w=o[N],F){var _=O[w]===T?F[w]:x,B=b(a[N],_);g(B,x)||(C.push(w),S.push(B))}else C.push(w)}return M[y]=C.length,e.createSparseMatrix({values:S,index:C,ptr:M,size:[v,y],datatype:c===e._datatype&&h===n._datatype?d:void 0})}})),Bo="dotMultiply",ko=Se(Bo,["typed","matrix","equalScalar","multiplyScalar","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.multiplyScalar,a=e.concat,o=Za({typed:t,equalScalar:n}),u=_o({typed:t,equalScalar:n}),s=Sa({typed:t,equalScalar:n}),c=Qa({typed:t,matrix:r,concat:a});return t(Bo,c({elop:i,SS:u,DS:o,Ss:s}))}));function Io(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw new Error("Integers expected in function bitAnd");var r=e.constructor;if(e.isNaN()||t.isNaN())return new r(NaN);if(e.isZero()||t.eq(-1)||e.eq(t))return e;if(t.isZero()||e.eq(-1))return t;if(!e.isFinite()||!t.isFinite()){if(!e.isFinite()&&!t.isFinite())return e.isNegative()===t.isNegative()?e:new r(0);if(!e.isFinite())return t.isNegative()?e:e.isNegative()?new r(0):t;if(!t.isFinite())return e.isNegative()?t:t.isNegative()?new r(0):e}return qo(e,t,(function(e,t){return e&t}))}function zo(e){if(e.isFinite()&&!e.isInteger())throw new Error("Integer expected in function bitNot");var t=e.constructor,r=t.precision;t.config({precision:1e9});var n=e.plus(new t(1));return n.s=-n.s||null,t.config({precision:r}),n}function Ro(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw new Error("Integers expected in function bitOr");var r=e.constructor;if(e.isNaN()||t.isNaN())return new r(NaN);var n=new r(-1);return e.isZero()||t.eq(n)||e.eq(t)?t:t.isZero()||e.eq(n)?e:e.isFinite()&&t.isFinite()?qo(e,t,(function(e,t){return e|t})):!e.isFinite()&&!e.isNegative()&&t.isNegative()||e.isNegative()&&!t.isNegative()&&!t.isFinite()?n:e.isNegative()&&t.isNegative()?e.isFinite()?e:t:e.isFinite()?t:e}function qo(e,t,r){var n,i,a,o,u,s=e.constructor,c=+(e.s<0),f=+(t.s<0);if(c){n=jo(zo(e));for(var l=0;l<n.length;++l)n[l]^=1}else n=jo(e);if(f){i=jo(zo(t));for(var p=0;p<i.length;++p)i[p]^=1}else i=jo(t);n.length<=i.length?(a=n,o=i,u=c):(a=i,o=n,u=f);var m=a.length,h=o.length,d=1^r(c,f),v=new s(1^d),y=new s(1),g=new s(2),x=s.precision;for(s.config({precision:1e9});m>0;)r(a[--m],o[--h])===d&&(v=v.plus(y)),y=y.times(g);for(;h>0;)r(u,o[--h])===d&&(v=v.plus(y)),y=y.times(g);return s.config({precision:x}),0===d&&(v.s=-v.s),v}function jo(e){for(var t=e.d,r=t[0]+"",n=1;n<t.length;++n){for(var i=t[n]+"",a=7-i.length;a--;)i="0"+i;r+=i}for(var o=r.length;"0"===r.charAt(o);)o--;var u=e.e,s=r.slice(0,o+1||1),c=s.length;if(u>0)if(++u>c)for(u-=c;u--;)s+="0";else u<c&&(s=s.slice(0,u)+"."+s.slice(u));for(var f=[0],l=0;l<s.length;){for(var p=f.length;p--;)f[p]*=10;f[0]+=parseInt(s.charAt(l++));for(var m=0;m<f.length;++m)f[m]>1&&(null!==f[m+1]&&void 0!==f[m+1]||(f[m+1]=0),f[m+1]+=f[m]>>1,f[m]&=1)}return f.reverse()}function Po(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw new Error("Integers expected in function bitXor");var r=e.constructor;if(e.isNaN()||t.isNaN())return new r(NaN);if(e.isZero())return t;if(t.isZero())return e;if(e.eq(t))return new r(0);var n=new r(-1);return e.eq(n)?zo(t):t.eq(n)?zo(e):e.isFinite()&&t.isFinite()?qo(e,t,(function(e,t){return e^t})):e.isFinite()||t.isFinite()?new r(e.isNegative()===t.isNegative()?1/0:-1/0):n}function Lo(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw new Error("Integers expected in function leftShift");var r=e.constructor;return e.isNaN()||t.isNaN()||t.isNegative()&&!t.isZero()?new r(NaN):e.isZero()||t.isZero()?e:e.isFinite()||t.isFinite()?t.lt(55)?e.times(Math.pow(2,t.toNumber())+""):e.times(new r(2).pow(t)):new r(NaN)}function Uo(e,t){if(e.isFinite()&&!e.isInteger()||t.isFinite()&&!t.isInteger())throw new Error("Integers expected in function rightArithShift");var r=e.constructor;return e.isNaN()||t.isNaN()||t.isNegative()&&!t.isZero()?new r(NaN):e.isZero()||t.isZero()?e:t.isFinite()?t.lt(55)?e.div(Math.pow(2,t.toNumber())+"").floor():e.div(new r(2).pow(t)).floor():e.isNegative()?new r(-1):e.isFinite()?new r(0):new r(NaN)}r(4490);var $o="number, number";function Ho(e,t){if(!V(e)||!V(t))throw new Error("Integers expected in function bitAnd");return e&t}function Go(e){if(!V(e))throw new Error("Integer expected in function bitNot");return~e}function Vo(e,t){if(!V(e)||!V(t))throw new Error("Integers expected in function bitOr");return e|t}function Zo(e,t){if(!V(e)||!V(t))throw new Error("Integers expected in function bitXor");return e^t}function Wo(e,t){if(!V(e)||!V(t))throw new Error("Integers expected in function leftShift");return e<<t}function Yo(e,t){if(!V(e)||!V(t))throw new Error("Integers expected in function rightArithShift");return e>>t}function Jo(e,t){if(!V(e)||!V(t))throw new Error("Integers expected in function rightLogShift");return e>>>t}Ho.signature=$o,Go.signature="number",Vo.signature=$o,Zo.signature=$o,Wo.signature=$o,Yo.signature=$o,Jo.signature=$o;var Xo="bitAnd",Qo=Se(Xo,["typed","matrix","equalScalar","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.concat,a=Za({typed:t,equalScalar:n}),o=co({typed:t,equalScalar:n}),u=Sa({typed:t,equalScalar:n}),s=Qa({typed:t,matrix:r,concat:i});return t(Xo,{"number, number":Ho,"BigNumber, BigNumber":Io},s({SS:o,DS:a,Ss:u}))})),Ko="bitNot",eu=Se(Ko,["typed"],(function(e){var t=e.typed;return t(Ko,{number:Go,BigNumber:zo,"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),tu="bitOr",ru=Se(tu,["typed","matrix","equalScalar","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.DenseMatrix,a=e.concat,o=eo({typed:t}),u=to({typed:t,equalScalar:n}),s=ro({typed:t,DenseMatrix:i}),c=Qa({typed:t,matrix:r,concat:a});return t(tu,{"number, number":Vo,"BigNumber, BigNumber":Ro},c({SS:u,DS:o,Ss:s}))})),nu=Se("matAlgo07xSSf",["typed","DenseMatrix"],(function(e){var t=e.typed,r=e.DenseMatrix;return function(e,i,a){var o=e._size,u=e._datatype||void 0===e._data?e._datatype:e.getDataType(),s=i._size,c=i._datatype||void 0===i._data?i._datatype:i.getDataType();if(o.length!==s.length)throw new un(o.length,s.length);if(o[0]!==s[0]||o[1]!==s[1])throw new RangeError("Dimension mismatch. Matrix A ("+o+") must match Matrix B ("+s+")");var f,l,p,m=o[0],h=o[1],d=0,v=a;"string"==typeof u&&u===c&&"mixed"!==u&&(f=u,d=t.convert(0,f),v=t.find(a,[f,f]));var y=[];for(l=0;l<m;l++)y[l]=[];var g=[],x=[],b=[],w=[];for(p=0;p<h;p++){var D=p+1;for(n(e,p,b,g,D),n(i,p,w,x,D),l=0;l<m;l++){var N=b[l]===D?g[l]:d,E=w[l]===D?x[l]:d;y[l][p]=v(N,E)}}return new r({data:y,size:[m,h],datatype:u===e._datatype&&c===i._datatype?f:void 0})};function n(e,t,r,n,i){for(var a=e._values,o=e._index,u=e._ptr,s=u[t],c=u[t+1];s<c;s++){var f=o[s];r[f]=i,n[f]=a[s]}}})),iu="bitXor",au=Se(iu,["typed","matrix","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.DenseMatrix,i=e.concat,a=Wa({typed:t}),o=nu({typed:t,DenseMatrix:n}),u=Ca({typed:t,DenseMatrix:n}),s=Qa({typed:t,matrix:r,concat:i});return t(iu,{"number, number":Zo,"BigNumber, BigNumber":Po},s({SS:o,DS:a,Ss:u}))})),ou=Se("arg",["typed"],(function(e){var t=e.typed;return t("arg",{number:function(e){return Math.atan2(0,e)},BigNumber:function(e){return e.constructor.atan2(0,e)},Complex:function(e){return e.arg()},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),uu="conj",su=Se(uu,["typed"],(function(e){var t=e.typed;return t(uu,{"number | BigNumber | Fraction":function(e){return e},Complex:function(e){return e.conjugate()},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),cu=Se("im",["typed"],(function(e){var t=e.typed;return t("im",{number:function(){return 0},"BigNumber | Fraction":function(e){return e.mul(0)},Complex:function(e){return e.im},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),fu=Se("re",["typed"],(function(e){var t=e.typed;return t("re",{"number | BigNumber | Fraction":function(e){return e},Complex:function(e){return e.re},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),lu="number, number";function pu(e){return!e}function mu(e,t){return!(!e&&!t)}function hu(e,t){return!!e!=!!t}function du(e,t){return!(!e||!t)}pu.signature="number",mu.signature=lu,hu.signature=lu,du.signature=lu;var vu=Se("not",["typed"],(function(e){var t=e.typed;return t("not",{"null | undefined":function(){return!0},number:pu,Complex:function(e){return 0===e.re&&0===e.im},BigNumber:function(e){return e.isZero()||e.isNaN()},Unit:t.referToSelf((function(e){return function(r){return t.find(e,r.valueType())(r.value)}})),"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),yu=Se("or",["typed","matrix","equalScalar","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.DenseMatrix,a=e.concat,o=Wa({typed:t}),u=Ya({typed:t,equalScalar:n}),s=Ca({typed:t,DenseMatrix:i}),c=Qa({typed:t,matrix:r,concat:a});return t("or",{"number, number":mu,"Complex, Complex":function(e,t){return 0!==e.re||0!==e.im||0!==t.re||0!==t.im},"BigNumber, BigNumber":function(e,t){return!e.isZero()&&!e.isNaN()||!t.isZero()&&!t.isNaN()},"Unit, Unit":t.referToSelf((function(e){return function(t,r){return e(t.value||0,r.value||0)}}))},c({SS:u,DS:o,Ss:s}))})),gu=Se("xor",["typed","matrix","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.DenseMatrix,i=e.concat,a=Wa({typed:t}),o=nu({typed:t,DenseMatrix:n}),u=Ca({typed:t,DenseMatrix:n}),s=Qa({typed:t,matrix:r,concat:i});return t("xor",{"number, number":hu,"Complex, Complex":function(e,t){return(0!==e.re||0!==e.im)!=(0!==t.re||0!==t.im)},"BigNumber, BigNumber":function(e,t){return(!e.isZero()&&!e.isNaN())!=(!t.isZero()&&!t.isNaN())},"Unit, Unit":t.referToSelf((function(e){return function(t,r){return e(t.value||0,r.value||0)}}))},s({SS:o,DS:a,Ss:u}))})),xu="concat",bu=Se(xu,["typed","matrix","isInteger"],(function(e){var t=e.typed,r=e.matrix,n=e.isInteger;return t(xu,{"...Array | Matrix | number | BigNumber":function(e){var t,o,u=e.length,s=-1,c=!1,f=[];for(t=0;t<u;t++){var p=e[t];if(l(p)&&(c=!0),i(p)||a(p)){if(t!==u-1)throw new Error("Dimension must be specified as last argument");if(o=s,s=p.valueOf(),!n(s))throw new TypeError("Integer number expected for dimension");if(s<0||t>0&&s>o)throw new sn(s,o+1)}else{var m=ye(p).valueOf(),h=cn(m);if(f[t]=m,o=s,s=h.length-1,t>0&&s!==o)throw new un(o+1,s+1)}}if(0===f.length)throw new SyntaxError("At least one matrix expected");for(var d=f.shift();f.length;)d=In(d,f.shift(),s);return c?r(d):d},"...string":function(e){return e.join("")}})})),wu="column",Du=Se(wu,["typed","Index","matrix","range"],(function(e){var t=e.typed,r=e.Index,n=e.matrix,i=e.range;return t(wu,{"Matrix, number":a,"Array, number":function(e,t){return a(n(ye(e)),t).valueOf()}});function a(e,t){if(2!==e.size().length)throw new Error("Only two dimensional matrix is supported");mn(t,e.size()[1]);var a=i(0,e.size()[0]),o=new r(a,t),u=e.subset(o);return l(u)?u:n([[u]])}})),Nu="count",Eu=Se(Nu,["typed","size","prod"],(function(e){var t=e.typed,r=e.size,n=e.prod;return t(Nu,{string:function(e){return e.length},"Matrix | Array":function(e){return n(r(e))}})})),Au="cross",Su=Se(Au,["typed","matrix","subtract","multiply"],(function(e){var t=e.typed,r=e.matrix,n=e.subtract,i=e.multiply;return t(Au,{"Matrix, Matrix":function(e,t){return r(a(e.toArray(),t.toArray()))},"Matrix, Array":function(e,t){return r(a(e.toArray(),t))},"Array, Matrix":function(e,t){return r(a(e,t.toArray()))},"Array, Array":a});function a(e,t){var r=Math.max(cn(e).length,cn(t).length);e=bn(e),t=bn(t);var a=cn(e),o=cn(t);if(1!==a.length||1!==o.length||3!==a[0]||3!==o[0])throw new RangeError("Vectors with length 3 expected (Size A = ["+a.join(", ")+"], B = ["+o.join(", ")+"])");var u=[n(i(e[1],t[2]),i(e[2],t[1])),n(i(e[2],t[0]),i(e[0],t[2])),n(i(e[0],t[1]),i(e[1],t[0]))];return r>1?[u]:u}})),Cu="diag",Mu=Se(Cu,["typed","matrix","DenseMatrix","SparseMatrix"],(function(e){var t=e.typed,r=e.matrix,n=e.DenseMatrix,i=e.SparseMatrix;return t(Cu,{Array:function(e){return a(e,0,cn(e),null)},"Array, number":function(e,t){return a(e,t,cn(e),null)},"Array, BigNumber":function(e,t){return a(e,t.toNumber(),cn(e),null)},"Array, string":function(e,t){return a(e,0,cn(e),t)},"Array, number, string":function(e,t,r){return a(e,t,cn(e),r)},"Array, BigNumber, string":function(e,t,r){return a(e,t.toNumber(),cn(e),r)},Matrix:function(e){return a(e,0,e.size(),e.storage())},"Matrix, number":function(e,t){return a(e,t,e.size(),e.storage())},"Matrix, BigNumber":function(e,t){return a(e,t.toNumber(),e.size(),e.storage())},"Matrix, string":function(e,t){return a(e,0,e.size(),t)},"Matrix, number, string":function(e,t,r){return a(e,t,e.size(),r)},"Matrix, BigNumber, string":function(e,t,r){return a(e,t.toNumber(),e.size(),r)}});function a(e,t,a,o){if(!V(t))throw new TypeError("Second parameter in function diag must be an integer");var u=t>0?t:0,s=t<0?-t:0;switch(a.length){case 1:return function(e,t,r,a,o,u){var s=[a+o,a+u];if(r&&"sparse"!==r&&"dense"!==r)throw new TypeError("Unknown matrix type ".concat(r,'"'));var c="sparse"===r?i.diagonal(s,e,t):n.diagonal(s,e,t);return null!==r?c:c.valueOf()}(e,t,o,a[0],s,u);case 2:return function(e,t,n,i,a,o){if(l(e)){var u=e.diagonal(t);return null!==n?n!==u.storage()?r(u,n):u:u.valueOf()}for(var s=Math.min(i[0]-a,i[1]-o),c=[],f=0;f<s;f++)c[f]=e[f+a][f+o];return null!==n?r(c):c}(e,t,o,a,s,u)}throw new RangeError("Matrix for function diag must be 2 dimensional")}}));function Fu(e,t,r,n,i){if(G.isTypedFunction(e)){var a=[t,r,n],o=G.resolve(e,a);if(o)return l(o.implementation,a);var u=[t,r],s=G.resolve(e,u);if(s)return l(s.implementation,u);var c=[t],f=G.resolve(e,c);return f?l(f.implementation,c):l(e,a)}return e(t,r,n);function l(a,o){try{return a.apply(a,o)}catch(a){var u;if(a instanceof TypeError&&"wrongType"===(null===(u=a.data)||void 0===u?void 0:u.category)){var s=[];throw s.push("value: ".concat(H(t))),o.length>=2&&s.push("index: ".concat(H(r))),o.length>=3&&s.push("array: ".concat(H(n))),new TypeError("Function ".concat(i," cannot apply callback arguments ")+"".concat(e.name,"(").concat(s.join(", "),") at index ").concat(JSON.stringify(r)))}throw new TypeError("Function ".concat(i," cannot apply callback arguments ")+"to function ".concat(e.name,": ").concat(a.message))}}}var Ou=Se("filter",["typed"],(function(e){return(0,e.typed)("filter",{"Array, function":Tu,"Matrix, function":function(e,t){return e.create(Tu(e.toArray(),t))},"Array, RegExp":Mn,"Matrix, RegExp":function(e,t){return e.create(Mn(e.toArray(),t))}})}));function Tu(e,t){return Cn(e,(function(e,r,n){return Fu(t,e,[r],n,"filter")}))}var _u="flatten",Bu=Se(_u,["typed","matrix"],(function(e){var t=e.typed,r=e.matrix;return t(_u,{Array:function(e){return En(e)},Matrix:function(e){var t=En(e.toArray());return r(t)}})})),ku="forEach",Iu=Se(ku,["typed"],(function(e){return(0,e.typed)(ku,{"Array, function":zu,"Matrix, function":function(e,t){e.forEach(t)}})}));function zu(e,t){!function r(n,i){if(!Array.isArray(n))return Fu(t,n,i,e,"forEach");Sn(n,(function(e,t){r(e,i.concat(t))}))}(e,[])}var Ru="getMatrixDataType",qu=Se(Ru,["typed"],(function(e){return(0,e.typed)(Ru,{Array:function(e){return _n(e,H)},Matrix:function(e){return e.getDataType()}})})),ju="identity",Pu=Se(ju,["typed","config","matrix","BigNumber","DenseMatrix","SparseMatrix"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.BigNumber,o=e.DenseMatrix,u=e.SparseMatrix;return t(ju,{"":function(){return"Matrix"===r.matrix?n([]):[]},string:function(e){return n(e)},"number | BigNumber":function(e){return c(e,e,"Matrix"===r.matrix?"dense":void 0)},"number | BigNumber, string":function(e,t){return c(e,e,t)},"number | BigNumber, number | BigNumber":function(e,t){return c(e,t,"Matrix"===r.matrix?"dense":void 0)},"number | BigNumber, number | BigNumber, string":function(e,t,r){return c(e,t,r)},Array:function(e){return s(e)},"Array, string":function(e,t){return s(e,t)},Matrix:function(e){return s(e.valueOf(),e.storage())},"Matrix, string":function(e,t){return s(e.valueOf(),t)}});function s(e,t){switch(e.length){case 0:return t?n(t):[];case 1:return c(e[0],e[0],t);case 2:return c(e[0],e[1],t);default:throw new Error("Vector containing two values expected")}}function c(e,t,r){var n=a(e)||a(t)?i:null;if(a(e)&&(e=e.toNumber()),a(t)&&(t=t.toNumber()),!V(e)||e<1)throw new Error("Parameters in function identity must be positive integers");if(!V(t)||t<1)throw new Error("Parameters in function identity must be positive integers");var s=n?new i(1):1,c=n?new n(0):0,f=[e,t];if(r){if("sparse"===r)return u.diagonal(f,s,0,c);if("dense"===r)return o.diagonal(f,s,0,c);throw new TypeError('Unknown matrix type "'.concat(r,'"'))}for(var l=dn([],f,c),p=e<t?e:t,m=0;m<p;m++)l[m][m]=s;return l}})),Lu="kron",Uu=Se(Lu,["typed","matrix","multiplyScalar"],(function(e){var t=e.typed,r=e.matrix,n=e.multiplyScalar;return t(Lu,{"Matrix, Matrix":function(e,t){return r(i(e.toArray(),t.toArray()))},"Matrix, Array":function(e,t){return r(i(e.toArray(),t))},"Array, Matrix":function(e,t){return r(i(e,t.toArray()))},"Array, Array":i});function i(e,t){if(1===cn(e).length&&(e=[e]),1===cn(t).length&&(t=[t]),cn(e).length>2||cn(t).length>2)throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = "+JSON.stringify(e.length)+", y = "+JSON.stringify(t.length)+")");var r=[],i=[];return e.map((function(e){return t.map((function(t){return i=[],r.push(i),e.map((function(e){return t.map((function(t){return i.push(n(e,t))}))}))}))}))&&r}})),$u=Se("map",["typed"],(function(e){return(0,e.typed)("map",{"Array, function":Hu,"Matrix, function":function(e,t){return e.map(t)}})}));function Hu(e,t){return function r(n,i){return Array.isArray(n)?n.map((function(e,t){return r(e,i.concat(t))})):Fu(t,n,i,e,"map")}(e,[])}var Gu="diff",Vu=Se(Gu,["typed","matrix","subtract","number"],(function(e){var t=e.typed,r=e.matrix,n=e.subtract,i=e.number;return t(Gu,{"Array | Matrix":function(e){return l(e)?r(o(e.toArray())):o(e)},"Array | Matrix, number":function(e,t){if(!V(t))throw new RangeError("Dimension must be a whole number");return l(e)?r(a(e.toArray(),t)):a(e,t)},"Array, BigNumber":t.referTo("Array,number",(function(e){return function(t,r){return e(t,i(r))}})),"Matrix, BigNumber":t.referTo("Matrix,number",(function(e){return function(t,r){return e(t,i(r))}}))});function a(e,t){if(l(e)&&(e=e.toArray()),!Array.isArray(e))throw RangeError("Array/Matrix does not have that many dimensions");if(t>0){var r=[];return e.forEach((function(e){r.push(a(e,t-1))})),r}if(0===t)return o(e);throw RangeError("Cannot have negative dimension")}function o(e){for(var t=[],r=e.length,n=1;n<r;n++)t.push(u(e[n-1],e[n]));return t}function u(e,t){l(e)&&(e=e.toArray()),l(t)&&(t=t.toArray());var r=Array.isArray(e),i=Array.isArray(t);if(r&&i)return function(e,t){if(e.length!==t.length)throw RangeError("Not all sub-arrays have the same length");for(var r=[],n=e.length,i=0;i<n;i++)r.push(u(e[i],t[i]));return r}(e,t);if(!r&&!i)return n(t,e);throw TypeError("Cannot calculate difference between 1 array and 1 non-array")}})),Zu=Se("ones",["typed","config","matrix","BigNumber"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.BigNumber;return t("ones",{"":function(){return"Array"===r.matrix?o([]):o([],"default")},"...number | BigNumber | string":function(e){if("string"==typeof e[e.length-1]){var t=e.pop();return o(e,t)}return"Array"===r.matrix?o(e):o(e,"default")},Array:o,Matrix:function(e){var t=e.storage();return o(e.valueOf(),t)},"Array | Matrix, string":function(e,t){return o(e.valueOf(),t)}});function o(e,t){var r=function(e){var t=!1;return e.forEach((function(e,r,n){a(e)&&(t=!0,n[r]=e.toNumber())})),t}(e),o=r?new i(1):1;if(function(e){e.forEach((function(e){if("number"!=typeof e||!V(e)||e<0)throw new Error("Parameters in function ones must be positive integers")}))}(e),t){var u=n(t);return e.length>0?u.resize(e,o):u}var s=[];return e.length>0?dn(s,e,o):s}}));function Wu(){throw new Error('No "bignumber" implementation available')}function Yu(){throw new Error('No "fraction" implementation available')}function Ju(){throw new Error('No "matrix" implementation available')}var Xu="range",Qu=Se(Xu,["typed","config","?matrix","?bignumber","smaller","smallerEq","larger","largerEq","add","isPositive"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.bignumber,a=e.smaller,o=e.smallerEq,u=e.larger,s=e.largerEq,c=e.add,f=e.isPositive;return t(Xu,{string:p,"string, boolean":p,"number, number":function(e,t){return l(m(e,t,1,!1))},"number, number, number":function(e,t,r){return l(m(e,t,r,!1))},"number, number, boolean":function(e,t,r){return l(m(e,t,1,r))},"number, number, number, boolean":function(e,t,r,n){return l(m(e,t,r,n))},"BigNumber, BigNumber":function(e,t){return l(m(e,t,new(0,e.constructor)(1),!1))},"BigNumber, BigNumber, BigNumber":function(e,t,r){return l(m(e,t,r,!1))},"BigNumber, BigNumber, boolean":function(e,t,r){return l(m(e,t,new(0,e.constructor)(1),r))},"BigNumber, BigNumber, BigNumber, boolean":function(e,t,r,n){return l(m(e,t,r,n))},"Unit, Unit, Unit":function(e,t,r){return l(m(e,t,r,!1))},"Unit, Unit, Unit, boolean":function(e,t,r,n){return l(m(e,t,r,n))}});function l(e){return"Matrix"===r.matrix?n?n(e):Ju():e}function p(e,t){var n=function(e){var t=e.split(":").map((function(e){return Number(e)}));if(t.some((function(e){return isNaN(e)})))return null;switch(t.length){case 2:return{start:t[0],end:t[1],step:1};case 3:return{start:t[0],end:t[2],step:t[1]};default:return null}}(e);if(!n)throw new SyntaxError('String "'+e+'" is no valid range');return"BigNumber"===r.number?(void 0===i&&Wu(),l(m(i(n.start),i(n.end),i(n.step)))):l(m(n.start,n.end,n.step,t))}function m(e,t,r,n){for(var i=[],l=f(r)?n?o:a:n?s:u,p=e;l(p,t);)i.push(p),p=c(p,r);return i}})),Ku="reshape",es=Se(Ku,["typed","isInteger","matrix"],(function(e){var t=e.typed,r=e.isInteger;return t(Ku,{"Matrix, Array":function(e,t){return e.reshape(t,!0)},"Array, Array":function(e,t){return t.forEach((function(e){if(!r(e))throw new TypeError("Invalid size for dimension: "+e)})),yn(e,t)}})})),ts=Se("resize",["config","matrix"],(function(e){var t=e.config,r=e.matrix;return function(e,n,i){if(2!==arguments.length&&3!==arguments.length)throw new no("resize",arguments.length,2,3);if(l(n)&&(n=n.valueOf()),a(n[0])&&(n=n.map((function(e){return a(e)?e.toNumber():e}))),l(e))return e.resize(n,i,!0);if("string"==typeof e)return function(e,t,r){if(void 0!==r){if("string"!=typeof r||1!==r.length)throw new TypeError("Single character expected as defaultValue")}else r=" ";if(1!==t.length)throw new un(t.length,1);var n=t[0];if("number"!=typeof n||!V(n))throw new TypeError("Invalid size, must contain positive integers (size: "+en(t)+")");if(e.length>n)return e.substring(0,n);if(e.length<n){for(var i=e,a=0,o=n-e.length;a<o;a++)i+=r;return i}return e}(e,n,i);var o=!Array.isArray(e)&&"Array"!==t.matrix;if(0===n.length){for(;Array.isArray(e);)e=e[0];return ye(e)}Array.isArray(e)||(e=[e]);var u=dn(e=ye(e),n,i);return o?r(u):u}})),rs="rotate",ns=Se(rs,["typed","multiply","rotationMatrix"],(function(e){var t=e.typed,r=e.multiply,n=e.rotationMatrix;return t(rs,{"Array , number | BigNumber | Complex | Unit":function(e,t){return i(e,2),r(n(t),e).toArray()},"Matrix , number | BigNumber | Complex | Unit":function(e,t){return i(e,2),r(n(t),e)},"Array, number | BigNumber | Complex | Unit, Array | Matrix":function(e,t,a){return i(e,3),r(n(t,a),e)},"Matrix, number | BigNumber | Complex | Unit, Array | Matrix":function(e,t,a){return i(e,3),r(n(t,a),e)}});function i(e,t){var r=Array.isArray(e)?cn(e):e.size();if(r.length>2)throw new RangeError("Vector must be of dimensions 1x".concat(t));if(2===r.length&&1!==r[1])throw new RangeError("Vector must be of dimensions 1x".concat(t));if(r[0]!==t)throw new RangeError("Vector must be of dimensions 1x".concat(t))}})),is="rotationMatrix",as=Se(is,["typed","config","multiplyScalar","addScalar","unaryMinus","norm","matrix","BigNumber","DenseMatrix","SparseMatrix","cos","sin"],(function(e){var t=e.typed,r=e.config,n=e.multiplyScalar,i=e.addScalar,o=e.unaryMinus,u=e.norm,s=e.BigNumber,c=e.matrix,f=e.DenseMatrix,l=e.SparseMatrix,p=e.cos,m=e.sin;return t(is,{"":function(){return"Matrix"===r.matrix?c([]):[]},string:function(e){return c(e)},"number | BigNumber | Complex | Unit":function(e){return h(e,"Matrix"===r.matrix?"dense":void 0)},"number | BigNumber | Complex | Unit, string":function(e,t){return h(e,t)},"number | BigNumber | Complex | Unit, Array":function(e,t){var r=c(t);return d(r),g(e,r,void 0)},"number | BigNumber | Complex | Unit, Matrix":function(e,t){d(t);var n=t.storage()||("Matrix"===r.matrix?"dense":void 0);return g(e,t,n)},"number | BigNumber | Complex | Unit, Array, string":function(e,t,r){var n=c(t);return d(n),g(e,n,r)},"number | BigNumber | Complex | Unit, Matrix, string":function(e,t,r){return d(t),g(e,t,r)}});function h(e,t){var r=a(e)?new s(-1):-1,i=p(e),o=m(e);return y([[i,n(r,o)],[o,i]],t)}function d(e){var t=e.size();if(t.length<1||3!==t[0])throw new RangeError("Vector must be of dimensions 1x3")}function v(e){return e.reduce((function(e,t){return n(e,t)}))}function y(e,t){if(t){if("sparse"===t)return new l(e);if("dense"===t)return new f(e);throw new TypeError('Unknown matrix type "'.concat(t,'"'))}return e}function g(e,t,r){var n=u(t);if(0===n)throw new RangeError("Rotation around zero vector");var c=a(e)?s:null,f=c?new c(1):1,l=c?new c(-1):-1,h=c?new c(t.get([0])/n):t.get([0])/n,d=c?new c(t.get([1])/n):t.get([1])/n,g=c?new c(t.get([2])/n):t.get([2])/n,x=p(e),b=i(f,o(x)),w=m(e);return y([[i(x,v([h,h,b])),i(v([h,d,b]),v([l,g,w])),i(v([h,g,b]),v([d,w]))],[i(v([h,d,b]),v([g,w])),i(x,v([d,d,b])),i(v([d,g,b]),v([l,h,w]))],[i(v([h,g,b]),v([l,d,w])),i(v([d,g,b]),v([h,w])),i(x,v([g,g,b]))]],r)}})),os=Se("row",["typed","Index","matrix","range"],(function(e){var t=e.typed,r=e.Index,n=e.matrix,i=e.range;return t("row",{"Matrix, number":a,"Array, number":function(e,t){return a(n(ye(e)),t).valueOf()}});function a(e,t){if(2!==e.size().length)throw new Error("Only two dimensional matrix is supported");mn(t,e.size()[0]);var a=i(0,e.size()[1]),o=new r(t,a),u=e.subset(o);return l(u)?u:n([[u]])}})),us="size",ss=Se(us,["typed","config","?matrix"],(function(e){var t=e.typed,r=e.config,n=e.matrix;return t(us,{Matrix:function(e){return e.create(e.size())},Array:cn,string:function(e){return"Array"===r.matrix?[e.length]:n([e.length])},"number | Complex | BigNumber | Unit | boolean | null":function(e){return"Array"===r.matrix?[]:n?n([]):Ju()}})})),cs="squeeze",fs=Se(cs,["typed","matrix"],(function(e){var t=e.typed,r=e.matrix;return t(cs,{Array:function(e){return bn(ye(e))},Matrix:function(e){var t=bn(e.toArray());return Array.isArray(t)?r(t):t},any:function(e){return ye(e)}})})),ls="subset",ps=Se(ls,["typed","matrix","zeros","add"],(function(e){var t=e.typed,r=e.matrix,n=e.zeros,i=e.add;return t(ls,{"Matrix, Index":function(e,t){return hn(t)?r():(pn(e,t),e.subset(t))},"Array, Index":t.referTo("Matrix, Index",(function(e){return function(t,n){var i=e(r(t),n);return n.isScalar()?i:i.valueOf()}})),"Object, Index":ds,"string, Index":ms,"Matrix, Index, any, any":function(e,t,r,a){return hn(t)?e:(pn(e,t),e.clone().subset(t,function(e,t){if("string"==typeof e)throw new Error("can't boradcast a string");if(t._isScalar)return e;var r=t.size();if(!r.every((function(e){return e>0})))return e;try{return i(e,n(r))}catch(t){return e}}(r,t),a))},"Array, Index, any, any":t.referTo("Matrix, Index, any, any",(function(e){return function(t,n,i,a){var o=e(r(t),n,i,a);return o.isMatrix?o.valueOf():o}})),"Array, Index, any":t.referTo("Matrix, Index, any, any",(function(e){return function(t,n,i){return e(r(t),n,i,void 0).valueOf()}})),"Matrix, Index, any":t.referTo("Matrix, Index, any, any",(function(e){return function(t,r,n){return e(t,r,n,void 0)}})),"string, Index, string":hs,"string, Index, string, string":hs,"Object, Index, any":vs})}));function ms(e,t){if(!v(t))throw new TypeError("Index expected");if(hn(t))return"";if(pn(Array.from(e),t),1!==t.size().length)throw new un(t.size().length,1);var r=e.length;mn(t.min()[0],r),mn(t.max()[0],r);var n=t.dimension(0),i="";return n.forEach((function(t){i+=e.charAt(t)})),i}function hs(e,t,r,n){if(!t||!0!==t.isIndex)throw new TypeError("Index expected");if(hn(t))return e;if(pn(Array.from(e),t),1!==t.size().length)throw new un(t.size().length,1);if(void 0!==n){if("string"!=typeof n||1!==n.length)throw new TypeError("Single character expected as defaultValue")}else n=" ";var i=t.dimension(0);if(i.size()[0]!==r.length)throw new un(i.size()[0],r.length);var a=e.length;mn(t.min()[0]),mn(t.max()[0]);for(var o=[],u=0;u<a;u++)o[u]=e.charAt(u);if(i.forEach((function(e,t){o[e]=r.charAt(t[0])})),o.length>a)for(var s=a-1,c=o.length;s<c;s++)o[s]||(o[s]=n);return o.join("")}function ds(e,t){if(!hn(t)){if(1!==t.size().length)throw new un(t.size(),1);var r=t.dimension(0);if("string"!=typeof r)throw new TypeError("String expected as index to retrieve an object property");return ze(e,r)}}function vs(e,t,r){if(hn(t))return e;if(1!==t.size().length)throw new un(t.size(),1);var n=t.dimension(0);if("string"!=typeof n)throw new TypeError("String expected as index to retrieve an object property");var i=ye(e);return Re(i,n,r),i}var ys="transpose",gs=Se(ys,["typed","matrix"],(function(e){var t=e.typed,r=e.matrix;return t(ys,{Array:function(e){return n(r(e)).valueOf()},Matrix:n,any:ye});function n(e){var t,r=e.size();switch(r.length){case 1:t=e.clone();break;case 2:var n=r[0],i=r[1];if(0===i)throw new RangeError("Cannot transpose a 2D matrix with no columns (size: "+en(r)+")");switch(e.storage()){case"dense":t=function(e,t,r){for(var n,i=e._data,a=[],o=0;o<r;o++){n=a[o]=[];for(var u=0;u<t;u++)n[u]=ye(i[u][o])}return e.createDenseMatrix({data:a,size:[r,t],datatype:e._datatype})}(e,n,i);break;case"sparse":t=function(e,t,r){for(var n,i,a,o=e._values,u=e._index,s=e._ptr,c=o?[]:void 0,f=[],l=[],p=[],m=0;m<t;m++)p[m]=0;for(n=0,i=u.length;n<i;n++)p[u[n]]++;for(var h=0,d=0;d<t;d++)l.push(h),h+=p[d],p[d]=l[d];for(l.push(h),a=0;a<r;a++)for(var v=s[a],y=s[a+1],g=v;g<y;g++){var x=p[u[g]]++;f[x]=a,o&&(c[x]=ye(o[g]))}return e.createSparseMatrix({values:c,index:f,ptr:l,size:[r,t],datatype:e._datatype})}(e,n,i)}break;default:throw new RangeError("Matrix must be a vector or two dimensional (size: "+en(r)+")")}return t}})),xs="ctranspose",bs=Se(xs,["typed","transpose","conj"],(function(e){var t=e.typed,r=e.transpose,n=e.conj;return t(xs,{any:function(e){return n(r(e))}})})),ws="zeros",Ds=Se(ws,["typed","config","matrix","BigNumber"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.BigNumber;return t(ws,{"":function(){return"Array"===r.matrix?o([]):o([],"default")},"...number | BigNumber | string":function(e){if("string"==typeof e[e.length-1]){var t=e.pop();return o(e,t)}return"Array"===r.matrix?o(e):o(e,"default")},Array:o,Matrix:function(e){var t=e.storage();return o(e.valueOf(),t)},"Array | Matrix, string":function(e,t){return o(e.valueOf(),t)}});function o(e,t){var r=function(e){var t=!1;return e.forEach((function(e,r,n){a(e)&&(t=!0,n[r]=e.toNumber())})),t}(e),o=r?new i(0):0;if(function(e){e.forEach((function(e){if("number"!=typeof e||!V(e)||e<0)throw new Error("Parameters in function zeros must be positive integers")}))}(e),t){var u=n(t);return e.length>0?u.resize(e,o):u}var s=[];return e.length>0?dn(s,e,o):s}})),Ns=Se("fft",["typed","matrix","addScalar","multiplyScalar","divideScalar","exp","tau","i","dotDivide","conj","pow","ceil","log2"],(function(e){var t=e.typed,r=(e.matrix,e.addScalar),n=e.multiplyScalar,i=e.divideScalar,a=e.exp,o=e.tau,u=e.i,s=e.dotDivide,c=e.conj,f=e.pow,l=e.ceil,p=e.log2;return t("fft",{Array:m,Matrix:function(e){return e.create(m(e.toArray()))}});function m(e){var t=cn(e);return 1===t.length?d(e,t[0]):h(e.map((function(e){return m(e,t.slice(1))})),0)}function h(e,t){var r=cn(e);if(0!==t)return new Array(r[0]).fill(0).map((function(r,n){return h(e[n],t-1)}));if(1===r.length)return d(e);function n(e){var t=cn(e);return new Array(t[1]).fill(0).map((function(r,n){return new Array(t[0]).fill(0).map((function(t,r){return e[r][n]}))}))}return n(h(n(e),1))}function d(e){var t=e.length;if(1===t)return[e[0]];if(t%2==0){for(var h=[].concat(Te(d(e.filter((function(e,t){return t%2==0})))),Te(d(e.filter((function(e,t){return t%2==1}))))),v=0;v<t/2;v++){var y=h[v],g=n(h[v+t/2],a(n(n(o,u),i(-v,t))));h[v]=r(y,g),h[v+t/2]=r(y,n(-1,g))}return h}return function(e){for(var t=e.length,r=a(i(n(-1,n(u,o)),t)),h=[],v=1-t;v<t;v++)h.push(f(r,i(f(v,2),2)));for(var y=f(2,l(p(t+t-1))),g=[].concat(Te(new Array(t).fill(0).map((function(r,i){return n(e[i],h[t-1+i])}))),Te(new Array(y-t).fill(0))),x=[].concat(Te(new Array(t+t-1).fill(0).map((function(e,t){return i(1,h[t])}))),Te(new Array(y-(t+t-1)).fill(0))),b=d(g),w=d(x),D=new Array(y).fill(0).map((function(e,t){return n(b[t],w[t])})),N=s(c(m(c(D))),y),E=[],A=t-1;A<t+t-1;A++)E.push(n(N[A],h[A]));return E}(e)}})),Es="ifft",As=Se(Es,["typed","fft","dotDivide","conj"],(function(e){var t=e.typed,r=e.fft,n=e.dotDivide,i=e.conj;return t(Es,{"Array | Matrix":function(e){var t=l(e)?e.size():cn(e);return n(i(r(i(e))),t.reduce((function(e,t){return e*t}),1))}})}));function Ss(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}r(7945),r(3851),r(1278);var Cs=Se("solveODE",["typed","add","subtract","multiply","divide","max","map","abs","isPositive","isNegative","larger","smaller","matrix","bignumber","unaryMinus"],(function(e){var t=e.typed,r=e.add,n=e.subtract,o=e.multiply,u=e.divide,c=e.max,f=e.map,l=e.abs,p=e.isPositive,m=e.isNegative,h=e.larger,d=e.smaller,v=e.matrix,y=e.bignumber,g=e.unaryMinus;function x(e){return function(t,i,v,x){if(2!==i.length||!i.every(N)&&!i.every(s))throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');var b=i[0],w=i[1],D=h(w,b),E=x.firstStep;if(void 0!==E&&!p(E))throw new Error('"firstStep" must be positive');var A=x.maxStep;if(void 0!==A&&!p(A))throw new Error('"maxStep" must be positive');var S=x.minStep;if(S&&m(S))throw new Error('"minStep" must be positive or zero');var C=[b,w,E,S,A].filter((function(e){return void 0!==e}));if(!C.every(N)&&!C.every(s))throw new Error('Inconsistent type of "t" dependant variables');for(var M=x.tol?x.tol:1e-4,F=x.minDelta?x.minDelta:.2,O=x.maxDelta?x.maxDelta:5,T=x.maxIter?x.maxIter:1e4,_=[b,w].concat(Te(v),[A,S]).some(a),B=Aa(_?[y(e.a),y(e.c),y(e.b),y(e.bp)]:[e.a,e.c,e.b,e.bp],4),k=B[0],I=B[1],z=B[2],R=B[3],q=E?D?E:g(E):u(n(w,b),1),j=[b],P=[v],L=n(z,R),U=0,$=0,H=function(e){return e?d:h}(D),G=function(e){var t=e?h:d;return function(e,i,a){var o=r(e,a);return t(o,i)?n(i,e):a}}(D);H(j[U],w);){var V=[];q=G(j[U],w,q),V.push(t(j[U],P[U]));for(var Z=1;Z<I.length;++Z)V.push(t(r(j[U],o(I[Z],q)),r(P[U],o(q,k[Z],V))));var W=c(l(f(o(L,V),(function(e){return s(e)?e.value:e}))));W<M&&M/W>1/4&&(j.push(r(j[U],q)),P.push(r(P[U],o(q,z,V))),U++);var Y=.84*Math.pow(M/W,.2);if(d(Y,F)?Y=F:h(Y,O)&&(Y=O),Y=_?y(Y):Y,q=o(q,Y),A&&h(l(q),A)?q=D?A:g(A):S&&d(l(q),S)&&(q=D?S:g(S)),++$>T)throw new Error("Maximum number of iterations reached, try changing options")}return{t:j,y:P}}}function b(e,t,r,n){return x({a:[[],[.5],[0,3/4],[2/9,1/3,4/9]],c:[null,.5,3/4,1],b:[2/9,1/3,4/9,0],bp:[7/24,1/4,1/3,1/8]})(e,t,r,n)}function w(e,t,r,n){return x({a:[[],[.2],[3/40,9/40],[44/45,-56/15,32/9],[19372/6561,-25360/2187,64448/6561,-212/729],[9017/3168,-355/33,46732/5247,49/176,-5103/18656],[35/384,0,500/1113,125/192,-2187/6784,11/84]],c:[null,.2,.3,.8,8/9,1,1],b:[35/384,0,500/1113,125/192,-2187/6784,11/84,0],bp:[5179/57600,0,7571/16695,393/640,-92097/339200,187/2100,1/40]})(e,t,r,n)}function D(e,t,r,n){var i=n.method?n.method:"RK45",a={RK23:b,RK45:w};if(i.toUpperCase()in a){var o=function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?Ss(Object(r),!0).forEach((function(t){Va(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):Ss(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}({},n);return delete o.method,a[i.toUpperCase()](e,t,r,o)}var u=Object.keys(a).map((function(e){return'"'.concat(e,'"')})),s="".concat(u.slice(0,-1).join(", ")," and ").concat(u.slice(-1));throw new Error('Unavailable method "'.concat(i,'". Available methods are ').concat(s))}function N(e){return a(e)||i(e)}function E(e,t,r,n){var i=D(e,t.toArray(),r.toArray(),n);return{t:v(i.t),y:v(i.y)}}return t("solveODE",{"function, Array, Array, Object":D,"function, Matrix, Matrix, Object":E,"function, Array, Array":function(e,t,r){return D(e,t,r,{})},"function, Matrix, Matrix":function(e,t,r){return E(e,t,r,{})},"function, Array, number | BigNumber | Unit":function(e,t,r){var n=D(e,t,[r],{});return{t:n.t,y:n.y.map((function(e){return e[0]}))}},"function, Matrix, number | BigNumber | Unit":function(e,t,r){var n=D(e,t.toArray(),[r],{});return{t:v(n.t),y:v(n.y.map((function(e){return e[0]})))}},"function, Array, number | BigNumber | Unit, Object":function(e,t,r,n){var i=D(e,t,[r],n);return{t:i.t,y:i.y.map((function(e){return e[0]}))}},"function, Matrix, number | BigNumber | Unit, Object":function(e,t,r,n){var i=D(e,t.toArray(),[r],n);return{t:v(i.t),y:v(i.y.map((function(e){return e[0]})))}}})})),Ms=Se("erf",["typed"],(function(e){var t=e.typed;return t("name",{number:function(e){var t=Math.abs(e);return t>=Bs?Z(e):t<=Fs?Z(e)*function(e){var t,r=e*e,n=Ts[0][4]*r,i=r;for(t=0;t<3;t+=1)n=(n+Ts[0][t])*r,i=(i+_s[0][t])*r;return e*(n+Ts[0][3])/(i+_s[0][3])}(t):t<=4?Z(e)*(1-function(e){var t,r=Ts[1][8]*e,n=e;for(t=0;t<7;t+=1)r=(r+Ts[1][t])*e,n=(n+_s[1][t])*e;var i=(r+Ts[1][7])/(n+_s[1][7]),a=parseInt(16*e)/16,o=(e-a)*(e+a);return Math.exp(-a*a)*Math.exp(-o)*i}(t)):Z(e)*(1-function(e){var t,r=1/(e*e),n=Ts[2][5]*r,i=r;for(t=0;t<4;t+=1)n=(n+Ts[2][t])*r,i=(i+_s[2][t])*r;var a=r*(n+Ts[2][4])/(i+_s[2][4]);a=(Os-a)/e;var o=(e-(r=parseInt(16*e)/16))*(e+r);return Math.exp(-r*r)*Math.exp(-o)*a}(t))},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),Fs=.46875,Os=.5641895835477563,Ts=[[3.1611237438705655,113.86415415105016,377.485237685302,3209.3775891384694,.18577770618460315],[.5641884969886701,8.883149794388377,66.11919063714163,298.6351381974001,881.952221241769,1712.0476126340707,2051.0783778260716,1230.3393547979972,2.1531153547440383e-8],[.30532663496123236,.36034489994980445,.12578172611122926,.016083785148742275,.0006587491615298378,.016315387137302097]],_s=[[23.601290952344122,244.02463793444417,1282.6165260773723,2844.236833439171],[15.744926110709835,117.6939508913125,537.1811018620099,1621.3895745666903,3290.7992357334597,4362.619090143247,3439.3676741437216,1230.3393548037495],[2.568520192289822,1.8729528499234604,.5279051029514285,.06051834131244132,.0023352049762686918]],Bs=Math.pow(2,53),ks="zeta",Is=Se(ks,["typed","config","multiply","pow","divide","factorial","equal","smallerEq","isNegative","gamma","sin","subtract","add","?Complex","?BigNumber","pi"],(function(e){var t=e.typed,r=e.config,n=e.multiply,i=e.pow,a=e.divide,o=e.factorial,u=e.equal,s=e.smallerEq,c=e.isNegative,f=e.gamma,l=e.sin,p=e.subtract,m=e.add,h=e.Complex,d=e.BigNumber,v=e.pi;return t(ks,{number:function(e){return y(e,(function(e){return e}),(function(){return 20}))},BigNumber:function(e){return y(e,(function(e){return new d(e)}),(function(){return Math.abs(Math.log10(r.epsilon))}))},Complex:function(e){return 0===e.re&&0===e.im?new h(-.5):1===e.re?new h(NaN,NaN):e.re===1/0&&0===e.im?new h(1):e.im===1/0||e.re===-1/0?new h(NaN,NaN):g(e,(function(e){return e}),(function(e){return Math.round(19.5+.9*Math.abs(e.im))}),(function(e){return e.re}))}});function y(e,t,r){return u(e,0)?t(-.5):u(e,1)?t(NaN):isFinite(e)?g(e,t,r,(function(e){return e})):c(e)?t(NaN):t(1)}function g(e,t,r,o){var u=r(e);if(o(e)>-(u-1)/2)return function(e,t,r){for(var o=a(1,n(x(r(0),t),p(1,i(2,p(1,e))))),u=r(0),c=r(1);s(c,t);c=m(c,1))u=m(u,a(n(Math.pow(-1,c-1),x(c,t)),i(c,e)));return n(o,u)}(e,t(u),t);var c=n(i(2,e),i(t(v),p(e,1)));return c=n(c,l(n(a(t(v),2),e))),c=n(c,f(p(1,e))),n(c,g(p(1,e),t,r,o))}function x(e,t){for(var r=e,u=e;s(u,t);u=m(u,1)){var c=a(n(o(m(t,p(u,1))),i(4,u)),n(o(p(t,u)),o(n(2,u))));r=m(r,c)}return n(t,r)}})),zs="mode",Rs=Se(zs,["typed","isNaN","isNumeric"],(function(e){var t=e.typed,r=e.isNaN,n=e.isNumeric;return t(zs,{"Array | Matrix":i,"...":function(e){return i(e)}});function i(e){if(0===(e=En(e.valueOf())).length)throw new Error("Cannot calculate mode of an empty array");for(var t={},i=[],a=0,o=0;o<e.length;o++){var u=e[o];if(n(u)&&r(u))throw new Error("Cannot calculate mode of an array containing NaN values");u in t||(t[u]=0),t[u]++,t[u]===a?i.push(u):t[u]>a&&(a=t[u],i=[u])}return i}}));function qs(e,t,r){var n;return-1!==String(e).indexOf("Unexpected type")?(n=arguments.length>2?" (type: "+H(r)+", value: "+JSON.stringify(r)+")":" (type: "+e.data.actual+")",new TypeError("Cannot calculate "+t+", unexpected type of argument"+n)):-1!==String(e).indexOf("complex numbers")?(n=arguments.length>2?" (type: "+H(r)+", value: "+JSON.stringify(r)+")":"",new TypeError("Cannot calculate "+t+", no ordering relation is defined for complex numbers"+n)):e}var js="prod",Ps=Se(js,["typed","config","multiplyScalar","numeric"],(function(e){var t=e.typed,r=e.config,n=e.multiplyScalar,i=e.numeric;return t(js,{"Array | Matrix":a,"Array | Matrix, number | BigNumber":function(e,t){throw new Error("prod(A, dim) is not yet supported")},"...":function(e){return a(e)}});function a(e){var t;if(Zn(e,(function(e){try{t=void 0===t?e:n(t,e)}catch(t){throw qs(t,"prod",e)}})),"string"==typeof t&&(t=i(t,r.number)),void 0===t)throw new Error("Cannot calculate prod of an empty array");return t}})),Ls="format",Us=Se(Ls,["typed"],(function(e){return(0,e.typed)(Ls,{any:en,"any, Object | function | number | BigNumber":en})})),$s=Se("bin",["typed","format"],(function(e){var t=e.typed,r=e.format;return t("bin",{"number | BigNumber":function(e){return r(e,{notation:"bin"})},"number | BigNumber, number | BigNumber":function(e,t){return r(e,{notation:"bin",wordSize:t})}})})),Hs=Se("oct",["typed","format"],(function(e){var t=e.typed,r=e.format;return t("oct",{"number | BigNumber":function(e){return r(e,{notation:"oct"})},"number | BigNumber, number | BigNumber":function(e,t){return r(e,{notation:"oct",wordSize:t})}})})),Gs=Se("hex",["typed","format"],(function(e){var t=e.typed,r=e.format;return t("hex",{"number | BigNumber":function(e){return r(e,{notation:"hex"})},"number | BigNumber, number | BigNumber":function(e,t){return r(e,{notation:"hex",wordSize:t})}})})),Vs=/\$([\w.]+)/g,Zs="print",Ws=Se(Zs,["typed"],(function(e){return(0,e.typed)(Zs,{"string, Object | Array":Ys,"string, Object | Array, number | Object":Ys})}));function Ys(e,t,r){return e.replace(Vs,(function(e,n){var i=n.split("."),a=t[i.shift()];for(void 0!==a&&a.isMatrix&&(a=a.toArray());i.length&&void 0!==a;){var o=i.shift();a=o?a[o]:a+"."}return void 0!==a?c(a)?a:en(a,r):e}))}var Js=Se("to",["typed","matrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.concat;return t("to",{"Unit, Unit | string":function(e,t){return e.to(t)}},Qa({typed:t,matrix:r,concat:n})({Ds:!0}))})),Xs="isPrime",Qs=Se(Xs,["typed"],(function(e){var t=e.typed;return t(Xs,{number:function(e){if(0*e!=0)return!1;if(e<=3)return e>1;if(e%2==0||e%3==0)return!1;for(var t=5;t*t<=e;t+=6)if(e%t==0||e%(t+2)==0)return!1;return!0},BigNumber:function(e){if(0*e.toNumber()!=0)return!1;if(e.lte(3))return e.gt(1);if(e.mod(2).eq(0)||e.mod(3).eq(0))return!1;if(e.lt(Math.pow(2,32))){for(var t=e.toNumber(),r=5;r*r<=t;r+=6)if(t%r==0||t%(r+2)==0)return!1;return!0}function n(e,t,r){for(var n=1;!t.eq(0);)t.mod(2).eq(0)?(t=t.div(2),e=e.mul(e).mod(r)):(t=t.sub(1),n=e.mul(n).mod(r));return n}for(var i=e.constructor.clone({precision:2*e.toFixed(0).length}),a=0,o=(e=new i(e)).sub(1);o.mod(2).eq(0);)o=o.div(2),a+=1;var u=null;if(e.lt("3317044064679887385961981"))u=[2,3,5,7,11,13,17,19,23,29,31,37,41].filter((function(t){return t<e}));else{var s=Math.min(e.toNumber()-2,Math.floor(2*Math.pow(e.toFixed(0).length*Math.log(10),2)));u=[];for(var c=2;c<=s;c+=1)u.push(s)}for(var f=0;f<u.length;f+=1){var l=u[f],p=n(e.sub(e).add(l),o,e);if(!p.eq(1))for(var m=0,h=p;!h.eq(e.sub(1));m+=1,h=h.mul(h).mod(e))if(m===a-1)return!1}return!0},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),Ks=Se("numeric",["number","?bignumber","?fraction"],(function(e){var t=e.number,r=e.bignumber,n=e.fraction,i={string:!0,number:!0,BigNumber:!0,Fraction:!0},a={number:function(e){return t(e)},BigNumber:r?function(e){return r(e)}:Wu,Fraction:n?function(e){return n(e)}:Yu};return function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"number";if(void 0!==(arguments.length>2?arguments[2]:void 0))throw new SyntaxError("numeric() takes one or two arguments");var r=H(e);if(!(r in i))throw new TypeError("Cannot convert "+e+' of type "'+r+'"; valid input types are '+Object.keys(i).join(", "));if(!(t in a))throw new TypeError("Cannot convert "+e+' to type "'+t+'"; valid output types are '+Object.keys(a).join(", "));return t===r?e:a[t](e)}})),ec="divideScalar",tc=Se(ec,["typed","numeric"],(function(e){var t=e.typed;return e.numeric,t(ec,{"number, number":function(e,t){return e/t},"Complex, Complex":function(e,t){return e.div(t)},"BigNumber, BigNumber":function(e,t){return e.div(t)},"Fraction, Fraction":function(e,t){return e.div(t)},"Unit, number | Complex | Fraction | BigNumber | Unit":function(e,t){return e.divide(t)},"number | Fraction | Complex | BigNumber, Unit":function(e,t){return t.divideInto(e)}})})),rc=Se("pow",["typed","config","identity","multiply","matrix","inv","fraction","number","Complex"],(function(e){var t=e.typed,r=e.config,n=e.identity,i=e.multiply,a=e.matrix,o=e.inv,u=e.number,s=e.fraction,c=e.Complex;return t("pow",{"number, number":f,"Complex, Complex":function(e,t){return e.pow(t)},"BigNumber, BigNumber":function(e,t){return t.isInteger()||e>=0||r.predictable?e.pow(t):new c(e.toNumber(),0).pow(t.toNumber(),0)},"Fraction, Fraction":function(e,t){var n=e.pow(t);if(null!=n)return n;if(r.predictable)throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");return f(e.valueOf(),t.valueOf())},"Array, number":l,"Array, BigNumber":function(e,t){return l(e,t.toNumber())},"Matrix, number":p,"Matrix, BigNumber":function(e,t){return p(e,t.toNumber())},"Unit, number | BigNumber":function(e,t){return e.pow(t)}});function f(e,t){if(r.predictable&&!V(t)&&e<0)try{var n=s(t),i=u(n);if((t===i||Math.abs((t-i)/t)<1e-14)&&n.d%2==1)return(n.n%2==0?1:-1)*Math.pow(-e,t)}catch(e){}return r.predictable&&(e<-1&&t===1/0||e>-1&&e<0&&t===-1/0)?NaN:V(t)||e>=0||r.predictable?ca(e,t):e*e<1&&t===1/0||e*e>1&&t===-1/0?0:new c(e,0).pow(t,0)}function l(e,t){if(!V(t))throw new TypeError("For A^b, b must be an integer (value is "+t+")");var r=cn(e);if(2!==r.length)throw new Error("For A^b, A must be 2 dimensional (A has "+r.length+" dimensions)");if(r[0]!==r[1])throw new Error("For A^b, A must be square (size is "+r[0]+"x"+r[1]+")");if(t<0)try{return l(o(e),-t)}catch(e){if("Cannot calculate inverse, determinant is zero"===e.message)throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is "+t+")");throw e}for(var a=n(r[0]).valueOf(),u=e;t>=1;)1==(1&t)&&(a=i(u,a)),t>>=1,u=i(u,u);return a}function p(e,t){return a(l(e.valueOf(),t))}})),nc="Number of decimals in function round must be an integer",ic="round",ac=Se(ic,["typed","config","matrix","equalScalar","zeros","BigNumber","DenseMatrix"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.equalScalar,a=e.zeros,o=e.BigNumber,u=e.DenseMatrix,s=Sa({typed:t,equalScalar:i}),c=Ca({typed:t,DenseMatrix:u}),f=Ma({typed:t});function l(e){return Math.abs(re(e).exponent)}return t(ic,{number:function(e){var t=fa(e,l(r.epsilon));return fa(se(e,t,r.epsilon)?t:e)},"number, number":function(e,t){var n=l(r.epsilon);if(t>=n)return fa(e,t);var i=fa(e,n);return fa(se(e,i,r.epsilon)?i:e,t)},"number, BigNumber":function(e,t){if(!t.isInteger())throw new TypeError(nc);return new o(e).toDecimalPlaces(t.toNumber())},Complex:function(e){return e.round()},"Complex, number":function(e,t){if(t%1)throw new TypeError(nc);return e.round(t)},"Complex, BigNumber":function(e,t){if(!t.isInteger())throw new TypeError(nc);var r=t.toNumber();return e.round(r)},BigNumber:function(e){var t=new o(e).toDecimalPlaces(l(r.epsilon));return(xi(e,t,r.epsilon)?t:e).toDecimalPlaces(0)},"BigNumber, BigNumber":function(e,t){if(!t.isInteger())throw new TypeError(nc);var n=l(r.epsilon);if(t>=n)return e.toDecimalPlaces(t.toNumber());var i=e.toDecimalPlaces(n);return(xi(e,i,r.epsilon)?i:e).toDecimalPlaces(t.toNumber())},Fraction:function(e){return e.round()},"Fraction, number":function(e,t){if(t%1)throw new TypeError(nc);return e.round(t)},"Fraction, BigNumber":function(e,t){if(!t.isInteger())throw new TypeError(nc);return e.round(t.toNumber())},"Unit, number, Unit":t.referToSelf((function(e){return function(t,r,n){var i=t.toNumeric(n);return n.multiply(e(i,r))}})),"Unit, BigNumber, Unit":t.referToSelf((function(e){return function(t,r,n){return e(t,r.toNumber(),n)}})),"Unit, Unit":t.referToSelf((function(e){return function(t,r){return e(t,0,r)}})),"Array | Matrix, number, Unit":t.referToSelf((function(e){return function(t,r,n){return Wn(t,(function(t){return e(t,r,n)}),!0)}})),"Array | Matrix, BigNumber, Unit":t.referToSelf((function(e){return function(t,r,n){return e(t,r.toNumber(),n)}})),"Array | Matrix, Unit":t.referToSelf((function(e){return function(t,r){return e(t,0,r)}})),"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e,!0)}})),"SparseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return s(t,r,e,!1)}})),"DenseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return f(t,r,e,!1)}})),"Array, number | BigNumber":t.referToSelf((function(e){return function(t,r){return f(n(t),r,e,!1).valueOf()}})),"number | Complex | BigNumber | Fraction, SparseMatrix":t.referToSelf((function(e){return function(t,r){return i(t,0)?a(r.size(),r.storage()):c(r,t,e,!0)}})),"number | Complex | BigNumber | Fraction, DenseMatrix":t.referToSelf((function(e){return function(t,r){return i(t,0)?a(r.size(),r.storage()):f(r,t,e,!0)}})),"number | Complex | BigNumber | Fraction, Array":t.referToSelf((function(e){return function(t,r){return f(n(r),t,e,!0).valueOf()}}))})})),oc=Se("log",["config","typed","divideScalar","Complex"],(function(e){var t=e.typed,r=e.config,n=e.divideScalar,i=e.Complex;return t("log",{number:function(e){return e>=0||r.predictable?function(e,t){return Math.log(e)}(e):new i(e,0).log()},Complex:function(e){return e.log()},BigNumber:function(e){return!e.isNegative()||r.predictable?e.ln():new i(e.toNumber(),0).log()},"any, any":t.referToSelf((function(e){return function(t,r){return n(e(t),e(r))}}))})})),uc="log1p",sc=Se(uc,["typed","config","divideScalar","log","Complex"],(function(e){var t=e.typed,r=e.config,n=e.divideScalar,i=e.log,a=e.Complex;return t(uc,{number:function(e){return e>=-1||r.predictable?J(e):o(new a(e,0))},Complex:o,BigNumber:function(e){var t=e.plus(1);return!t.isNegative()||r.predictable?t.ln():o(new a(e.toNumber(),0))},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}})),"any, any":t.referToSelf((function(e){return function(t,r){return n(e(t),i(r))}}))});function o(e){var t=e.re+1;return new a(Math.log(Math.sqrt(t*t+e.im*e.im)),Math.atan2(e.im,t))}})),cc="nthRoots",fc=Se(cc,["config","typed","divideScalar","Complex"],(function(e){var t=e.typed,r=(e.config,e.divideScalar,e.Complex),n=[function(e){return new r(e,0)},function(e){return new r(0,e)},function(e){return new r(-e,0)},function(e){return new r(0,-e)}];function i(e,t){if(t<0)throw new Error("Root must be greater than zero");if(0===t)throw new Error("Root must be non-zero");if(t%1!=0)throw new Error("Root must be an integer");if(0===e||0===e.abs())return[new r(0,0)];var i,a="number"==typeof e;(a||0===e.re||0===e.im)&&(i=a?2*+(e<0):0===e.im?2*+(e.re<0):2*+(e.im<0)+1);for(var o=e.arg(),u=e.abs(),s=[],c=Math.pow(u,1/t),f=0;f<t;f++){var l=(i+4*f)/t;l!==Math.round(l)?s.push(new r({r:c,phi:(o+2*Math.PI*f)/t})):s.push(n[l%4](c))}return s}return t(cc,{Complex:function(e){return i(e,2)},"Complex, number":i})})),lc="dotPow",pc=Se(lc,["typed","equalScalar","matrix","pow","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.equalScalar,n=e.matrix,i=e.pow,a=e.DenseMatrix,o=e.concat,u=Wa({typed:t}),s=nu({typed:t,DenseMatrix:a}),c=Sa({typed:t,equalScalar:r}),f=Ca({typed:t,DenseMatrix:a}),l=Qa({typed:t,matrix:n,concat:o}),p={};for(var m in i.signatures)Object.prototype.hasOwnProperty.call(i.signatures,m)&&(m.includes("Matrix")||m.includes("Array")||(p[m]=i.signatures[m]));var h=t(p);return t(lc,l({elop:h,SS:s,DS:u,Ss:c,sS:f}))})),mc="dotDivide",hc=Se(mc,["typed","matrix","equalScalar","divideScalar","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.divideScalar,a=e.DenseMatrix,o=e.concat,u=Za({typed:t,equalScalar:n}),s=Wa({typed:t}),c=nu({typed:t,DenseMatrix:a}),f=Sa({typed:t,equalScalar:n}),l=Ca({typed:t,DenseMatrix:a}),p=Qa({typed:t,matrix:r,concat:o});return t(mc,p({elop:i,SS:c,DS:s,SD:u,Ss:f,sS:l}))}));function dc(e){var t=e.DenseMatrix;return function(e,r,n){var i=e.size();if(2!==i.length)throw new RangeError("Matrix must be two dimensional (size: "+en(i)+")");var a=i[0];if(a!==i[1])throw new RangeError("Matrix must be square (size: "+en(i)+")");var o=[];if(l(r)){var u=r.size(),s=r._data;if(1===u.length){if(u[0]!==a)throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var c=0;c<a;c++)o[c]=[s[c]];return new t({data:o,size:[a,1],datatype:r._datatype})}if(2===u.length){if(u[0]!==a||1!==u[1])throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");if(m(r)){if(n){o=[];for(var p=0;p<a;p++)o[p]=[s[p][0]];return new t({data:o,size:[a,1],datatype:r._datatype})}return r}if(h(r)){for(var d=0;d<a;d++)o[d]=[0];for(var v=r._values,y=r._index,g=r._ptr,x=g[1],b=g[0];b<x;b++)o[y[b]][0]=v[b];return new t({data:o,size:[a,1],datatype:r._datatype})}}throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.")}if(f(r)){var w=cn(r);if(1===w.length){if(w[0]!==a)throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var D=0;D<a;D++)o[D]=[r[D]];return new t({data:o,size:[a,1]})}if(2===w.length){if(w[0]!==a||1!==w[1])throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var N=0;N<a;N++)o[N]=[r[N][0]];return new t({data:o,size:[a,1]})}throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.")}}}var vc="lsolve",yc=Se(vc,["typed","matrix","divideScalar","multiplyScalar","subtractScalar","equalScalar","DenseMatrix"],(function(e){var t=e.typed,r=e.matrix,n=e.divideScalar,i=e.multiplyScalar,a=e.subtractScalar,o=e.equalScalar,u=e.DenseMatrix,s=dc({DenseMatrix:u});return t(vc,{"SparseMatrix, Array | Matrix":function(e,t){return function(e,t){for(var r=(t=s(e,t,!0))._data,c=e._size[0],f=e._size[1],l=e._values,p=e._index,m=e._ptr,h=[],d=0;d<f;d++){var v=r[d][0]||0;if(o(v,0))h[d]=[0];else{for(var y=0,g=[],x=[],b=m[d],w=m[d+1],D=b;D<w;D++){var N=p[D];N===d?y=l[D]:N>d&&(g.push(l[D]),x.push(N))}if(o(y,0))throw new Error("Linear system cannot be solved since matrix is singular");for(var E=n(v,y),A=0,S=x.length;A<S;A++){var C=x[A];r[C]=[a(r[C][0]||0,i(E,g[A]))]}h[d]=[E]}}return new u({data:h,size:[c,1]})}(e,t)},"DenseMatrix, Array | Matrix":function(e,t){return c(e,t)},"Array, Array | Matrix":function(e,t){return c(r(e),t).valueOf()}});function c(e,t){for(var r=(t=s(e,t,!0))._data,c=e._size[0],f=e._size[1],l=[],p=e._data,m=0;m<f;m++){var h=r[m][0]||0,d=void 0;if(o(h,0))d=0;else{var v=p[m][m];if(o(v,0))throw new Error("Linear system cannot be solved since matrix is singular");d=n(h,v);for(var y=m+1;y<c;y++)r[y]=[a(r[y][0]||0,i(d,p[y][m]))]}l[m]=[d]}return new u({data:l,size:[c,1]})}})),gc="usolve",xc=Se(gc,["typed","matrix","divideScalar","multiplyScalar","subtractScalar","equalScalar","DenseMatrix"],(function(e){var t=e.typed,r=e.matrix,n=e.divideScalar,i=e.multiplyScalar,a=e.subtractScalar,o=e.equalScalar,u=e.DenseMatrix,s=dc({DenseMatrix:u});return t(gc,{"SparseMatrix, Array | Matrix":function(e,t){return function(e,t){for(var r=(t=s(e,t,!0))._data,c=e._size[0],f=e._size[1],l=e._values,p=e._index,m=e._ptr,h=[],d=f-1;d>=0;d--){var v=r[d][0]||0;if(o(v,0))h[d]=[0];else{for(var y=0,g=[],x=[],b=m[d],w=m[d+1]-1;w>=b;w--){var D=p[w];D===d?y=l[w]:D<d&&(g.push(l[w]),x.push(D))}if(o(y,0))throw new Error("Linear system cannot be solved since matrix is singular");for(var N=n(v,y),E=0,A=x.length;E<A;E++){var S=x[E];r[S]=[a(r[S][0],i(N,g[E]))]}h[d]=[N]}}return new u({data:h,size:[c,1]})}(e,t)},"DenseMatrix, Array | Matrix":function(e,t){return c(e,t)},"Array, Array | Matrix":function(e,t){return c(r(e),t).valueOf()}});function c(e,t){for(var r=(t=s(e,t,!0))._data,c=e._size[0],f=e._size[1],l=[],p=e._data,m=f-1;m>=0;m--){var h=r[m][0]||0,d=void 0;if(o(h,0))d=0;else{var v=p[m][m];if(o(v,0))throw new Error("Linear system cannot be solved since matrix is singular");d=n(h,v);for(var y=m-1;y>=0;y--)r[y]=[a(r[y][0]||0,i(d,p[y][m]))]}l[m]=[d]}return new u({data:l,size:[c,1]})}})),bc="lsolveAll",wc=Se(bc,["typed","matrix","divideScalar","multiplyScalar","subtractScalar","equalScalar","DenseMatrix"],(function(e){var t=e.typed,r=e.matrix,n=e.divideScalar,i=e.multiplyScalar,a=e.subtractScalar,o=e.equalScalar,u=e.DenseMatrix,s=dc({DenseMatrix:u});return t(bc,{"SparseMatrix, Array | Matrix":function(e,t){return function(e,t){for(var r=[s(e,t,!0)._data.map((function(e){return e[0]}))],c=e._size[0],f=e._size[1],l=e._values,p=e._index,m=e._ptr,h=0;h<f;h++)for(var d=r.length,v=0;v<d;v++){for(var y=r[v],g=[],x=[],b=m[h],w=m[h+1],D=0,N=b;N<w;N++){var E=p[N];E===h?D=l[N]:E>h&&(g.push(l[N]),x.push(E))}if(o(D,0))if(o(y[h],0)){if(0===v){var A=Te(y);A[h]=1;for(var S=0,C=x.length;S<C;S++){var M=x[S];A[M]=a(A[M],g[S])}r.push(A)}}else{if(0===v)return[];r.splice(v,1),v-=1,d-=1}else{y[h]=n(y[h],D);for(var F=0,O=x.length;F<O;F++){var T=x[F];y[T]=a(y[T],i(y[h],g[F]))}}}return r.map((function(e){return new u({data:e.map((function(e){return[e]})),size:[c,1]})}))}(e,t)},"DenseMatrix, Array | Matrix":function(e,t){return c(e,t)},"Array, Array | Matrix":function(e,t){return c(r(e),t).map((function(e){return e.valueOf()}))}});function c(e,t){for(var r=[s(e,t,!0)._data.map((function(e){return e[0]}))],c=e._data,f=e._size[0],l=e._size[1],p=0;p<l;p++)for(var m=r.length,h=0;h<m;h++){var d=r[h];if(o(c[p][p],0))if(o(d[p],0)){if(0===h){var v=Te(d);v[p]=1;for(var y=p+1;y<l;y++)v[y]=a(v[y],c[y][p]);r.push(v)}}else{if(0===h)return[];r.splice(h,1),h-=1,m-=1}else{d[p]=n(d[p],c[p][p]);for(var g=p+1;g<l;g++)d[g]=a(d[g],i(d[p],c[g][p]))}}return r.map((function(e){return new u({data:e.map((function(e){return[e]})),size:[f,1]})}))}})),Dc="usolveAll",Nc=Se(Dc,["typed","matrix","divideScalar","multiplyScalar","subtractScalar","equalScalar","DenseMatrix"],(function(e){var t=e.typed,r=e.matrix,n=e.divideScalar,i=e.multiplyScalar,a=e.subtractScalar,o=e.equalScalar,u=e.DenseMatrix,s=dc({DenseMatrix:u});return t(Dc,{"SparseMatrix, Array | Matrix":function(e,t){return function(e,t){for(var r=[s(e,t,!0)._data.map((function(e){return e[0]}))],c=e._size[0],f=e._size[1],l=e._values,p=e._index,m=e._ptr,h=f-1;h>=0;h--)for(var d=r.length,v=0;v<d;v++){for(var y=r[v],g=[],x=[],b=m[h],w=0,D=m[h+1]-1;D>=b;D--){var N=p[D];N===h?w=l[D]:N<h&&(g.push(l[D]),x.push(N))}if(o(w,0))if(o(y[h],0)){if(0===v){var E=Te(y);E[h]=1;for(var A=0,S=x.length;A<S;A++){var C=x[A];E[C]=a(E[C],g[A])}r.push(E)}}else{if(0===v)return[];r.splice(v,1),v-=1,d-=1}else{y[h]=n(y[h],w);for(var M=0,F=x.length;M<F;M++){var O=x[M];y[O]=a(y[O],i(y[h],g[M]))}}}return r.map((function(e){return new u({data:e.map((function(e){return[e]})),size:[c,1]})}))}(e,t)},"DenseMatrix, Array | Matrix":function(e,t){return c(e,t)},"Array, Array | Matrix":function(e,t){return c(r(e),t).map((function(e){return e.valueOf()}))}});function c(e,t){for(var r=[s(e,t,!0)._data.map((function(e){return e[0]}))],c=e._data,f=e._size[0],l=e._size[1]-1;l>=0;l--)for(var p=r.length,m=0;m<p;m++){var h=r[m];if(o(c[l][l],0))if(o(h[l],0)){if(0===m){var d=Te(h);d[l]=1;for(var v=l-1;v>=0;v--)d[v]=a(d[v],c[v][l]);r.push(d)}}else{if(0===m)return[];r.splice(m,1),m-=1,p-=1}else{h[l]=n(h[l],c[l][l]);for(var y=l-1;y>=0;y--)h[y]=a(h[y],i(h[l],c[y][l]))}}return r.map((function(e){return new u({data:e.map((function(e){return[e]})),size:[f,1]})}))}})),Ec=Se("matAlgo08xS0Sid",["typed","equalScalar"],(function(e){var t=e.typed,r=e.equalScalar;return function(e,n,i){var a=e._values,o=e._index,u=e._ptr,s=e._size,c=e._datatype||void 0===e._data?e._datatype:e.getDataType(),f=n._values,l=n._index,p=n._ptr,m=n._size,h=n._datatype||void 0===n._data?n._datatype:n.getDataType();if(s.length!==m.length)throw new un(s.length,m.length);if(s[0]!==m[0]||s[1]!==m[1])throw new RangeError("Dimension mismatch. Matrix A ("+s+") must match Matrix B ("+m+")");if(!a||!f)throw new Error("Cannot perform operation on Pattern Sparse Matrices");var d,v=s[0],y=s[1],g=r,x=0,b=i;"string"==typeof c&&c===h&&"mixed"!==c&&(d=c,g=t.find(r,[d,d]),x=t.convert(0,d),b=t.find(i,[d,d]));for(var w,D,N,E,A=[],S=[],C=[],M=[],F=[],O=0;O<y;O++){C[O]=S.length;var T=O+1;for(D=u[O],N=u[O+1],w=D;w<N;w++)F[E=o[w]]=T,M[E]=a[w],S.push(E);for(D=p[O],N=p[O+1],w=D;w<N;w++)F[E=l[w]]===T&&(M[E]=b(M[E],f[w]));for(w=C[O];w<S.length;){var _=M[E=S[w]];g(_,x)?S.splice(w,1):(A.push(_),w++)}}return C[y]=S.length,e.createSparseMatrix({values:A,index:S,ptr:C,size:[v,y],datatype:c===e._datatype&&h===n._datatype?d:void 0})}})),Ac=Se("useMatrixForArrayScalar",["typed","matrix"],(function(e){var t=e.typed,r=e.matrix;return{"Array, number":t.referTo("DenseMatrix, number",(function(e){return function(t,n){return e(r(t),n).valueOf()}})),"Array, BigNumber":t.referTo("DenseMatrix, BigNumber",(function(e){return function(t,n){return e(r(t),n).valueOf()}})),"number, Array":t.referTo("number, DenseMatrix",(function(e){return function(t,n){return e(t,r(n)).valueOf()}})),"BigNumber, Array":t.referTo("BigNumber, DenseMatrix",(function(e){return function(t,n){return e(t,r(n)).valueOf()}}))}})),Sc="leftShift",Cc=Se(Sc,["typed","matrix","equalScalar","zeros","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.zeros,a=e.DenseMatrix,o=e.concat,u=eo({typed:t}),s=Za({typed:t,equalScalar:n}),c=Ec({typed:t,equalScalar:n}),f=ro({typed:t,DenseMatrix:a}),l=Sa({typed:t,equalScalar:n}),p=Ma({typed:t}),m=Qa({typed:t,matrix:r,concat:o}),h=Ac({typed:t,matrix:r});return t(Sc,{"number, number":Wo,"BigNumber, BigNumber":Lo,"SparseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return n(r,0)?t.clone():l(t,r,e,!1)}})),"DenseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return n(r,0)?t.clone():p(t,r,e,!1)}})),"number | BigNumber, SparseMatrix":t.referToSelf((function(e){return function(t,r){return n(t,0)?i(r.size(),r.storage()):f(r,t,e,!0)}})),"number | BigNumber, DenseMatrix":t.referToSelf((function(e){return function(t,r){return n(t,0)?i(r.size(),r.storage()):p(r,t,e,!0)}}))},h,m({SS:c,DS:u,SD:s}))})),Mc="rightArithShift",Fc=Se(Mc,["typed","matrix","equalScalar","zeros","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.zeros,a=e.DenseMatrix,o=e.concat,u=eo({typed:t}),s=Za({typed:t,equalScalar:n}),c=Ec({typed:t,equalScalar:n}),f=ro({typed:t,DenseMatrix:a}),l=Sa({typed:t,equalScalar:n}),p=Ma({typed:t}),m=Qa({typed:t,matrix:r,concat:o}),h=Ac({typed:t,matrix:r});return t(Mc,{"number, number":Yo,"BigNumber, BigNumber":Uo,"SparseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return n(r,0)?t.clone():l(t,r,e,!1)}})),"DenseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return n(r,0)?t.clone():p(t,r,e,!1)}})),"number | BigNumber, SparseMatrix":t.referToSelf((function(e){return function(t,r){return n(t,0)?i(r.size(),r.storage()):f(r,t,e,!0)}})),"number | BigNumber, DenseMatrix":t.referToSelf((function(e){return function(t,r){return n(t,0)?i(r.size(),r.storage()):p(r,t,e,!0)}}))},h,m({SS:c,DS:u,SD:s}))})),Oc="rightLogShift",Tc=Se(Oc,["typed","matrix","equalScalar","zeros","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.zeros,a=e.DenseMatrix,o=e.concat,u=eo({typed:t}),s=Za({typed:t,equalScalar:n}),c=Ec({typed:t,equalScalar:n}),f=ro({typed:t,DenseMatrix:a}),l=Sa({typed:t,equalScalar:n}),p=Ma({typed:t}),m=Qa({typed:t,matrix:r,concat:o}),h=Ac({typed:t,matrix:r});return t(Oc,{"number, number":Jo,"SparseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return n(r,0)?t.clone():l(t,r,e,!1)}})),"DenseMatrix, number | BigNumber":t.referToSelf((function(e){return function(t,r){return n(r,0)?t.clone():p(t,r,e,!1)}})),"number | BigNumber, SparseMatrix":t.referToSelf((function(e){return function(t,r){return n(t,0)?i(r.size(),r.storage()):f(r,t,e,!0)}})),"number | BigNumber, DenseMatrix":t.referToSelf((function(e){return function(t,r){return n(t,0)?i(r.size(),r.storage()):p(r,t,e,!0)}}))},h,m({SS:c,DS:u,SD:s}))})),_c=Se("and",["typed","matrix","equalScalar","zeros","not","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.zeros,a=e.not,o=e.concat,u=Za({typed:t,equalScalar:n}),s=co({typed:t,equalScalar:n}),c=Sa({typed:t,equalScalar:n}),f=Ma({typed:t}),l=Qa({typed:t,matrix:r,concat:o});return t("and",{"number, number":du,"Complex, Complex":function(e,t){return!(0===e.re&&0===e.im||0===t.re&&0===t.im)},"BigNumber, BigNumber":function(e,t){return!(e.isZero()||t.isZero()||e.isNaN()||t.isNaN())},"Unit, Unit":t.referToSelf((function(e){return function(t,r){return e(t.value||0,r.value||0)}})),"SparseMatrix, any":t.referToSelf((function(e){return function(t,r){return a(r)?i(t.size(),t.storage()):c(t,r,e,!1)}})),"DenseMatrix, any":t.referToSelf((function(e){return function(t,r){return a(r)?i(t.size(),t.storage()):f(t,r,e,!1)}})),"any, SparseMatrix":t.referToSelf((function(e){return function(t,r){return a(t)?i(t.size(),t.storage()):c(r,t,e,!0)}})),"any, DenseMatrix":t.referToSelf((function(e){return function(t,r){return a(t)?i(t.size(),t.storage()):f(r,t,e,!0)}})),"Array, any":t.referToSelf((function(e){return function(t,n){return e(r(t),n).valueOf()}})),"any, Array":t.referToSelf((function(e){return function(t,n){return e(t,r(n)).valueOf()}}))},l({SS:s,DS:u}))})),Bc="compare",kc=Se(Bc,["typed","config","matrix","equalScalar","BigNumber","Fraction","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.config,n=e.equalScalar,i=e.matrix,a=e.BigNumber,o=e.Fraction,u=e.DenseMatrix,s=e.concat,c=Wa({typed:t}),f=Ya({typed:t,equalScalar:n}),l=Ca({typed:t,DenseMatrix:u}),p=Qa({typed:t,matrix:i,concat:s}),m=bi({typed:t});return t(Bc,Ic({typed:t,config:r}),{"boolean, boolean":function(e,t){return e===t?0:e>t?1:-1},"BigNumber, BigNumber":function(e,t){return xi(e,t,r.epsilon)?new a(0):new a(e.cmp(t))},"Fraction, Fraction":function(e,t){return new o(e.compare(t))},"Complex, Complex":function(){throw new TypeError("No ordering relation is defined for complex numbers")}},m,p({SS:f,DS:c,Ss:l}))})),Ic=Se(Bc,["typed","config"],(function(e){var t=e.typed,r=e.config;return t(Bc,{"number, number":function(e,t){return se(e,t,r.epsilon)?0:e>t?1:-1}})})),zc=r(1880),Rc="compareNatural",qc=Se(Rc,["typed","compare"],(function(e){var t=e.typed,r=e.compare,n=r.signatures["boolean,boolean"];return t(Rc,{"any, any":function e(t,o){var u,s=H(t),c=H(o);if(!("number"!==s&&"BigNumber"!==s&&"Fraction"!==s||"number"!==c&&"BigNumber"!==c&&"Fraction"!==c))return"0"!==(u=r(t,o)).toString()?u>0?1:-1:zc(s,c);var f=["Array","DenseMatrix","SparseMatrix"];if(f.includes(s)||f.includes(c))return 0!==(u=i(e,t,o))?u:zc(s,c);if(s!==c)return zc(s,c);if("Complex"===s)return function(e,t){return e.re>t.re?1:e.re<t.re?-1:e.im>t.im?1:e.im<t.im?-1:0}(t,o);if("Unit"===s)return t.equalBase(o)?e(t.value,o.value):a(e,t.formatUnits(),o.formatUnits());if("boolean"===s)return n(t,o);if("string"===s)return zc(t,o);if("Object"===s)return function(e,t,r){var n=Object.keys(t),i=Object.keys(r);n.sort(zc),i.sort(zc);var o=a(e,n,i);if(0!==o)return o;for(var u=0;u<n.length;u++){var s=e(t[n[u]],r[i[u]]);if(0!==s)return s}return 0}(e,t,o);if("null"===s)return 0;if("undefined"===s)return 0;throw new TypeError('Unsupported type of value "'+s+'"')}});function i(e,t,r){return h(t)&&h(r)?a(e,t.toJSON().values,r.toJSON().values):h(t)?i(e,t.toArray(),r):h(r)?i(e,t,r.toArray()):m(t)?i(e,t.toJSON().data,r):m(r)?i(e,t,r.toJSON().data):Array.isArray(t)?Array.isArray(r)?a(e,t,r):i(e,t,[r]):i(e,[t],r)}function a(e,t,r){for(var n=0,i=Math.min(t.length,r.length);n<i;n++){var a=e(t[n],r[n]);if(0!==a)return a}return t.length>r.length?1:t.length<r.length?-1:0}})),jc="compareText",Pc=["typed","matrix","concat"];on.signature="any, any";var Lc=Se(jc,Pc,(function(e){var t=e.typed,r=e.matrix,n=e.concat,i=Qa({typed:t,matrix:r,concat:n});return t(jc,on,i({elop:on,Ds:!0}))})),Uc="equal",$c=Se(Uc,["typed","matrix","equalScalar","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.DenseMatrix,a=e.concat,o=Wa({typed:t}),u=nu({typed:t,DenseMatrix:i}),s=Ca({typed:t,DenseMatrix:i}),c=Qa({typed:t,matrix:r,concat:a});return t(Uc,Hc({typed:t,equalScalar:n}),c({elop:n,SS:u,DS:o,Ss:s}))})),Hc=Se(Uc,["typed","equalScalar"],(function(e){var t=e.typed,r=e.equalScalar;return t(Uc,{"any, any":function(e,t){return null===e?null===t:null===t?null===e:void 0===e?void 0===t:void 0===t?void 0===e:r(e,t)}})})),Gc="equalText",Vc=Se(Gc,["typed","compareText","isZero"],(function(e){var t=e.typed,r=e.compareText,n=e.isZero;return t(Gc,{"any, any":function(e,t){return n(r(e,t))}})})),Zc="smaller",Wc=Se(Zc,["typed","config","matrix","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.DenseMatrix,a=e.concat,o=Wa({typed:t}),u=nu({typed:t,DenseMatrix:i}),s=Ca({typed:t,DenseMatrix:i}),c=Qa({typed:t,matrix:n,concat:a}),f=bi({typed:t});return t(Zc,Yc({typed:t,config:r}),{"boolean, boolean":function(e,t){return e<t},"BigNumber, BigNumber":function(e,t){return e.lt(t)&&!xi(e,t,r.epsilon)},"Fraction, Fraction":function(e,t){return-1===e.compare(t)},"Complex, Complex":function(e,t){throw new TypeError("No ordering relation is defined for complex numbers")}},f,c({SS:u,DS:o,Ss:s}))})),Yc=Se(Zc,["typed","config"],(function(e){var t=e.typed,r=e.config;return t(Zc,{"number, number":function(e,t){return e<t&&!se(e,t,r.epsilon)}})})),Jc="smallerEq",Xc=Se(Jc,["typed","config","matrix","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.DenseMatrix,a=e.concat,o=Wa({typed:t}),u=nu({typed:t,DenseMatrix:i}),s=Ca({typed:t,DenseMatrix:i}),c=Qa({typed:t,matrix:n,concat:a}),f=bi({typed:t});return t(Jc,Qc({typed:t,config:r}),{"boolean, boolean":function(e,t){return e<=t},"BigNumber, BigNumber":function(e,t){return e.lte(t)||xi(e,t,r.epsilon)},"Fraction, Fraction":function(e,t){return 1!==e.compare(t)},"Complex, Complex":function(){throw new TypeError("No ordering relation is defined for complex numbers")}},f,c({SS:u,DS:o,Ss:s}))})),Qc=Se(Jc,["typed","config"],(function(e){var t=e.typed,r=e.config;return t(Jc,{"number, number":function(e,t){return e<=t||se(e,t,r.epsilon)}})})),Kc="larger",ef=Se(Kc,["typed","config","matrix","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.DenseMatrix,a=e.concat,o=Wa({typed:t}),u=nu({typed:t,DenseMatrix:i}),s=Ca({typed:t,DenseMatrix:i}),c=Qa({typed:t,matrix:n,concat:a}),f=bi({typed:t});return t(Kc,tf({typed:t,config:r}),{"boolean, boolean":function(e,t){return e>t},"BigNumber, BigNumber":function(e,t){return e.gt(t)&&!xi(e,t,r.epsilon)},"Fraction, Fraction":function(e,t){return 1===e.compare(t)},"Complex, Complex":function(){throw new TypeError("No ordering relation is defined for complex numbers")}},f,c({SS:u,DS:o,Ss:s}))})),tf=Se(Kc,["typed","config"],(function(e){var t=e.typed,r=e.config;return t(Kc,{"number, number":function(e,t){return e>t&&!se(e,t,r.epsilon)}})})),rf="largerEq",nf=Se(rf,["typed","config","matrix","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.DenseMatrix,a=e.concat,o=Wa({typed:t}),u=nu({typed:t,DenseMatrix:i}),s=Ca({typed:t,DenseMatrix:i}),c=Qa({typed:t,matrix:n,concat:a}),f=bi({typed:t});return t(rf,af({typed:t,config:r}),{"boolean, boolean":function(e,t){return e>=t},"BigNumber, BigNumber":function(e,t){return e.gte(t)||xi(e,t,r.epsilon)},"Fraction, Fraction":function(e,t){return-1!==e.compare(t)},"Complex, Complex":function(){throw new TypeError("No ordering relation is defined for complex numbers")}},f,c({SS:u,DS:o,Ss:s}))})),af=Se(rf,["typed","config"],(function(e){var t=e.typed,r=e.config;return t(rf,{"number, number":function(e,t){return e>=t||se(e,t,r.epsilon)}})})),of="deepEqual",uf=Se(of,["typed","equal"],(function(e){var t=e.typed,r=e.equal;return t(of,{"any, any":function(e,t){return n(e.valueOf(),t.valueOf())}});function n(e,t){if(Array.isArray(e)){if(Array.isArray(t)){var i=e.length;if(i!==t.length)return!1;for(var a=0;a<i;a++)if(!n(e[a],t[a]))return!1;return!0}return!1}return!Array.isArray(t)&&r(e,t)}})),sf="unequal",cf=Se(sf,["typed","config","equalScalar","matrix","DenseMatrix","concat"],(function(e){var t=e.typed,r=(e.config,e.equalScalar),n=e.matrix,i=e.DenseMatrix,a=e.concat,o=Wa({typed:t}),u=nu({typed:t,DenseMatrix:i}),s=Ca({typed:t,DenseMatrix:i}),c=Qa({typed:t,matrix:n,concat:a});return t(sf,ff({typed:t,equalScalar:r}),c({elop:function(e,t){return!r(e,t)},SS:u,DS:o,Ss:s}))})),ff=Se(sf,["typed","equalScalar"],(function(e){var t=e.typed,r=e.equalScalar;return t(sf,{"any, any":function(e,t){return null===e?null!==t:null===t?null!==e:void 0===e?void 0!==t:void 0===t?void 0!==e:!r(e,t)}})})),lf="partitionSelect",pf=Se(lf,["typed","isNumeric","isNaN","compare"],(function(e){var t=e.typed,r=e.isNumeric,n=e.isNaN,i=e.compare,a=i,o=function(e,t){return-i(e,t)};return t(lf,{"Array | Matrix, number":function(e,t){return u(e,t,a)},"Array | Matrix, number, string":function(e,t,r){if("asc"===r)return u(e,t,a);if("desc"===r)return u(e,t,o);throw new Error('Compare string must be "asc" or "desc"')},"Array | Matrix, number, function":u});function u(e,t,r){if(!V(t)||t<0)throw new Error("k must be a non-negative integer");if(l(e)){if(e.size().length>1)throw new Error("Only one dimensional matrices supported");return s(e.valueOf(),t,r)}if(Array.isArray(e))return s(e,t,r)}function s(e,t,i){if(t>=e.length)throw new Error("k out of bounds");for(var a=0;a<e.length;a++)if(r(e[a])&&n(e[a]))return e[a];for(var o=0,u=e.length-1;o<u;){for(var s=o,c=u,f=e[Math.floor(Math.random()*(u-o+1))+o];s<c;)if(i(e[s],f)>=0){var l=e[c];e[c]=e[s],e[s]=l,--c}else++s;i(e[s],f)>0&&--s,t<=s?u=s:o=s+1}return e[t]}})),mf="sort",hf=Se(mf,["typed","matrix","compare","compareNatural"],(function(e){var t=e.typed,r=e.matrix,n=e.compare,i=e.compareNatural,a=n,o=function(e,t){return-n(e,t)};return t(mf,{Array:function(e){return s(e),e.sort(a)},Matrix:function(e){return c(e),r(e.toArray().sort(a),e.storage())},"Array, function":function(e,t){return s(e),e.sort(t)},"Matrix, function":function(e,t){return c(e),r(e.toArray().sort(t),e.storage())},"Array, string":function(e,t){return s(e),e.sort(u(t))},"Matrix, string":function(e,t){return c(e),r(e.toArray().sort(u(t)),e.storage())}});function u(e){if("asc"===e)return a;if("desc"===e)return o;if("natural"===e)return i;throw new Error('String "asc", "desc", or "natural" expected')}function s(e){if(1!==cn(e).length)throw new Error("One dimensional array expected")}function c(e){if(1!==e.size().length)throw new Error("One dimensional matrix expected")}})),df=Se("max",["typed","config","numeric","larger"],(function(e){var t=e.typed,r=e.config,n=e.numeric,i=e.larger;return t("max",{"Array | Matrix":o,"Array | Matrix, number | BigNumber":function(e,t){return Yn(e,t.valueOf(),a)},"...":function(e){if(Vn(e))throw new TypeError("Scalar values expected in function max");return o(e)}});function a(e,t){try{return i(e,t)?e:t}catch(e){throw qs(e,"max",t)}}function o(e){var t;if(Zn(e,(function(e){try{isNaN(e)&&"number"==typeof e?t=NaN:(void 0===t||i(e,t))&&(t=e)}catch(t){throw qs(t,"max",e)}})),void 0===t)throw new Error("Cannot calculate max of an empty array");return"string"==typeof t&&(t=n(t,r.number)),t}})),vf=Se("min",["typed","config","numeric","smaller"],(function(e){var t=e.typed,r=e.config,n=e.numeric,i=e.smaller;return t("min",{"Array | Matrix":o,"Array | Matrix, number | BigNumber":function(e,t){return Yn(e,t.valueOf(),a)},"...":function(e){if(Vn(e))throw new TypeError("Scalar values expected in function min");return o(e)}});function a(e,t){try{return i(e,t)?e:t}catch(e){throw qs(e,"min",t)}}function o(e){var t;if(Zn(e,(function(e){try{isNaN(e)&&"number"==typeof e?t=NaN:(void 0===t||i(e,t))&&(t=e)}catch(t){throw qs(t,"min",e)}})),void 0===t)throw new Error("Cannot calculate min of an empty array");return"string"==typeof t&&(t=n(t,r.number)),t}})),yf=Se("ImmutableDenseMatrix",["smaller","DenseMatrix"],(function(e){var t=e.smaller,r=e.DenseMatrix;function n(e,t){if(!(this instanceof n))throw new SyntaxError("Constructor must be called with the new operator");if(t&&!c(t))throw new Error("Invalid datatype: "+t);if(l(e)||f(e)){var i=new r(e,t);this._data=i._data,this._size=i._size,this._datatype=i._datatype,this._min=null,this._max=null}else if(e&&f(e.data)&&f(e.size))this._data=e.data,this._size=e.size,this._datatype=e.datatype,this._min=void 0!==e.min?e.min:null,this._max=void 0!==e.max?e.max:null;else{if(e)throw new TypeError("Unsupported type of data ("+H(e)+")");this._data=[],this._size=[0],this._datatype=t,this._min=null,this._max=null}}return n.prototype=new r,n.prototype.type="ImmutableDenseMatrix",n.prototype.isImmutableDenseMatrix=!0,n.prototype.subset=function(e){switch(arguments.length){case 1:var t=r.prototype.subset.call(this,e);return l(t)?new n({data:t._data,size:t._size,datatype:t._datatype}):t;case 2:case 3:throw new Error("Cannot invoke set subset on an Immutable Matrix instance");default:throw new SyntaxError("Wrong number of arguments")}},n.prototype.set=function(){throw new Error("Cannot invoke set on an Immutable Matrix instance")},n.prototype.resize=function(){throw new Error("Cannot invoke resize on an Immutable Matrix instance")},n.prototype.reshape=function(){throw new Error("Cannot invoke reshape on an Immutable Matrix instance")},n.prototype.clone=function(){return new n({data:ye(this._data),size:ye(this._size),datatype:this._datatype})},n.prototype.toJSON=function(){return{mathjs:"ImmutableDenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},n.fromJSON=function(e){return new n(e)},n.prototype.swapRows=function(){throw new Error("Cannot invoke swapRows on an Immutable Matrix instance")},n.prototype.min=function(){if(null===this._min){var e=null;this.forEach((function(r){(null===e||t(r,e))&&(e=r)})),this._min=null!==e?e:void 0}return this._min},n.prototype.max=function(){if(null===this._max){var e=null;this.forEach((function(r){(null===e||t(e,r))&&(e=r)})),this._max=null!==e?e:void 0}return this._max},n}),{isClass:!0}),gf=Se("Index",["ImmutableDenseMatrix","getMatrixDataType"],(function(e){var t=e.ImmutableDenseMatrix,r=e.getMatrixDataType;function n(e){if(!(this instanceof n))throw new SyntaxError("Constructor must be called with the new operator");this._dimensions=[],this._sourceSize=[],this._isScalar=!0;for(var t=0,a=arguments.length;t<a;t++){var o=arguments[t],u=f(o),s=l(o),c=null;if(d(o))this._dimensions.push(o),this._isScalar=!1;else if(u||s){var p=void 0;"boolean"===r(o)?(u&&(p=i(xf(o).valueOf())),s&&(p=i(xf(o._data).valueOf())),c=o.valueOf().length):p=i(o.valueOf()),this._dimensions.push(p);var m=p.size();1===m.length&&1===m[0]&&null===c||(this._isScalar=!1)}else if("number"==typeof o)this._dimensions.push(i([o]));else{if("string"!=typeof o)throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");this._dimensions.push(o)}this._sourceSize.push(c)}}function i(e){for(var r=0,n=e.length;r<n;r++)if("number"!=typeof e[r]||!V(e[r]))throw new TypeError("Index parameters must be positive integer numbers");return new t(e)}return n.prototype.type="Index",n.prototype.isIndex=!0,n.prototype.clone=function(){var e=new n;return e._dimensions=ye(this._dimensions),e._isScalar=this._isScalar,e._sourceSize=this._sourceSize,e},n.create=function(e){var t=new n;return n.apply(t,e),t},n.prototype.size=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];e[t]="string"==typeof n?1:n.size()[0]}return e},n.prototype.max=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];e[t]="string"==typeof n?n:n.max()}return e},n.prototype.min=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];e[t]="string"==typeof n?n:n.min()}return e},n.prototype.forEach=function(e){for(var t=0,r=this._dimensions.length;t<r;t++)e(this._dimensions[t],t,this)},n.prototype.dimension=function(e){return this._dimensions[e]||null},n.prototype.isObjectProperty=function(){return 1===this._dimensions.length&&"string"==typeof this._dimensions[0]},n.prototype.getObjectProperty=function(){return this.isObjectProperty()?this._dimensions[0]:null},n.prototype.isScalar=function(){return this._isScalar},n.prototype.toArray=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];e.push("string"==typeof n?n:n.toArray())}return e},n.prototype.valueOf=n.prototype.toArray,n.prototype.toString=function(){for(var e=[],t=0,r=this._dimensions.length;t<r;t++){var n=this._dimensions[t];"string"==typeof n?e.push(JSON.stringify(n)):e.push(n.toString())}return"["+e.join(", ")+"]"},n.prototype.toJSON=function(){return{mathjs:"Index",dimensions:this._dimensions}},n.fromJSON=function(e){return n.create(e.dimensions)},n}),{isClass:!0});function xf(e){var t=[];return e.forEach((function(e,r){e&&t.push(r)})),t}var bf=Se("FibonacciHeap",["smaller","larger"],(function(e){var t=e.smaller,r=e.larger,n=1/Math.log((1+Math.sqrt(5))/2);function i(){if(!(this instanceof i))throw new SyntaxError("Constructor must be called with the new operator");this._minimum=null,this._size=0}function a(e,t,r){t.left.right=t.right,t.right.left=t.left,r.degree--,r.child===t&&(r.child=t.right),0===r.degree&&(r.child=null),t.left=e,t.right=e.right,e.right=t,t.right.left=t,t.parent=null,t.mark=!1}function o(e,t){var r=t.parent;r&&(t.mark?(a(e,t,r),o(r)):t.mark=!0)}i.prototype.type="FibonacciHeap",i.prototype.isFibonacciHeap=!0,i.prototype.insert=function(e,r){var n={key:e,value:r,degree:0};if(this._minimum){var i=this._minimum;n.left=i,n.right=i.right,i.right=n,n.right.left=n,t(e,i.key)&&(this._minimum=n)}else n.left=n,n.right=n,this._minimum=n;return this._size++,n},i.prototype.size=function(){return this._size},i.prototype.clear=function(){this._minimum=null,this._size=0},i.prototype.isEmpty=function(){return 0===this._size},i.prototype.extractMinimum=function(){var e=this._minimum;if(null===e)return e;for(var i=this._minimum,a=e.degree,o=e.child;a>0;){var s=o.right;o.left.right=o.right,o.right.left=o.left,o.left=i,o.right=i.right,i.right=o,o.right.left=o,o.parent=null,o=s,a--}return e.left.right=e.right,e.right.left=e.left,i=e===e.right?null:function(e,i){var a,o=Math.floor(Math.log(i)*n)+1,s=new Array(o),c=0,f=e;if(f)for(c++,f=f.right;f!==e;)c++,f=f.right;for(;c>0;){for(var l=f.degree,p=f.right;a=s[l];){if(r(f.key,a.key)){var m=a;a=f,f=m}u(a,f),s[l]=null,l++}s[l]=f,f=p,c--}e=null;for(var h=0;h<o;h++)(a=s[h])&&(e?(a.left.right=a.right,a.right.left=a.left,a.left=e,a.right=e.right,e.right=a,a.right.left=a,t(a.key,e.key)&&(e=a)):e=a);return e}(i=e.right,this._size),this._size--,this._minimum=i,e},i.prototype.remove=function(e){this._minimum=function(e,r,n){r.key=-1;var i=r.parent;return i&&t(r.key,i.key)&&(a(e,r,i),o(e,i)),t(r.key,e.key)&&(e=r),e}(this._minimum,e),this.extractMinimum()};var u=function(e,t){e.left.right=e.right,e.right.left=e.left,e.parent=t,t.child?(e.left=t.child,e.right=t.child.right,t.child.right=e,e.right.left=e):(t.child=e,e.right=e,e.left=e),t.degree++,e.mark=!1};return i}),{isClass:!0}),wf=Se("Spa",["addScalar","equalScalar","FibonacciHeap"],(function(e){var t=e.addScalar,r=e.equalScalar,n=e.FibonacciHeap;function i(){if(!(this instanceof i))throw new SyntaxError("Constructor must be called with the new operator");this._values=[],this._heap=new n}return i.prototype.type="Spa",i.prototype.isSpa=!0,i.prototype.set=function(e,t){if(this._values[e])this._values[e].value=t;else{var r=this._heap.insert(e,t);this._values[e]=r}},i.prototype.get=function(e){var t=this._values[e];return t?t.value:0},i.prototype.accumulate=function(e,r){var n=this._values[e];n?n.value=t(n.value,r):(n=this._heap.insert(e,r),this._values[e]=n)},i.prototype.forEach=function(e,t,n){var i=this._heap,a=this._values,o=[],u=i.extractMinimum();for(u&&o.push(u);u&&u.key<=t;)u.key>=e&&(r(u.value,0)||n(u.key,u.value,this)),(u=i.extractMinimum())&&o.push(u);for(var s=0;s<o.length;s++){var c=o[s];a[(u=i.insert(c.key,c.value)).key]=u}},i.prototype.swap=function(e,t){var r=this._values[e],n=this._values[t];if(!r&&n)r=this._heap.insert(e,n.value),this._heap.remove(n),this._values[e]=r,this._values[t]=void 0;else if(r&&!n)n=this._heap.insert(t,r.value),this._heap.remove(r),this._values[t]=n,this._values[e]=void 0;else if(r&&n){var i=r.value;r.value=n.value,n.value=i}},i}),{isClass:!0}),Df=(r(375),jn((function(e){return new e(1).exp()}),{hasher:Sf})),Nf=jn((function(e){return new e(1).plus(new e(5).sqrt()).div(2)}),{hasher:Sf}),Ef=jn((function(e){return e.acos(-1)}),{hasher:Sf}),Af=jn((function(e){return Ef(e).times(2)}),{hasher:Sf});function Sf(e){return e[0].precision}function Cf(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function Mf(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?Cf(Object(r),!0).forEach((function(t){Va(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):Cf(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}var Ff=Se("Unit",["?on","config","addScalar","subtractScalar","multiplyScalar","divideScalar","pow","abs","fix","round","equal","isNumeric","format","number","Complex","BigNumber","Fraction"],(function(e){var r,n,i,a=e.on,u=e.config,c=e.addScalar,f=e.subtractScalar,l=e.multiplyScalar,p=e.divideScalar,m=e.pow,h=e.abs,d=e.fix,v=e.round,y=e.equal,g=e.isNumeric,x=e.format,b=e.number,w=e.Complex,D=e.BigNumber,N=e.Fraction,E=b;function A(e,t){if(!(this instanceof A))throw new Error("Constructor must be called with the new operator");if(null!=e&&!g(e)&&!o(e))throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");if(this.fixPrefix=!1,this.skipAutomaticSimplification=!0,void 0===t)this.units=[],this.dimensions=z.map((function(e){return 0}));else if("string"==typeof t){var r=A.parse(t);this.units=r.units,this.dimensions=r.dimensions}else{if(!s(t)||null!==t.value)throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");this.fixPrefix=t.fixPrefix,this.skipAutomaticSimplification=t.skipAutomaticSimplification,this.dimensions=t.dimensions.slice(0),this.units=t.units.map((function(e){return Yr({},e)}))}this.value=this._normalize(e)}function S(){for(;" "===i||"\t"===i;)M()}function C(e){return e>="0"&&e<="9"}function M(){n++,i=r.charAt(n)}function F(e){n=e,i=r.charAt(n)}function O(){var e="",t=n;if("+"===i?M():"-"===i&&(e+=i,M()),!function(e){return e>="0"&&e<="9"||"."===e}(i))return F(t),null;if("."===i){if(e+=i,M(),!C(i))return F(t),null}else{for(;C(i);)e+=i,M();"."===i&&(e+=i,M())}for(;C(i);)e+=i,M();if("E"===i||"e"===i){var r="",a=n;if(r+=i,M(),"+"!==i&&"-"!==i||(r+=i,M()),!C(i))return F(a),e;for(e+=r;C(i);)e+=i,M()}return e}function T(){for(var e="";C(i)||A.isValidAlpha(i);)e+=i,M();var t=e.charAt(0);return A.isValidAlpha(t)?e:null}function _(e){return i===e?(M(),e):null}Object.defineProperty(A,"name",{value:"Unit"}),A.prototype.constructor=A,A.prototype.type="Unit",A.prototype.isUnit=!0,A.parse=function(e,t){if(t=t||{},n=-1,i="","string"!=typeof(r=e))throw new TypeError("Invalid argument in Unit.parse, string expected");var a=new A;a.units=[];var o=1,s=!1;M(),S();var c=O(),f=null;if(c){if("BigNumber"===u.number)f=new D(c);else if("Fraction"===u.number)try{f=new N(c)}catch(e){f=parseFloat(c)}else f=parseFloat(c);S(),_("*")?(o=1,s=!0):_("/")&&(o=-1,s=!0)}for(var l=[],p=1;;){for(S();"("===i;)l.push(o),p*=o,o=1,M(),S();var m;if(!i)break;var h=i;if(null===(m=T()))throw new SyntaxError('Unexpected "'+h+'" in "'+r+'" at index '+n.toString());var d=B(m);if(null===d)throw new SyntaxError('Unit "'+m+'" not found.');var v=o*p;if(S(),_("^")){S();var y=O();if(null===y)throw new SyntaxError('In "'+e+'", "^" must be followed by a floating-point number');v*=y}a.units.push({unit:d.unit,prefix:d.prefix,power:v});for(var g=0;g<z.length;g++)a.dimensions[g]+=(d.unit.dimensions[g]||0)*v;for(S();")"===i;){if(0===l.length)throw new SyntaxError('Unmatched ")" in "'+r+'" at index '+n.toString());p/=l.pop(),M(),S()}if(s=!1,_("*")?(o=1,s=!0):_("/")?(o=-1,s=!0):o=1,d.unit.base){var x=d.unit.base.key;$.auto[x]={unit:d.unit,prefix:d.prefix}}}if(S(),i)throw new SyntaxError('Could not parse: "'+e+'"');if(s)throw new SyntaxError('Trailing characters: "'+e+'"');if(0!==l.length)throw new SyntaxError('Unmatched "(" in "'+r+'"');if(0===a.units.length&&!t.allowNoUnits)throw new SyntaxError('"'+e+'" contains no units');return a.value=void 0!==f?a._normalize(f):null,a},A.prototype.clone=function(){var e=new A;e.fixPrefix=this.fixPrefix,e.skipAutomaticSimplification=this.skipAutomaticSimplification,e.value=ye(this.value),e.dimensions=this.dimensions.slice(0),e.units=[];for(var t=0;t<this.units.length;t++)for(var r in e.units[t]={},this.units[t])Ae(this.units[t],r)&&(e.units[t][r]=this.units[t][r]);return e},A.prototype.valueType=function(){return H(this.value)},A.prototype._isDerived=function(){return 0!==this.units.length&&(this.units.length>1||Math.abs(this.units[0].power-1)>1e-15)},A.prototype._normalize=function(e){if(null==e||0===this.units.length)return e;for(var t=e,r=A._getNumberConverter(H(e)),n=0;n<this.units.length;n++){var i=r(this.units[n].unit.value),a=r(this.units[n].prefix.value),o=r(this.units[n].power);t=l(t,m(l(i,a),o))}return t},A.prototype._denormalize=function(e,t){if(null==e||0===this.units.length)return e;for(var r=e,n=A._getNumberConverter(H(e)),i=0;i<this.units.length;i++){var a=n(this.units[i].unit.value),o=n(this.units[i].prefix.value),u=n(this.units[i].power);r=p(r,m(l(a,o),u))}return r};var B=jn((function(e){if(Ae(P,e)){var t=P[e];return{unit:t,prefix:t.prefixes[""]}}for(var r in P)if(Ae(P,r)&&Kr(e,r)){var n=P[r],i=e.length-r.length,a=e.substring(0,i),o=Ae(n.prefixes,a)?n.prefixes[a]:void 0;if(void 0!==o)return{unit:n,prefix:o}}return null}),{hasher:function(e){return e[0]},limit:100});function k(e){return e.equalBase(R.NONE)&&null!==e.value&&!u.predictable?e.value:e}A.isValuelessUnit=function(e){return null!==B(e)},A.prototype.hasBase=function(e){if("string"==typeof e&&(e=R[e]),!e)return!1;for(var t=0;t<z.length;t++)if(Math.abs((this.dimensions[t]||0)-(e.dimensions[t]||0))>1e-12)return!1;return!0},A.prototype.equalBase=function(e){for(var t=0;t<z.length;t++)if(Math.abs((this.dimensions[t]||0)-(e.dimensions[t]||0))>1e-12)return!1;return!0},A.prototype.equals=function(e){return this.equalBase(e)&&y(this.value,e.value)},A.prototype.multiply=function(e){for(var t=this.clone(),r=s(e)?e:new A(e),n=0;n<z.length;n++)t.dimensions[n]=(this.dimensions[n]||0)+(r.dimensions[n]||0);for(var i=0;i<r.units.length;i++){var a=Mf({},r.units[i]);t.units.push(a)}if(null!==this.value||null!==r.value){var o=null===this.value?this._normalize(1):this.value,u=null===r.value?r._normalize(1):r.value;t.value=l(o,u)}else t.value=null;return s(e)&&(t.skipAutomaticSimplification=!1),k(t)},A.prototype.divideInto=function(e){return new A(e).divide(this)},A.prototype.divide=function(e){for(var t=this.clone(),r=s(e)?e:new A(e),n=0;n<z.length;n++)t.dimensions[n]=(this.dimensions[n]||0)-(r.dimensions[n]||0);for(var i=0;i<r.units.length;i++){var a=Mf(Mf({},r.units[i]),{},{power:-r.units[i].power});t.units.push(a)}if(null!==this.value||null!==r.value){var o=null===this.value?this._normalize(1):this.value,u=null===r.value?r._normalize(1):r.value;t.value=p(o,u)}else t.value=null;return s(e)&&(t.skipAutomaticSimplification=!1),k(t)},A.prototype.pow=function(e){for(var t=this.clone(),r=0;r<z.length;r++)t.dimensions[r]=(this.dimensions[r]||0)*e;for(var n=0;n<t.units.length;n++)t.units[n].power*=e;return null!==t.value?t.value=m(t.value,e):t.value=null,t.skipAutomaticSimplification=!1,k(t)},A.prototype.abs=function(){var e=this.clone();if(null!==e.value)if(e._isDerived()||0===e.units.length||0===e.units[0].unit.offset)e.value=h(e.value);else{var t=e._numberConverter(),r=t(e.units[0].unit.value),n=t(e.units[0].unit.offset),i=l(r,n);e.value=f(h(c(e.value,i)),i)}for(var a in e.units)"VA"!==e.units[a].unit.name&&"VAR"!==e.units[a].unit.name||(e.units[a].unit=P.W);return e},A.prototype.to=function(e){var t,r=null===this.value?this._normalize(1):this.value;if("string"==typeof e)t=A.parse(e);else{if(!s(e))throw new Error("String or Unit expected as parameter");t=e.clone()}if(!this.equalBase(t))throw new Error("Units do not match ('".concat(t.toString(),"' != '").concat(this.toString(),"')"));if(null!==t.value)throw new Error("Cannot convert to a unit with a value");if(null===this.value||this._isDerived()||0===this.units.length||0===t.units.length||this.units[0].unit.offset===t.units[0].unit.offset)t.value=ye(r);else{var n=A._getNumberConverter(H(r)),i=this.units[0].unit.value,a=this.units[0].unit.offset,o=l(i,a),u=t.units[0].unit.value,p=t.units[0].unit.offset,m=l(u,p);t.value=c(r,n(f(o,m)))}return t.fixPrefix=!0,t.skipAutomaticSimplification=!0,t},A.prototype.toNumber=function(e){return E(this.toNumeric(e))},A.prototype.toNumeric=function(e){var t;return(t=e?this.to(e):this.clone())._isDerived()||0===t.units.length?t._denormalize(t.value):t._denormalize(t.value,t.units[0].prefix.value)},A.prototype.toString=function(){return this.format()},A.prototype.toJSON=function(){return{mathjs:"Unit",value:this._denormalize(this.value),unit:this.formatUnits(),fixPrefix:this.fixPrefix}},A.fromJSON=function(e){var t=new A(e.value,e.unit);return t.fixPrefix=e.fixPrefix||!1,t},A.prototype.valueOf=A.prototype.toString,A.prototype.simplify=function(){var e,t,r=this.clone(),n=[];for(var i in G)if(Ae(G,i)&&r.hasBase(R[i])){e=i;break}if("NONE"===e)r.units=[];else if(e&&Ae(G,e)&&(t=G[e]),t)r.units=[{unit:t.unit,prefix:t.prefix,power:1}];else{for(var a=!1,o=0;o<z.length;o++){var u=z[o];Math.abs(r.dimensions[o]||0)>1e-12&&(Ae(G,u)?n.push({unit:G[u].unit,prefix:G[u].prefix,power:r.dimensions[o]||0}):a=!0)}n.length<r.units.length&&!a&&(r.units=n)}return r},A.prototype.toSI=function(){for(var e=this.clone(),t=[],r=0;r<z.length;r++){var n=z[r];if(Math.abs(e.dimensions[r]||0)>1e-12){if(!Ae($.si,n))throw new Error("Cannot express custom unit "+n+" in SI units");t.push({unit:$.si[n].unit,prefix:$.si[n].prefix,power:e.dimensions[r]||0})}}return e.units=t,e.fixPrefix=!0,e.skipAutomaticSimplification=!0,null!==this.value?(e.value=null,this.to(e)):e},A.prototype.formatUnits=function(){for(var e="",t="",r=0,n=0,i=0;i<this.units.length;i++)this.units[i].power>0?(r++,e+=" "+this.units[i].prefix.name+this.units[i].unit.name,Math.abs(this.units[i].power-1)>1e-15&&(e+="^"+this.units[i].power)):this.units[i].power<0&&n++;if(n>0)for(var a=0;a<this.units.length;a++)this.units[a].power<0&&(r>0?(t+=" "+this.units[a].prefix.name+this.units[a].unit.name,Math.abs(this.units[a].power+1)>1e-15&&(t+="^"+-this.units[a].power)):(t+=" "+this.units[a].prefix.name+this.units[a].unit.name,t+="^"+this.units[a].power));e=e.substr(1),t=t.substr(1),r>1&&n>0&&(e="("+e+")"),n>1&&r>0&&(t="("+t+")");var o=e;return r>0&&n>0&&(o+=" / "),o+t},A.prototype.format=function(e){var t=this.skipAutomaticSimplification||null===this.value?this.clone():this.simplify(),r=!1;for(var n in void 0!==t.value&&null!==t.value&&o(t.value)&&(r=Math.abs(t.value.re)<1e-14),t.units)Ae(t.units,n)&&t.units[n].unit&&("VA"===t.units[n].unit.name&&r?t.units[n].unit=P.VAR:"VAR"!==t.units[n].unit.name||r||(t.units[n].unit=P.VA));1!==t.units.length||t.fixPrefix||Math.abs(t.units[0].power-Math.round(t.units[0].power))<1e-14&&(t.units[0].prefix=t._bestPrefix());var i=t._denormalize(t.value),a=null!==t.value?x(i,e||{}):"",u=t.formatUnits();return t.value&&o(t.value)&&(a="("+a+")"),u.length>0&&a.length>0&&(a+=" "),a+u},A.prototype._bestPrefix=function(){if(1!==this.units.length)throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");if(Math.abs(this.units[0].power-Math.round(this.units[0].power))>=1e-14)throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");var e=null!==this.value?h(this.value):0,t=h(this.units[0].unit.value),r=this.units[0].prefix;if(0===e)return r;var n=this.units[0].power,i=Math.log(e/Math.pow(r.value*t,n))/Math.LN10-1.2;if(i>-2.200001&&i<1.800001)return r;i=Math.abs(i);var a=this.units[0].unit.prefixes;for(var o in a)if(Ae(a,o)){var u=a[o];if(u.scientific){var s=Math.abs(Math.log(e/Math.pow(u.value*t,n))/Math.LN10-1.2);(s<i||s===i&&u.name.length<r.name.length)&&(r=u,i=s)}}return r},A.prototype.splitUnit=function(e){for(var t=this.clone(),r=[],n=0;n<e.length&&(t=t.to(e[n]),n!==e.length-1);n++){var i=t.toNumeric(),a=v(i),o=new A(y(a,i)?a:d(t.toNumeric()),e[n].toString());r.push(o),t=f(t,o)}for(var u=0,s=0;s<r.length;s++)u=c(u,r[s].value);return y(u,this.value)&&(t.value=0),r.push(t),r};var I={NONE:{"":{name:"",value:1,scientific:!0}},SHORT:{"":{name:"",value:1,scientific:!0},da:{name:"da",value:10,scientific:!1},h:{name:"h",value:100,scientific:!1},k:{name:"k",value:1e3,scientific:!0},M:{name:"M",value:1e6,scientific:!0},G:{name:"G",value:1e9,scientific:!0},T:{name:"T",value:1e12,scientific:!0},P:{name:"P",value:1e15,scientific:!0},E:{name:"E",value:1e18,scientific:!0},Z:{name:"Z",value:1e21,scientific:!0},Y:{name:"Y",value:1e24,scientific:!0},R:{name:"R",value:1e27,scientific:!0},Q:{name:"Q",value:1e30,scientific:!0},d:{name:"d",value:.1,scientific:!1},c:{name:"c",value:.01,scientific:!1},m:{name:"m",value:.001,scientific:!0},u:{name:"u",value:1e-6,scientific:!0},n:{name:"n",value:1e-9,scientific:!0},p:{name:"p",value:1e-12,scientific:!0},f:{name:"f",value:1e-15,scientific:!0},a:{name:"a",value:1e-18,scientific:!0},z:{name:"z",value:1e-21,scientific:!0},y:{name:"y",value:1e-24,scientific:!0},r:{name:"r",value:1e-27,scientific:!0},q:{name:"q",value:1e-30,scientific:!0}},LONG:{"":{name:"",value:1,scientific:!0},deca:{name:"deca",value:10,scientific:!1},hecto:{name:"hecto",value:100,scientific:!1},kilo:{name:"kilo",value:1e3,scientific:!0},mega:{name:"mega",value:1e6,scientific:!0},giga:{name:"giga",value:1e9,scientific:!0},tera:{name:"tera",value:1e12,scientific:!0},peta:{name:"peta",value:1e15,scientific:!0},exa:{name:"exa",value:1e18,scientific:!0},zetta:{name:"zetta",value:1e21,scientific:!0},yotta:{name:"yotta",value:1e24,scientific:!0},ronna:{name:"ronna",value:1e27,scientific:!0},quetta:{name:"quetta",value:1e30,scientific:!0},deci:{name:"deci",value:.1,scientific:!1},centi:{name:"centi",value:.01,scientific:!1},milli:{name:"milli",value:.001,scientific:!0},micro:{name:"micro",value:1e-6,scientific:!0},nano:{name:"nano",value:1e-9,scientific:!0},pico:{name:"pico",value:1e-12,scientific:!0},femto:{name:"femto",value:1e-15,scientific:!0},atto:{name:"atto",value:1e-18,scientific:!0},zepto:{name:"zepto",value:1e-21,scientific:!0},yocto:{name:"yocto",value:1e-24,scientific:!0},ronto:{name:"ronto",value:1e-27,scientific:!0},quecto:{name:"quecto",value:1e-30,scientific:!0}},SQUARED:{"":{name:"",value:1,scientific:!0},da:{name:"da",value:100,scientific:!1},h:{name:"h",value:1e4,scientific:!1},k:{name:"k",value:1e6,scientific:!0},M:{name:"M",value:1e12,scientific:!0},G:{name:"G",value:1e18,scientific:!0},T:{name:"T",value:1e24,scientific:!0},P:{name:"P",value:1e30,scientific:!0},E:{name:"E",value:1e36,scientific:!0},Z:{name:"Z",value:1e42,scientific:!0},Y:{name:"Y",value:1e48,scientific:!0},R:{name:"R",value:1e54,scientific:!0},Q:{name:"Q",value:1e60,scientific:!0},d:{name:"d",value:.01,scientific:!1},c:{name:"c",value:1e-4,scientific:!1},m:{name:"m",value:1e-6,scientific:!0},u:{name:"u",value:1e-12,scientific:!0},n:{name:"n",value:1e-18,scientific:!0},p:{name:"p",value:1e-24,scientific:!0},f:{name:"f",value:1e-30,scientific:!0},a:{name:"a",value:1e-36,scientific:!0},z:{name:"z",value:1e-42,scientific:!0},y:{name:"y",value:1e-48,scientific:!0},r:{name:"r",value:1e-54,scientific:!0},q:{name:"q",value:1e-60,scientific:!0}},CUBIC:{"":{name:"",value:1,scientific:!0},da:{name:"da",value:1e3,scientific:!1},h:{name:"h",value:1e6,scientific:!1},k:{name:"k",value:1e9,scientific:!0},M:{name:"M",value:1e18,scientific:!0},G:{name:"G",value:1e27,scientific:!0},T:{name:"T",value:1e36,scientific:!0},P:{name:"P",value:1e45,scientific:!0},E:{name:"E",value:1e54,scientific:!0},Z:{name:"Z",value:1e63,scientific:!0},Y:{name:"Y",value:1e72,scientific:!0},R:{name:"R",value:1e81,scientific:!0},Q:{name:"Q",value:1e90,scientific:!0},d:{name:"d",value:.001,scientific:!1},c:{name:"c",value:1e-6,scientific:!1},m:{name:"m",value:1e-9,scientific:!0},u:{name:"u",value:1e-18,scientific:!0},n:{name:"n",value:1e-27,scientific:!0},p:{name:"p",value:1e-36,scientific:!0},f:{name:"f",value:1e-45,scientific:!0},a:{name:"a",value:1e-54,scientific:!0},z:{name:"z",value:1e-63,scientific:!0},y:{name:"y",value:1e-72,scientific:!0},r:{name:"r",value:1e-81,scientific:!0},q:{name:"q",value:1e-90,scientific:!0}},BINARY_SHORT_SI:{"":{name:"",value:1,scientific:!0},k:{name:"k",value:1e3,scientific:!0},M:{name:"M",value:1e6,scientific:!0},G:{name:"G",value:1e9,scientific:!0},T:{name:"T",value:1e12,scientific:!0},P:{name:"P",value:1e15,scientific:!0},E:{name:"E",value:1e18,scientific:!0},Z:{name:"Z",value:1e21,scientific:!0},Y:{name:"Y",value:1e24,scientific:!0}},BINARY_SHORT_IEC:{"":{name:"",value:1,scientific:!0},Ki:{name:"Ki",value:1024,scientific:!0},Mi:{name:"Mi",value:Math.pow(1024,2),scientific:!0},Gi:{name:"Gi",value:Math.pow(1024,3),scientific:!0},Ti:{name:"Ti",value:Math.pow(1024,4),scientific:!0},Pi:{name:"Pi",value:Math.pow(1024,5),scientific:!0},Ei:{name:"Ei",value:Math.pow(1024,6),scientific:!0},Zi:{name:"Zi",value:Math.pow(1024,7),scientific:!0},Yi:{name:"Yi",value:Math.pow(1024,8),scientific:!0}},BINARY_LONG_SI:{"":{name:"",value:1,scientific:!0},kilo:{name:"kilo",value:1e3,scientific:!0},mega:{name:"mega",value:1e6,scientific:!0},giga:{name:"giga",value:1e9,scientific:!0},tera:{name:"tera",value:1e12,scientific:!0},peta:{name:"peta",value:1e15,scientific:!0},exa:{name:"exa",value:1e18,scientific:!0},zetta:{name:"zetta",value:1e21,scientific:!0},yotta:{name:"yotta",value:1e24,scientific:!0}},BINARY_LONG_IEC:{"":{name:"",value:1,scientific:!0},kibi:{name:"kibi",value:1024,scientific:!0},mebi:{name:"mebi",value:Math.pow(1024,2),scientific:!0},gibi:{name:"gibi",value:Math.pow(1024,3),scientific:!0},tebi:{name:"tebi",value:Math.pow(1024,4),scientific:!0},pebi:{name:"pebi",value:Math.pow(1024,5),scientific:!0},exi:{name:"exi",value:Math.pow(1024,6),scientific:!0},zebi:{name:"zebi",value:Math.pow(1024,7),scientific:!0},yobi:{name:"yobi",value:Math.pow(1024,8),scientific:!0}},BTU:{"":{name:"",value:1,scientific:!0},MM:{name:"MM",value:1e6,scientific:!0}}};I.SHORTLONG=Yr({},I.SHORT,I.LONG),I.BINARY_SHORT=Yr({},I.BINARY_SHORT_SI,I.BINARY_SHORT_IEC),I.BINARY_LONG=Yr({},I.BINARY_LONG_SI,I.BINARY_LONG_IEC);var z=["MASS","LENGTH","TIME","CURRENT","TEMPERATURE","LUMINOUS_INTENSITY","AMOUNT_OF_SUBSTANCE","ANGLE","BIT"],R={NONE:{dimensions:[0,0,0,0,0,0,0,0,0]},MASS:{dimensions:[1,0,0,0,0,0,0,0,0]},LENGTH:{dimensions:[0,1,0,0,0,0,0,0,0]},TIME:{dimensions:[0,0,1,0,0,0,0,0,0]},CURRENT:{dimensions:[0,0,0,1,0,0,0,0,0]},TEMPERATURE:{dimensions:[0,0,0,0,1,0,0,0,0]},LUMINOUS_INTENSITY:{dimensions:[0,0,0,0,0,1,0,0,0]},AMOUNT_OF_SUBSTANCE:{dimensions:[0,0,0,0,0,0,1,0,0]},FORCE:{dimensions:[1,1,-2,0,0,0,0,0,0]},SURFACE:{dimensions:[0,2,0,0,0,0,0,0,0]},VOLUME:{dimensions:[0,3,0,0,0,0,0,0,0]},ENERGY:{dimensions:[1,2,-2,0,0,0,0,0,0]},POWER:{dimensions:[1,2,-3,0,0,0,0,0,0]},PRESSURE:{dimensions:[1,-1,-2,0,0,0,0,0,0]},ELECTRIC_CHARGE:{dimensions:[0,0,1,1,0,0,0,0,0]},ELECTRIC_CAPACITANCE:{dimensions:[-1,-2,4,2,0,0,0,0,0]},ELECTRIC_POTENTIAL:{dimensions:[1,2,-3,-1,0,0,0,0,0]},ELECTRIC_RESISTANCE:{dimensions:[1,2,-3,-2,0,0,0,0,0]},ELECTRIC_INDUCTANCE:{dimensions:[1,2,-2,-2,0,0,0,0,0]},ELECTRIC_CONDUCTANCE:{dimensions:[-1,-2,3,2,0,0,0,0,0]},MAGNETIC_FLUX:{dimensions:[1,2,-2,-1,0,0,0,0,0]},MAGNETIC_FLUX_DENSITY:{dimensions:[1,0,-2,-1,0,0,0,0,0]},FREQUENCY:{dimensions:[0,0,-1,0,0,0,0,0,0]},ANGLE:{dimensions:[0,0,0,0,0,0,0,1,0]},BIT:{dimensions:[0,0,0,0,0,0,0,0,1]}};for(var q in R)Ae(R,q)&&(R[q].key=q);var j={name:"",base:{},value:1,offset:0,dimensions:z.map((function(e){return 0}))},P={meter:{name:"meter",base:R.LENGTH,prefixes:I.LONG,value:1,offset:0},inch:{name:"inch",base:R.LENGTH,prefixes:I.NONE,value:.0254,offset:0},foot:{name:"foot",base:R.LENGTH,prefixes:I.NONE,value:.3048,offset:0},yard:{name:"yard",base:R.LENGTH,prefixes:I.NONE,value:.9144,offset:0},mile:{name:"mile",base:R.LENGTH,prefixes:I.NONE,value:1609.344,offset:0},link:{name:"link",base:R.LENGTH,prefixes:I.NONE,value:.201168,offset:0},rod:{name:"rod",base:R.LENGTH,prefixes:I.NONE,value:5.0292,offset:0},chain:{name:"chain",base:R.LENGTH,prefixes:I.NONE,value:20.1168,offset:0},angstrom:{name:"angstrom",base:R.LENGTH,prefixes:I.NONE,value:1e-10,offset:0},m:{name:"m",base:R.LENGTH,prefixes:I.SHORT,value:1,offset:0},in:{name:"in",base:R.LENGTH,prefixes:I.NONE,value:.0254,offset:0},ft:{name:"ft",base:R.LENGTH,prefixes:I.NONE,value:.3048,offset:0},yd:{name:"yd",base:R.LENGTH,prefixes:I.NONE,value:.9144,offset:0},mi:{name:"mi",base:R.LENGTH,prefixes:I.NONE,value:1609.344,offset:0},li:{name:"li",base:R.LENGTH,prefixes:I.NONE,value:.201168,offset:0},rd:{name:"rd",base:R.LENGTH,prefixes:I.NONE,value:5.02921,offset:0},ch:{name:"ch",base:R.LENGTH,prefixes:I.NONE,value:20.1168,offset:0},mil:{name:"mil",base:R.LENGTH,prefixes:I.NONE,value:254e-7,offset:0},m2:{name:"m2",base:R.SURFACE,prefixes:I.SQUARED,value:1,offset:0},sqin:{name:"sqin",base:R.SURFACE,prefixes:I.NONE,value:64516e-8,offset:0},sqft:{name:"sqft",base:R.SURFACE,prefixes:I.NONE,value:.09290304,offset:0},sqyd:{name:"sqyd",base:R.SURFACE,prefixes:I.NONE,value:.83612736,offset:0},sqmi:{name:"sqmi",base:R.SURFACE,prefixes:I.NONE,value:2589988.110336,offset:0},sqrd:{name:"sqrd",base:R.SURFACE,prefixes:I.NONE,value:25.29295,offset:0},sqch:{name:"sqch",base:R.SURFACE,prefixes:I.NONE,value:404.6873,offset:0},sqmil:{name:"sqmil",base:R.SURFACE,prefixes:I.NONE,value:6.4516e-10,offset:0},acre:{name:"acre",base:R.SURFACE,prefixes:I.NONE,value:4046.86,offset:0},hectare:{name:"hectare",base:R.SURFACE,prefixes:I.NONE,value:1e4,offset:0},m3:{name:"m3",base:R.VOLUME,prefixes:I.CUBIC,value:1,offset:0},L:{name:"L",base:R.VOLUME,prefixes:I.SHORT,value:.001,offset:0},l:{name:"l",base:R.VOLUME,prefixes:I.SHORT,value:.001,offset:0},litre:{name:"litre",base:R.VOLUME,prefixes:I.LONG,value:.001,offset:0},cuin:{name:"cuin",base:R.VOLUME,prefixes:I.NONE,value:16387064e-12,offset:0},cuft:{name:"cuft",base:R.VOLUME,prefixes:I.NONE,value:.028316846592,offset:0},cuyd:{name:"cuyd",base:R.VOLUME,prefixes:I.NONE,value:.764554857984,offset:0},teaspoon:{name:"teaspoon",base:R.VOLUME,prefixes:I.NONE,value:5e-6,offset:0},tablespoon:{name:"tablespoon",base:R.VOLUME,prefixes:I.NONE,value:15e-6,offset:0},drop:{name:"drop",base:R.VOLUME,prefixes:I.NONE,value:5e-8,offset:0},gtt:{name:"gtt",base:R.VOLUME,prefixes:I.NONE,value:5e-8,offset:0},minim:{name:"minim",base:R.VOLUME,prefixes:I.NONE,value:6.161152e-8,offset:0},fluiddram:{name:"fluiddram",base:R.VOLUME,prefixes:I.NONE,value:36966911e-13,offset:0},fluidounce:{name:"fluidounce",base:R.VOLUME,prefixes:I.NONE,value:2957353e-11,offset:0},gill:{name:"gill",base:R.VOLUME,prefixes:I.NONE,value:.0001182941,offset:0},cc:{name:"cc",base:R.VOLUME,prefixes:I.NONE,value:1e-6,offset:0},cup:{name:"cup",base:R.VOLUME,prefixes:I.NONE,value:.0002365882,offset:0},pint:{name:"pint",base:R.VOLUME,prefixes:I.NONE,value:.0004731765,offset:0},quart:{name:"quart",base:R.VOLUME,prefixes:I.NONE,value:.0009463529,offset:0},gallon:{name:"gallon",base:R.VOLUME,prefixes:I.NONE,value:.003785412,offset:0},beerbarrel:{name:"beerbarrel",base:R.VOLUME,prefixes:I.NONE,value:.1173478,offset:0},oilbarrel:{name:"oilbarrel",base:R.VOLUME,prefixes:I.NONE,value:.1589873,offset:0},hogshead:{name:"hogshead",base:R.VOLUME,prefixes:I.NONE,value:.238481,offset:0},fldr:{name:"fldr",base:R.VOLUME,prefixes:I.NONE,value:36966911e-13,offset:0},floz:{name:"floz",base:R.VOLUME,prefixes:I.NONE,value:2957353e-11,offset:0},gi:{name:"gi",base:R.VOLUME,prefixes:I.NONE,value:.0001182941,offset:0},cp:{name:"cp",base:R.VOLUME,prefixes:I.NONE,value:.0002365882,offset:0},pt:{name:"pt",base:R.VOLUME,prefixes:I.NONE,value:.0004731765,offset:0},qt:{name:"qt",base:R.VOLUME,prefixes:I.NONE,value:.0009463529,offset:0},gal:{name:"gal",base:R.VOLUME,prefixes:I.NONE,value:.003785412,offset:0},bbl:{name:"bbl",base:R.VOLUME,prefixes:I.NONE,value:.1173478,offset:0},obl:{name:"obl",base:R.VOLUME,prefixes:I.NONE,value:.1589873,offset:0},g:{name:"g",base:R.MASS,prefixes:I.SHORT,value:.001,offset:0},gram:{name:"gram",base:R.MASS,prefixes:I.LONG,value:.001,offset:0},ton:{name:"ton",base:R.MASS,prefixes:I.SHORT,value:907.18474,offset:0},t:{name:"t",base:R.MASS,prefixes:I.SHORT,value:1e3,offset:0},tonne:{name:"tonne",base:R.MASS,prefixes:I.LONG,value:1e3,offset:0},grain:{name:"grain",base:R.MASS,prefixes:I.NONE,value:6479891e-11,offset:0},dram:{name:"dram",base:R.MASS,prefixes:I.NONE,value:.0017718451953125,offset:0},ounce:{name:"ounce",base:R.MASS,prefixes:I.NONE,value:.028349523125,offset:0},poundmass:{name:"poundmass",base:R.MASS,prefixes:I.NONE,value:.45359237,offset:0},hundredweight:{name:"hundredweight",base:R.MASS,prefixes:I.NONE,value:45.359237,offset:0},stick:{name:"stick",base:R.MASS,prefixes:I.NONE,value:.115,offset:0},stone:{name:"stone",base:R.MASS,prefixes:I.NONE,value:6.35029318,offset:0},gr:{name:"gr",base:R.MASS,prefixes:I.NONE,value:6479891e-11,offset:0},dr:{name:"dr",base:R.MASS,prefixes:I.NONE,value:.0017718451953125,offset:0},oz:{name:"oz",base:R.MASS,prefixes:I.NONE,value:.028349523125,offset:0},lbm:{name:"lbm",base:R.MASS,prefixes:I.NONE,value:.45359237,offset:0},cwt:{name:"cwt",base:R.MASS,prefixes:I.NONE,value:45.359237,offset:0},s:{name:"s",base:R.TIME,prefixes:I.SHORT,value:1,offset:0},min:{name:"min",base:R.TIME,prefixes:I.NONE,value:60,offset:0},h:{name:"h",base:R.TIME,prefixes:I.NONE,value:3600,offset:0},second:{name:"second",base:R.TIME,prefixes:I.LONG,value:1,offset:0},sec:{name:"sec",base:R.TIME,prefixes:I.LONG,value:1,offset:0},minute:{name:"minute",base:R.TIME,prefixes:I.NONE,value:60,offset:0},hour:{name:"hour",base:R.TIME,prefixes:I.NONE,value:3600,offset:0},day:{name:"day",base:R.TIME,prefixes:I.NONE,value:86400,offset:0},week:{name:"week",base:R.TIME,prefixes:I.NONE,value:604800,offset:0},month:{name:"month",base:R.TIME,prefixes:I.NONE,value:2629800,offset:0},year:{name:"year",base:R.TIME,prefixes:I.NONE,value:31557600,offset:0},decade:{name:"decade",base:R.TIME,prefixes:I.NONE,value:315576e3,offset:0},century:{name:"century",base:R.TIME,prefixes:I.NONE,value:315576e4,offset:0},millennium:{name:"millennium",base:R.TIME,prefixes:I.NONE,value:315576e5,offset:0},hertz:{name:"Hertz",base:R.FREQUENCY,prefixes:I.LONG,value:1,offset:0,reciprocal:!0},Hz:{name:"Hz",base:R.FREQUENCY,prefixes:I.SHORT,value:1,offset:0,reciprocal:!0},rad:{name:"rad",base:R.ANGLE,prefixes:I.SHORT,value:1,offset:0},radian:{name:"radian",base:R.ANGLE,prefixes:I.LONG,value:1,offset:0},deg:{name:"deg",base:R.ANGLE,prefixes:I.SHORT,value:null,offset:0},degree:{name:"degree",base:R.ANGLE,prefixes:I.LONG,value:null,offset:0},grad:{name:"grad",base:R.ANGLE,prefixes:I.SHORT,value:null,offset:0},gradian:{name:"gradian",base:R.ANGLE,prefixes:I.LONG,value:null,offset:0},cycle:{name:"cycle",base:R.ANGLE,prefixes:I.NONE,value:null,offset:0},arcsec:{name:"arcsec",base:R.ANGLE,prefixes:I.NONE,value:null,offset:0},arcmin:{name:"arcmin",base:R.ANGLE,prefixes:I.NONE,value:null,offset:0},A:{name:"A",base:R.CURRENT,prefixes:I.SHORT,value:1,offset:0},ampere:{name:"ampere",base:R.CURRENT,prefixes:I.LONG,value:1,offset:0},K:{name:"K",base:R.TEMPERATURE,prefixes:I.SHORT,value:1,offset:0},degC:{name:"degC",base:R.TEMPERATURE,prefixes:I.SHORT,value:1,offset:273.15},degF:{name:"degF",base:R.TEMPERATURE,prefixes:I.SHORT,value:new N(5,9),offset:459.67},degR:{name:"degR",base:R.TEMPERATURE,prefixes:I.SHORT,value:new N(5,9),offset:0},kelvin:{name:"kelvin",base:R.TEMPERATURE,prefixes:I.LONG,value:1,offset:0},celsius:{name:"celsius",base:R.TEMPERATURE,prefixes:I.LONG,value:1,offset:273.15},fahrenheit:{name:"fahrenheit",base:R.TEMPERATURE,prefixes:I.LONG,value:new N(5,9),offset:459.67},rankine:{name:"rankine",base:R.TEMPERATURE,prefixes:I.LONG,value:new N(5,9),offset:0},mol:{name:"mol",base:R.AMOUNT_OF_SUBSTANCE,prefixes:I.SHORT,value:1,offset:0},mole:{name:"mole",base:R.AMOUNT_OF_SUBSTANCE,prefixes:I.LONG,value:1,offset:0},cd:{name:"cd",base:R.LUMINOUS_INTENSITY,prefixes:I.SHORT,value:1,offset:0},candela:{name:"candela",base:R.LUMINOUS_INTENSITY,prefixes:I.LONG,value:1,offset:0},N:{name:"N",base:R.FORCE,prefixes:I.SHORT,value:1,offset:0},newton:{name:"newton",base:R.FORCE,prefixes:I.LONG,value:1,offset:0},dyn:{name:"dyn",base:R.FORCE,prefixes:I.SHORT,value:1e-5,offset:0},dyne:{name:"dyne",base:R.FORCE,prefixes:I.LONG,value:1e-5,offset:0},lbf:{name:"lbf",base:R.FORCE,prefixes:I.NONE,value:4.4482216152605,offset:0},poundforce:{name:"poundforce",base:R.FORCE,prefixes:I.NONE,value:4.4482216152605,offset:0},kip:{name:"kip",base:R.FORCE,prefixes:I.LONG,value:4448.2216,offset:0},kilogramforce:{name:"kilogramforce",base:R.FORCE,prefixes:I.NONE,value:9.80665,offset:0},J:{name:"J",base:R.ENERGY,prefixes:I.SHORT,value:1,offset:0},joule:{name:"joule",base:R.ENERGY,prefixes:I.LONG,value:1,offset:0},erg:{name:"erg",base:R.ENERGY,prefixes:I.SHORTLONG,value:1e-7,offset:0},Wh:{name:"Wh",base:R.ENERGY,prefixes:I.SHORT,value:3600,offset:0},BTU:{name:"BTU",base:R.ENERGY,prefixes:I.BTU,value:1055.05585262,offset:0},eV:{name:"eV",base:R.ENERGY,prefixes:I.SHORT,value:1602176565e-28,offset:0},electronvolt:{name:"electronvolt",base:R.ENERGY,prefixes:I.LONG,value:1602176565e-28,offset:0},W:{name:"W",base:R.POWER,prefixes:I.SHORT,value:1,offset:0},watt:{name:"watt",base:R.POWER,prefixes:I.LONG,value:1,offset:0},hp:{name:"hp",base:R.POWER,prefixes:I.NONE,value:745.6998715386,offset:0},VAR:{name:"VAR",base:R.POWER,prefixes:I.SHORT,value:w.I,offset:0},VA:{name:"VA",base:R.POWER,prefixes:I.SHORT,value:1,offset:0},Pa:{name:"Pa",base:R.PRESSURE,prefixes:I.SHORT,value:1,offset:0},psi:{name:"psi",base:R.PRESSURE,prefixes:I.NONE,value:6894.75729276459,offset:0},atm:{name:"atm",base:R.PRESSURE,prefixes:I.NONE,value:101325,offset:0},bar:{name:"bar",base:R.PRESSURE,prefixes:I.SHORTLONG,value:1e5,offset:0},torr:{name:"torr",base:R.PRESSURE,prefixes:I.NONE,value:133.322,offset:0},mmHg:{name:"mmHg",base:R.PRESSURE,prefixes:I.NONE,value:133.322,offset:0},mmH2O:{name:"mmH2O",base:R.PRESSURE,prefixes:I.NONE,value:9.80665,offset:0},cmH2O:{name:"cmH2O",base:R.PRESSURE,prefixes:I.NONE,value:98.0665,offset:0},coulomb:{name:"coulomb",base:R.ELECTRIC_CHARGE,prefixes:I.LONG,value:1,offset:0},C:{name:"C",base:R.ELECTRIC_CHARGE,prefixes:I.SHORT,value:1,offset:0},farad:{name:"farad",base:R.ELECTRIC_CAPACITANCE,prefixes:I.LONG,value:1,offset:0},F:{name:"F",base:R.ELECTRIC_CAPACITANCE,prefixes:I.SHORT,value:1,offset:0},volt:{name:"volt",base:R.ELECTRIC_POTENTIAL,prefixes:I.LONG,value:1,offset:0},V:{name:"V",base:R.ELECTRIC_POTENTIAL,prefixes:I.SHORT,value:1,offset:0},ohm:{name:"ohm",base:R.ELECTRIC_RESISTANCE,prefixes:I.SHORTLONG,value:1,offset:0},henry:{name:"henry",base:R.ELECTRIC_INDUCTANCE,prefixes:I.LONG,value:1,offset:0},H:{name:"H",base:R.ELECTRIC_INDUCTANCE,prefixes:I.SHORT,value:1,offset:0},siemens:{name:"siemens",base:R.ELECTRIC_CONDUCTANCE,prefixes:I.LONG,value:1,offset:0},S:{name:"S",base:R.ELECTRIC_CONDUCTANCE,prefixes:I.SHORT,value:1,offset:0},weber:{name:"weber",base:R.MAGNETIC_FLUX,prefixes:I.LONG,value:1,offset:0},Wb:{name:"Wb",base:R.MAGNETIC_FLUX,prefixes:I.SHORT,value:1,offset:0},tesla:{name:"tesla",base:R.MAGNETIC_FLUX_DENSITY,prefixes:I.LONG,value:1,offset:0},T:{name:"T",base:R.MAGNETIC_FLUX_DENSITY,prefixes:I.SHORT,value:1,offset:0},b:{name:"b",base:R.BIT,prefixes:I.BINARY_SHORT,value:1,offset:0},bits:{name:"bits",base:R.BIT,prefixes:I.BINARY_LONG,value:1,offset:0},B:{name:"B",base:R.BIT,prefixes:I.BINARY_SHORT,value:8,offset:0},bytes:{name:"bytes",base:R.BIT,prefixes:I.BINARY_LONG,value:8,offset:0}},L={meters:"meter",inches:"inch",feet:"foot",yards:"yard",miles:"mile",links:"link",rods:"rod",chains:"chain",angstroms:"angstrom",lt:"l",litres:"litre",liter:"litre",liters:"litre",teaspoons:"teaspoon",tablespoons:"tablespoon",minims:"minim",fluiddrams:"fluiddram",fluidounces:"fluidounce",gills:"gill",cups:"cup",pints:"pint",quarts:"quart",gallons:"gallon",beerbarrels:"beerbarrel",oilbarrels:"oilbarrel",hogsheads:"hogshead",gtts:"gtt",grams:"gram",tons:"ton",tonnes:"tonne",grains:"grain",drams:"dram",ounces:"ounce",poundmasses:"poundmass",hundredweights:"hundredweight",sticks:"stick",lb:"lbm",lbs:"lbm",kips:"kip",kgf:"kilogramforce",acres:"acre",hectares:"hectare",sqfeet:"sqft",sqyard:"sqyd",sqmile:"sqmi",sqmiles:"sqmi",mmhg:"mmHg",mmh2o:"mmH2O",cmh2o:"cmH2O",seconds:"second",secs:"second",minutes:"minute",mins:"minute",hours:"hour",hr:"hour",hrs:"hour",days:"day",weeks:"week",months:"month",years:"year",decades:"decade",centuries:"century",millennia:"millennium",hertz:"hertz",radians:"radian",degrees:"degree",gradians:"gradian",cycles:"cycle",arcsecond:"arcsec",arcseconds:"arcsec",arcminute:"arcmin",arcminutes:"arcmin",BTUs:"BTU",watts:"watt",joules:"joule",amperes:"ampere",amps:"ampere",amp:"ampere",coulombs:"coulomb",volts:"volt",ohms:"ohm",farads:"farad",webers:"weber",teslas:"tesla",electronvolts:"electronvolt",moles:"mole",bit:"bits",byte:"bytes"};function U(e){if("BigNumber"===e.number){var t=Ef(D);P.rad.value=new D(1),P.deg.value=t.div(180),P.grad.value=t.div(200),P.cycle.value=t.times(2),P.arcsec.value=t.div(648e3),P.arcmin.value=t.div(10800)}else P.rad.value=1,P.deg.value=Math.PI/180,P.grad.value=Math.PI/200,P.cycle.value=2*Math.PI,P.arcsec.value=Math.PI/648e3,P.arcmin.value=Math.PI/10800;P.radian.value=P.rad.value,P.degree.value=P.deg.value,P.gradian.value=P.grad.value}U(u),a&&a("config",(function(e,t){e.number!==t.number&&U(e)}));var $={si:{NONE:{unit:j,prefix:I.NONE[""]},LENGTH:{unit:P.m,prefix:I.SHORT[""]},MASS:{unit:P.g,prefix:I.SHORT.k},TIME:{unit:P.s,prefix:I.SHORT[""]},CURRENT:{unit:P.A,prefix:I.SHORT[""]},TEMPERATURE:{unit:P.K,prefix:I.SHORT[""]},LUMINOUS_INTENSITY:{unit:P.cd,prefix:I.SHORT[""]},AMOUNT_OF_SUBSTANCE:{unit:P.mol,prefix:I.SHORT[""]},ANGLE:{unit:P.rad,prefix:I.SHORT[""]},BIT:{unit:P.bits,prefix:I.SHORT[""]},FORCE:{unit:P.N,prefix:I.SHORT[""]},ENERGY:{unit:P.J,prefix:I.SHORT[""]},POWER:{unit:P.W,prefix:I.SHORT[""]},PRESSURE:{unit:P.Pa,prefix:I.SHORT[""]},ELECTRIC_CHARGE:{unit:P.C,prefix:I.SHORT[""]},ELECTRIC_CAPACITANCE:{unit:P.F,prefix:I.SHORT[""]},ELECTRIC_POTENTIAL:{unit:P.V,prefix:I.SHORT[""]},ELECTRIC_RESISTANCE:{unit:P.ohm,prefix:I.SHORT[""]},ELECTRIC_INDUCTANCE:{unit:P.H,prefix:I.SHORT[""]},ELECTRIC_CONDUCTANCE:{unit:P.S,prefix:I.SHORT[""]},MAGNETIC_FLUX:{unit:P.Wb,prefix:I.SHORT[""]},MAGNETIC_FLUX_DENSITY:{unit:P.T,prefix:I.SHORT[""]},FREQUENCY:{unit:P.Hz,prefix:I.SHORT[""]}}};$.cgs=JSON.parse(JSON.stringify($.si)),$.cgs.LENGTH={unit:P.m,prefix:I.SHORT.c},$.cgs.MASS={unit:P.g,prefix:I.SHORT[""]},$.cgs.FORCE={unit:P.dyn,prefix:I.SHORT[""]},$.cgs.ENERGY={unit:P.erg,prefix:I.NONE[""]},$.us=JSON.parse(JSON.stringify($.si)),$.us.LENGTH={unit:P.ft,prefix:I.NONE[""]},$.us.MASS={unit:P.lbm,prefix:I.NONE[""]},$.us.TEMPERATURE={unit:P.degF,prefix:I.NONE[""]},$.us.FORCE={unit:P.lbf,prefix:I.NONE[""]},$.us.ENERGY={unit:P.BTU,prefix:I.BTU[""]},$.us.POWER={unit:P.hp,prefix:I.NONE[""]},$.us.PRESSURE={unit:P.psi,prefix:I.NONE[""]},$.auto=JSON.parse(JSON.stringify($.si));var G=$.auto;for(var V in A.setUnitSystem=function(e){if(!Ae($,e))throw new Error("Unit system "+e+" does not exist. Choices are: "+Object.keys($).join(", "));G=$[e]},A.getUnitSystem=function(){for(var e in $)if(Ae($,e)&&$[e]===G)return e},A.typeConverters={BigNumber:function(e){return null!=e&&e.isFraction?new D(e.n).div(e.d).times(e.s):new D(e+"")},Fraction:function(e){return new N(e)},Complex:function(e){return e},number:function(e){return null!=e&&e.isFraction?b(e):e}},A.prototype._numberConverter=function(){var e=A.typeConverters[this.valueType()];if(e)return e;throw new TypeError('Unsupported Unit value type "'+this.valueType()+'"')},A._getNumberConverter=function(e){if(!A.typeConverters[e])throw new TypeError('Unsupported type "'+e+'"');return A.typeConverters[e]},P)if(Ae(P,V)){var Z=P[V];Z.dimensions=Z.base.dimensions}for(var W in L)if(Ae(L,W)){var Y=P[L[W]],J={};for(var X in Y)Ae(Y,X)&&(J[X]=Y[X]);J.name=W,P[W]=J}return A.isValidAlpha=function(e){return/^[a-zA-Z]$/.test(e)},A.createUnit=function(e,r){if("object"!==t(e))throw new TypeError("createUnit expects first parameter to be of type 'Object'");if(r&&r.override)for(var n in e)if(Ae(e,n)&&A.deleteUnit(n),e[n].aliases)for(var i=0;i<e[n].aliases.length;i++)A.deleteUnit(e[n].aliases[i]);var a;for(var o in e)Ae(e,o)&&(a=A.createUnitSingle(o,e[o]));return a},A.createUnitSingle=function(e,r){if(null==r&&(r={}),"string"!=typeof e)throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");if(Ae(P,e))throw new Error('Cannot create unit "'+e+'": a unit with that name already exists');!function(e){for(var t=0;t<e.length;t++){if(i=e.charAt(t),0===t&&!A.isValidAlpha(i))throw new Error('Invalid unit name (must begin with alpha character): "'+e+'"');if(t>0&&!A.isValidAlpha(i)&&!C(i))throw new Error('Invalid unit name (only alphanumeric characters are allowed): "'+e+'"')}}(e);var n,a,o,u=null,s=[],c=0;if(r&&"Unit"===r.type)u=r.clone();else if("string"==typeof r)""!==r&&(n=r);else{if("object"!==t(r))throw new TypeError('Cannot create unit "'+e+'" from "'+r.toString()+'": expecting "string" or "Unit" or "Object"');n=r.definition,a=r.prefixes,c=r.offset,o=r.baseName,r.aliases&&(s=r.aliases.valueOf())}if(s)for(var f=0;f<s.length;f++)if(Ae(P,s[f]))throw new Error('Cannot create alias "'+s[f]+'": a unit with that name already exists');if(n&&"string"==typeof n&&!u)try{u=A.parse(n,{allowNoUnits:!0})}catch(t){throw t.message='Could not create unit "'+e+'" from "'+n+'": '+t.message,t}else n&&"Unit"===n.type&&(u=n.clone());s=s||[],c=c||0,a=a&&a.toUpperCase&&I[a.toUpperCase()]||I.NONE;var l={};if(u){l={name:e,value:u.value,dimensions:u.dimensions.slice(0),prefixes:a,offset:c};var p=!1;for(var m in R)if(Ae(R,m)){for(var h=!0,d=0;d<z.length;d++)if(Math.abs((l.dimensions[d]||0)-(R[m].dimensions[d]||0))>1e-12){h=!1;break}if(h){p=!0,l.base=R[m];break}}if(!p){o=o||e+"_STUFF";var v={dimensions:u.dimensions.slice(0)};v.key=o,R[o]=v,G[o]={unit:l,prefix:I.NONE[""]},l.base=R[o]}}else{if(o=o||e+"_STUFF",z.indexOf(o)>=0)throw new Error('Cannot create new base unit "'+e+'": a base unit with that name already exists (and cannot be overridden)');for(var y in z.push(o),R)Ae(R,y)&&(R[y].dimensions[z.length-1]=0);for(var g={dimensions:[]},x=0;x<z.length;x++)g.dimensions[x]=0;g.dimensions[z.length-1]=1,g.key=o,R[o]=g,l={name:e,value:1,dimensions:R[o].dimensions.slice(0),prefixes:a,offset:c,base:R[o]},G[o]={unit:l,prefix:I.NONE[""]}}A.UNITS[e]=l;for(var b=0;b<s.length;b++){var w=s[b],D={};for(var N in l)Ae(l,N)&&(D[N]=l[N]);D.name=w,A.UNITS[w]=D}return delete B.cache,new A(null,e)},A.deleteUnit=function(e){delete A.UNITS[e],delete B.cache},A.PREFIXES=I,A.BASE_DIMENSIONS=z,A.BASE_UNITS=R,A.UNIT_SYSTEMS=$,A.UNITS=P,A}),{isClass:!0}),Of="unit",Tf=Se(Of,["typed","Unit"],(function(e){var t=e.typed,r=e.Unit;return t(Of,{Unit:function(e){return e.clone()},string:function(e){return r.isValuelessUnit(e)?new r(null,e):r.parse(e,{allowNoUnits:!0})},"number | BigNumber | Fraction | Complex, string | Unit":function(e,t){return new r(e,t)},"number | BigNumber | Fraction":function(e){return new r(e)},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),_f="sparse",Bf=Se(_f,["typed","SparseMatrix"],(function(e){var t=e.typed,r=e.SparseMatrix;return t(_f,{"":function(){return new r([])},string:function(e){return new r([],e)},"Array | Matrix":function(e){return new r(e)},"Array | Matrix, string":function(e,t){return new r(e,t)}})})),kf="createUnit",If=Se(kf,["typed","Unit"],(function(e){var t=e.typed,r=e.Unit;return t(kf,{"Object, Object":function(e,t){return r.createUnit(e,t)},Object:function(e){return r.createUnit(e,{})},"string, Unit | string | Object, Object":function(e,t,n){var i={};return i[e]=t,r.createUnit(i,n)},"string, Unit | string | Object":function(e,t){var n={};return n[e]=t,r.createUnit(n,{})},string:function(e){var t={};return t[e]={},r.createUnit(t,{})}})})),zf="acos",Rf=Se(zf,["typed","config","Complex"],(function(e){var t=e.typed,r=e.config,n=e.Complex;return t(zf,{number:function(e){return e>=-1&&e<=1||r.predictable?Math.acos(e):new n(e,0).acos()},Complex:function(e){return e.acos()},BigNumber:function(e){return e.acos()}})})),qf="number";function jf(e){return ce(e)}function Pf(e){return Math.atan(1/e)}function Lf(e){return isFinite(e)?(Math.log((e+1)/e)+Math.log(e/(e-1)))/2:0}function Uf(e){return Math.asin(1/e)}function $f(e){var t=1/e;return Math.log(t+Math.sqrt(t*t+1))}function Hf(e){return Math.acos(1/e)}function Gf(e){var t=1/e,r=Math.sqrt(t*t-1);return Math.log(r+t)}function Vf(e){return fe(e)}function Zf(e){return le(e)}function Wf(e){return 1/Math.tan(e)}function Yf(e){var t=Math.exp(2*e);return(t+1)/(t-1)}function Jf(e){return 1/Math.sin(e)}function Xf(e){return 0===e?Number.POSITIVE_INFINITY:Math.abs(2/(Math.exp(e)-Math.exp(-e)))*Z(e)}function Qf(e){return 1/Math.cos(e)}function Kf(e){return 2/(Math.exp(e)+Math.exp(-e))}function el(e){return me(e)}jf.signature=qf,Pf.signature=qf,Lf.signature=qf,Uf.signature=qf,$f.signature=qf,Hf.signature=qf,Gf.signature=qf,Vf.signature=qf,Zf.signature=qf,Wf.signature=qf,Yf.signature=qf,Jf.signature=qf,Xf.signature=qf,Qf.signature=qf,Kf.signature=qf,el.signature=qf;var tl="acosh",rl=Se(tl,["typed","config","Complex"],(function(e){var t=e.typed,r=e.config,n=e.Complex;return t(tl,{number:function(e){return e>=1||r.predictable?jf(e):e<=-1?new n(Math.log(Math.sqrt(e*e-1)-e),Math.PI):new n(e,0).acosh()},Complex:function(e){return e.acosh()},BigNumber:function(e){return e.acosh()}})})),nl="acot",il=Se(nl,["typed","BigNumber"],(function(e){var t=e.typed,r=e.BigNumber;return t(nl,{number:Pf,Complex:function(e){return e.acot()},BigNumber:function(e){return new r(1).div(e).atan()}})})),al="acoth",ol=Se(al,["typed","config","Complex","BigNumber"],(function(e){var t=e.typed,r=e.config,n=e.Complex,i=e.BigNumber;return t(al,{number:function(e){return e>=1||e<=-1||r.predictable?Lf(e):new n(e,0).acoth()},Complex:function(e){return e.acoth()},BigNumber:function(e){return new i(1).div(e).atanh()}})})),ul="acsc",sl=Se(ul,["typed","config","Complex","BigNumber"],(function(e){var t=e.typed,r=e.config,n=e.Complex,i=e.BigNumber;return t(ul,{number:function(e){return e<=-1||e>=1||r.predictable?Uf(e):new n(e,0).acsc()},Complex:function(e){return e.acsc()},BigNumber:function(e){return new i(1).div(e).asin()}})})),cl="acsch",fl=Se(cl,["typed","BigNumber"],(function(e){var t=e.typed,r=e.BigNumber;return t(cl,{number:$f,Complex:function(e){return e.acsch()},BigNumber:function(e){return new r(1).div(e).asinh()}})})),ll="asec",pl=Se(ll,["typed","config","Complex","BigNumber"],(function(e){var t=e.typed,r=e.config,n=e.Complex,i=e.BigNumber;return t(ll,{number:function(e){return e<=-1||e>=1||r.predictable?Hf(e):new n(e,0).asec()},Complex:function(e){return e.asec()},BigNumber:function(e){return new i(1).div(e).acos()}})})),ml="asech",hl=Se(ml,["typed","config","Complex","BigNumber"],(function(e){var t=e.typed,r=e.config,n=e.Complex,i=e.BigNumber;return t(ml,{number:function(e){if(e<=1&&e>=-1||r.predictable){var t=1/e;if(t>0||r.predictable)return Gf(e);var i=Math.sqrt(t*t-1);return new n(Math.log(i-t),Math.PI)}return new n(e,0).asech()},Complex:function(e){return e.asech()},BigNumber:function(e){return new i(1).div(e).acosh()}})})),dl="asin",vl=Se(dl,["typed","config","Complex"],(function(e){var t=e.typed,r=e.config,n=e.Complex;return t(dl,{number:function(e){return e>=-1&&e<=1||r.predictable?Math.asin(e):new n(e,0).asin()},Complex:function(e){return e.asin()},BigNumber:function(e){return e.asin()}})})),yl=Se("asinh",["typed"],(function(e){return(0,e.typed)("asinh",{number:Vf,Complex:function(e){return e.asinh()},BigNumber:function(e){return e.asinh()}})})),gl=Se("atan",["typed"],(function(e){return(0,e.typed)("atan",{number:function(e){return Math.atan(e)},Complex:function(e){return e.atan()},BigNumber:function(e){return e.atan()}})})),xl="atan2",bl=Se(xl,["typed","matrix","equalScalar","BigNumber","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.BigNumber,a=e.DenseMatrix,o=e.concat,u=Za({typed:t,equalScalar:n}),s=Wa({typed:t}),c=_o({typed:t,equalScalar:n}),f=Sa({typed:t,equalScalar:n}),l=Ca({typed:t,DenseMatrix:a}),p=Qa({typed:t,matrix:r,concat:o});return t(xl,{"number, number":Math.atan2,"BigNumber, BigNumber":function(e,t){return i.atan2(e,t)}},p({scalar:"number | BigNumber",SS:c,DS:s,SD:u,Ss:f,sS:l}))})),wl="atanh",Dl=Se(wl,["typed","config","Complex"],(function(e){var t=e.typed,r=e.config,n=e.Complex;return t(wl,{number:function(e){return e<=1&&e>=-1||r.predictable?Zf(e):new n(e,0).atanh()},Complex:function(e){return e.atanh()},BigNumber:function(e){return e.atanh()}})})),Nl=Se("trigUnit",["typed"],(function(e){var t=e.typed;return{Unit:t.referToSelf((function(e){return function(r){if(!r.hasBase(r.constructor.BASE_UNITS.ANGLE))throw new TypeError("Unit in function cot is no angle");return t.find(e,r.valueType())(r.value)}}))}})),El=Se("cos",["typed"],(function(e){var t=e.typed,r=Nl({typed:t});return t("cos",{number:Math.cos,"Complex | BigNumber":function(e){return e.cos()}},r)})),Al="cosh",Sl=Se(Al,["typed"],(function(e){return(0,e.typed)(Al,{number:pe,"Complex | BigNumber":function(e){return e.cosh()}})})),Cl=Se("cot",["typed","BigNumber"],(function(e){var t=e.typed,r=e.BigNumber;return t("cot",{number:Wf,Complex:function(e){return e.cot()},BigNumber:function(e){return new r(1).div(e.tan())}},Nl({typed:t}))})),Ml="coth",Fl=Se(Ml,["typed","BigNumber"],(function(e){var t=e.typed,r=e.BigNumber;return t(Ml,{number:Yf,Complex:function(e){return e.coth()},BigNumber:function(e){return new r(1).div(e.tanh())}})})),Ol=Se("csc",["typed","BigNumber"],(function(e){var t=e.typed,r=e.BigNumber;return t("csc",{number:Jf,Complex:function(e){return e.csc()},BigNumber:function(e){return new r(1).div(e.sin())}},Nl({typed:t}))})),Tl="csch",_l=Se(Tl,["typed","BigNumber"],(function(e){var t=e.typed,r=e.BigNumber;return t(Tl,{number:Xf,Complex:function(e){return e.csch()},BigNumber:function(e){return new r(1).div(e.sinh())}})})),Bl=Se("sec",["typed","BigNumber"],(function(e){var t=e.typed,r=e.BigNumber;return t("sec",{number:Qf,Complex:function(e){return e.sec()},BigNumber:function(e){return new r(1).div(e.cos())}},Nl({typed:t}))})),kl="sech",Il=Se(kl,["typed","BigNumber"],(function(e){var t=e.typed,r=e.BigNumber;return t(kl,{number:Kf,Complex:function(e){return e.sech()},BigNumber:function(e){return new r(1).div(e.cosh())}})})),zl=Se("sin",["typed"],(function(e){var t=e.typed,r=Nl({typed:t});return t("sin",{number:Math.sin,"Complex | BigNumber":function(e){return e.sin()}},r)})),Rl="sinh",ql=Se(Rl,["typed"],(function(e){return(0,e.typed)(Rl,{number:el,"Complex | BigNumber":function(e){return e.sinh()}})})),jl=Se("tan",["typed"],(function(e){var t=e.typed,r=Nl({typed:t});return t("tan",{number:Math.tan,"Complex | BigNumber":function(e){return e.tan()}},r)})),Pl=Se("tanh",["typed"],(function(e){return(0,e.typed)("tanh",{number:he,"Complex | BigNumber":function(e){return e.tanh()}})})),Ll="setCartesian",Ul=Se(Ll,["typed","size","subset","compareNatural","Index","DenseMatrix"],(function(e){var t=e.typed,r=e.size,n=e.subset,i=e.compareNatural,a=e.Index,o=e.DenseMatrix;return t(Ll,{"Array | Matrix, Array | Matrix":function(e,t){var u=[];if(0!==n(r(e),new a(0))&&0!==n(r(t),new a(0))){var s=En(Array.isArray(e)?e:e.toArray()).sort(i),c=En(Array.isArray(t)?t:t.toArray()).sort(i);u=[];for(var f=0;f<s.length;f++)for(var l=0;l<c.length;l++)u.push([s[f],c[l]])}return Array.isArray(e)&&Array.isArray(t)?u:new o(u)}})})),$l="setDifference",Hl=Se($l,["typed","size","subset","compareNatural","Index","DenseMatrix"],(function(e){var t=e.typed,r=e.size,n=e.subset,i=e.compareNatural,a=e.Index,o=e.DenseMatrix;return t($l,{"Array | Matrix, Array | Matrix":function(e,t){var u;if(0===n(r(e),new a(0)))u=[];else{if(0===n(r(t),new a(0)))return En(e.toArray());var s,c=On(En(Array.isArray(e)?e:e.toArray()).sort(i)),f=On(En(Array.isArray(t)?t:t.toArray()).sort(i));u=[];for(var l=0;l<c.length;l++){s=!1;for(var p=0;p<f.length;p++)if(0===i(c[l].value,f[p].value)&&c[l].identifier===f[p].identifier){s=!0;break}s||u.push(c[l])}}return Array.isArray(e)&&Array.isArray(t)?Tn(u):new o(Tn(u))}})})),Gl="setDistinct",Vl=Se(Gl,["typed","size","subset","compareNatural","Index","DenseMatrix"],(function(e){var t=e.typed,r=e.size,n=e.subset,i=e.compareNatural,a=e.Index,o=e.DenseMatrix;return t(Gl,{"Array | Matrix":function(e){var t;if(0===n(r(e),new a(0)))t=[];else{var u=En(Array.isArray(e)?e:e.toArray()).sort(i);(t=[]).push(u[0]);for(var s=1;s<u.length;s++)0!==i(u[s],u[s-1])&&t.push(u[s])}return Array.isArray(e)?t:new o(t)}})})),Zl="setIntersect",Wl=Se(Zl,["typed","size","subset","compareNatural","Index","DenseMatrix"],(function(e){var t=e.typed,r=e.size,n=e.subset,i=e.compareNatural,a=e.Index,o=e.DenseMatrix;return t(Zl,{"Array | Matrix, Array | Matrix":function(e,t){var u;if(0===n(r(e),new a(0))||0===n(r(t),new a(0)))u=[];else{var s=On(En(Array.isArray(e)?e:e.toArray()).sort(i)),c=On(En(Array.isArray(t)?t:t.toArray()).sort(i));u=[];for(var f=0;f<s.length;f++)for(var l=0;l<c.length;l++)if(0===i(s[f].value,c[l].value)&&s[f].identifier===c[l].identifier){u.push(s[f]);break}}return Array.isArray(e)&&Array.isArray(t)?Tn(u):new o(Tn(u))}})})),Yl="setIsSubset",Jl=Se(Yl,["typed","size","subset","compareNatural","Index"],(function(e){var t=e.typed,r=e.size,n=e.subset,i=e.compareNatural,a=e.Index;return t(Yl,{"Array | Matrix, Array | Matrix":function(e,t){if(0===n(r(e),new a(0)))return!0;if(0===n(r(t),new a(0)))return!1;for(var o,u=On(En(Array.isArray(e)?e:e.toArray()).sort(i)),s=On(En(Array.isArray(t)?t:t.toArray()).sort(i)),c=0;c<u.length;c++){o=!1;for(var f=0;f<s.length;f++)if(0===i(u[c].value,s[f].value)&&u[c].identifier===s[f].identifier){o=!0;break}if(!1===o)return!1}return!0}})})),Xl="setMultiplicity",Ql=Se(Xl,["typed","size","subset","compareNatural","Index"],(function(e){var t=e.typed,r=e.size,n=e.subset,i=e.compareNatural,a=e.Index;return t(Xl,{"number | BigNumber | Fraction | Complex, Array | Matrix":function(e,t){if(0===n(r(t),new a(0)))return 0;for(var o=En(Array.isArray(t)?t:t.toArray()),u=0,s=0;s<o.length;s++)0===i(o[s],e)&&u++;return u}})})),Kl="setPowerset",ep=Se(Kl,["typed","size","subset","compareNatural","Index"],(function(e){var t=e.typed,r=e.size,n=e.subset,i=e.compareNatural,a=e.Index;return t(Kl,{"Array | Matrix":function(e){if(0===n(r(e),new a(0)))return[];for(var t=En(Array.isArray(e)?e:e.toArray()).sort(i),u=[],s=0;s.toString(2).length<=t.length;)u.push(o(t,s.toString(2).split("").reverse())),s++;return function(e){for(var t=[],r=e.length-1;r>0;r--)for(var n=0;n<r;n++)e[n].length>e[n+1].length&&(t=e[n],e[n]=e[n+1],e[n+1]=t);return e}(u)}});function o(e,t){for(var r=[],n=0;n<t.length;n++)"1"===t[n]&&r.push(e[n]);return r}})),tp="setSize",rp=Se(tp,["typed","compareNatural"],(function(e){var t=e.typed,r=e.compareNatural;return t(tp,{"Array | Matrix":function(e){return Array.isArray(e)?En(e).length:En(e.toArray()).length},"Array | Matrix, boolean":function(e,t){if(!1===t||0===e.length)return Array.isArray(e)?En(e).length:En(e.toArray()).length;for(var n=En(Array.isArray(e)?e:e.toArray()).sort(r),i=1,a=1;a<n.length;a++)0!==r(n[a],n[a-1])&&i++;return i}})})),np="setSymDifference",ip=Se(np,["typed","size","concat","subset","setDifference","Index"],(function(e){var t=e.typed,r=e.size,n=e.concat,i=e.subset,a=e.setDifference,o=e.Index;return t(np,{"Array | Matrix, Array | Matrix":function(e,t){if(0===i(r(e),new o(0)))return En(t);if(0===i(r(t),new o(0)))return En(e);var u=En(e),s=En(t);return n(a(u,s),a(s,u))}})})),ap="setUnion",op=Se(ap,["typed","size","concat","subset","setIntersect","setSymDifference","Index"],(function(e){var t=e.typed,r=e.size,n=e.concat,i=e.subset,a=e.setIntersect,o=e.setSymDifference,u=e.Index;return t(ap,{"Array | Matrix, Array | Matrix":function(e,t){if(0===i(r(e),new u(0)))return En(t);if(0===i(r(t),new u(0)))return En(e);var s=En(e),c=En(t);return n(o(s,c),a(s,c))}})})),up=Se("add",["typed","matrix","addScalar","equalScalar","DenseMatrix","SparseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.addScalar,i=e.equalScalar,a=e.DenseMatrix,o=(e.SparseMatrix,e.concat),u=eo({typed:t}),s=to({typed:t,equalScalar:i}),c=ro({typed:t,DenseMatrix:a}),f=Qa({typed:t,matrix:r,concat:o});return t("add",{"any, any":n,"any, any, ...any":t.referToSelf((function(e){return function(t,r,n){for(var i=e(t,r),a=0;a<n.length;a++)i=e(i,n[a]);return i}}))},f({elop:n,DS:u,SS:s,Ss:c}))})),sp="hypot",cp=Se(sp,["typed","abs","addScalar","divideScalar","multiplyScalar","sqrt","smaller","isPositive"],(function(e){var t=e.typed,r=e.abs,n=e.addScalar,i=e.divideScalar,a=e.multiplyScalar,u=e.sqrt,s=e.smaller,c=e.isPositive;return t(sp,{"... number | BigNumber":f,Array:f,Matrix:function(e){return f(En(e.toArray()))}});function f(e){for(var t=0,f=0,l=0;l<e.length;l++){if(o(e[l]))throw new TypeError("Unexpected type of argument to hypot");var p=r(e[l]);s(f,p)?(t=a(t,a(i(f,p),i(f,p))),t=n(t,1),f=p):t=n(t,c(p)?a(i(p,f),i(p,f)):p)}return a(f,u(t))}})),fp="norm",lp=Se(fp,["typed","abs","add","pow","conj","sqrt","multiply","equalScalar","larger","smaller","matrix","ctranspose","eigs"],(function(e){var t=e.typed,r=e.abs,n=e.add,i=e.pow,a=e.conj,o=e.sqrt,u=e.multiply,s=e.equalScalar,c=e.larger,f=e.smaller,l=e.matrix,p=e.ctranspose,m=e.eigs;return t(fp,{number:Math.abs,Complex:function(e){return e.abs()},BigNumber:function(e){return e.abs()},boolean:function(e){return Math.abs(e)},Array:function(e){return h(l(e),2)},Matrix:function(e){return h(e,2)},"Array, number | BigNumber | string":function(e,t){return h(l(e),t)},"Matrix, number | BigNumber | string":function(e,t){return h(e,t)}});function h(e,t){var l=e.size();if(1===l.length)return function(e,t){if(t===Number.POSITIVE_INFINITY||"inf"===t)return function(e){var t=0;return e.forEach((function(e){var n=r(e);c(n,t)&&(t=n)}),!0),t}(e);if(t===Number.NEGATIVE_INFINITY||"-inf"===t)return function(e){var t;return e.forEach((function(e){var n=r(e);t&&!f(n,t)||(t=n)}),!0),t||0}(e);if("fro"===t)return h(e,2);if("number"==typeof t&&!isNaN(t)){if(!s(t,0)){var a=0;return e.forEach((function(e){a=n(i(r(e),t),a)}),!0),i(a,1/t)}return Number.POSITIVE_INFINITY}throw new Error("Unsupported parameter value")}(e,t);if(2===l.length){if(l[0]&&l[1])return function(e,t){if(1===t)return function(e){var t=[],i=0;return e.forEach((function(e,a){var o=a[1],u=n(t[o]||0,r(e));c(u,i)&&(i=u),t[o]=u}),!0),i}(e);if(t===Number.POSITIVE_INFINITY||"inf"===t)return function(e){var t=[],i=0;return e.forEach((function(e,a){var o=a[0],u=n(t[o]||0,r(e));c(u,i)&&(i=u),t[o]=u}),!0),i}(e);if("fro"===t)return function(e){var t=0;return e.forEach((function(e,r){t=n(t,u(e,a(e)))})),r(o(t))}(e);if(2===t)return function(e){var t=e.size();if(t[0]!==t[1])throw new RangeError("Invalid matrix dimensions");var n=p(e),i=u(n,e),a=m(i).values.toArray(),s=a[a.length-1];return r(o(s))}(e);throw new Error("Unsupported parameter value "+t)}(e,t);throw new RangeError("Invalid matrix dimensions")}}})),pp=Se("dot",["typed","addScalar","multiplyScalar","conj","size"],(function(e){var t=e.typed,r=e.addScalar,n=e.multiplyScalar,i=e.conj,a=e.size;return t("dot",{"Array | DenseMatrix, Array | DenseMatrix":function(e,a){var s=o(e,a),c=l(e)?e._data:e,f=l(e)?e._datatype||e.getDataType():void 0,p=l(a)?a._data:a,m=l(a)?a._datatype||a.getDataType():void 0,h=2===u(e).length,d=2===u(a).length,v=r,y=n;if(f&&m&&f===m&&"string"==typeof f&&"mixed"!==f){var g=f;v=t.find(r,[g,g]),y=t.find(n,[g,g])}if(!h&&!d){for(var x=y(i(c[0]),p[0]),b=1;b<s;b++)x=v(x,y(i(c[b]),p[b]));return x}if(!h&&d){for(var w=y(i(c[0]),p[0][0]),D=1;D<s;D++)w=v(w,y(i(c[D]),p[D][0]));return w}if(h&&!d){for(var N=y(i(c[0][0]),p[0]),E=1;E<s;E++)N=v(N,y(i(c[E][0]),p[E]));return N}if(h&&d){for(var A=y(i(c[0][0]),p[0][0]),S=1;S<s;S++)A=v(A,y(i(c[S][0]),p[S][0]));return A}},"SparseMatrix, SparseMatrix":function(e,t){o(e,t);for(var i=e._index,a=e._values,u=t._index,s=t._values,c=0,f=r,l=n,p=0,m=0;p<i.length&&m<u.length;){var h=i[p],d=u[m];h<d?p++:h>d?m++:h===d&&(c=f(c,l(a[p],s[m])),p++,m++)}return c}});function o(e,t){var r,n,i=u(e),a=u(t);if(1===i.length)r=i[0];else{if(2!==i.length||1!==i[1])throw new RangeError("Expected a column vector, instead got a matrix of size ("+i.join(", ")+")");r=i[0]}if(1===a.length)n=a[0];else{if(2!==a.length||1!==a[1])throw new RangeError("Expected a column vector, instead got a matrix of size ("+a.join(", ")+")");n=a[0]}if(r!==n)throw new RangeError("Vectors must have equal length ("+r+" != "+n+")");if(0===r)throw new RangeError("Cannot calculate the dot product of empty vectors");return r}function u(e){return l(e)?e.size():a(e)}})),mp=Se("trace",["typed","matrix","add"],(function(e){var t=e.typed,r=e.matrix,n=e.add;return t("trace",{Array:function(e){return i(r(e))},SparseMatrix:function(e){var t=e._values,r=e._index,i=e._ptr,a=e._size,o=a[0],u=a[1];if(o===u){var s=0;if(t.length>0)for(var c=0;c<u;c++)for(var f=i[c],l=i[c+1],p=f;p<l;p++){var m=r[p];if(m===c){s=n(s,t[p]);break}if(m>c)break}return s}throw new RangeError("Matrix must be square (size: "+en(a)+")")},DenseMatrix:i,any:ye});function i(e){var t=e._size,r=e._data;switch(t.length){case 1:if(1===t[0])return ye(r[0]);throw new RangeError("Matrix must be square (size: "+en(t)+")");case 2:var i=t[0];if(i===t[1]){for(var a=0,o=0;o<i;o++)a=n(a,r[o][o]);return a}throw new RangeError("Matrix must be square (size: "+en(t)+")");default:throw new RangeError("Matrix must be two dimensional (size: "+en(t)+")")}}})),hp="index",dp=Se(hp,["typed","Index"],(function(e){var t=e.typed,r=e.Index;return t(hp,{"...number | string | BigNumber | Range | Array | Matrix":function(e){var t=e.map((function(e){return a(e)?e.toNumber():f(e)||l(e)?e.map((function(e){return a(e)?e.toNumber():e})):e})),n=new r;return r.apply(n,t),n}})})),vp=new Set(["end"]),yp=Se("Node",["mathWithTransform"],(function(e){var r=e.mathWithTransform;return function(){return Ie((function e(){_e(this,e)}),[{key:"type",get:function(){return"Node"}},{key:"isNode",get:function(){return!0}},{key:"evaluate",value:function(e){return this.compile().evaluate(e)}},{key:"compile",value:function(){var e=this._compile(r,{}),t={};return{evaluate:function(r){var n=Ye(r);return function(e){for(var t=0,r=Te(vp);t<r.length;t++){var n=r[t];if(e.has(n))throw new Error('Scope contains an illegal symbol, "'+n+'" is a reserved keyword')}}(n),e(n,t,null)}}}},{key:"_compile",value:function(e,t){throw new Error("Method _compile must be implemented by type "+this.type)}},{key:"forEach",value:function(e){throw new Error("Cannot run forEach on a Node interface")}},{key:"map",value:function(e){throw new Error("Cannot run map on a Node interface")}},{key:"_ifNode",value:function(e){if(!z(e))throw new TypeError("Callback function must return a Node");return e}},{key:"traverse",value:function(e){e(this,null,null),function e(t,r){t.forEach((function(t,n,i){r(t,n,i),e(t,r)}))}(this,e)}},{key:"transform",value:function(e){return function t(r,n,i){var a=e(r,n,i);return a!==r?a:r.map(t)}(this,null,null)}},{key:"filter",value:function(e){var t=[];return this.traverse((function(r,n,i){e(r,n,i)&&t.push(r)})),t}},{key:"clone",value:function(){throw new Error("Cannot clone a Node interface")}},{key:"cloneDeep",value:function(){return this.map((function(e){return e.cloneDeep()}))}},{key:"equals",value:function(e){return!!e&&this.type===e.type&&we(this,e)}},{key:"toString",value:function(e){var t=this._getCustomString(e);return void 0!==t?t:this._toString(e)}},{key:"_toString",value:function(){throw new Error("_toString not implemented for "+this.type)}},{key:"toJSON",value:function(){throw new Error("Cannot serialize object: toJSON not implemented by "+this.type)}},{key:"toHTML",value:function(e){var t=this._getCustomString(e);return void 0!==t?t:this._toHTML(e)}},{key:"_toHTML",value:function(){throw new Error("_toHTML not implemented for "+this.type)}},{key:"toTex",value:function(e){var t=this._getCustomString(e);return void 0!==t?t:this._toTex(e)}},{key:"_toTex",value:function(e){throw new Error("_toTex not implemented for "+this.type)}},{key:"_getCustomString",value:function(e){if(e&&"object"===t(e))switch(t(e.handler)){case"object":case"undefined":return;case"function":return e.handler(this,e);default:throw new TypeError("Object or function expected as callback")}}},{key:"getIdentifier",value:function(){return this.type}},{key:"getContent",value:function(){return this}}])}()}),{isClass:!0,isNode:!0});function gp(e,r){if(r&&("object"===t(r)||"function"==typeof r))return r;if(void 0!==r)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function xp(e){return xp=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},xp(e)}function bp(e,t){return bp=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},bp(e,t)}function wp(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&bp(e,t)}function Dp(e){return e&&e.isIndexError?new sn(e.index+1,e.min+1,void 0!==e.max?e.max+1:void 0):e}function Np(e){var r=e.subset;return function(e,n){try{if(Array.isArray(e))return r(e,n);if(e&&"function"==typeof e.subset)return e.subset(n);if("string"==typeof e)return r(e,n);if("object"===t(e)){if(!n.isObjectProperty())throw new TypeError("Cannot apply a numeric index as object property");return ze(e,n.getObjectProperty())}throw new TypeError("Cannot apply index: unsupported type of object")}catch(e){throw Dp(e)}}}function Ep(e,t,r){return t=xp(t),gp(e,Ap()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function Ap(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(Ap=function(){return!!e})()}r(825);var Sp="AccessorNode",Cp=Se(Sp,["subset","Node"],(function(e){var t=e.subset,r=e.Node,n=Np({subset:t});function i(e){return!(S(e)||C(e)||T(e)||k(e)||R(e)||j(e)||U(e))}var a=function(e){function t(e,r){var n;if(_e(this,t),n=Ep(this,t),!z(e))throw new TypeError('Node expected for parameter "object"');if(!I(r))throw new TypeError('IndexNode expected for parameter "index"');return n.object=e,n.index=r,n}return wp(t,e),Ie(t,[{key:"name",get:function(){return this.index?this.index.isObjectProperty()?this.index.getObjectProperty():"":this.object.name||""}},{key:"type",get:function(){return Sp}},{key:"isAccessorNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var r=this.object._compile(e,t),i=this.index._compile(e,t);if(this.index.isObjectProperty()){var a=this.index.getObjectProperty();return function(e,t,n){return ze(r(e,t,n),a)}}return function(e,t,a){var o=r(e,t,a),u=i(e,t,o);return n(o,u)}}},{key:"forEach",value:function(e){e(this.object,"object",this),e(this.index,"index",this)}},{key:"map",value:function(e){return new t(this._ifNode(e(this.object,"object",this)),this._ifNode(e(this.index,"index",this)))}},{key:"clone",value:function(){return new t(this.object,this.index)}},{key:"_toString",value:function(e){var t=this.object.toString(e);return i(this.object)&&(t="("+t+")"),t+this.index.toString(e)}},{key:"_toHTML",value:function(e){var t=this.object.toHTML(e);return i(this.object)&&(t='<span class="math-parenthesis math-round-parenthesis">(</span>'+t+'<span class="math-parenthesis math-round-parenthesis">)</span>'),t+this.index.toHTML(e)}},{key:"_toTex",value:function(e){var t=this.object.toTex(e);return i(this.object)&&(t="\\left(' + object + '\\right)"),t+this.index.toTex(e)}},{key:"toJSON",value:function(){return{mathjs:Sp,object:this.object,index:this.index}}}],[{key:"fromJSON",value:function(e){return new t(e.object,e.index)}}])}(r);return Va(a,"name",Sp),a}),{isClass:!0,isNode:!0});function Mp(e,t,r){return t=xp(t),gp(e,Fp()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function Fp(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(Fp=function(){return!!e})()}var Op="ArrayNode",Tp=Se(Op,["Node"],(function(e){var t=function(e){function t(e){var r;if(_e(this,t),(r=Mp(this,t)).items=e||[],!Array.isArray(r.items)||!r.items.every(z))throw new TypeError("Array containing Nodes expected");return r}return wp(t,e),Ie(t,[{key:"type",get:function(){return Op}},{key:"isArrayNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var r=An(this.items,(function(r){return r._compile(e,t)}));if("Array"!==e.config.matrix){var n=e.matrix;return function(e,t,i){return n(An(r,(function(r){return r(e,t,i)})))}}return function(e,t,n){return An(r,(function(r){return r(e,t,n)}))}}},{key:"forEach",value:function(e){for(var t=0;t<this.items.length;t++)e(this.items[t],"items["+t+"]",this)}},{key:"map",value:function(e){for(var r=[],n=0;n<this.items.length;n++)r[n]=this._ifNode(e(this.items[n],"items["+n+"]",this));return new t(r)}},{key:"clone",value:function(){return new t(this.items.slice(0))}},{key:"_toString",value:function(e){return"["+this.items.map((function(t){return t.toString(e)})).join(", ")+"]"}},{key:"toJSON",value:function(){return{mathjs:Op,items:this.items}}},{key:"_toHTML",value:function(e){return'<span class="math-parenthesis math-square-parenthesis">[</span>'+this.items.map((function(t){return t.toHTML(e)})).join('<span class="math-separator">,</span>')+'<span class="math-parenthesis math-square-parenthesis">]</span>'}},{key:"_toTex",value:function(e){return function t(r,n){var i=r.some(C)&&!r.every(C),a=n||i,o=a?"&":"\\\\",u=r.map((function(r){return r.items?t(r.items,!n):r.toTex(e)})).join(o);return i||!a||a&&!n?"\\begin{bmatrix}"+u+"\\end{bmatrix}":u}(this.items,!1)}}],[{key:"fromJSON",value:function(e){return new t(e.items)}}])}(e.Node);return Va(t,"name",Op),t}),{isClass:!0,isNode:!0});function _p(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var Bp=[{AssignmentNode:{},FunctionAssignmentNode:{}},{ConditionalNode:{latexLeftParens:!1,latexRightParens:!1,latexParens:!1}},{"OperatorNode:or":{op:"or",associativity:"left",associativeWith:[]}},{"OperatorNode:xor":{op:"xor",associativity:"left",associativeWith:[]}},{"OperatorNode:and":{op:"and",associativity:"left",associativeWith:[]}},{"OperatorNode:bitOr":{op:"|",associativity:"left",associativeWith:[]}},{"OperatorNode:bitXor":{op:"^|",associativity:"left",associativeWith:[]}},{"OperatorNode:bitAnd":{op:"&",associativity:"left",associativeWith:[]}},{"OperatorNode:equal":{op:"==",associativity:"left",associativeWith:[]},"OperatorNode:unequal":{op:"!=",associativity:"left",associativeWith:[]},"OperatorNode:smaller":{op:"<",associativity:"left",associativeWith:[]},"OperatorNode:larger":{op:">",associativity:"left",associativeWith:[]},"OperatorNode:smallerEq":{op:"<=",associativity:"left",associativeWith:[]},"OperatorNode:largerEq":{op:">=",associativity:"left",associativeWith:[]},RelationalNode:{associativity:"left",associativeWith:[]}},{"OperatorNode:leftShift":{op:"<<",associativity:"left",associativeWith:[]},"OperatorNode:rightArithShift":{op:">>",associativity:"left",associativeWith:[]},"OperatorNode:rightLogShift":{op:">>>",associativity:"left",associativeWith:[]}},{"OperatorNode:to":{op:"to",associativity:"left",associativeWith:[]}},{RangeNode:{}},{"OperatorNode:add":{op:"+",associativity:"left",associativeWith:["OperatorNode:add","OperatorNode:subtract"]},"OperatorNode:subtract":{op:"-",associativity:"left",associativeWith:[]}},{"OperatorNode:multiply":{op:"*",associativity:"left",associativeWith:["OperatorNode:multiply","OperatorNode:divide","Operator:dotMultiply","Operator:dotDivide"]},"OperatorNode:divide":{op:"/",associativity:"left",associativeWith:[],latexLeftParens:!1,latexRightParens:!1,latexParens:!1},"OperatorNode:dotMultiply":{op:".*",associativity:"left",associativeWith:["OperatorNode:multiply","OperatorNode:divide","OperatorNode:dotMultiply","OperatorNode:doDivide"]},"OperatorNode:dotDivide":{op:"./",associativity:"left",associativeWith:[]},"OperatorNode:mod":{op:"mod",associativity:"left",associativeWith:[]}},{"OperatorNode:multiply":{associativity:"left",associativeWith:["OperatorNode:multiply","OperatorNode:divide","Operator:dotMultiply","Operator:dotDivide"]}},{"OperatorNode:unaryPlus":{op:"+",associativity:"right"},"OperatorNode:unaryMinus":{op:"-",associativity:"right"},"OperatorNode:bitNot":{op:"~",associativity:"right"},"OperatorNode:not":{op:"not",associativity:"right"}},{"OperatorNode:pow":{op:"^",associativity:"right",associativeWith:[],latexRightParens:!1},"OperatorNode:dotPow":{op:".^",associativity:"right",associativeWith:[]}},{"OperatorNode:factorial":{op:"!",associativity:"left"}},{"OperatorNode:ctranspose":{op:"'",associativity:"left"}}];function kp(e,t){if(!t||"auto"!==t)return e;for(var r=e;j(r);)r=r.content;return r}function Ip(e,t,r,n){var i=e;"keep"!==t&&(i=e.getContent());for(var a=i.getIdentifier(),o=null,u=0;u<Bp.length;u++)if(a in Bp[u]){o=u;break}if("OperatorNode:multiply"===a&&i.implicit&&"show"!==r){var s=kp(i.args[0],t);T(s)&&n&&"OperatorNode:divide"===n.getIdentifier()&&_(kp(n.args[0],t))||"OperatorNode:divide"===s.getIdentifier()&&_(kp(s.args[0],t))&&T(kp(s.args[1]))||(o+=1)}return o}function zp(e,t){var r=e;"keep"!==t&&(r=e.getContent());var n=r.getIdentifier(),i=Ip(r,t);if(null===i)return null;var a=Bp[i][n];if(Ae(a,"associativity")){if("left"===a.associativity)return"left";if("right"===a.associativity)return"right";throw Error("'"+n+"' has the invalid associativity '"+a.associativity+"'.")}return null}function Rp(e,t,r){var n="keep"!==r?e.getContent():e,i="keep"!==r?e.getContent():t,a=n.getIdentifier(),o=i.getIdentifier(),u=Ip(n,r);if(null===u)return null;var s=Bp[u][a];if(Ae(s,"associativeWith")&&s.associativeWith instanceof Array){for(var c=0;c<s.associativeWith.length;c++)if(s.associativeWith[c]===o)return!0;return!1}return null}function qp(e,t,r){return t=xp(t),gp(e,jp()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function jp(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(jp=function(){return!!e})()}var Pp="AssignmentNode",Lp=Se(Pp,["subset","?matrix","Node"],(function(e){var r=e.subset,n=e.matrix,i=e.Node,a=Np({subset:r}),o=function(e){var r=e.subset,n=e.matrix;return function(e,i,a){try{if(Array.isArray(e))return n(e).subset(i,a).valueOf().forEach((function(t,r){e[r]=t})),e;if(e&&"function"==typeof e.subset)return e.subset(i,a);if("string"==typeof e)return r(e,i,a);if("object"===t(e)){if(!i.isObjectProperty())throw TypeError("Cannot apply a numeric index as object property");return Re(e,i.getObjectProperty(),a),e}throw new TypeError("Cannot apply index: unsupported type of object")}catch(e){throw Dp(e)}}}({subset:r,matrix:n});function u(e,t,r){t||(t="keep");var n=Ip(e,t,r),i=Ip(e.value,t,r);return"all"===t||null!==i&&i<=n}var s=function(e){function t(e,r,n){var i;if(_e(this,t),(i=qp(this,t)).object=e,i.index=n?r:null,i.value=n||r,!U(e)&&!S(e))throw new TypeError('SymbolNode or AccessorNode expected as "object"');if(U(e)&&"end"===e.name)throw new Error('Cannot assign to symbol "end"');if(i.index&&!I(i.index))throw new TypeError('IndexNode expected as "index"');if(!z(i.value))throw new TypeError('Node expected as "value"');return i}return wp(t,e),Ie(t,[{key:"name",get:function(){return this.index?this.index.isObjectProperty()?this.index.getObjectProperty():"":this.object.name||""}},{key:"type",get:function(){return Pp}},{key:"isAssignmentNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var r=this.object._compile(e,t),n=this.index?this.index._compile(e,t):null,i=this.value._compile(e,t),u=this.object.name;if(this.index){if(this.index.isObjectProperty()){var s=this.index.getObjectProperty();return function(e,t,n){var a=r(e,t,n),o=i(e,t,n);return Re(a,s,o),o}}if(U(this.object))return function(e,t,a){var s=r(e,t,a),c=i(e,t,a),f=n(e,t,s);return e.set(u,o(s,f,c)),c};var c=this.object.object._compile(e,t);if(this.object.index.isObjectProperty()){var f=this.object.index.getObjectProperty();return function(e,t,r){var a=c(e,t,r),u=ze(a,f),s=n(e,t,u),l=i(e,t,r);return Re(a,f,o(u,s,l)),l}}var l=this.object.index._compile(e,t);return function(e,t,r){var u=c(e,t,r),s=l(e,t,u),f=a(u,s),p=n(e,t,f),m=i(e,t,r);return o(u,s,o(f,p,m)),m}}if(!U(this.object))throw new TypeError("SymbolNode expected as object");return function(e,t,r){var n=i(e,t,r);return e.set(u,n),n}}},{key:"forEach",value:function(e){e(this.object,"object",this),this.index&&e(this.index,"index",this),e(this.value,"value",this)}},{key:"map",value:function(e){return new t(this._ifNode(e(this.object,"object",this)),this.index?this._ifNode(e(this.index,"index",this)):null,this._ifNode(e(this.value,"value",this)))}},{key:"clone",value:function(){return new t(this.object,this.index,this.value)}},{key:"_toString",value:function(e){var t=this.object.toString(e),r=this.index?this.index.toString(e):"",n=this.value.toString(e);return u(this,e&&e.parenthesis,e&&e.implicit)&&(n="("+n+")"),t+r+" = "+n}},{key:"toJSON",value:function(){return{mathjs:Pp,object:this.object,index:this.index,value:this.value}}},{key:"_toHTML",value:function(e){var t=this.object.toHTML(e),r=this.index?this.index.toHTML(e):"",n=this.value.toHTML(e);return u(this,e&&e.parenthesis,e&&e.implicit)&&(n='<span class="math-paranthesis math-round-parenthesis">(</span>'+n+'<span class="math-paranthesis math-round-parenthesis">)</span>'),t+r+'<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>'+n}},{key:"_toTex",value:function(e){var t=this.object.toTex(e),r=this.index?this.index.toTex(e):"",n=this.value.toTex(e);return u(this,e&&e.parenthesis,e&&e.implicit)&&(n="\\left(".concat(n,"\\right)")),t+r+"="+n}}],[{key:"fromJSON",value:function(e){return new t(e.object,e.index,e.value)}}])}(i);return Va(s,"name",Pp),s}),{isClass:!0,isNode:!0});function Up(e,t,r){return t=xp(t),gp(e,$p()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function $p(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return($p=function(){return!!e})()}var Hp="BlockNode",Gp=Se(Hp,["ResultSet","Node"],(function(e){var t=e.ResultSet,r=function(e){function r(e){var t;if(_e(this,r),t=Up(this,r),!Array.isArray(e))throw new Error("Array expected");return t.blocks=e.map((function(e){var t=e&&e.node,r=!e||void 0===e.visible||e.visible;if(!z(t))throw new TypeError('Property "node" must be a Node');if("boolean"!=typeof r)throw new TypeError('Property "visible" must be a boolean');return{node:t,visible:r}})),t}return wp(r,e),Ie(r,[{key:"type",get:function(){return Hp}},{key:"isBlockNode",get:function(){return!0}},{key:"_compile",value:function(e,r){var n=An(this.blocks,(function(t){return{evaluate:t.node._compile(e,r),visible:t.visible}}));return function(e,r,i){var a=[];return Sn(n,(function(t){var n=t.evaluate(e,r,i);t.visible&&a.push(n)})),new t(a)}}},{key:"forEach",value:function(e){for(var t=0;t<this.blocks.length;t++)e(this.blocks[t].node,"blocks["+t+"].node",this)}},{key:"map",value:function(e){for(var t=[],n=0;n<this.blocks.length;n++){var i=this.blocks[n],a=this._ifNode(e(i.node,"blocks["+n+"].node",this));t[n]={node:a,visible:i.visible}}return new r(t)}},{key:"clone",value:function(){return new r(this.blocks.map((function(e){return{node:e.node,visible:e.visible}})))}},{key:"_toString",value:function(e){return this.blocks.map((function(t){return t.node.toString(e)+(t.visible?"":";")})).join("\n")}},{key:"toJSON",value:function(){return{mathjs:Hp,blocks:this.blocks}}},{key:"_toHTML",value:function(e){return this.blocks.map((function(t){return t.node.toHTML(e)+(t.visible?"":'<span class="math-separator">;</span>')})).join('<span class="math-separator"><br /></span>')}},{key:"_toTex",value:function(e){return this.blocks.map((function(t){return t.node.toTex(e)+(t.visible?"":";")})).join("\\;\\;\n")}}],[{key:"fromJSON",value:function(e){return new r(e.blocks)}}])}(e.Node);return Va(r,"name",Hp),r}),{isClass:!0,isNode:!0});function Vp(e,t,r){return t=xp(t),gp(e,Zp()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function Zp(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(Zp=function(){return!!e})()}var Wp="ConditionalNode",Yp=Se(Wp,["Node"],(function(e){var t=function(e){function t(e,r,n){var i;if(_e(this,t),i=Vp(this,t),!z(e))throw new TypeError("Parameter condition must be a Node");if(!z(r))throw new TypeError("Parameter trueExpr must be a Node");if(!z(n))throw new TypeError("Parameter falseExpr must be a Node");return i.condition=e,i.trueExpr=r,i.falseExpr=n,i}return wp(t,e),Ie(t,[{key:"type",get:function(){return Wp}},{key:"isConditionalNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var r=this.condition._compile(e,t),n=this.trueExpr._compile(e,t),i=this.falseExpr._compile(e,t);return function(e,t,u){return function(e){if("number"==typeof e||"boolean"==typeof e||"string"==typeof e)return!!e;if(e){if(a(e))return!e.isZero();if(o(e))return!(!e.re&&!e.im);if(s(e))return!!e.value}if(null==e)return!1;throw new TypeError('Unsupported type of condition "'+H(e)+'"')}(r(e,t,u))?n(e,t,u):i(e,t,u)}}},{key:"forEach",value:function(e){e(this.condition,"condition",this),e(this.trueExpr,"trueExpr",this),e(this.falseExpr,"falseExpr",this)}},{key:"map",value:function(e){return new t(this._ifNode(e(this.condition,"condition",this)),this._ifNode(e(this.trueExpr,"trueExpr",this)),this._ifNode(e(this.falseExpr,"falseExpr",this)))}},{key:"clone",value:function(){return new t(this.condition,this.trueExpr,this.falseExpr)}},{key:"_toString",value:function(e){var t=e&&e.parenthesis?e.parenthesis:"keep",r=Ip(this,t,e&&e.implicit),n=this.condition.toString(e),i=Ip(this.condition,t,e&&e.implicit);("all"===t||"OperatorNode"===this.condition.type||null!==i&&i<=r)&&(n="("+n+")");var a=this.trueExpr.toString(e),o=Ip(this.trueExpr,t,e&&e.implicit);("all"===t||"OperatorNode"===this.trueExpr.type||null!==o&&o<=r)&&(a="("+a+")");var u=this.falseExpr.toString(e),s=Ip(this.falseExpr,t,e&&e.implicit);return("all"===t||"OperatorNode"===this.falseExpr.type||null!==s&&s<=r)&&(u="("+u+")"),n+" ? "+a+" : "+u}},{key:"toJSON",value:function(){return{mathjs:Wp,condition:this.condition,trueExpr:this.trueExpr,falseExpr:this.falseExpr}}},{key:"_toHTML",value:function(e){var t=e&&e.parenthesis?e.parenthesis:"keep",r=Ip(this,t,e&&e.implicit),n=this.condition.toHTML(e),i=Ip(this.condition,t,e&&e.implicit);("all"===t||"OperatorNode"===this.condition.type||null!==i&&i<=r)&&(n='<span class="math-parenthesis math-round-parenthesis">(</span>'+n+'<span class="math-parenthesis math-round-parenthesis">)</span>');var a=this.trueExpr.toHTML(e),o=Ip(this.trueExpr,t,e&&e.implicit);("all"===t||"OperatorNode"===this.trueExpr.type||null!==o&&o<=r)&&(a='<span class="math-parenthesis math-round-parenthesis">(</span>'+a+'<span class="math-parenthesis math-round-parenthesis">)</span>');var u=this.falseExpr.toHTML(e),s=Ip(this.falseExpr,t,e&&e.implicit);return("all"===t||"OperatorNode"===this.falseExpr.type||null!==s&&s<=r)&&(u='<span class="math-parenthesis math-round-parenthesis">(</span>'+u+'<span class="math-parenthesis math-round-parenthesis">)</span>'),n+'<span class="math-operator math-conditional-operator">?</span>'+a+'<span class="math-operator math-conditional-operator">:</span>'+u}},{key:"_toTex",value:function(e){return"\\begin{cases} {"+this.trueExpr.toTex(e)+"}, &\\quad{\\text{if }\\;"+this.condition.toTex(e)+"}\\\\{"+this.falseExpr.toTex(e)+"}, &\\quad{\\text{otherwise}}\\end{cases}"}}],[{key:"fromJSON",value:function(e){return new t(e.condition,e.trueExpr,e.falseExpr)}}])}(e.Node);return Va(t,"name",Wp),t}),{isClass:!0,isNode:!0}),Jp=r(3144),Xp={Alpha:"A",alpha:"\\alpha",Beta:"B",beta:"\\beta",Gamma:"\\Gamma",gamma:"\\gamma",Delta:"\\Delta",delta:"\\delta",Epsilon:"E",epsilon:"\\epsilon",varepsilon:"\\varepsilon",Zeta:"Z",zeta:"\\zeta",Eta:"H",eta:"\\eta",Theta:"\\Theta",theta:"\\theta",vartheta:"\\vartheta",Iota:"I",iota:"\\iota",Kappa:"K",kappa:"\\kappa",varkappa:"\\varkappa",Lambda:"\\Lambda",lambda:"\\lambda",Mu:"M",mu:"\\mu",Nu:"N",nu:"\\nu",Xi:"\\Xi",xi:"\\xi",Omicron:"O",omicron:"o",Pi:"\\Pi",pi:"\\pi",varpi:"\\varpi",Rho:"P",rho:"\\rho",varrho:"\\varrho",Sigma:"\\Sigma",sigma:"\\sigma",varsigma:"\\varsigma",Tau:"T",tau:"\\tau",Upsilon:"\\Upsilon",upsilon:"\\upsilon",Phi:"\\Phi",phi:"\\phi",varphi:"\\varphi",Chi:"X",chi:"\\chi",Psi:"\\Psi",psi:"\\psi",Omega:"\\Omega",omega:"\\omega",true:"\\mathrm{True}",false:"\\mathrm{False}",i:"i",inf:"\\infty",Inf:"\\infty",infinity:"\\infty",Infinity:"\\infty",oo:"\\infty",lim:"\\lim",undefined:"\\mathbf{?}"},Qp={transpose:"^\\top",ctranspose:"^H",factorial:"!",pow:"^",dotPow:".^\\wedge",unaryPlus:"+",unaryMinus:"-",bitNot:"\\~",not:"\\neg",multiply:"\\cdot",divide:"\\frac",dotMultiply:".\\cdot",dotDivide:".:",mod:"\\mod",add:"+",subtract:"-",to:"\\rightarrow",leftShift:"<<",rightArithShift:">>",rightLogShift:">>>",equal:"=",unequal:"\\neq",smaller:"<",larger:">",smallerEq:"\\leq",largerEq:"\\geq",bitAnd:"\\&",bitXor:"\\underline{|}",bitOr:"|",and:"\\wedge",xor:"\\veebar",or:"\\vee"},Kp={abs:{1:"\\left|${args[0]}\\right|"},add:{2:"\\left(${args[0]}".concat(Qp.add,"${args[1]}\\right)")},cbrt:{1:"\\sqrt[3]{${args[0]}}"},ceil:{1:"\\left\\lceil${args[0]}\\right\\rceil"},cube:{1:"\\left(${args[0]}\\right)^3"},divide:{2:"\\frac{${args[0]}}{${args[1]}}"},dotDivide:{2:"\\left(${args[0]}".concat(Qp.dotDivide,"${args[1]}\\right)")},dotMultiply:{2:"\\left(${args[0]}".concat(Qp.dotMultiply,"${args[1]}\\right)")},dotPow:{2:"\\left(${args[0]}".concat(Qp.dotPow,"${args[1]}\\right)")},exp:{1:"\\exp\\left(${args[0]}\\right)"},expm1:"\\left(e".concat(Qp.pow,"{${args[0]}}-1\\right)"),fix:{1:"\\mathrm{${name}}\\left(${args[0]}\\right)"},floor:{1:"\\left\\lfloor${args[0]}\\right\\rfloor"},gcd:"\\gcd\\left(${args}\\right)",hypot:"\\hypot\\left(${args}\\right)",log:{1:"\\ln\\left(${args[0]}\\right)",2:"\\log_{${args[1]}}\\left(${args[0]}\\right)"},log10:{1:"\\log_{10}\\left(${args[0]}\\right)"},log1p:{1:"\\ln\\left(${args[0]}+1\\right)",2:"\\log_{${args[1]}}\\left(${args[0]}+1\\right)"},log2:"\\log_{2}\\left(${args[0]}\\right)",mod:{2:"\\left(${args[0]}".concat(Qp.mod,"${args[1]}\\right)")},multiply:{2:"\\left(${args[0]}".concat(Qp.multiply,"${args[1]}\\right)")},norm:{1:"\\left\\|${args[0]}\\right\\|",2:void 0},nthRoot:{2:"\\sqrt[${args[1]}]{${args[0]}}"},nthRoots:{2:"\\{y : $y^{args[1]} = {${args[0]}}\\}"},pow:{2:"\\left(${args[0]}\\right)".concat(Qp.pow,"{${args[1]}}")},round:{1:"\\left\\lfloor${args[0]}\\right\\rceil",2:void 0},sign:{1:"\\mathrm{${name}}\\left(${args[0]}\\right)"},sqrt:{1:"\\sqrt{${args[0]}}"},square:{1:"\\left(${args[0]}\\right)^2"},subtract:{2:"\\left(${args[0]}".concat(Qp.subtract,"${args[1]}\\right)")},unaryMinus:{1:"".concat(Qp.unaryMinus,"\\left(${args[0]}\\right)")},unaryPlus:{1:"".concat(Qp.unaryPlus,"\\left(${args[0]}\\right)")},bitAnd:{2:"\\left(${args[0]}".concat(Qp.bitAnd,"${args[1]}\\right)")},bitNot:{1:Qp.bitNot+"\\left(${args[0]}\\right)"},bitOr:{2:"\\left(${args[0]}".concat(Qp.bitOr,"${args[1]}\\right)")},bitXor:{2:"\\left(${args[0]}".concat(Qp.bitXor,"${args[1]}\\right)")},leftShift:{2:"\\left(${args[0]}".concat(Qp.leftShift,"${args[1]}\\right)")},rightArithShift:{2:"\\left(${args[0]}".concat(Qp.rightArithShift,"${args[1]}\\right)")},rightLogShift:{2:"\\left(${args[0]}".concat(Qp.rightLogShift,"${args[1]}\\right)")},bellNumbers:{1:"\\mathrm{B}_{${args[0]}}"},catalan:{1:"\\mathrm{C}_{${args[0]}}"},stirlingS2:{2:"\\mathrm{S}\\left(${args}\\right)"},arg:{1:"\\arg\\left(${args[0]}\\right)"},conj:{1:"\\left(${args[0]}\\right)^*"},im:{1:"\\Im\\left\\lbrace${args[0]}\\right\\rbrace"},re:{1:"\\Re\\left\\lbrace${args[0]}\\right\\rbrace"},and:{2:"\\left(${args[0]}".concat(Qp.and,"${args[1]}\\right)")},not:{1:Qp.not+"\\left(${args[0]}\\right)"},or:{2:"\\left(${args[0]}".concat(Qp.or,"${args[1]}\\right)")},xor:{2:"\\left(${args[0]}".concat(Qp.xor,"${args[1]}\\right)")},cross:{2:"\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"},ctranspose:{1:"\\left(${args[0]}\\right)".concat(Qp.ctranspose)},det:{1:"\\det\\left(${args[0]}\\right)"},dot:{2:"\\left(${args[0]}\\cdot${args[1]}\\right)"},expm:{1:"\\exp\\left(${args[0]}\\right)"},inv:{1:"\\left(${args[0]}\\right)^{-1}"},pinv:{1:"\\left(${args[0]}\\right)^{+}"},sqrtm:{1:"{${args[0]}}".concat(Qp.pow,"{\\frac{1}{2}}")},trace:{1:"\\mathrm{tr}\\left(${args[0]}\\right)"},transpose:{1:"\\left(${args[0]}\\right)".concat(Qp.transpose)},combinations:{2:"\\binom{${args[0]}}{${args[1]}}"},combinationsWithRep:{2:"\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"},factorial:{1:"\\left(${args[0]}\\right)".concat(Qp.factorial)},gamma:{1:"\\Gamma\\left(${args[0]}\\right)"},lgamma:{1:"\\ln\\Gamma\\left(${args[0]}\\right)"},equal:{2:"\\left(${args[0]}".concat(Qp.equal,"${args[1]}\\right)")},larger:{2:"\\left(${args[0]}".concat(Qp.larger,"${args[1]}\\right)")},largerEq:{2:"\\left(${args[0]}".concat(Qp.largerEq,"${args[1]}\\right)")},smaller:{2:"\\left(${args[0]}".concat(Qp.smaller,"${args[1]}\\right)")},smallerEq:{2:"\\left(${args[0]}".concat(Qp.smallerEq,"${args[1]}\\right)")},unequal:{2:"\\left(${args[0]}".concat(Qp.unequal,"${args[1]}\\right)")},erf:{1:"erf\\left(${args[0]}\\right)"},max:"\\max\\left(${args}\\right)",min:"\\min\\left(${args}\\right)",variance:"\\mathrm{Var}\\left(${args}\\right)",acos:{1:"\\cos^{-1}\\left(${args[0]}\\right)"},acosh:{1:"\\cosh^{-1}\\left(${args[0]}\\right)"},acot:{1:"\\cot^{-1}\\left(${args[0]}\\right)"},acoth:{1:"\\coth^{-1}\\left(${args[0]}\\right)"},acsc:{1:"\\csc^{-1}\\left(${args[0]}\\right)"},acsch:{1:"\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"},asec:{1:"\\sec^{-1}\\left(${args[0]}\\right)"},asech:{1:"\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"},asin:{1:"\\sin^{-1}\\left(${args[0]}\\right)"},asinh:{1:"\\sinh^{-1}\\left(${args[0]}\\right)"},atan:{1:"\\tan^{-1}\\left(${args[0]}\\right)"},atan2:{2:"\\mathrm{atan2}\\left(${args}\\right)"},atanh:{1:"\\tanh^{-1}\\left(${args[0]}\\right)"},cos:{1:"\\cos\\left(${args[0]}\\right)"},cosh:{1:"\\cosh\\left(${args[0]}\\right)"},cot:{1:"\\cot\\left(${args[0]}\\right)"},coth:{1:"\\coth\\left(${args[0]}\\right)"},csc:{1:"\\csc\\left(${args[0]}\\right)"},csch:{1:"\\mathrm{csch}\\left(${args[0]}\\right)"},sec:{1:"\\sec\\left(${args[0]}\\right)"},sech:{1:"\\mathrm{sech}\\left(${args[0]}\\right)"},sin:{1:"\\sin\\left(${args[0]}\\right)"},sinh:{1:"\\sinh\\left(${args[0]}\\right)"},tan:{1:"\\tan\\left(${args[0]}\\right)"},tanh:{1:"\\tanh\\left(${args[0]}\\right)"},to:{2:"\\left(${args[0]}".concat(Qp.to,"${args[1]}\\right)")},numeric:function(e,t){return e.args[0].toTex()},number:{0:"0",1:"\\left(${args[0]}\\right)",2:"\\left(\\left(${args[0]}\\right)${args[1]}\\right)"},string:{0:'\\mathtt{""}',1:"\\mathrm{string}\\left(${args[0]}\\right)"},bignumber:{0:"0",1:"\\left(${args[0]}\\right)"},complex:{0:"0",1:"\\left(${args[0]}\\right)",2:"\\left(\\left(${args[0]}\\right)+".concat(Xp.i,"\\cdot\\left(${args[1]}\\right)\\right)")},matrix:{0:"\\begin{bmatrix}\\end{bmatrix}",1:"\\left(${args[0]}\\right)",2:"\\left(${args[0]}\\right)"},sparse:{0:"\\begin{bsparse}\\end{bsparse}",1:"\\left(${args[0]}\\right)"},unit:{1:"\\left(${args[0]}\\right)",2:"\\left(\\left(${args[0]}\\right)${args[1]}\\right)"}},em={deg:"^\\circ"};function tm(e){return Jp(e,{preserveFormatting:!0})}function rm(e,t){return(t=void 0!==t&&t)?Ae(em,e)?em[e]:"\\mathrm{"+tm(e)+"}":Ae(Xp,e)?Xp[e]:tm(e)}function nm(e,t,r){return t=xp(t),gp(e,im()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function im(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(im=function(){return!!e})()}var am="ConstantNode",om=Se(am,["Node"],(function(e){var t=function(e){function t(e){var r;return _e(this,t),(r=nm(this,t)).value=e,r}return wp(t,e),Ie(t,[{key:"type",get:function(){return am}},{key:"isConstantNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var r=this.value;return function(){return r}}},{key:"forEach",value:function(e){}},{key:"map",value:function(e){return this.clone()}},{key:"clone",value:function(){return new t(this.value)}},{key:"_toString",value:function(e){return en(this.value,e)}},{key:"_toHTML",value:function(e){var t=this._toString(e);switch(H(this.value)){case"number":case"BigNumber":case"Fraction":return'<span class="math-number">'+t+"</span>";case"string":return'<span class="math-string">'+t+"</span>";case"boolean":return'<span class="math-boolean">'+t+"</span>";case"null":return'<span class="math-null-symbol">'+t+"</span>";case"undefined":return'<span class="math-undefined">'+t+"</span>";default:return'<span class="math-symbol">'+t+"</span>"}}},{key:"toJSON",value:function(){return{mathjs:am,value:this.value}}},{key:"_toTex",value:function(e){var t=this._toString(e),r=H(this.value);switch(r){case"string":return"\\mathtt{"+tm(t)+"}";case"number":case"BigNumber":if(!("BigNumber"===r?this.value.isFinite():isFinite(this.value)))return this.value.valueOf()<0?"-\\infty":"\\infty";var n=t.toLowerCase().indexOf("e");return-1!==n?t.substring(0,n)+"\\cdot10^{"+t.substring(n+1)+"}":t;case"Fraction":return this.value.toLatex();default:return t}}}],[{key:"fromJSON",value:function(e){return new t(e.value)}}])}(e.Node);return Va(t,"name",am),t}),{isClass:!0,isNode:!0});function um(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function sm(e,t,r){return t=xp(t),gp(e,cm()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function cm(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(cm=function(){return!!e})()}var fm="FunctionAssignmentNode",lm=Se(fm,["typed","Node"],(function(e){var t=e.typed;function r(e,t,r){var n=Ip(e,t,r),i=Ip(e.expr,t,r);return"all"===t||null!==i&&i<=n}var n=function(e){function n(e,t,r){var i;if(_e(this,n),i=sm(this,n),"string"!=typeof e)throw new TypeError('String expected for parameter "name"');if(!Array.isArray(t))throw new TypeError('Array containing strings or objects expected for parameter "params"');if(!z(r))throw new TypeError('Node expected for parameter "expr"');if(vp.has(e))throw new Error('Illegal function name, "'+e+'" is a reserved keyword');var a,o=new Set,u=function(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return um(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?um(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,o=!0,u=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return o=e.done,e},e:function(e){u=!0,a=e},f:function(){try{o||null==r.return||r.return()}finally{if(u)throw a}}}}(t);try{for(u.s();!(a=u.n()).done;){var s=a.value,c="string"==typeof s?s:s.name;if(o.has(c))throw new Error('Duplicate parameter name "'.concat(c,'"'));o.add(c)}}catch(e){u.e(e)}finally{u.f()}return i.name=e,i.params=t.map((function(e){return e&&e.name||e})),i.types=t.map((function(e){return e&&e.type||"any"})),i.expr=r,i}return wp(n,e),Ie(n,[{key:"type",get:function(){return fm}},{key:"isFunctionAssignmentNode",get:function(){return!0}},{key:"_compile",value:function(e,r){var n=Object.create(r);Sn(this.params,(function(e){n[e]=!0}));var i=this.expr._compile(e,n),a=this.name,o=this.params,u=Fn(this.types,","),s=a+"("+Fn(this.params,", ")+")";return function(e,r,n){var c={};c[u]=function(){for(var t=Object.create(r),a=0;a<o.length;a++)t[o[a]]=arguments[a];return i(e,t,n)};var f=t(a,c);return f.syntax=s,e.set(a,f),f}}},{key:"forEach",value:function(e){e(this.expr,"expr",this)}},{key:"map",value:function(e){var t=this._ifNode(e(this.expr,"expr",this));return new n(this.name,this.params.slice(0),t)}},{key:"clone",value:function(){return new n(this.name,this.params.slice(0),this.expr)}},{key:"_toString",value:function(e){var t=e&&e.parenthesis?e.parenthesis:"keep",n=this.expr.toString(e);return r(this,t,e&&e.implicit)&&(n="("+n+")"),this.name+"("+this.params.join(", ")+") = "+n}},{key:"toJSON",value:function(){var e=this.types;return{mathjs:fm,name:this.name,params:this.params.map((function(t,r){return{name:t,type:e[r]}})),expr:this.expr}}},{key:"_toHTML",value:function(e){for(var t=e&&e.parenthesis?e.parenthesis:"keep",n=[],i=0;i<this.params.length;i++)n.push('<span class="math-symbol math-parameter">'+nn(this.params[i])+"</span>");var a=this.expr.toHTML(e);return r(this,t,e&&e.implicit)&&(a='<span class="math-parenthesis math-round-parenthesis">(</span>'+a+'<span class="math-parenthesis math-round-parenthesis">)</span>'),'<span class="math-function">'+nn(this.name)+'</span><span class="math-parenthesis math-round-parenthesis">(</span>'+n.join('<span class="math-separator">,</span>')+'<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>'+a}},{key:"_toTex",value:function(e){var t=e&&e.parenthesis?e.parenthesis:"keep",n=this.expr.toTex(e);return r(this,t,e&&e.implicit)&&(n="\\left(".concat(n,"\\right)")),"\\mathrm{"+this.name+"}\\left("+this.params.map(rm).join(",")+"\\right)="+n}}],[{key:"fromJSON",value:function(e){return new n(e.name,e.params,e.expr)}}])}(e.Node);return Va(n,"name",fm),n}),{isClass:!0,isNode:!0});function pm(e,t,r){return t=xp(t),gp(e,mm()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function mm(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(mm=function(){return!!e})()}var hm="IndexNode",dm=Se(hm,["Node","size"],(function(e){var t=e.Node,r=e.size,n=function(e){function t(e,r){var n;if(_e(this,t),(n=pm(this,t)).dimensions=e,n.dotNotation=r||!1,!Array.isArray(e)||!e.every(z))throw new TypeError('Array containing Nodes expected for parameter "dimensions"');if(n.dotNotation&&!n.isObjectProperty())throw new Error("dotNotation only applicable for object properties");return n}return wp(t,e),Ie(t,[{key:"type",get:function(){return hm}},{key:"isIndexNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var n=An(this.dimensions,(function(n,i){if(n.filter((function(e){return e.isSymbolNode&&"end"===e.name})).length>0){var a=Object.create(t);a.end=!0;var o=n._compile(e,a);return function(e,t,n){if(!l(n)&&!f(n)&&!c(n))throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is '+H(n));var a=r(n).valueOf(),u=Object.create(t);return u.end=a[i],o(e,u,n)}}return n._compile(e,t)})),i=ze(e,"index");return function(e,t,r){var a=An(n,(function(n){return n(e,t,r)}));return i.apply(void 0,Te(a))}}},{key:"forEach",value:function(e){for(var t=0;t<this.dimensions.length;t++)e(this.dimensions[t],"dimensions["+t+"]",this)}},{key:"map",value:function(e){for(var r=[],n=0;n<this.dimensions.length;n++)r[n]=this._ifNode(e(this.dimensions[n],"dimensions["+n+"]",this));return new t(r,this.dotNotation)}},{key:"clone",value:function(){return new t(this.dimensions.slice(0),this.dotNotation)}},{key:"isObjectProperty",value:function(){return 1===this.dimensions.length&&T(this.dimensions[0])&&"string"==typeof this.dimensions[0].value}},{key:"getObjectProperty",value:function(){return this.isObjectProperty()?this.dimensions[0].value:null}},{key:"_toString",value:function(e){return this.dotNotation?"."+this.getObjectProperty():"["+this.dimensions.join(", ")+"]"}},{key:"toJSON",value:function(){return{mathjs:hm,dimensions:this.dimensions,dotNotation:this.dotNotation}}},{key:"_toHTML",value:function(e){for(var t=[],r=0;r<this.dimensions.length;r++)t[r]=this.dimensions[r].toHTML();return this.dotNotation?'<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">'+nn(this.getObjectProperty())+"</span>":'<span class="math-parenthesis math-square-parenthesis">[</span>'+t.join('<span class="math-separator">,</span>')+'<span class="math-parenthesis math-square-parenthesis">]</span>'}},{key:"_toTex",value:function(e){var t=this.dimensions.map((function(t){return t.toTex(e)}));return this.dotNotation?"."+this.getObjectProperty():"_{"+t.join(",")+"}"}}],[{key:"fromJSON",value:function(e){return new t(e.dimensions,e.dotNotation)}}])}(t);return Va(n,"name",hm),n}),{isClass:!0,isNode:!0});function vm(e,t,r){return t=xp(t),gp(e,ym()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function ym(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(ym=function(){return!!e})()}var gm="ObjectNode",xm=Se(gm,["Node"],(function(e){var r=function(e){function r(e){var n;if(_e(this,r),(n=vm(this,r)).properties=e||{},e&&("object"!==t(e)||!Object.keys(e).every((function(t){return z(e[t])}))))throw new TypeError("Object containing Nodes expected");return n}return wp(r,e),Ie(r,[{key:"type",get:function(){return gm}},{key:"isObjectNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var r={};for(var n in this.properties)if(Ae(this.properties,n)){var i=tn(n),a=JSON.parse(i),o=ze(this.properties,n);r[a]=o._compile(e,t)}return function(e,t,n){var i={};for(var a in r)Ae(r,a)&&(i[a]=r[a](e,t,n));return i}}},{key:"forEach",value:function(e){for(var t in this.properties)Ae(this.properties,t)&&e(this.properties[t],"properties["+tn(t)+"]",this)}},{key:"map",value:function(e){var t={};for(var n in this.properties)Ae(this.properties,n)&&(t[n]=this._ifNode(e(this.properties[n],"properties["+tn(n)+"]",this)));return new r(t)}},{key:"clone",value:function(){var e={};for(var t in this.properties)Ae(this.properties,t)&&(e[t]=this.properties[t]);return new r(e)}},{key:"_toString",value:function(e){var t=[];for(var r in this.properties)Ae(this.properties,r)&&t.push(tn(r)+": "+this.properties[r].toString(e));return"{"+t.join(", ")+"}"}},{key:"toJSON",value:function(){return{mathjs:gm,properties:this.properties}}},{key:"_toHTML",value:function(e){var t=[];for(var r in this.properties)Ae(this.properties,r)&&t.push('<span class="math-symbol math-property">'+nn(r)+'</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>'+this.properties[r].toHTML(e));return'<span class="math-parenthesis math-curly-parenthesis">{</span>'+t.join('<span class="math-separator">,</span>')+'<span class="math-parenthesis math-curly-parenthesis">}</span>'}},{key:"_toTex",value:function(e){var t=[];for(var r in this.properties)Ae(this.properties,r)&&t.push("\\mathbf{"+r+":} & "+this.properties[r].toTex(e)+"\\\\");return"\\left\\{\\begin{array}{ll}"+t.join("\n")+"\\end{array}\\right\\}"}}],[{key:"fromJSON",value:function(e){return new r(e.properties)}}])}(e.Node);return Va(r,"name",gm),r}),{isClass:!0,isNode:!0});function bm(e,t){return new Ve(e,new Ge(t),new Set(Object.keys(t)))}function wm(e,t,r){return t=xp(t),gp(e,Dm()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function Dm(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(Dm=function(){return!!e})()}var Nm="OperatorNode",Em=Se(Nm,["Node"],(function(e){function t(e,r){var n=e;if("auto"===r)for(;j(n);)n=n.content;return!!T(n)||!!q(n)&&t(n.args[0],r)}function r(e,r,n,i,a){var o,u=Ip(e,r,n),s=zp(e,r);if("all"===r||i.length>2&&"OperatorNode:add"!==e.getIdentifier()&&"OperatorNode:multiply"!==e.getIdentifier())return i.map((function(e){switch(e.getContent().type){case"ArrayNode":case"ConstantNode":case"SymbolNode":case"ParenthesisNode":return!1;default:return!0}}));switch(i.length){case 0:o=[];break;case 1:var c=Ip(i[0],r,n,e);if(a&&null!==c){var f,l;if("keep"===r?(f=i[0].getIdentifier(),l=e.getIdentifier()):(f=i[0].getContent().getIdentifier(),l=e.getContent().getIdentifier()),!1===Bp[u][l].latexLeftParens){o=[!1];break}if(!1===Bp[c][f].latexParens){o=[!1];break}}if(null===c){o=[!1];break}if(c<=u){o=[!0];break}o=[!1];break;case 2:var p,m,h=Ip(i[0],r,n,e),d=Rp(e,i[0],r);p=null!==h&&(h===u&&"right"===s&&!d||h<u);var v,y,g,x=Ip(i[1],r,n,e),b=Rp(e,i[1],r);m=null!==x&&(x===u&&"left"===s&&!b||x<u),a&&("keep"===r?(v=e.getIdentifier(),y=e.args[0].getIdentifier(),g=e.args[1].getIdentifier()):(v=e.getContent().getIdentifier(),y=e.args[0].getContent().getIdentifier(),g=e.args[1].getContent().getIdentifier()),null!==h&&(!1===Bp[u][v].latexLeftParens&&(p=!1),!1===Bp[h][y].latexParens&&(p=!1)),null!==x&&(!1===Bp[u][v].latexRightParens&&(m=!1),!1===Bp[x][g].latexParens&&(m=!1))),o=[p,m];break;default:"OperatorNode:add"!==e.getIdentifier()&&"OperatorNode:multiply"!==e.getIdentifier()||(o=i.map((function(t){var i=Ip(t,r,n,e),a=Rp(e,t,r),o=zp(t,r);return null!==i&&(u===i&&s===o&&!a||i<u)})))}if(i.length>=2&&"OperatorNode:multiply"===e.getIdentifier()&&e.implicit&&"all"!==r&&"hide"===n)for(var w=1;w<o.length;++w)!t(i[w],r)||o[w-1]||"keep"===r&&j(i[w-1])||(o[w]=!0);return o}var n=function(e){function t(e,r,n,i,a){var o;if(_e(this,t),o=wm(this,t),"string"!=typeof e)throw new TypeError('string expected for parameter "op"');if("string"!=typeof r)throw new TypeError('string expected for parameter "fn"');if(!Array.isArray(n)||!n.every(z))throw new TypeError('Array containing Nodes expected for parameter "args"');return o.implicit=!0===i,o.isPercentage=!0===a,o.op=e,o.fn=r,o.args=n||[],o}return wp(t,e),Ie(t,[{key:"type",get:function(){return Nm}},{key:"isOperatorNode",get:function(){return!0}},{key:"_compile",value:function(e,t){if("string"!=typeof this.fn||!je(e,this.fn))throw e[this.fn]?new Error('No access to function "'+this.fn+'"'):new Error("Function "+this.fn+' missing in provided namespace "math"');var r=ze(e,this.fn),n=An(this.args,(function(r){return r._compile(e,t)}));if("function"==typeof r&&!0===r.rawArgs){var i=this.args;return function(t,n,a){return r(i,e,bm(t,n))}}if(1===n.length){var a=n[0];return function(e,t,n){return r(a(e,t,n))}}if(2===n.length){var o=n[0],u=n[1];return function(e,t,n){return r(o(e,t,n),u(e,t,n))}}return function(e,t,i){return r.apply(null,An(n,(function(r){return r(e,t,i)})))}}},{key:"forEach",value:function(e){for(var t=0;t<this.args.length;t++)e(this.args[t],"args["+t+"]",this)}},{key:"map",value:function(e){for(var r=[],n=0;n<this.args.length;n++)r[n]=this._ifNode(e(this.args[n],"args["+n+"]",this));return new t(this.op,this.fn,r,this.implicit,this.isPercentage)}},{key:"clone",value:function(){return new t(this.op,this.fn,this.args.slice(0),this.implicit,this.isPercentage)}},{key:"isUnary",value:function(){return 1===this.args.length}},{key:"isBinary",value:function(){return 2===this.args.length}},{key:"_toString",value:function(e){var t=e&&e.parenthesis?e.parenthesis:"keep",n=e&&e.implicit?e.implicit:"hide",i=this.args,a=r(this,t,n,i,!1);if(1===i.length){var o=zp(this,t),u=i[0].toString(e);a[0]&&(u="("+u+")");var s=/[a-zA-Z]+/.test(this.op);return"right"===o?this.op+(s?" ":"")+u:"left"===o?u+(s?" ":"")+this.op:u+this.op}if(2===i.length){var c=i[0].toString(e),f=i[1].toString(e);return a[0]&&(c="("+c+")"),a[1]&&(f="("+f+")"),this.implicit&&"OperatorNode:multiply"===this.getIdentifier()&&"hide"===n?c+" "+f:c+" "+this.op+" "+f}if(i.length>2&&("OperatorNode:add"===this.getIdentifier()||"OperatorNode:multiply"===this.getIdentifier())){var l=i.map((function(t,r){return t=t.toString(e),a[r]&&(t="("+t+")"),t}));return this.implicit&&"OperatorNode:multiply"===this.getIdentifier()&&"hide"===n?l.join(" "):l.join(" "+this.op+" ")}return this.fn+"("+this.args.join(", ")+")"}},{key:"toJSON",value:function(){return{mathjs:Nm,op:this.op,fn:this.fn,args:this.args,implicit:this.implicit,isPercentage:this.isPercentage}}},{key:"_toHTML",value:function(e){var t=e&&e.parenthesis?e.parenthesis:"keep",n=e&&e.implicit?e.implicit:"hide",i=this.args,a=r(this,t,n,i,!1);if(1===i.length){var o=zp(this,t),u=i[0].toHTML(e);return a[0]&&(u='<span class="math-parenthesis math-round-parenthesis">(</span>'+u+'<span class="math-parenthesis math-round-parenthesis">)</span>'),"right"===o?'<span class="math-operator math-unary-operator math-lefthand-unary-operator">'+nn(this.op)+"</span>"+u:u+'<span class="math-operator math-unary-operator math-righthand-unary-operator">'+nn(this.op)+"</span>"}if(2===i.length){var s=i[0].toHTML(e),c=i[1].toHTML(e);return a[0]&&(s='<span class="math-parenthesis math-round-parenthesis">(</span>'+s+'<span class="math-parenthesis math-round-parenthesis">)</span>'),a[1]&&(c='<span class="math-parenthesis math-round-parenthesis">(</span>'+c+'<span class="math-parenthesis math-round-parenthesis">)</span>'),this.implicit&&"OperatorNode:multiply"===this.getIdentifier()&&"hide"===n?s+'<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>'+c:s+'<span class="math-operator math-binary-operator math-explicit-binary-operator">'+nn(this.op)+"</span>"+c}var f=i.map((function(t,r){return t=t.toHTML(e),a[r]&&(t='<span class="math-parenthesis math-round-parenthesis">(</span>'+t+'<span class="math-parenthesis math-round-parenthesis">)</span>'),t}));return i.length>2&&("OperatorNode:add"===this.getIdentifier()||"OperatorNode:multiply"===this.getIdentifier())?this.implicit&&"OperatorNode:multiply"===this.getIdentifier()&&"hide"===n?f.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>'):f.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">'+nn(this.op)+"</span>"):'<span class="math-function">'+nn(this.fn)+'</span><span class="math-paranthesis math-round-parenthesis">(</span>'+f.join('<span class="math-separator">,</span>')+'<span class="math-paranthesis math-round-parenthesis">)</span>'}},{key:"_toTex",value:function(e){var t=e&&e.parenthesis?e.parenthesis:"keep",n=e&&e.implicit?e.implicit:"hide",i=this.args,a=r(this,t,n,i,!0),o=Qp[this.fn];if(o=void 0===o?this.op:o,1===i.length){var u=zp(this,t),s=i[0].toTex(e);return a[0]&&(s="\\left(".concat(s,"\\right)")),"right"===u?o+s:s+o}if(2===i.length){var c=i[0],f=c.toTex(e);a[0]&&(f="\\left(".concat(f,"\\right)"));var l,p=i[1].toTex(e);switch(a[1]&&(p="\\left(".concat(p,"\\right)")),l="keep"===t?c.getIdentifier():c.getContent().getIdentifier(),this.getIdentifier()){case"OperatorNode:divide":return o+"{"+f+"}{"+p+"}";case"OperatorNode:pow":switch(f="{"+f+"}",p="{"+p+"}",l){case"ConditionalNode":case"OperatorNode:divide":f="\\left(".concat(f,"\\right)")}break;case"OperatorNode:multiply":if(this.implicit&&"hide"===n)return f+"~"+p}return f+o+p}if(i.length>2&&("OperatorNode:add"===this.getIdentifier()||"OperatorNode:multiply"===this.getIdentifier())){var m=i.map((function(t,r){return t=t.toTex(e),a[r]&&(t="\\left(".concat(t,"\\right)")),t}));return"OperatorNode:multiply"===this.getIdentifier()&&this.implicit&&"hide"===n?m.join("~"):m.join(o)}return"\\mathrm{"+this.fn+"}\\left("+i.map((function(t){return t.toTex(e)})).join(",")+"\\right)"}},{key:"getIdentifier",value:function(){return this.type+":"+this.fn}}],[{key:"fromJSON",value:function(e){return new t(e.op,e.fn,e.args,e.implicit,e.isPercentage)}}])}(e.Node);return Va(n,"name",Nm),n}),{isClass:!0,isNode:!0});function Am(e,t,r){return t=xp(t),gp(e,Sm()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function Sm(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(Sm=function(){return!!e})()}var Cm="ParenthesisNode",Mm=Se(Cm,["Node"],(function(e){var t=function(e){function t(e){var r;if(_e(this,t),r=Am(this,t),!z(e))throw new TypeError('Node expected for parameter "content"');return r.content=e,r}return wp(t,e),Ie(t,[{key:"type",get:function(){return Cm}},{key:"isParenthesisNode",get:function(){return!0}},{key:"_compile",value:function(e,t){return this.content._compile(e,t)}},{key:"getContent",value:function(){return this.content.getContent()}},{key:"forEach",value:function(e){e(this.content,"content",this)}},{key:"map",value:function(e){return new t(e(this.content,"content",this))}},{key:"clone",value:function(){return new t(this.content)}},{key:"_toString",value:function(e){return!e||e&&!e.parenthesis||e&&"keep"===e.parenthesis?"("+this.content.toString(e)+")":this.content.toString(e)}},{key:"toJSON",value:function(){return{mathjs:Cm,content:this.content}}},{key:"_toHTML",value:function(e){return!e||e&&!e.parenthesis||e&&"keep"===e.parenthesis?'<span class="math-parenthesis math-round-parenthesis">(</span>'+this.content.toHTML(e)+'<span class="math-parenthesis math-round-parenthesis">)</span>':this.content.toHTML(e)}},{key:"_toTex",value:function(e){return!e||e&&!e.parenthesis||e&&"keep"===e.parenthesis?"\\left(".concat(this.content.toTex(e),"\\right)"):this.content.toTex(e)}}],[{key:"fromJSON",value:function(e){return new t(e.content)}}])}(e.Node);return Va(t,"name",Cm),t}),{isClass:!0,isNode:!0});function Fm(e,t,r){return t=xp(t),gp(e,Om()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function Om(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(Om=function(){return!!e})()}var Tm="RangeNode",_m=Se(Tm,["Node"],(function(e){function t(e,t,r){var n=Ip(e,t,r),i={},a=Ip(e.start,t,r);if(i.start=null!==a&&a<=n||"all"===t,e.step){var o=Ip(e.step,t,r);i.step=null!==o&&o<=n||"all"===t}var u=Ip(e.end,t,r);return i.end=null!==u&&u<=n||"all"===t,i}var r=function(e){function r(e,t,n){var i;if(_e(this,r),i=Fm(this,r),!z(e))throw new TypeError("Node expected");if(!z(t))throw new TypeError("Node expected");if(n&&!z(n))throw new TypeError("Node expected");if(arguments.length>3)throw new Error("Too many arguments");return i.start=e,i.end=t,i.step=n||null,i}return wp(r,e),Ie(r,[{key:"type",get:function(){return Tm}},{key:"isRangeNode",get:function(){return!0}},{key:"needsEnd",value:function(){return this.filter((function(e){return U(e)&&"end"===e.name})).length>0}},{key:"_compile",value:function(e,t){var r=e.range,n=this.start._compile(e,t),i=this.end._compile(e,t);if(this.step){var a=this.step._compile(e,t);return function(e,t,o){return r(n(e,t,o),i(e,t,o),a(e,t,o))}}return function(e,t,a){return r(n(e,t,a),i(e,t,a))}}},{key:"forEach",value:function(e){e(this.start,"start",this),e(this.end,"end",this),this.step&&e(this.step,"step",this)}},{key:"map",value:function(e){return new r(this._ifNode(e(this.start,"start",this)),this._ifNode(e(this.end,"end",this)),this.step&&this._ifNode(e(this.step,"step",this)))}},{key:"clone",value:function(){return new r(this.start,this.end,this.step&&this.step)}},{key:"_toString",value:function(e){var r,n=t(this,e&&e.parenthesis?e.parenthesis:"keep",e&&e.implicit),i=this.start.toString(e);if(n.start&&(i="("+i+")"),r=i,this.step){var a=this.step.toString(e);n.step&&(a="("+a+")"),r+=":"+a}var o=this.end.toString(e);return n.end&&(o="("+o+")"),r+":"+o}},{key:"toJSON",value:function(){return{mathjs:Tm,start:this.start,end:this.end,step:this.step}}},{key:"_toHTML",value:function(e){var r,n=t(this,e&&e.parenthesis?e.parenthesis:"keep",e&&e.implicit),i=this.start.toHTML(e);if(n.start&&(i='<span class="math-parenthesis math-round-parenthesis">(</span>'+i+'<span class="math-parenthesis math-round-parenthesis">)</span>'),r=i,this.step){var a=this.step.toHTML(e);n.step&&(a='<span class="math-parenthesis math-round-parenthesis">(</span>'+a+'<span class="math-parenthesis math-round-parenthesis">)</span>'),r+='<span class="math-operator math-range-operator">:</span>'+a}var o=this.end.toHTML(e);return n.end&&(o='<span class="math-parenthesis math-round-parenthesis">(</span>'+o+'<span class="math-parenthesis math-round-parenthesis">)</span>'),r+'<span class="math-operator math-range-operator">:</span>'+o}},{key:"_toTex",value:function(e){var r=t(this,e&&e.parenthesis?e.parenthesis:"keep",e&&e.implicit),n=this.start.toTex(e);if(r.start&&(n="\\left(".concat(n,"\\right)")),this.step){var i=this.step.toTex(e);r.step&&(i="\\left(".concat(i,"\\right)")),n+=":"+i}var a=this.end.toTex(e);return r.end&&(a="\\left(".concat(a,"\\right)")),n+":"+a}}],[{key:"fromJSON",value:function(e){return new r(e.start,e.end,e.step)}}])}(e.Node);return Va(r,"name",Tm),r}),{isClass:!0,isNode:!0});function Bm(e,t,r){return t=xp(t),gp(e,km()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function km(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(km=function(){return!!e})()}var Im="RelationalNode",zm=Se(Im,["Node"],(function(e){var t=e.Node,r={equal:"==",unequal:"!=",smaller:"<",larger:">",smallerEq:"<=",largerEq:">="},n=function(e){function t(e,r){var n;if(_e(this,t),n=Bm(this,t),!Array.isArray(e))throw new TypeError("Parameter conditionals must be an array");if(!Array.isArray(r))throw new TypeError("Parameter params must be an array");if(e.length!==r.length-1)throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");return n.conditionals=e,n.params=r,n}return wp(t,e),Ie(t,[{key:"type",get:function(){return Im}},{key:"isRelationalNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var r=this,n=this.params.map((function(r){return r._compile(e,t)}));return function(t,i,a){for(var o,u=n[0](t,i,a),s=0;s<r.conditionals.length;s++)if(o=u,u=n[s+1](t,i,a),!ze(e,r.conditionals[s])(o,u))return!1;return!0}}},{key:"forEach",value:function(e){var t=this;this.params.forEach((function(r,n){return e(r,"params["+n+"]",t)}),this)}},{key:"map",value:function(e){var r=this;return new t(this.conditionals.slice(),this.params.map((function(t,n){return r._ifNode(e(t,"params["+n+"]",r))}),this))}},{key:"clone",value:function(){return new t(this.conditionals,this.params)}},{key:"_toString",value:function(e){for(var t=e&&e.parenthesis?e.parenthesis:"keep",n=Ip(this,t,e&&e.implicit),i=this.params.map((function(r,i){var a=Ip(r,t,e&&e.implicit);return"all"===t||null!==a&&a<=n?"("+r.toString(e)+")":r.toString(e)})),a=i[0],o=0;o<this.conditionals.length;o++)a+=" "+r[this.conditionals[o]],a+=" "+i[o+1];return a}},{key:"toJSON",value:function(){return{mathjs:Im,conditionals:this.conditionals,params:this.params}}},{key:"_toHTML",value:function(e){for(var t=e&&e.parenthesis?e.parenthesis:"keep",n=Ip(this,t,e&&e.implicit),i=this.params.map((function(r,i){var a=Ip(r,t,e&&e.implicit);return"all"===t||null!==a&&a<=n?'<span class="math-parenthesis math-round-parenthesis">(</span>'+r.toHTML(e)+'<span class="math-parenthesis math-round-parenthesis">)</span>':r.toHTML(e)})),a=i[0],o=0;o<this.conditionals.length;o++)a+='<span class="math-operator math-binary-operator math-explicit-binary-operator">'+nn(r[this.conditionals[o]])+"</span>"+i[o+1];return a}},{key:"_toTex",value:function(e){for(var t=e&&e.parenthesis?e.parenthesis:"keep",r=Ip(this,t,e&&e.implicit),n=this.params.map((function(n,i){var a=Ip(n,t,e&&e.implicit);return"all"===t||null!==a&&a<=r?"\\left("+n.toTex(e)+"\right)":n.toTex(e)})),i=n[0],a=0;a<this.conditionals.length;a++)i+=Qp[this.conditionals[a]]+n[a+1];return i}}],[{key:"fromJSON",value:function(e){return new t(e.conditionals,e.params)}}])}(t);return Va(n,"name",Im),n}),{isClass:!0,isNode:!0});function Rm(e,t,r){return t=xp(t),gp(e,qm()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function qm(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(qm=function(){return!!e})()}var jm=Se("SymbolNode",["math","?Unit","Node"],(function(e){var t=e.math,r=e.Unit;function n(e){return!!r&&r.isValuelessUnit(e)}var i=function(e){function i(e){var t;if(_e(this,i),t=Rm(this,i),"string"!=typeof e)throw new TypeError('String expected for parameter "name"');return t.name=e,t}return wp(i,e),Ie(i,[{key:"type",get:function(){return"SymbolNode"}},{key:"isSymbolNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var a=this.name;if(!0===t[a])return function(e,t,r){return ze(t,a)};if(a in e)return function(t,r,n){return t.has(a)?t.get(a):ze(e,a)};var o=n(a);return function(e,t,n){return e.has(a)?e.get(a):o?new r(null,a):i.onUndefinedSymbol(a)}}},{key:"forEach",value:function(e){}},{key:"map",value:function(e){return this.clone()}},{key:"clone",value:function(){return new i(this.name)}},{key:"_toString",value:function(e){return this.name}},{key:"_toHTML",value:function(e){var t=nn(this.name);return"true"===t||"false"===t?'<span class="math-symbol math-boolean">'+t+"</span>":"i"===t?'<span class="math-symbol math-imaginary-symbol">'+t+"</span>":"Infinity"===t?'<span class="math-symbol math-infinity-symbol">'+t+"</span>":"NaN"===t?'<span class="math-symbol math-nan-symbol">'+t+"</span>":"null"===t?'<span class="math-symbol math-null-symbol">'+t+"</span>":"undefined"===t?'<span class="math-symbol math-undefined-symbol">'+t+"</span>":'<span class="math-symbol">'+t+"</span>"}},{key:"toJSON",value:function(){return{mathjs:"SymbolNode",name:this.name}}},{key:"_toTex",value:function(e){var r=!1;void 0===t[this.name]&&n(this.name)&&(r=!0);var i=rm(this.name,r);return"\\"===i[0]?i:" "+i}}],[{key:"onUndefinedSymbol",value:function(e){throw new Error("Undefined symbol "+e)}},{key:"fromJSON",value:function(e){return new i(e.name)}}])}(e.Node);return i}),{isClass:!0,isNode:!0});function Pm(){return Pm="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var n=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=xp(e)););return e}(e,t);if(n){var i=Object.getOwnPropertyDescriptor(n,t);return i.get?i.get.call(arguments.length<3?e:r):i.value}},Pm.apply(this,arguments)}function Lm(e,t,r){return t=xp(t),gp(e,Um()?Reflect.construct(t,r||[],xp(e).constructor):t.apply(e,r))}function Um(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(e){}return(Um=function(){return!!e})()}var $m="FunctionNode",Hm=Se($m,["math","Node","SymbolNode"],(function(e){var r,n=e.math,i=e.Node,a=e.SymbolNode,o=function(e){return en(e,{truncate:78})};function u(e,r,n){for(var i,a="",o=/\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi,u=0;null!==(i=o.exec(e));)if(a+=e.substring(u,i.index),u=i.index,"$$"===i[0])a+="$",u++;else{u+=i[0].length;var s=r[i[1]];if(!s)throw new ReferenceError("Template: Property "+i[1]+" does not exist.");if(void 0===i[2])switch(t(s)){case"string":a+=s;break;case"object":if(z(s))a+=s.toTex(n);else{if(!Array.isArray(s))throw new TypeError("Template: "+i[1]+" has to be a Node, String or array of Nodes");a+=s.map((function(e,t){if(z(e))return e.toTex(n);throw new TypeError("Template: "+i[1]+"["+t+"] is not a Node.")})).join(",")}break;default:throw new TypeError("Template: "+i[1]+" has to be a Node, String or array of Nodes")}else{if(!z(s[i[2]]&&s[i[2]]))throw new TypeError("Template: "+i[1]+"["+i[2]+"] is not a Node.");a+=s[i[2]].toTex(n)}}return a+e.slice(u)}var s=function(e){function r(e,t){var n;if(_e(this,r),n=Lm(this,r),"string"==typeof e&&(e=new a(e)),!z(e))throw new TypeError('Node expected as parameter "fn"');if(!Array.isArray(t)||!t.every(z))throw new TypeError('Array containing Nodes expected for parameter "args"');return n.fn=e,n.args=t||[],n}return wp(r,e),Ie(r,[{key:"name",get:function(){return this.fn.name||""}},{key:"type",get:function(){return $m}},{key:"isFunctionNode",get:function(){return!0}},{key:"_compile",value:function(e,t){var n=this.args.map((function(r){return r._compile(e,t)}));if(!U(this.fn)){if(S(this.fn)&&I(this.fn.index)&&this.fn.index.isObjectProperty()){var i=this.fn.object._compile(e,t),a=this.fn.index.getObjectProperty(),u=this.args;return function(t,r,o){var s=i(t,r,o),c=function(e,t){if(!je(e,t))throw new Error('No access to method "'+t+'"');return e[t]}(s,a);if(null!=c&&c.rawArgs)return c(u,e,bm(t,r));var f=n.map((function(e){return e(t,r,o)}));return c.apply(s,f)}}var s=this.fn.toString(),c=this.fn._compile(e,t),f=this.args;return function(t,r,i){var a=c(t,r,i);if("function"!=typeof a)throw new TypeError("Expression '".concat(s,"' did not evaluate to a function; value is:")+"\n  ".concat(o(a)));if(a.rawArgs)return a(f,e,bm(t,r));var u=n.map((function(e){return e(t,r,i)}));return a.apply(a,u)}}var l=this.fn.name;if(t[l]){var p=this.args;return function(t,r,i){var a=ze(r,l);if("function"!=typeof a)throw new TypeError("Argument '".concat(l,"' was not a function; received: ").concat(o(a)));if(a.rawArgs)return a(p,e,bm(t,r));var u=n.map((function(e){return e(t,r,i)}));return a.apply(a,u)}}var m=l in e?ze(e,l):void 0,h="function"==typeof m&&!0===m.rawArgs,d=function(t){var n;if(t.has(l))n=t.get(l);else{if(!(l in e))return r.onUndefinedFunction(l);n=ze(e,l)}if("function"==typeof n)return n;throw new TypeError("'".concat(l,"' is not a function; its value is:\n  ").concat(o(n)))};if(h){var v=this.args;return function(t,r,n){return d(t)(v,e,bm(t,r))}}switch(n.length){case 0:return function(e,t,r){return d(e)()};case 1:return function(e,t,r){return d(e)((0,n[0])(e,t,r))};case 2:return function(e,t,r){var i=d(e),a=n[0],o=n[1];return i(a(e,t,r),o(e,t,r))};default:return function(e,t,r){var i=d(e),a=n.map((function(n){return n(e,t,r)}));return i.apply(void 0,Te(a))}}}},{key:"forEach",value:function(e){e(this.fn,"fn",this);for(var t=0;t<this.args.length;t++)e(this.args[t],"args["+t+"]",this)}},{key:"map",value:function(e){for(var t=this._ifNode(e(this.fn,"fn",this)),n=[],i=0;i<this.args.length;i++)n[i]=this._ifNode(e(this.args[i],"args["+i+"]",this));return new r(t,n)}},{key:"clone",value:function(){return new r(this.fn,this.args.slice(0))}},{key:"toString",value:function(e){var n,i=this.fn.toString(e);return e&&"object"===t(e.handler)&&Ae(e.handler,i)&&(n=e.handler[i](this,e)),void 0!==n?n:Pm(xp(r.prototype),"toString",this).call(this,e)}},{key:"_toString",value:function(e){var t=this.args.map((function(t){return t.toString(e)}));return(B(this.fn)?"("+this.fn.toString(e)+")":this.fn.toString(e))+"("+t.join(", ")+")"}},{key:"toJSON",value:function(){return{mathjs:$m,fn:this.fn,args:this.args}}},{key:"_toHTML",value:function(e){var t=this.args.map((function(t){return t.toHTML(e)}));return'<span class="math-function">'+nn(this.fn)+'</span><span class="math-paranthesis math-round-parenthesis">(</span>'+t.join('<span class="math-separator">,</span>')+'<span class="math-paranthesis math-round-parenthesis">)</span>'}},{key:"toTex",value:function(e){var n;return e&&"object"===t(e.handler)&&Ae(e.handler,this.name)&&(n=e.handler[this.name](this,e)),void 0!==n?n:Pm(xp(r.prototype),"toTex",this).call(this,e)}},{key:"_toTex",value:function(e){var r,i,a=this.args.map((function(t){return t.toTex(e)}));switch(Kp[this.name]&&(r=Kp[this.name]),!n[this.name]||"function"!=typeof n[this.name].toTex&&"object"!==t(n[this.name].toTex)&&"string"!=typeof n[this.name].toTex||(r=n[this.name].toTex),t(r)){case"function":i=r(this,e);break;case"string":i=u(r,this,e);break;case"object":switch(t(r[a.length])){case"function":i=r[a.length](this,e);break;case"string":i=u(r[a.length],this,e)}}return void 0!==i?i:u("\\mathrm{${name}}\\left(${args}\\right)",this,e)}},{key:"getIdentifier",value:function(){return this.type+":"+this.name}}])}(i);return r=s,Va(s,"name",$m),Va(s,"onUndefinedFunction",(function(e){throw new Error("Undefined function "+e)})),Va(s,"fromJSON",(function(e){return new r(e.fn,e.args)})),s}),{isClass:!0,isNode:!0}),Gm="parse",Vm=Se(Gm,["typed","numeric","config","AccessorNode","ArrayNode","AssignmentNode","BlockNode","ConditionalNode","ConstantNode","FunctionAssignmentNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","RangeNode","RelationalNode","SymbolNode"],(function(e){var t=e.typed,r=e.numeric,n=e.config,i=e.AccessorNode,a=e.ArrayNode,o=e.AssignmentNode,u=e.BlockNode,s=e.ConditionalNode,c=e.ConstantNode,f=e.FunctionAssignmentNode,l=e.FunctionNode,p=e.IndexNode,m=e.ObjectNode,h=e.OperatorNode,d=e.ParenthesisNode,v=e.RangeNode,y=e.RelationalNode,g=e.SymbolNode,x=t(Gm,{string:function(e){return L(e,{})},"Array | Matrix":function(e){return b(e,{})},"string, Object":function(e,t){return L(e,void 0!==t.nodes?t.nodes:{})},"Array | Matrix, Object":b});function b(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=void 0!==t.nodes?t.nodes:{};return Wn(e,(function(e){if("string"!=typeof e)throw new TypeError("String expected");return L(e,r)}))}var w={NULL:0,DELIMITER:1,NUMBER:2,SYMBOL:3,UNKNOWN:4},D={",":!0,"(":!0,")":!0,"[":!0,"]":!0,"{":!0,"}":!0,'"':!0,"'":!0,";":!0,"+":!0,"-":!0,"*":!0,".*":!0,"/":!0,"./":!0,"%":!0,"^":!0,".^":!0,"~":!0,"!":!0,"&":!0,"|":!0,"^|":!0,"=":!0,":":!0,"?":!0,"==":!0,"!=":!0,"<":!0,">":!0,"<=":!0,">=":!0,"<<":!0,">>":!0,">>>":!0},N={mod:!0,to:!0,in:!0,and:!0,xor:!0,or:!0,not:!0},E={true:!0,false:!1,null:null,undefined:void 0},A=["NaN","Infinity"],C={'"':'"',"'":"'","\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"};function M(e,t){return e.expression.substr(e.index,t)}function F(e){return M(e,1)}function O(e){e.index++}function B(e){return e.expression.charAt(e.index-1)}function I(e){return e.expression.charAt(e.index+1)}function z(e){for(e.tokenType=w.NULL,e.token="",e.comment="";;){if("#"===F(e))for(;"\n"!==F(e)&&""!==F(e);)e.comment+=F(e),O(e);if(!x.isWhitespace(F(e),e.nestingLevel))break;O(e)}if(""!==F(e)){if("\n"===F(e)&&!e.nestingLevel)return e.tokenType=w.DELIMITER,e.token=F(e),void O(e);var t=F(e),r=M(e,2),n=M(e,3);if(3===n.length&&D[n])return e.tokenType=w.DELIMITER,e.token=n,O(e),O(e),void O(e);if(2===r.length&&D[r])return e.tokenType=w.DELIMITER,e.token=r,O(e),void O(e);if(D[t])return e.tokenType=w.DELIMITER,e.token=t,void O(e);if(x.isDigitDot(t)){e.tokenType=w.NUMBER;var i=M(e,2);if("0b"===i||"0o"===i||"0x"===i){for(e.token+=F(e),O(e),e.token+=F(e),O(e);x.isHexDigit(F(e));)e.token+=F(e),O(e);if("."===F(e))for(e.token+=".",O(e);x.isHexDigit(F(e));)e.token+=F(e),O(e);else if("i"===F(e))for(e.token+="i",O(e);x.isDigit(F(e));)e.token+=F(e),O(e);return}if("."===F(e)){if(e.token+=F(e),O(e),!x.isDigit(F(e)))return void(e.tokenType=w.DELIMITER)}else{for(;x.isDigit(F(e));)e.token+=F(e),O(e);x.isDecimalMark(F(e),I(e))&&(e.token+=F(e),O(e))}for(;x.isDigit(F(e));)e.token+=F(e),O(e);if("E"===F(e)||"e"===F(e))if(x.isDigit(I(e))||"-"===I(e)||"+"===I(e)){if(e.token+=F(e),O(e),"+"!==F(e)&&"-"!==F(e)||(e.token+=F(e),O(e)),!x.isDigit(F(e)))throw ce(e,'Digit expected, got "'+F(e)+'"');for(;x.isDigit(F(e));)e.token+=F(e),O(e);if(x.isDecimalMark(F(e),I(e)))throw ce(e,'Digit expected, got "'+F(e)+'"')}else if("."===I(e))throw O(e),ce(e,'Digit expected, got "'+F(e)+'"')}else{if(!x.isAlpha(F(e),B(e),I(e))){for(e.tokenType=w.UNKNOWN;""!==F(e);)e.token+=F(e),O(e);throw ce(e,'Syntax error in part "'+e.token+'"')}for(;x.isAlpha(F(e),B(e),I(e))||x.isDigit(F(e));)e.token+=F(e),O(e);Ae(N,e.token)?e.tokenType=w.DELIMITER:e.tokenType=w.SYMBOL}}else e.tokenType=w.DELIMITER}function R(e){do{z(e)}while("\n"===e.token)}function j(e){e.nestingLevel++}function P(e){e.nestingLevel--}function L(e,t){var r={extraNodes:{},expression:"",comment:"",index:0,token:"",tokenType:w.NULL,nestingLevel:0,conditionalLevel:null};Yr(r,{expression:e,extraNodes:t}),z(r);var n=function(e){var t,r,n=[];for(""!==e.token&&"\n"!==e.token&&";"!==e.token&&(t=$(e),e.comment&&(t.comment=e.comment));"\n"===e.token||";"===e.token;)0===n.length&&t&&(r=";"!==e.token,n.push({node:t,visible:r})),z(e),"\n"!==e.token&&";"!==e.token&&""!==e.token&&(t=$(e),e.comment&&(t.comment=e.comment),r=";"!==e.token,n.push({node:t,visible:r}));return n.length>0?new u(n):(t||(t=new c(void 0),e.comment&&(t.comment=e.comment)),t)}(r);if(""!==r.token)throw r.tokenType===w.DELIMITER?fe(r,"Unexpected operator "+r.token):ce(r,'Unexpected part "'+r.token+'"');return n}function $(e){var t,r,n,i,a=function(e){for(var t=function(e){for(var t=H(e);"or"===e.token;)R(e),t=new h("or","or",[t,H(e)]);return t}(e);"?"===e.token;){var r=e.conditionalLevel;e.conditionalLevel=e.nestingLevel,R(e);var n=t,i=$(e);if(":"!==e.token)throw ce(e,"False part of conditional expression expected");e.conditionalLevel=null,R(e);var a=$(e);t=new s(n,i,a),e.conditionalLevel=r}return t}(e);if("="===e.token){if(U(a))return t=a.name,R(e),n=$(e),new o(new g(t),n);if(S(a))return R(e),n=$(e),new o(a.object,a.index,n);if(k(a)&&U(a.fn)&&(i=!0,r=[],t=a.name,a.args.forEach((function(e,t){U(e)?r[t]=e.name:i=!1})),i))return R(e),n=$(e),new f(t,r,n);throw ce(e,"Invalid left hand side of assignment operator =")}return a}function H(e){for(var t=G(e);"xor"===e.token;)R(e),t=new h("xor","xor",[t,G(e)]);return t}function G(e){for(var t=V(e);"and"===e.token;)R(e),t=new h("and","and",[t,V(e)]);return t}function V(e){for(var t=Z(e);"|"===e.token;)R(e),t=new h("|","bitOr",[t,Z(e)]);return t}function Z(e){for(var t=W(e);"^|"===e.token;)R(e),t=new h("^|","bitXor",[t,W(e)]);return t}function W(e){for(var t=Y(e);"&"===e.token;)R(e),t=new h("&","bitAnd",[t,Y(e)]);return t}function Y(e){for(var t=[J(e)],r=[],n={"==":"equal","!=":"unequal","<":"smaller",">":"larger","<=":"smallerEq",">=":"largerEq"};Ae(n,e.token);){var i={name:e.token,fn:n[e.token]};r.push(i),R(e),t.push(J(e))}return 1===t.length?t[0]:2===t.length?new h(r[0].name,r[0].fn,t):new y(r.map((function(e){return e.fn})),t)}function J(e){var t,r,n,i;t=X(e);for(var a={"<<":"leftShift",">>":"rightArithShift",">>>":"rightLogShift"};Ae(a,e.token);)n=a[r=e.token],R(e),i=[t,X(e)],t=new h(r,n,i);return t}function X(e){var t,r,n,i;t=Q(e);for(var a={to:"to",in:"to"};Ae(a,e.token);)n=a[r=e.token],R(e),"in"===r&&""===e.token?t=new h("*","multiply",[t,new g("in")],!0):(i=[t,Q(e)],t=new h(r,n,i));return t}function Q(e){var t,r=[];if(t=":"===e.token?new c(1):K(e),":"===e.token&&e.conditionalLevel!==e.nestingLevel){for(r.push(t);":"===e.token&&r.length<3;)R(e),")"===e.token||"]"===e.token||","===e.token||""===e.token?r.push(new g("end")):r.push(K(e));t=3===r.length?new v(r[0],r[2],r[1]):new v(r[0],r[1])}return t}function K(e){var t,r,n,i;t=ee(e);for(var a={"+":"add","-":"subtract"};Ae(a,e.token);){n=a[r=e.token],R(e);var o=ee(e);i=o.isPercentage?[t,new h("*","multiply",[t,o])]:[t,o],t=new h(r,n,i)}return t}function ee(e){var t,r,n,i;r=t=te(e);for(var a={"*":"multiply",".*":"dotMultiply","/":"divide","./":"dotDivide"};Ae(a,e.token);)i=a[n=e.token],R(e),r=te(e),t=new h(n,i,[t,r]);return t}function te(e){var t,r;for(r=t=re(e);e.tokenType===w.SYMBOL||"in"===e.token&&T(t)||!(e.tokenType!==w.NUMBER||T(r)||q(r)&&"!"!==r.op)||"("===e.token;)r=re(e),t=new h("*","multiply",[t,r],!0);return t}function re(e){for(var t=ne(e),r=t,n=[];"/"===e.token&&_(r);){if(n.push(Yr({},e)),R(e),e.tokenType!==w.NUMBER){Yr(e,n.pop());break}if(n.push(Yr({},e)),R(e),e.tokenType!==w.SYMBOL&&"("!==e.token){n.pop(),Yr(e,n.pop());break}Yr(e,n.pop()),n.pop(),r=ne(e),t=new h("/","divide",[t,r])}return t}function ne(e){var t,r,n,i;t=ie(e);for(var a={"%":"mod",mod:"mod"};Ae(a,e.token);)n=a[r=e.token],R(e),"%"===r&&e.tokenType===w.DELIMITER&&"("!==e.token?t=new h("/","divide",[t,new c(100)],!1,!0):(i=[t,ie(e)],t=new h(r,n,i));return t}function ie(e){var t,i,o,u={"-":"unaryMinus","+":"unaryPlus","~":"bitNot",not:"not"};return Ae(u,e.token)?(o=u[e.token],t=e.token,R(e),i=[ie(e)],new h(t,o,i)):function(e){var t,i,o,u;return t=function(e){var t,i,o;t=function(e){var t=[];if(e.tokenType===w.SYMBOL&&Ae(e.extraNodes,e.token)){var i=e.extraNodes[e.token];if(z(e),"("===e.token){if(t=[],j(e),z(e),")"!==e.token)for(t.push($(e));","===e.token;)z(e),t.push($(e));if(")"!==e.token)throw ce(e,"Parenthesis ) expected");P(e),z(e)}return new i(t)}return function(e){var t;return e.tokenType===w.SYMBOL||e.tokenType===w.DELIMITER&&e.token in N?(t=e.token,z(e),ae(e,Ae(E,t)?new c(E[t]):-1!==A.indexOf(t)?new c(r(t,"number")):new g(t))):function(e){var t;return'"'===e.token||"'"===e.token?(t=oe(e,e.token),ae(e,new c(t))):function(e){var t,i,o,u;if("["===e.token){if(j(e),z(e),"]"!==e.token){var s=ue(e);if(";"===e.token){for(o=1,i=[s];";"===e.token;)z(e),"]"!==e.token&&(i[o]=ue(e),o++);if("]"!==e.token)throw ce(e,"End of matrix ] expected");P(e),z(e),u=i[0].items.length;for(var f=1;f<o;f++)if(i[f].items.length!==u)throw fe(e,"Column dimensions mismatch ("+i[f].items.length+" !== "+u+")");t=new a(i)}else{if("]"!==e.token)throw ce(e,"End of matrix ] expected");P(e),z(e),t=s}}else P(e),z(e),t=new a([]);return ae(e,t)}return function(e){if("{"===e.token){var t;j(e);var i={};do{if(z(e),"}"!==e.token){if('"'===e.token||"'"===e.token)t=oe(e,e.token);else{if(!(e.tokenType===w.SYMBOL||e.tokenType===w.DELIMITER&&e.token in N))throw ce(e,"Symbol or string expected as object key");t=e.token,z(e)}if(":"!==e.token)throw ce(e,"Colon : expected after object key");z(e),i[t]=$(e)}}while(","===e.token);if("}"!==e.token)throw ce(e,"Comma , or bracket } expected after object value");P(e),z(e);var a=new m(i);return ae(e,a)}return function(e){var t;return e.tokenType===w.NUMBER?(t=e.token,z(e),new c(r(t,n.number))):function(e){var t;if("("===e.token){if(j(e),z(e),t=$(e),")"!==e.token)throw ce(e,"Parenthesis ) expected");return P(e),z(e),ae(e,t=new d(t))}return function(e){throw""===e.token?ce(e,"Unexpected end of expression"):ce(e,"Value expected")}(e)}(e)}(e)}(e)}(e)}(e)}(e)}(e);for(var u={"!":"factorial","'":"ctranspose"};Ae(u,e.token);)o=u[i=e.token],z(e),t=ae(e,t=new h(i,o,[t]));return t}(e),("^"===e.token||".^"===e.token)&&(o="^"===(i=e.token)?"pow":"dotPow",R(e),u=[t,ie(e)],t=new h(i,o,u)),t}(e)}function ae(e,t,r){for(var n;!("("!==e.token&&"["!==e.token&&"."!==e.token||r&&-1===r.indexOf(e.token));)if(n=[],"("===e.token){if(!U(t)&&!S(t))return t;if(j(e),z(e),")"!==e.token)for(n.push($(e));","===e.token;)z(e),n.push($(e));if(")"!==e.token)throw ce(e,"Parenthesis ) expected");P(e),z(e),t=new l(t,n)}else if("["===e.token){if(j(e),z(e),"]"!==e.token)for(n.push($(e));","===e.token;)z(e),n.push($(e));if("]"!==e.token)throw ce(e,"Parenthesis ] expected");P(e),z(e),t=new i(t,new p(n))}else{if(z(e),!(e.tokenType===w.SYMBOL||e.tokenType===w.DELIMITER&&e.token in N))throw ce(e,"Property name expected after dot");n.push(new c(e.token)),z(e),t=new i(t,new p(n,!0))}return t}function oe(e,t){for(var r="";""!==F(e)&&F(e)!==t;)if("\\"===F(e)){O(e);var n=F(e),i=C[n];if(void 0!==i)r+=i,e.index+=1;else{if("u"!==n)throw ce(e,"Bad escape character \\".concat(n));var a=e.expression.slice(e.index+1,e.index+5);if(!/^[0-9A-Fa-f]{4}$/.test(a))throw ce(e,"Invalid unicode character \\u".concat(a));r+=String.fromCharCode(parseInt(a,16)),e.index+=5}}else r+=F(e),O(e);if(z(e),e.token!==t)throw ce(e,"End of string ".concat(t," expected"));return z(e),r}function ue(e){for(var t=[$(e)],r=1;","===e.token;)z(e),"]"!==e.token&&";"!==e.token&&(t[r]=$(e),r++);return new a(t)}function se(e){return e.index-e.token.length+1}function ce(e,t){var r=se(e),n=new SyntaxError(t+" (char "+r+")");return n.char=r,n}function fe(e,t){var r=se(e),n=new SyntaxError(t+" (char "+r+")");return n.char=r,n}return x.isAlpha=function(e,t,r){return x.isValidLatinOrGreek(e)||x.isValidMathSymbol(e,r)||x.isValidMathSymbol(t,e)},x.isValidLatinOrGreek=function(e){return/^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(e)},x.isValidMathSymbol=function(e,t){return/^[\uD835]$/.test(e)&&/^[\uDC00-\uDFFF]$/.test(t)&&/^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(t)},x.isWhitespace=function(e,t){return" "===e||"\t"===e||"\n"===e&&t>0},x.isDecimalMark=function(e,t){return"."===e&&"/"!==t&&"*"!==t&&"^"!==t},x.isDigitDot=function(e){return e>="0"&&e<="9"||"."===e},x.isDigit=function(e){return e>="0"&&e<="9"},x.isHexDigit=function(e){return e>="0"&&e<="9"||e>="a"&&e<="f"||e>="A"&&e<="F"},t.addConversion({from:"string",to:"Node",convert:x}),x})),Zm="compile",Wm=Se(Zm,["typed","parse"],(function(e){var t=e.typed,r=e.parse;return t(Zm,{string:function(e){return r(e).compile()},"Array | Matrix":function(e){return Wn(e,(function(e){return r(e).compile()}))}})})),Ym="evaluate",Jm=Se(Ym,["typed","parse"],(function(e){var t=e.typed,r=e.parse;return t(Ym,{string:function(e){var t=We();return r(e).compile().evaluate(t)},"string, Map | Object":function(e,t){return r(e).compile().evaluate(t)},"Array | Matrix":function(e){var t=We();return Wn(e,(function(e){return r(e).compile().evaluate(t)}))},"Array | Matrix, Map | Object":function(e,t){return Wn(e,(function(e){return r(e).compile().evaluate(t)}))}})})),Xm=Se("Parser",["evaluate"],(function(e){var t=e.evaluate;function r(){if(!(this instanceof r))throw new SyntaxError("Constructor must be called with the new operator");Object.defineProperty(this,"scope",{value:We(),writable:!1})}return r.prototype.type="Parser",r.prototype.isParser=!0,r.prototype.evaluate=function(e){return t(e,this.scope)},r.prototype.get=function(e){if(this.scope.has(e))return this.scope.get(e)},r.prototype.getAll=function(){return function(e){if(e instanceof Ge)return e.wrappedObject;var t,r={},n=$e(e.keys());try{for(n.s();!(t=n.n()).done;){var i=t.value;Re(r,i,e.get(i))}}catch(e){n.e(e)}finally{n.f()}return r}(this.scope)},r.prototype.getAllAsMap=function(){return this.scope},r.prototype.set=function(e,t){return this.scope.set(e,t),t},r.prototype.remove=function(e){this.scope.delete(e)},r.prototype.clear=function(){this.scope.clear()},r}),{isClass:!0}),Qm="parser",Km=Se(Qm,["typed","Parser"],(function(e){var t=e.typed,r=e.Parser;return t(Qm,{"":function(){return new r}})})),eh=Se("lup",["typed","matrix","abs","addScalar","divideScalar","multiplyScalar","subtractScalar","larger","equalScalar","unaryMinus","DenseMatrix","SparseMatrix","Spa"],(function(e){var t=e.typed,r=e.matrix,n=e.abs,i=e.addScalar,a=e.divideScalar,o=e.multiplyScalar,u=e.subtractScalar,s=e.larger,c=e.equalScalar,f=e.unaryMinus,l=e.DenseMatrix,p=e.SparseMatrix,m=e.Spa;return t("lup",{DenseMatrix:function(e){return h(e)},SparseMatrix:function(e){return function(e){var t,r,i,u=e._size[0],l=e._size[1],h=Math.min(u,l),d=e._values,v=e._index,y=e._ptr,g=[],x=[],b=[],w=[u,h],D=[],N=[],E=[],A=[h,l],S=[],C=[];for(t=0;t<u;t++)S[t]=t,C[t]=t;var M=function(){var e=new m;r<u&&(b.push(g.length),g.push(1),x.push(r)),E.push(D.length);var l=y[r],h=y[r+1];for(i=l;i<h;i++)t=v[i],e.set(S[t],d[i]);r>0&&e.forEach(0,r-1,(function(t,r){p._forEachRow(t,g,x,b,(function(n,i){n>t&&e.accumulate(n,f(o(i,r)))}))}));var M,F,O,T,_=r,B=e.get(r),k=n(B);e.forEach(r+1,u-1,(function(e,t){var r=n(t);s(r,k)&&(_=e,k=r,B=t)})),r!==_&&(p._swapRows(r,_,w[1],g,x,b),p._swapRows(r,_,A[1],D,N,E),e.swap(r,_),F=_,O=C[M=r],T=C[F],S[O]=F,S[T]=M,C[M]=T,C[F]=O),e.forEach(0,u-1,(function(e,t){e<=r?(D.push(t),N.push(e)):(t=a(t,B),c(t,0)||(g.push(t),x.push(e)))}))};for(r=0;r<l;r++)M();return E.push(D.length),b.push(g.length),{L:new p({values:g,index:x,ptr:b,size:w}),U:new p({values:D,index:N,ptr:E,size:A}),p:S,toString:function(){return"L: "+this.L.toString()+"\nU: "+this.U.toString()+"\nP: "+this.p}}}(e)},Array:function(e){var t=h(r(e));return{L:t.L.valueOf(),U:t.U.valueOf(),p:t.p}}});function h(e){var t,r,f,p=e._size[0],m=e._size[1],h=Math.min(p,m),d=ye(e._data),v=[],y=[p,h],g=[],x=[h,m],b=[];for(t=0;t<p;t++)b[t]=t;for(r=0;r<m;r++){if(r>0)for(t=0;t<p;t++){var w=Math.min(t,r),D=0;for(f=0;f<w;f++)D=i(D,o(d[t][f],d[f][r]));d[t][r]=u(d[t][r],D)}var N=r,E=0,A=0;for(t=r;t<p;t++){var S=d[t][r],C=n(S);s(C,E)&&(N=t,E=C,A=S)}if(r!==N&&(b[r]=[b[N],b[N]=b[r]][0],l._swapRows(r,N,d)),r<p)for(t=r+1;t<p;t++){var M=d[t][r];c(M,0)||(d[t][r]=a(d[t][r],A))}}for(r=0;r<m;r++)for(t=0;t<p;t++)0===r&&(t<m&&(g[t]=[]),v[t]=[]),t<r?(t<m&&(g[t][r]=d[t][r]),r<p&&(v[t][r]=0)):t!==r?(t<m&&(g[t][r]=0),r<p&&(v[t][r]=d[t][r])):(t<m&&(g[t][r]=d[t][r]),r<p&&(v[t][r]=1));var F=new l({data:v,size:y}),O=new l({data:g,size:x}),T=[];for(t=0,h=b.length;t<h;t++)T[b[t]]=t;return{L:F,U:O,p:T,toString:function(){return"L: "+this.L.toString()+"\nU: "+this.U.toString()+"\nP: "+this.p}}}})),th=Se("qr",["typed","matrix","zeros","identity","isZero","equal","sign","sqrt","conj","unaryMinus","addScalar","divideScalar","multiplyScalar","subtractScalar","complex"],(function(e){var t=e.typed,r=e.matrix,n=e.zeros,i=e.identity,a=e.isZero,o=e.equal,u=e.sign,s=e.sqrt,c=e.conj,f=e.unaryMinus,l=e.addScalar,p=e.divideScalar,m=e.multiplyScalar,h=e.subtractScalar,d=e.complex;return Yr(t("qr",{DenseMatrix:function(e){return y(e)},SparseMatrix:function(e){return function(e){throw new Error("qr not implemented for sparse matrices yet")}()},Array:function(e){var t=y(r(e));return{Q:t.Q.valueOf(),R:t.R.valueOf()}}}),{_denseQRimpl:v});function v(e){var t,r,d,v=e._size[0],y=e._size[1],g=i([v],"dense"),x=g._data,b=e.clone(),w=b._data,D=n([v],"");for(d=0;d<Math.min(y,v);++d){var N=w[d][d],E=f(o(N,0)?1:u(N)),A=c(E),S=0;for(t=d;t<v;t++)S=l(S,m(w[t][d],c(w[t][d])));var C=m(E,s(S));if(!a(C)){var M=h(N,C);for(D[d]=1,t=d+1;t<v;t++)D[t]=p(w[t][d],M);var F=f(c(p(M,C))),O=void 0;for(r=d;r<y;r++){for(O=0,t=d;t<v;t++)O=l(O,m(c(D[t]),w[t][r]));for(O=m(O,F),t=d;t<v;t++)w[t][r]=m(h(w[t][r],m(D[t],O)),A)}for(t=0;t<v;t++){for(O=0,r=d;r<v;r++)O=l(O,m(x[t][r],D[r]));for(O=m(O,F),r=d;r<v;++r)x[t][r]=p(h(x[t][r],m(O,c(D[r]))),A)}}}return{Q:g,R:b,toString:function(){return"Q: "+this.Q.toString()+"\nR: "+this.R.toString()}}}function y(e){var t=v(e),r=t.R._data;if(e._data.length>0)for(var n="Complex"===r[0][0].type?d(0):0,i=0;i<r.length;++i)for(var a=0;a<i&&a<(r[0]||[]).length;++a)r[i][a]=n;return t}}));function rh(e,t,r,n,i,a,o){var u=0;for(r[o]=e;u>=0;){var s=r[o+u],c=r[n+s];-1===c?(u--,a[t++]=s):(r[n+s]=r[i+c],r[o+ ++u]=c)}return t}function nh(e){return-e-2}var ih=Se("csAmd",["add","multiply","transpose"],(function(e){var t=e.add,r=e.multiply,n=e.transpose;return function(e,o){if(!o||e<=0||e>3)return null;var u=o._size,s=u[0],c=u[1],f=0,l=Math.max(16,10*Math.sqrt(c)),p=function(e,i,a,o,u){var s=n(i);if(1===e&&o===a)return t(i,s);if(2===e){for(var c=s._index,f=s._ptr,l=0,p=0;p<a;p++){var m=f[p];if(f[p]=l,!(f[p+1]-m>u))for(var h=f[p+1];m<h;m++)c[l++]=c[m]}return f[a]=l,i=n(s),r(s,i)}return r(s,i)}(e,o,s,c,l=Math.min(c-2,l));!function(e,t,r){for(var n=e._values,i=e._index,a=e._ptr,o=e._size[1],u=0,s=0;s<o;s++){var c=a[s];for(a[s]=u;c<a[s+1];c++)t(i[c],s,n?n[c]:1,null)&&(i[u]=i[c],n&&(n[u]=n[c]),u++)}a[o]=u,i.splice(u,i.length-u),n&&n.splice(u,n.length-u)}(p,a);for(var m,h,d,v,y,g,x,b,w,D,N,E,A,S,C,M,F=p._index,O=p._ptr,T=O[c],_=[],B=[],k=c+1,I=2*(c+1),z=3*(c+1),R=4*(c+1),q=5*(c+1),j=6*(c+1),P=7*(c+1),L=_,U=function(e,t,r,n,a,o,u,s,c,f,l,p){for(var m=0;m<e;m++)r[0+m]=t[m+1]-t[m];r[0+e]=0;for(var h=0;h<=e;h++)r[a+h]=-1,o[h]=-1,r[u+h]=-1,r[s+h]=-1,r[c+h]=1,r[f+h]=1,r[l+h]=0,r[p+h]=r[0+h];var d=i(0,0,r,f,e);return r[l+e]=-2,t[e]=-1,r[f+e]=0,d}(c,O,B,0,z,L,I,P,k,j,R,q),$=function(e,t,r,n,i,a,o,u,s,c,f){for(var l=0,p=0;p<e;p++){var m=r[n+p];if(0===m)r[i+p]=-2,l++,t[p]=-1,r[a+p]=0;else if(m>o)r[u+p]=0,r[i+p]=-1,l++,t[p]=nh(e),r[u+e]++;else{var h=r[s+m];-1!==h&&(c[h]=p),r[f+p]=r[s+m],r[s+m]=p}}return l}(c,O,B,q,R,j,l,k,z,L,I),H=0;$<c;){for(d=-1;H<c&&-1===(d=B[z+H]);H++);-1!==B[I+d]&&(L[B[I+d]]=-1),B[z+H]=B[I+d];var G=B[R+d],V=B[k+d];$+=V;var Z=0;B[k+d]=-V;var W=O[d],Y=0===G?W:T,J=Y;for(v=1;v<=G+1;v++){for(v>G?(g=d,x=W,b=B[0+d]-G):(x=O[g=F[W++]],b=B[0+g]),y=1;y<=b;y++)(w=B[k+(m=F[x++])])<=0||(Z+=w,B[k+m]=-w,F[J++]=m,-1!==B[I+m]&&(L[B[I+m]]=L[m]),-1!==L[m]?B[I+L[m]]=B[I+m]:B[z+B[q+m]]=B[I+m]);g!==d&&(O[g]=nh(d),B[j+g]=0)}for(0!==G&&(T=J),B[q+d]=Z,O[d]=Y,B[0+d]=J-Y,B[R+d]=-2,U=i(U,f,B,j,c),D=Y;D<J;D++)if(!((N=B[R+(m=F[D])])<=0)){var X=U-(w=-B[k+m]);for(W=O[m],E=O[m]+N-1;W<=E;W++)B[j+(g=F[W])]>=U?B[j+g]-=w:0!==B[j+g]&&(B[j+g]=B[q+g]+X)}for(D=Y;D<J;D++){for(A=(E=O[m=F[D]])+B[R+m]-1,S=E,C=0,M=0,W=E;W<=A;W++)if(0!==B[j+(g=F[W])]){var Q=B[j+g]-U;Q>0?(M+=Q,F[S++]=g,C+=g):(O[g]=nh(d),B[j+g]=0)}B[R+m]=S-E+1;var K=S,ee=E+B[0+m];for(W=A+1;W<ee;W++){var te=B[k+(h=F[W])];te<=0||(M+=te,F[S++]=h,C+=h)}0===M?(O[m]=nh(d),Z-=w=-B[k+m],V+=w,$+=w,B[k+m]=0,B[R+m]=-1):(B[q+m]=Math.min(B[q+m],M),F[S]=F[K],F[K]=F[E],F[E]=d,B[0+m]=S-E+1,C=(C<0?-C:C)%c,B[I+m]=B[P+C],B[P+C]=m,L[m]=C)}for(B[q+d]=Z,U=i(U+(f=Math.max(f,Z)),f,B,j,c),D=Y;D<J;D++)if(!(B[k+(m=F[D])]>=0))for(m=B[P+(C=L[m])],B[P+C]=-1;-1!==m&&-1!==B[I+m];m=B[I+m],U++){for(b=B[0+m],N=B[R+m],W=O[m]+1;W<=O[m]+b-1;W++)B[j+F[W]]=U;var re=m;for(h=B[I+m];-1!==h;){var ne=B[0+h]===b&&B[R+h]===N;for(W=O[h]+1;ne&&W<=O[h]+b-1;W++)B[j+F[W]]!==U&&(ne=0);ne?(O[h]=nh(m),B[k+m]+=B[k+h],B[k+h]=0,B[R+h]=-1,h=B[I+h],B[I+re]=h):(re=h,h=B[I+h])}}for(W=Y,D=Y;D<J;D++)(w=-B[k+(m=F[D])])<=0||(B[k+m]=w,M=B[q+m]+Z-w,-1!==B[z+(M=Math.min(M,c-$-w))]&&(L[B[z+M]]=m),B[I+m]=B[z+M],L[m]=-1,B[z+M]=m,H=Math.min(H,M),B[q+m]=M,F[W++]=m);B[k+d]=V,0==(B[0+d]=W-Y)&&(O[d]=-1,B[j+d]=0),0!==G&&(T=W)}for(m=0;m<c;m++)O[m]=nh(O[m]);for(h=0;h<=c;h++)B[z+h]=-1;for(h=c;h>=0;h--)B[k+h]>0||(B[I+h]=B[z+O[h]],B[z+O[h]]=h);for(g=c;g>=0;g--)B[k+g]<=0||-1!==O[g]&&(B[I+g]=B[z+O[g]],B[z+O[g]]=g);for(d=0,m=0;m<=c;m++)-1===O[m]&&(d=rh(m,d,B,z,I,_,j));return _.splice(_.length-1,1),_};function i(e,t,r,n,i){if(e<2||e+t<0){for(var a=0;a<i;a++)0!==r[n+a]&&(r[n+a]=1);e=2}return e}function a(e,t){return e!==t}}));function ah(e,t,r,n,i,a,o){var u,s,c,f=0;if(e<=t||r[n+t]<=r[i+e])return-1;r[i+e]=r[n+t];var l=r[a+e];if(r[a+e]=t,-1===l)f=1,c=e;else{for(f=2,c=l;c!==r[o+c];c=r[o+c]);for(u=l;u!==c;u=s)s=r[o+u],r[o+u]=c}return{jleaf:f,q:c}}var oh=Se("csCounts",["transpose"],(function(e){var t=e.transpose;return function(e,r,n,i){if(!e||!r||!n)return null;var a,o,u,s,c,f,l,p=e._size,m=p[0],h=p[1],d=4*h+(i?h+m+1:0),v=[],y=h,g=2*h,x=3*h,b=4*h,w=5*h+1;for(u=0;u<d;u++)v[u]=-1;var D=[],N=t(e),E=N._index,A=N._ptr;for(u=0;u<h;u++)for(D[o=n[u]]=-1===v[x+o]?1:0;-1!==o&&-1===v[x+o];o=r[o])v[x+o]=u;if(i){for(u=0;u<h;u++)v[n[u]]=u;for(a=0;a<m;a++){for(u=h,f=A[a],l=A[a+1],c=f;c<l;c++)u=Math.min(u,v[E[c]]);v[w+a]=v[b+u],v[b+u]=a}}for(a=0;a<h;a++)v[0+a]=a;for(u=0;u<h;u++){for(-1!==r[o=n[u]]&&D[r[o]]--,s=i?v[b+u]:o;-1!==s;s=i?v[w+s]:-1)for(c=A[s];c<A[s+1];c++){var S=ah(a=E[c],o,v,x,y,g,0);S.jleaf>=1&&D[o]++,2===S.jleaf&&D[S.q]--}-1!==r[o]&&(v[0+o]=r[o])}for(o=0;o<h;o++)-1!==r[o]&&(D[r[o]]+=D[o]);return D}})),uh=Se("csSqr",["add","multiply","transpose"],(function(e){var t=e.add,r=e.multiply,n=e.transpose,i=ih({add:t,multiply:r,transpose:n}),a=oh({transpose:n});return function(e,t,r){var n,o=t._ptr,u=t._size[1],s={};if(s.q=i(e,t),e&&!s.q)return null;if(r){var c=e?function(e,t,r,n){for(var i=e._values,a=e._index,o=e._ptr,u=e._size,s=e._datatype,c=u[0],f=u[1],l=null,p=[],m=[],h=0,d=0;d<f;d++){m[d]=h;for(var v=r?r[d]:d,y=o[v],g=o[v+1],x=y;x<g;x++){var b=a[x];p[h]=b,l&&(l[h]=i[x]),h++}}return m[f]=h,e.createSparseMatrix({values:l,index:p,ptr:m,size:[c,f],datatype:s})}(t,0,s.q):t;s.parent=function(e,t){if(!e)return null;var r,n,i=e._index,a=e._ptr,o=e._size,u=o[0],s=o[1],c=[],f=[],l=s;for(r=0;r<u;r++)f[l+r]=-1;for(var p=0;p<s;p++){c[p]=-1,f[0+p]=-1;for(var m=a[p],h=a[p+1],d=m;d<h;d++){var v=i[d];for(r=f[l+v];-1!==r&&r<p;r=n)n=f[0+r],f[0+r]=p,-1===n&&(c[r]=p);f[l+v]=p}}return c}(c);var f=function(e,t){if(!e)return null;var r,n=0,i=[],a=[],o=t,u=2*t;for(r=0;r<t;r++)a[0+r]=-1;for(r=t-1;r>=0;r--)-1!==e[r]&&(a[o+r]=a[0+e[r]],a[0+e[r]]=r);for(r=0;r<t;r++)-1===e[r]&&(n=rh(r,n,a,0,o,i,u));return i}(s.parent,u);if(s.cp=a(c,s.parent,f,1),c&&s.parent&&s.cp&&function(e,t){var r=e._ptr,n=e._index,i=e._size,a=i[0],o=i[1];t.pinv=[],t.leftmost=[];var u,s,c,f,l,p=t.parent,m=t.pinv,h=t.leftmost,d=[],v=a,y=a+o,g=a+2*o;for(s=0;s<o;s++)d[v+s]=-1,d[y+s]=-1,d[g+s]=0;for(u=0;u<a;u++)h[u]=-1;for(s=o-1;s>=0;s--)for(f=r[s],l=r[s+1],c=f;c<l;c++)h[n[c]]=s;for(u=a-1;u>=0;u--)m[u]=-1,-1!==(s=h[u])&&(0==d[g+s]++&&(d[y+s]=u),d[0+u]=d[v+s],d[v+s]=u);for(t.lnz=0,t.m2=a,s=0;s<o;s++)if(u=d[v+s],t.lnz++,u<0&&(u=t.m2++),m[u]=s,!(--g[s]<=0)){t.lnz+=d[g+s];var x=p[s];-1!==x&&(0===d[g+x]&&(d[y+x]=d[y+s]),d[0+d[y+s]]=d[v+x],d[v+x]=d[0+u],d[g+x]+=d[g+s])}for(u=0;u<a;u++)m[u]<0&&(m[u]=s++);return!0}(c,s))for(s.unz=0,n=0;n<u;n++)s.unz+=s.cp[n]}else s.unz=4*o[u]+u,s.lnz=s.unz;return s}}));function sh(e,t){return e[t]<0}function ch(e,t){e[t]=nh(e[t])}function fh(e){return e<0?nh(e):e}function lh(e,t,r,n,i){var a,o,u,s=t._index,c=t._ptr,f=t._size[1],l=0;for(n[0]=e;l>=0;){e=n[l];var p=i?i[e]:e;sh(c,e)||(ch(c,e),n[f+l]=p<0?0:fh(c[p]));var m=1;for(o=n[f+l],u=p<0?0:fh(c[p+1]);o<u;o++)if(!sh(c,a=s[o])){n[f+l]=o,n[++l]=a,m=0;break}m&&(l--,n[--r]=e)}return r}var ph=Se("csSpsolve",["divideScalar","multiply","subtract"],(function(e){var t=e.divideScalar,r=e.multiply,n=e.subtract;return function(e,i,a,o,u,s,c){var f,l,p,m,h=e._values,d=e._index,v=e._ptr,y=e._size[1],g=i._values,x=i._index,b=i._ptr,w=function(e,t,r,n,i){var a,o,u,s=e._ptr,c=e._size,f=t._index,l=t._ptr,p=c[1],m=p;for(o=l[r],u=l[r+1],a=o;a<u;a++){var h=f[a];sh(s,h)||(m=lh(h,e,m,n,i))}for(a=m;a<p;a++)ch(s,n[a]);return m}(e,i,a,o,s);for(f=w;f<y;f++)u[o[f]]=0;for(l=b[a],p=b[a+1],f=l;f<p;f++)u[x[f]]=g[f];for(var D=w;D<y;D++){var N=o[D],E=s?s[N]:N;if(!(E<0))for(l=v[E],p=v[E+1],u[N]=t(u[N],h[c?l:p-1]),f=c?l+1:l,m=c?p:p-1;f<m;f++){var A=d[f];u[A]=n(u[A],r(h[f],u[N]))}}return w}})),mh=Se("csLu",["abs","divideScalar","multiply","subtract","larger","largerEq","SparseMatrix"],(function(e){var t=e.abs,r=e.divideScalar,n=e.multiply,i=e.subtract,a=e.larger,o=e.largerEq,u=e.SparseMatrix,s=ph({divideScalar:r,multiply:n,subtract:i});return function(e,i,c){if(!e)return null;var f,l=e._size[1],p=100,m=100;i&&(f=i.q,p=i.lnz||p,m=i.unz||m);var h,d,v=[],y=[],g=[],x=new u({values:v,index:y,ptr:g,size:[l,l]}),b=[],w=[],D=[],N=new u({values:b,index:w,ptr:D,size:[l,l]}),E=[],A=[],S=[];for(h=0;h<l;h++)A[h]=0,E[h]=-1,g[h+1]=0;p=0,m=0;for(var C=0;C<l;C++){g[C]=p,D[C]=m;var M=f?f[C]:C,F=s(x,e,M,S,A,E,1),O=-1,T=-1;for(d=F;d<l;d++)if(E[h=S[d]]<0){var _=t(A[h]);a(_,T)&&(T=_,O=h)}else w[m]=E[h],b[m++]=A[h];if(-1===O||T<=0)return null;E[M]<0&&o(t(A[M]),n(T,c))&&(O=M);var B=A[O];for(w[m]=C,b[m++]=B,E[O]=C,y[p]=O,v[p++]=1,d=F;d<l;d++)E[h=S[d]]<0&&(y[p]=h,v[p++]=r(A[h],B)),A[h]=0}for(g[l]=p,D[l]=m,d=0;d<p;d++)y[d]=E[y[d]];return v.splice(p,v.length-p),y.splice(p,y.length-p),b.splice(m,b.length-m),w.splice(m,w.length-m),{L:x,U:N,pinv:E}}})),hh=Se("slu",["typed","abs","add","multiply","transpose","divideScalar","subtract","larger","largerEq","SparseMatrix"],(function(e){var t=e.typed,r=e.abs,n=e.add,i=e.multiply,a=e.transpose,o=e.divideScalar,u=e.subtract,s=e.larger,c=e.largerEq,f=e.SparseMatrix,l=uh({add:n,multiply:i,transpose:a}),p=mh({abs:r,divideScalar:o,multiply:i,subtract:u,larger:s,largerEq:c,SparseMatrix:f});return t("slu",{"SparseMatrix, number, number":function(e,t,r){if(!V(t)||t<0||t>3)throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");if(r<0||r>1)throw new Error("Partial pivoting threshold must be a number from 0 to 1");var n=l(t,e,!1),i=p(e,n,r);return{L:i.L,U:i.U,p:i.pinv,q:n.q,toString:function(){return"L: "+this.L.toString()+"\nU: "+this.U.toString()+"\np: "+this.p.toString()+(this.q?"\nq: "+this.q.toString():"")+"\n"}}}})}));function dh(e,t){var r,n=t.length,i=[];if(e)for(r=0;r<n;r++)i[e[r]]=t[r];else for(r=0;r<n;r++)i[r]=t[r];return i}var vh="lusolve",yh=Se(vh,["typed","matrix","lup","slu","usolve","lsolve","DenseMatrix"],(function(e){var t=e.typed,r=e.matrix,n=e.lup,i=e.slu,a=e.usolve,o=e.lsolve,u=dc({DenseMatrix:e.DenseMatrix});return t(vh,{"Array, Array | Matrix":function(e,t){e=r(e);var i=n(e);return c(i.L,i.U,i.p,null,t).valueOf()},"DenseMatrix, Array | Matrix":function(e,t){var r=n(e);return c(r.L,r.U,r.p,null,t)},"SparseMatrix, Array | Matrix":function(e,t){var r=n(e);return c(r.L,r.U,r.p,null,t)},"SparseMatrix, Array | Matrix, number, number":function(e,t,r,n){var a=i(e,r,n);return c(a.L,a.U,a.p,a.q,t)},"Object, Array | Matrix":function(e,t){return c(e.L,e.U,e.p,e.q,t)}});function s(e){if(l(e))return e;if(f(e))return r(e);throw new TypeError("Invalid Matrix LU decomposition")}function c(e,t,r,n,i){e=s(e),t=s(t),r&&((i=u(e,i,!0))._data=dh(r,i._data));var c=o(e,i),f=a(t,c);return n&&(f._data=dh(n,f._data)),f}})),gh="polynomialRoot",xh=Se(gh,["typed","isZero","equalScalar","add","subtract","multiply","divide","sqrt","unaryMinus","cbrt","typeOf","im","re"],(function(e){var t=e.typed,r=e.isZero,n=e.equalScalar,i=e.add,a=e.subtract,o=e.multiply,u=e.divide,s=e.sqrt,c=e.unaryMinus,f=e.cbrt,l=e.typeOf,p=e.im,m=e.re;return t(gh,{"number|Complex, ...number|Complex":function(e,t){for(var h=[e].concat(Te(t));h.length>0&&r(h[h.length-1]);)h.pop();if(h.length<2)throw new RangeError("Polynomial [".concat(e,", ").concat(t,"] must have a non-zero non-constant coefficient"));switch(h.length){case 2:return[c(u(h[0],h[1]))];case 3:var d=Aa(h,3),v=d[0],y=d[1],g=d[2],x=o(2,g),b=o(y,y),w=o(4,g,v);if(n(b,w))return[u(c(y),x)];var D=s(a(b,w));return[u(a(D,y),x),u(a(c(D),y),x)];case 4:var N=Aa(h,4),E=N[0],A=N[1],S=N[2],C=N[3],M=c(o(3,C)),F=o(S,S),O=o(3,C,A),T=i(o(2,S,S,S),o(27,C,C,E)),_=o(9,C,S,A);if(n(F,O)&&n(T,_))return[u(S,M)];var B,k=a(F,O),I=a(T,_),z=i(o(18,C,S,A,E),o(S,S,A,A)),R=i(o(4,S,S,S,E),o(4,C,A,A,A),o(27,C,C,E,E));return n(z,R)?[u(a(o(4,C,S,A),i(o(9,C,C,E),o(S,S,S))),o(C,k)),u(a(o(9,C,E),o(S,A)),o(2,k))]:(B=n(F,O)?I:u(i(I,s(a(o(I,I),o(4,k,k,k)))),2),f(B,!0).toArray().map((function(e){return u(i(S,e,u(k,e)),M)})).map((function(e){return"Complex"===l(e)&&n(m(e),m(e)+p(e))?m(e):e})));default:throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(h))}}})})),bh=Se("Help",["evaluate"],(function(e){var t=e.evaluate;function r(e){if(!(this instanceof r))throw new SyntaxError("Constructor must be called with the new operator");if(!e)throw new Error('Argument "doc" missing');this.doc=e}return r.prototype.type="Help",r.prototype.isHelp=!0,r.prototype.toString=function(){var e=this.doc||{},r="\n";if(e.name&&(r+="Name: "+e.name+"\n\n"),e.category&&(r+="Category: "+e.category+"\n\n"),e.description&&(r+="Description:\n    "+e.description+"\n\n"),e.syntax&&(r+="Syntax:\n    "+e.syntax.join("\n    ")+"\n\n"),e.examples){r+="Examples:\n";for(var n=!1,i=t("config()"),a={config:function(e){return n=!0,t("config(newConfig)",{newConfig:e})}},o=0;o<e.examples.length;o++){var u=e.examples[o];r+="    "+u+"\n";var s=void 0;try{s=t(u,a)}catch(e){s=e}void 0===s||x(s)||(r+="        "+en(s,{precision:14})+"\n")}r+="\n",n&&t("config(originalConfig)",{originalConfig:i})}return e.mayThrow&&e.mayThrow.length&&(r+="Throws: "+e.mayThrow.join(", ")+"\n\n"),e.seealso&&e.seealso.length&&(r+="See also: "+e.seealso.join(", ")+"\n"),r},r.prototype.toJSON=function(){var e=ye(this.doc);return e.mathjs="Help",e},r.fromJSON=function(e){var t={};return Object.keys(e).filter((function(e){return"mathjs"!==e})).forEach((function(r){t[r]=e[r]})),new r(t)},r.prototype.valueOf=r.prototype.toString,r}),{isClass:!0}),wh=Se("Chain",["?on","math","typed"],(function(e){var t=e.on,r=e.math,n=e.typed;function i(e){if(!(this instanceof i))throw new SyntaxError("Constructor must be called with the new operator");$(e)?this.value=e.value:this.value=e}function a(e,t){Ee(i.prototype,e,(function(){var e=t();if("function"==typeof e)return o(e)}))}function o(e){return function(){if(0===arguments.length)return new i(e(this.value));for(var t=[this.value],r=0;r<arguments.length;r++)t[r+1]=arguments[r];if(n.isTypedFunction(e)){var a=n.resolve(e,t);if(1===a.params.length)throw new Error("chain function "+e.name+" cannot match rest parameter between chain value and additional arguments.");return new i(a.implementation.apply(e,t))}return new i(e.apply(e,t))}}i.prototype.type="Chain",i.prototype.isChain=!0,i.prototype.done=function(){return this.value},i.prototype.valueOf=function(){return this.value},i.prototype.toString=function(){return en(this.value)},i.prototype.toJSON=function(){return{mathjs:"Chain",value:this.value}},i.fromJSON=function(e){return new i(e.value)},i.createProxy=function(e,t){if("string"==typeof e)s=e,"function"==typeof(c=t)&&(i.prototype[s]=o(c));else{var r=function(t){Ae(e,t)&&void 0===u[t]&&a(t,(function(){return e[t]}))};for(var n in e)r(n)}var s,c};var u={expression:!0,docs:!0,type:!0,classes:!0,json:!0,error:!0,isChain:!0};return i.createProxy(r),t&&t("import",(function(e,t,r){r||a(e,t)})),i}),{isClass:!0}),Dh={name:"e",category:"Constants",syntax:["e"],description:"Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",examples:["e","e ^ 2","exp(2)","log(e)"],seealso:["exp"]},Nh={name:"pi",category:"Constants",syntax:["pi"],description:"The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",examples:["pi","sin(pi/2)"],seealso:["tau"]},Eh={bignumber:{name:"bignumber",category:"Construction",syntax:["bignumber(x)"],description:"Create a big number from a number or string.",examples:["0.1 + 0.2","bignumber(0.1) + bignumber(0.2)",'bignumber("7.2")','bignumber("7.2e500")',"bignumber([0.1, 0.2, 0.3])"],seealso:["boolean","complex","fraction","index","matrix","string","unit"]},boolean:{name:"boolean",category:"Construction",syntax:["x","boolean(x)"],description:"Convert a string or number into a boolean.",examples:["boolean(0)","boolean(1)","boolean(3)",'boolean("true")','boolean("false")',"boolean([1, 0, 1, 1])"],seealso:["bignumber","complex","index","matrix","number","string","unit"]},complex:{name:"complex",category:"Construction",syntax:["complex()","complex(re, im)","complex(string)"],description:"Create a complex number.",examples:["complex()","complex(2, 3)",'complex("7 - 2i")'],seealso:["bignumber","boolean","index","matrix","number","string","unit"]},createUnit:{name:"createUnit",category:"Construction",syntax:["createUnit(definitions)","createUnit(name, definition)"],description:"Create a user-defined unit and register it with the Unit type.",examples:['createUnit("foo")','createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})','createUnit("mph", "1 mile/hour")'],seealso:["unit","splitUnit"]},fraction:{name:"fraction",category:"Construction",syntax:["fraction(num)","fraction(matrix)","fraction(num,den)","fraction({n: num, d: den})"],description:"Create a fraction from a number or from integer numerator and denominator.",examples:["fraction(0.125)","fraction(1, 3) + fraction(2, 5)","fraction({n: 333, d: 53})","fraction([sqrt(9), sqrt(10), sqrt(11)])"],seealso:["bignumber","boolean","complex","index","matrix","string","unit"]},index:{name:"index",category:"Construction",syntax:["[start]","[start:end]","[start:step:end]","[start1, start 2, ...]","[start1:end1, start2:end2, ...]","[start1:step1:end1, start2:step2:end2, ...]"],description:"Create an index to get or replace a subset of a matrix",examples:["A = [1, 2, 3; 4, 5, 6]","A[1, :]","A[1, 2] = 50","A[1:2, 1:2] = 1","B = [1, 2, 3]","B[B>1 and B<3]"],seealso:["bignumber","boolean","complex","matrix,","number","range","string","unit"]},matrix:{name:"matrix",category:"Construction",syntax:["[]","[a1, b1, ...; a2, b2, ...]","matrix()",'matrix("dense")',"matrix([...])"],description:"Create a matrix.",examples:["[]","[1, 2, 3]","[1, 2, 3; 4, 5, 6]","matrix()","matrix([3, 4])",'matrix([3, 4; 5, 6], "sparse")','matrix([3, 4; 5, 6], "sparse", "number")'],seealso:["bignumber","boolean","complex","index","number","string","unit","sparse"]},number:{name:"number",category:"Construction",syntax:["x","number(x)","number(unit, valuelessUnit)"],description:"Create a number or convert a string or boolean into a number.",examples:["2","2e3","4.05","number(2)",'number("7.2")',"number(true)","number([true, false, true, true])",'number(unit("52cm"), "m")'],seealso:["bignumber","boolean","complex","fraction","index","matrix","string","unit"]},sparse:{name:"sparse",category:"Construction",syntax:["sparse()","sparse([a1, b1, ...; a1, b2, ...])",'sparse([a1, b1, ...; a1, b2, ...], "number")'],description:"Create a sparse matrix.",examples:["sparse()","sparse([3, 4; 5, 6])",'sparse([3, 0; 5, 0], "number")'],seealso:["bignumber","boolean","complex","index","number","string","unit","matrix"]},splitUnit:{name:"splitUnit",category:"Construction",syntax:["splitUnit(unit: Unit, parts: Unit[])"],description:"Split a unit in an array of units whose sum is equal to the original unit.",examples:['splitUnit(1 m, ["feet", "inch"])'],seealso:["unit","createUnit"]},string:{name:"string",category:"Construction",syntax:['"text"',"string(x)"],description:"Create a string or convert a value to a string",examples:['"Hello World!"',"string(4.2)","string(3 + 2i)"],seealso:["bignumber","boolean","complex","index","matrix","number","unit"]},unit:{name:"unit",category:"Construction",syntax:["value unit","unit(value, unit)","unit(string)"],description:"Create a unit.",examples:["5.5 mm","3 inch",'unit(7.1, "kilogram")','unit("23 deg")'],seealso:["bignumber","boolean","complex","index","matrix","number","string"]},e:Dh,E:Dh,false:{name:"false",category:"Constants",syntax:["false"],description:"Boolean value false",examples:["false"],seealso:["true"]},i:{name:"i",category:"Constants",syntax:["i"],description:"Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",examples:["i","i * i","sqrt(-1)"],seealso:[]},Infinity:{name:"Infinity",category:"Constants",syntax:["Infinity"],description:"Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",examples:["Infinity","1 / 0"],seealso:[]},LN2:{name:"LN2",category:"Constants",syntax:["LN2"],description:"Returns the natural logarithm of 2, approximately equal to 0.693",examples:["LN2","log(2)"],seealso:[]},LN10:{name:"LN10",category:"Constants",syntax:["LN10"],description:"Returns the natural logarithm of 10, approximately equal to 2.302",examples:["LN10","log(10)"],seealso:[]},LOG2E:{name:"LOG2E",category:"Constants",syntax:["LOG2E"],description:"Returns the base-2 logarithm of E, approximately equal to 1.442",examples:["LOG2E","log(e, 2)"],seealso:[]},LOG10E:{name:"LOG10E",category:"Constants",syntax:["LOG10E"],description:"Returns the base-10 logarithm of E, approximately equal to 0.434",examples:["LOG10E","log(e, 10)"],seealso:[]},NaN:{name:"NaN",category:"Constants",syntax:["NaN"],description:"Not a number",examples:["NaN","0 / 0"],seealso:[]},null:{name:"null",category:"Constants",syntax:["null"],description:"Value null",examples:["null"],seealso:["true","false"]},pi:Nh,PI:Nh,phi:{name:"phi",category:"Constants",syntax:["phi"],description:"Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",examples:["phi"],seealso:[]},SQRT1_2:{name:"SQRT1_2",category:"Constants",syntax:["SQRT1_2"],description:"Returns the square root of 1/2, approximately equal to 0.707",examples:["SQRT1_2","sqrt(1/2)"],seealso:[]},SQRT2:{name:"SQRT2",category:"Constants",syntax:["SQRT2"],description:"Returns the square root of 2, approximately equal to 1.414",examples:["SQRT2","sqrt(2)"],seealso:[]},tau:{name:"tau",category:"Constants",syntax:["tau"],description:"Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",examples:["tau","2 * pi"],seealso:["pi"]},true:{name:"true",category:"Constants",syntax:["true"],description:"Boolean value true",examples:["true"],seealso:["false"]},version:{name:"version",category:"Constants",syntax:["version"],description:"A string with the version number of math.js",examples:["version"],seealso:[]},speedOfLight:{description:"Speed of light in vacuum",examples:["speedOfLight"]},gravitationConstant:{description:"Newtonian constant of gravitation",examples:["gravitationConstant"]},planckConstant:{description:"Planck constant",examples:["planckConstant"]},reducedPlanckConstant:{description:"Reduced Planck constant",examples:["reducedPlanckConstant"]},magneticConstant:{description:"Magnetic constant (vacuum permeability)",examples:["magneticConstant"]},electricConstant:{description:"Electric constant (vacuum permeability)",examples:["electricConstant"]},vacuumImpedance:{description:"Characteristic impedance of vacuum",examples:["vacuumImpedance"]},coulomb:{description:"Coulomb's constant",examples:["coulomb"]},elementaryCharge:{description:"Elementary charge",examples:["elementaryCharge"]},bohrMagneton:{description:"Borh magneton",examples:["bohrMagneton"]},conductanceQuantum:{description:"Conductance quantum",examples:["conductanceQuantum"]},inverseConductanceQuantum:{description:"Inverse conductance quantum",examples:["inverseConductanceQuantum"]},magneticFluxQuantum:{description:"Magnetic flux quantum",examples:["magneticFluxQuantum"]},nuclearMagneton:{description:"Nuclear magneton",examples:["nuclearMagneton"]},klitzing:{description:"Von Klitzing constant",examples:["klitzing"]},bohrRadius:{description:"Borh radius",examples:["bohrRadius"]},classicalElectronRadius:{description:"Classical electron radius",examples:["classicalElectronRadius"]},electronMass:{description:"Electron mass",examples:["electronMass"]},fermiCoupling:{description:"Fermi coupling constant",examples:["fermiCoupling"]},fineStructure:{description:"Fine-structure constant",examples:["fineStructure"]},hartreeEnergy:{description:"Hartree energy",examples:["hartreeEnergy"]},protonMass:{description:"Proton mass",examples:["protonMass"]},deuteronMass:{description:"Deuteron Mass",examples:["deuteronMass"]},neutronMass:{description:"Neutron mass",examples:["neutronMass"]},quantumOfCirculation:{description:"Quantum of circulation",examples:["quantumOfCirculation"]},rydberg:{description:"Rydberg constant",examples:["rydberg"]},thomsonCrossSection:{description:"Thomson cross section",examples:["thomsonCrossSection"]},weakMixingAngle:{description:"Weak mixing angle",examples:["weakMixingAngle"]},efimovFactor:{description:"Efimov factor",examples:["efimovFactor"]},atomicMass:{description:"Atomic mass constant",examples:["atomicMass"]},avogadro:{description:"Avogadro's number",examples:["avogadro"]},boltzmann:{description:"Boltzmann constant",examples:["boltzmann"]},faraday:{description:"Faraday constant",examples:["faraday"]},firstRadiation:{description:"First radiation constant",examples:["firstRadiation"]},loschmidt:{description:"Loschmidt constant at T=273.15 K and p=101.325 kPa",examples:["loschmidt"]},gasConstant:{description:"Gas constant",examples:["gasConstant"]},molarPlanckConstant:{description:"Molar Planck constant",examples:["molarPlanckConstant"]},molarVolume:{description:"Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",examples:["molarVolume"]},sackurTetrode:{description:"Sackur-Tetrode constant at T=1 K and p=101.325 kPa",examples:["sackurTetrode"]},secondRadiation:{description:"Second radiation constant",examples:["secondRadiation"]},stefanBoltzmann:{description:"Stefan-Boltzmann constant",examples:["stefanBoltzmann"]},wienDisplacement:{description:"Wien displacement law constant",examples:["wienDisplacement"]},molarMass:{description:"Molar mass constant",examples:["molarMass"]},molarMassC12:{description:"Molar mass constant of carbon-12",examples:["molarMassC12"]},gravity:{description:"Standard acceleration of gravity (standard acceleration of free-fall on Earth)",examples:["gravity"]},planckLength:{description:"Planck length",examples:["planckLength"]},planckMass:{description:"Planck mass",examples:["planckMass"]},planckTime:{description:"Planck time",examples:["planckTime"]},planckCharge:{description:"Planck charge",examples:["planckCharge"]},planckTemperature:{description:"Planck temperature",examples:["planckTemperature"]},derivative:{name:"derivative",category:"Algebra",syntax:["derivative(expr, variable)","derivative(expr, variable, {simplify: boolean})"],description:"Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",examples:['derivative("2x^3", "x")','derivative("2x^3", "x", {simplify: false})','derivative("2x^2 + 3x + 4", "x")','derivative("sin(2x)", "x")','f = parse("x^2 + x")','x = parse("x")',"df = derivative(f, x)","df.evaluate({x: 3})"],seealso:["simplify","parse","evaluate"]},lsolve:{name:"lsolve",category:"Algebra",syntax:["x=lsolve(L, b)"],description:"Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",examples:["a = [-2, 3; 2, 1]","b = [11, 9]","x = lsolve(a, b)"],seealso:["lsolveAll","lup","lusolve","usolve","matrix","sparse"]},lsolveAll:{name:"lsolveAll",category:"Algebra",syntax:["x=lsolveAll(L, b)"],description:"Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",examples:["a = [-2, 3; 2, 1]","b = [11, 9]","x = lsolve(a, b)"],seealso:["lsolve","lup","lusolve","usolve","matrix","sparse"]},lup:{name:"lup",category:"Algebra",syntax:["lup(m)"],description:"Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",examples:["lup([[2, 1], [1, 4]])","lup(matrix([[2, 1], [1, 4]]))","lup(sparse([[2, 1], [1, 4]]))"],seealso:["lusolve","lsolve","usolve","matrix","sparse","slu","qr"]},lusolve:{name:"lusolve",category:"Algebra",syntax:["x=lusolve(A, b)","x=lusolve(lu, b)"],description:"Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",examples:["a = [-2, 3; 2, 1]","b = [11, 9]","x = lusolve(a, b)"],seealso:["lup","slu","lsolve","usolve","matrix","sparse"]},leafCount:{name:"leafCount",category:"Algebra",syntax:["leafCount(expr)"],description:"Computes the number of leaves in the parse tree of the given expression",examples:['leafCount("e^(i*pi)-1")','leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],seealso:["simplify"]},polynomialRoot:{name:"polynomialRoot",category:"Algebra",syntax:["x=polynomialRoot(-6, 3)","x=polynomialRoot(4, -4, 1)","x=polynomialRoot(-8, 12, -6, 1)"],description:"Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",examples:["a = polynomialRoot(-6, 11, -6, 1)"],seealso:["cbrt","sqrt"]},resolve:{name:"resolve",category:"Algebra",syntax:["resolve(node, scope)"],description:"Recursively substitute variables in an expression tree.",examples:['resolve(parse("1 + x"), { x: 7 })','resolve(parse("size(text)"), { text: "Hello World" })','resolve(parse("x + y"), { x: parse("3z") })','resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],seealso:["simplify","evaluate"],mayThrow:["ReferenceError"]},simplify:{name:"simplify",category:"Algebra",syntax:["simplify(expr)","simplify(expr, rules)"],description:"Simplify an expression tree.",examples:['simplify("3 + 2 / 4")','simplify("2x + x")','f = parse("x * (x + 2 + x)")',"simplified = simplify(f)","simplified.evaluate({x: 2})"],seealso:["simplifyCore","derivative","evaluate","parse","rationalize","resolve"]},simplifyConstant:{name:"simplifyConstant",category:"Algebra",syntax:["simplifyConstant(expr)","simplifyConstant(expr, options)"],description:"Replace constant subexpressions of node with their values.",examples:['simplifyConstant("(3-3)*x")','simplifyConstant(parse("z-cos(tau/8)"))'],seealso:["simplify","simplifyCore","evaluate"]},simplifyCore:{name:"simplifyCore",category:"Algebra",syntax:["simplifyCore(node)"],description:"Perform simple one-pass simplifications on an expression tree.",examples:['simplifyCore(parse("0*x"))','simplifyCore(parse("(x+0)*2"))'],seealso:["simplify","simplifyConstant","evaluate"]},symbolicEqual:{name:"symbolicEqual",category:"Algebra",syntax:["symbolicEqual(expr1, expr2)","symbolicEqual(expr1, expr2, options)"],description:"Returns true if the difference of the expressions simplifies to 0",examples:['symbolicEqual("x*y","y*x")','symbolicEqual("abs(x^2)", "x^2")','symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],seealso:["simplify","evaluate"]},rationalize:{name:"rationalize",category:"Algebra",syntax:["rationalize(expr)","rationalize(expr, scope)","rationalize(expr, scope, detailed)"],description:"Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",examples:['rationalize("2x/y - y/(x+1)")','rationalize("2x/y - y/(x+1)", true)'],seealso:["simplify"]},slu:{name:"slu",category:"Algebra",syntax:["slu(A, order, threshold)"],description:"Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",examples:["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],seealso:["lusolve","lsolve","usolve","matrix","sparse","lup","qr"]},usolve:{name:"usolve",category:"Algebra",syntax:["x=usolve(U, b)"],description:"Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",examples:["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],seealso:["usolveAll","lup","lusolve","lsolve","matrix","sparse"]},usolveAll:{name:"usolveAll",category:"Algebra",syntax:["x=usolve(U, b)"],description:"Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",examples:["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],seealso:["usolve","lup","lusolve","lsolve","matrix","sparse"]},qr:{name:"qr",category:"Algebra",syntax:["qr(A)"],description:"Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",examples:["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],seealso:["lup","slu","matrix"]},abs:{name:"abs",category:"Arithmetic",syntax:["abs(x)"],description:"Compute the absolute value.",examples:["abs(3.5)","abs(-4.2)"],seealso:["sign"]},add:{name:"add",category:"Operators",syntax:["x + y","add(x, y)"],description:"Add two values.",examples:["a = 2.1 + 3.6","a - 3.6","3 + 2i","3 cm + 2 inch",'"2.3" + "4"'],seealso:["subtract"]},cbrt:{name:"cbrt",category:"Arithmetic",syntax:["cbrt(x)","cbrt(x, allRoots)"],description:"Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",examples:["cbrt(64)","cube(4)","cbrt(-8)","cbrt(2 + 3i)","cbrt(8i)","cbrt(8i, true)","cbrt(27 m^3)"],seealso:["square","sqrt","cube","multiply"]},ceil:{name:"ceil",category:"Arithmetic",syntax:["ceil(x)"],description:"Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",examples:["ceil(3.2)","ceil(3.8)","ceil(-4.2)"],seealso:["floor","fix","round"]},cube:{name:"cube",category:"Arithmetic",syntax:["cube(x)"],description:"Compute the cube of a value. The cube of x is x * x * x.",examples:["cube(2)","2^3","2 * 2 * 2"],seealso:["multiply","square","pow"]},divide:{name:"divide",category:"Operators",syntax:["x / y","divide(x, y)"],description:"Divide two values.",examples:["a = 2 / 3","a * 3","4.5 / 2","3 + 4 / 2","(3 + 4) / 2","18 km / 4.5"],seealso:["multiply"]},dotDivide:{name:"dotDivide",category:"Operators",syntax:["x ./ y","dotDivide(x, y)"],description:"Divide two values element wise.",examples:["a = [1, 2, 3; 4, 5, 6]","b = [2, 1, 1; 3, 2, 5]","a ./ b"],seealso:["multiply","dotMultiply","divide"]},dotMultiply:{name:"dotMultiply",category:"Operators",syntax:["x .* y","dotMultiply(x, y)"],description:"Multiply two values element wise.",examples:["a = [1, 2, 3; 4, 5, 6]","b = [2, 1, 1; 3, 2, 5]","a .* b"],seealso:["multiply","divide","dotDivide"]},dotPow:{name:"dotPow",category:"Operators",syntax:["x .^ y","dotPow(x, y)"],description:"Calculates the power of x to y element wise.",examples:["a = [1, 2, 3; 4, 5, 6]","a .^ 2"],seealso:["pow"]},exp:{name:"exp",category:"Arithmetic",syntax:["exp(x)"],description:"Calculate the exponent of a value.",examples:["exp(1.3)","e ^ 1.3","log(exp(1.3))","x = 2.4","(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],seealso:["expm","expm1","pow","log"]},expm:{name:"expm",category:"Arithmetic",syntax:["exp(x)"],description:"Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",examples:["expm([[0,2],[0,0]])"],seealso:["exp"]},expm1:{name:"expm1",category:"Arithmetic",syntax:["expm1(x)"],description:"Calculate the value of subtracting 1 from the exponential value.",examples:["expm1(2)","pow(e, 2) - 1","log(expm1(2) + 1)"],seealso:["exp","pow","log"]},fix:{name:"fix",category:"Arithmetic",syntax:["fix(x)"],description:"Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",examples:["fix(3.2)","fix(3.8)","fix(-4.2)","fix(-4.8)"],seealso:["ceil","floor","round"]},floor:{name:"floor",category:"Arithmetic",syntax:["floor(x)"],description:"Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",examples:["floor(3.2)","floor(3.8)","floor(-4.2)"],seealso:["ceil","fix","round"]},gcd:{name:"gcd",category:"Arithmetic",syntax:["gcd(a, b)","gcd(a, b, c, ...)"],description:"Compute the greatest common divisor.",examples:["gcd(8, 12)","gcd(-4, 6)","gcd(25, 15, -10)"],seealso:["lcm","xgcd"]},hypot:{name:"hypot",category:"Arithmetic",syntax:["hypot(a, b, c, ...)","hypot([a, b, c, ...])"],description:"Calculate the hypotenusa of a list with values. ",examples:["hypot(3, 4)","sqrt(3^2 + 4^2)","hypot(-2)","hypot([3, 4, 5])"],seealso:["abs","norm"]},lcm:{name:"lcm",category:"Arithmetic",syntax:["lcm(x, y)"],description:"Compute the least common multiple.",examples:["lcm(4, 6)","lcm(6, 21)","lcm(6, 21, 5)"],seealso:["gcd"]},log:{name:"log",category:"Arithmetic",syntax:["log(x)","log(x, base)"],description:"Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",examples:["log(3.5)","a = log(2.4)","exp(a)","10 ^ 4","log(10000, 10)","log(10000) / log(10)","b = log(1024, 2)","2 ^ b"],seealso:["exp","log1p","log2","log10"]},log2:{name:"log2",category:"Arithmetic",syntax:["log2(x)"],description:"Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",examples:["log2(0.03125)","log2(16)","log2(16) / log2(2)","pow(2, 4)"],seealso:["exp","log1p","log","log10"]},log1p:{name:"log1p",category:"Arithmetic",syntax:["log1p(x)","log1p(x, base)"],description:"Calculate the logarithm of a `value+1`",examples:["log1p(2.5)","exp(log1p(1.4))","pow(10, 4)","log1p(9999, 10)","log1p(9999) / log(10)"],seealso:["exp","log","log2","log10"]},log10:{name:"log10",category:"Arithmetic",syntax:["log10(x)"],description:"Compute the 10-base logarithm of a value.",examples:["log10(0.00001)","log10(10000)","10 ^ 4","log(10000) / log(10)","log(10000, 10)"],seealso:["exp","log"]},mod:{name:"mod",category:"Operators",syntax:["x % y","x mod y","mod(x, y)"],description:"Calculates the modulus, the remainder of an integer division.",examples:["7 % 3","11 % 2","10 mod 4","isOdd(x) = x % 2","isOdd(2)","isOdd(3)"],seealso:["divide"]},multiply:{name:"multiply",category:"Operators",syntax:["x * y","multiply(x, y)"],description:"multiply two values.",examples:["a = 2.1 * 3.4","a / 3.4","2 * 3 + 4","2 * (3 + 4)","3 * 2.1 km"],seealso:["divide"]},norm:{name:"norm",category:"Arithmetic",syntax:["norm(x)","norm(x, p)"],description:"Calculate the norm of a number, vector or matrix.",examples:["abs(-3.5)","norm(-3.5)","norm(3 - 4i)","norm([1, 2, -3], Infinity)","norm([1, 2, -3], -Infinity)","norm([3, 4], 2)","norm([[1, 2], [3, 4]], 1)",'norm([[1, 2], [3, 4]], "inf")','norm([[1, 2], [3, 4]], "fro")']},nthRoot:{name:"nthRoot",category:"Arithmetic",syntax:["nthRoot(a)","nthRoot(a, root)"],description:'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',examples:["4 ^ 3","nthRoot(64, 3)","nthRoot(9, 2)","sqrt(9)"],seealso:["nthRoots","pow","sqrt"]},nthRoots:{name:"nthRoots",category:"Arithmetic",syntax:["nthRoots(A)","nthRoots(A, root)"],description:'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',examples:["nthRoots(1)","nthRoots(1, 3)"],seealso:["sqrt","pow","nthRoot"]},pow:{name:"pow",category:"Operators",syntax:["x ^ y","pow(x, y)"],description:"Calculates the power of x to y, x^y.",examples:["2^3","2*2*2","1 + e ^ (pi * i)","pow([[1, 2], [4, 3]], 2)","pow([[1, 2], [4, 3]], -1)"],seealso:["multiply","nthRoot","nthRoots","sqrt"]},round:{name:"round",category:"Arithmetic",syntax:["round(x)","round(x, n)","round(unit, valuelessUnit)","round(unit, n, valuelessUnit)"],description:"round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",examples:["round(3.2)","round(3.8)","round(-4.2)","round(-4.8)","round(pi, 3)","round(123.45678, 2)","round(3.241cm, 2, cm)","round([3.2, 3.8, -4.7])"],seealso:["ceil","floor","fix"]},sign:{name:"sign",category:"Arithmetic",syntax:["sign(x)"],description:"Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",examples:["sign(3.5)","sign(-4.2)","sign(0)"],seealso:["abs"]},sqrt:{name:"sqrt",category:"Arithmetic",syntax:["sqrt(x)"],description:"Compute the square root value. If x = y * y, then y is the square root of x.",examples:["sqrt(25)","5 * 5","sqrt(-1)"],seealso:["square","sqrtm","multiply","nthRoot","nthRoots","pow"]},sqrtm:{name:"sqrtm",category:"Arithmetic",syntax:["sqrtm(x)"],description:"Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",examples:["sqrtm([[33, 24], [48, 57]])"],seealso:["sqrt","abs","square","multiply"]},square:{name:"square",category:"Arithmetic",syntax:["square(x)"],description:"Compute the square of a value. The square of x is x * x.",examples:["square(3)","sqrt(9)","3^2","3 * 3"],seealso:["multiply","pow","sqrt","cube"]},subtract:{name:"subtract",category:"Operators",syntax:["x - y","subtract(x, y)"],description:"subtract two values.",examples:["a = 5.3 - 2","a + 2","2/3 - 1/6","2 * 3 - 3","2.1 km - 500m"],seealso:["add"]},unaryMinus:{name:"unaryMinus",category:"Operators",syntax:["-x","unaryMinus(x)"],description:"Inverse the sign of a value. Converts booleans and strings to numbers.",examples:["-4.5","-(-5.6)",'-"22"'],seealso:["add","subtract","unaryPlus"]},unaryPlus:{name:"unaryPlus",category:"Operators",syntax:["+x","unaryPlus(x)"],description:"Converts booleans and strings to numbers.",examples:["+true",'+"2"'],seealso:["add","subtract","unaryMinus"]},xgcd:{name:"xgcd",category:"Arithmetic",syntax:["xgcd(a, b)"],description:"Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",examples:["xgcd(8, 12)","gcd(8, 12)","xgcd(36163, 21199)"],seealso:["gcd","lcm"]},invmod:{name:"invmod",category:"Arithmetic",syntax:["invmod(a, b)"],description:"Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax ≣ 1 (mod b)",examples:["invmod(8, 12)","invmod(7, 13)","invmod(15151, 15122)"],seealso:["gcd","xgcd"]},bitAnd:{name:"bitAnd",category:"Bitwise",syntax:["x & y","bitAnd(x, y)"],description:"Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",examples:["5 & 3","bitAnd(53, 131)","[1, 12, 31] & 42"],seealso:["bitNot","bitOr","bitXor","leftShift","rightArithShift","rightLogShift"]},bitNot:{name:"bitNot",category:"Bitwise",syntax:["~x","bitNot(x)"],description:"Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",examples:["~1","~2","bitNot([2, -3, 4])"],seealso:["bitAnd","bitOr","bitXor","leftShift","rightArithShift","rightLogShift"]},bitOr:{name:"bitOr",category:"Bitwise",syntax:["x | y","bitOr(x, y)"],description:"Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",examples:["5 | 3","bitOr([1, 2, 3], 4)"],seealso:["bitAnd","bitNot","bitXor","leftShift","rightArithShift","rightLogShift"]},bitXor:{name:"bitXor",category:"Bitwise",syntax:["bitXor(x, y)"],description:"Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",examples:["bitOr(1, 2)","bitXor([2, 3, 4], 4)"],seealso:["bitAnd","bitNot","bitOr","leftShift","rightArithShift","rightLogShift"]},leftShift:{name:"leftShift",category:"Bitwise",syntax:["x << y","leftShift(x, y)"],description:"Bitwise left logical shift of a value x by y number of bits.",examples:["4 << 1","8 >> 1"],seealso:["bitAnd","bitNot","bitOr","bitXor","rightArithShift","rightLogShift"]},rightArithShift:{name:"rightArithShift",category:"Bitwise",syntax:["x >> y","rightArithShift(x, y)"],description:"Bitwise right arithmetic shift of a value x by y number of bits.",examples:["8 >> 1","4 << 1","-12 >> 2"],seealso:["bitAnd","bitNot","bitOr","bitXor","leftShift","rightLogShift"]},rightLogShift:{name:"rightLogShift",category:"Bitwise",syntax:["x >>> y","rightLogShift(x, y)"],description:"Bitwise right logical shift of a value x by y number of bits.",examples:["8 >>> 1","4 << 1","-12 >>> 2"],seealso:["bitAnd","bitNot","bitOr","bitXor","leftShift","rightArithShift"]},bellNumbers:{name:"bellNumbers",category:"Combinatorics",syntax:["bellNumbers(n)"],description:"The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",examples:["bellNumbers(3)","bellNumbers(8)"],seealso:["stirlingS2"]},catalan:{name:"catalan",category:"Combinatorics",syntax:["catalan(n)"],description:"The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",examples:["catalan(3)","catalan(8)"],seealso:["bellNumbers"]},composition:{name:"composition",category:"Combinatorics",syntax:["composition(n, k)"],description:"The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",examples:["composition(5, 3)"],seealso:["combinations"]},stirlingS2:{name:"stirlingS2",category:"Combinatorics",syntax:["stirlingS2(n, k)"],description:"he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",examples:["stirlingS2(5, 3)"],seealso:["bellNumbers"]},config:{name:"config",category:"Core",syntax:["config()","config(options)"],description:"Get configuration or change configuration.",examples:["config()","1/3 + 1/4",'config({number: "Fraction"})',"1/3 + 1/4"],seealso:[]},import:{name:"import",category:"Core",syntax:["import(functions)","import(functions, options)"],description:"Import functions or constants from an object.",examples:["import({myFn: f(x)=x^2, myConstant: 32 })","myFn(2)","myConstant"],seealso:[]},typed:{name:"typed",category:"Core",syntax:["typed(signatures)","typed(name, signatures)"],description:"Create a typed function.",examples:['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })',"double(2)",'double("hello")'],seealso:[]},arg:{name:"arg",category:"Complex",syntax:["arg(x)"],description:"Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",examples:["arg(2 + 2i)","atan2(3, 2)","arg(2 + 3i)"],seealso:["re","im","conj","abs"]},conj:{name:"conj",category:"Complex",syntax:["conj(x)"],description:"Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",examples:["conj(2 + 3i)","conj(2 - 3i)","conj(-5.2i)"],seealso:["re","im","abs","arg"]},re:{name:"re",category:"Complex",syntax:["re(x)"],description:"Get the real part of a complex number.",examples:["re(2 + 3i)","im(2 + 3i)","re(-5.2i)","re(2.4)"],seealso:["im","conj","abs","arg"]},im:{name:"im",category:"Complex",syntax:["im(x)"],description:"Get the imaginary part of a complex number.",examples:["im(2 + 3i)","re(2 + 3i)","im(-5.2i)","im(2.4)"],seealso:["re","conj","abs","arg"]},evaluate:{name:"evaluate",category:"Expression",syntax:["evaluate(expression)","evaluate(expression, scope)","evaluate([expr1, expr2, expr3, ...])","evaluate([expr1, expr2, expr3, ...], scope)"],description:"Evaluate an expression or an array with expressions.",examples:['evaluate("2 + 3")','evaluate("sqrt(16)")','evaluate("2 inch to cm")','evaluate("sin(x * pi)", { "x": 1/2 })','evaluate(["width=2", "height=4","width*height"])'],seealso:[]},help:{name:"help",category:"Expression",syntax:["help(object)","help(string)"],description:"Display documentation on a function or data type.",examples:["help(sqrt)",'help("complex")'],seealso:[]},distance:{name:"distance",category:"Geometry",syntax:["distance([x1, y1], [x2, y2])","distance([[x1, y1], [x2, y2]])"],description:"Calculates the Euclidean distance between two points.",examples:["distance([0,0], [4,4])","distance([[0,0], [4,4]])"],seealso:[]},intersect:{name:"intersect",category:"Geometry",syntax:["intersect(expr1, expr2, expr3, expr4)","intersect(expr1, expr2, expr3)"],description:"Computes the intersection point of lines and/or planes.",examples:["intersect([0, 0], [10, 10], [10, 0], [0, 10])","intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],seealso:[]},and:{name:"and",category:"Logical",syntax:["x and y","and(x, y)"],description:"Logical and. Test whether two values are both defined with a nonzero/nonempty value.",examples:["true and false","true and true","2 and 4"],seealso:["not","or","xor"]},not:{name:"not",category:"Logical",syntax:["not x","not(x)"],description:"Logical not. Flips the boolean value of given argument.",examples:["not true","not false","not 2","not 0"],seealso:["and","or","xor"]},or:{name:"or",category:"Logical",syntax:["x or y","or(x, y)"],description:"Logical or. Test if at least one value is defined with a nonzero/nonempty value.",examples:["true or false","false or false","0 or 4"],seealso:["not","and","xor"]},xor:{name:"xor",category:"Logical",syntax:["x xor y","xor(x, y)"],description:"Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",examples:["true xor false","false xor false","true xor true","0 xor 4"],seealso:["not","and","or"]},concat:{name:"concat",category:"Matrix",syntax:["concat(A, B, C, ...)","concat(A, B, C, ..., dim)"],description:"Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",examples:["A = [1, 2; 5, 6]","B = [3, 4; 7, 8]","concat(A, B)","concat(A, B, 1)","concat(A, B, 2)"],seealso:["det","diag","identity","inv","ones","range","size","squeeze","subset","trace","transpose","zeros"]},count:{name:"count",category:"Matrix",syntax:["count(x)"],description:"Count the number of elements of a matrix, array or string.",examples:["a = [1, 2; 3, 4; 5, 6]","count(a)","size(a)",'count("hello world")'],seealso:["size"]},cross:{name:"cross",category:"Matrix",syntax:["cross(A, B)"],description:"Calculate the cross product for two vectors in three dimensional space.",examples:["cross([1, 1, 0],  [0, 1, 1])","cross([3, -3, 1], [4, 9, 2])","cross([2, 3, 4],  [5, 6, 7])"],seealso:["multiply","dot"]},column:{name:"column",category:"Matrix",syntax:["column(x, index)"],description:"Return a column from a matrix or array.",examples:["A = [[1, 2], [3, 4]]","column(A, 1)","column(A, 2)"],seealso:["row","matrixFromColumns"]},ctranspose:{name:"ctranspose",category:"Matrix",syntax:["x'","ctranspose(x)"],description:"Complex Conjugate and Transpose a matrix",examples:["a = [1, 2, 3; 4, 5, 6]","a'","ctranspose(a)"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","subset","trace","zeros"]},det:{name:"det",category:"Matrix",syntax:["det(x)"],description:"Calculate the determinant of a matrix",examples:["det([1, 2; 3, 4])","det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],seealso:["concat","diag","identity","inv","ones","range","size","squeeze","subset","trace","transpose","zeros"]},diag:{name:"diag",category:"Matrix",syntax:["diag(x)","diag(x, k)"],description:"Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",examples:["diag(1:3)","diag(1:3, 1)","a = [1, 2, 3; 4, 5, 6; 7, 8, 9]","diag(a)"],seealso:["concat","det","identity","inv","ones","range","size","squeeze","subset","trace","transpose","zeros"]},diff:{name:"diff",category:"Matrix",syntax:["diff(arr)","diff(arr, dim)"],description:["Create a new matrix or array with the difference of the passed matrix or array.","Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference","If no dimension parameter is passed it is assumed as dimension 0","Dimension is zero-based in javascript and one-based in the parser","Arrays must be 'rectangular' meaning arrays like [1, 2]","If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],examples:["A = [1, 2, 4, 7, 0]","diff(A)","diff(A, 1)","B = [[1, 2], [3, 4]]","diff(B)","diff(B, 1)","diff(B, 2)","diff(B, bignumber(2))","diff([[1, 2], matrix([3, 4])], 2)"],seealso:["subtract","partitionSelect"]},dot:{name:"dot",category:"Matrix",syntax:["dot(A, B)","A * B"],description:"Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",examples:["dot([2, 4, 1], [2, 2, 3])","[2, 4, 1] * [2, 2, 3]"],seealso:["multiply","cross"]},getMatrixDataType:{name:"getMatrixDataType",category:"Matrix",syntax:["getMatrixDataType(x)"],description:'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',examples:["getMatrixDataType([1, 2, 3])","getMatrixDataType([[5 cm], [2 inch]])",'getMatrixDataType([1, "text"])',"getMatrixDataType([1, bignumber(4)])"],seealso:["matrix","sparse","typeOf"]},identity:{name:"identity",category:"Matrix",syntax:["identity(n)","identity(m, n)","identity([m, n])"],description:"Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",examples:["identity(3)","identity(3, 5)","a = [1, 2, 3; 4, 5, 6]","identity(size(a))"],seealso:["concat","det","diag","inv","ones","range","size","squeeze","subset","trace","transpose","zeros"]},filter:{name:"filter",category:"Matrix",syntax:["filter(x, test)"],description:"Filter items in a matrix.",examples:["isPositive(x) = x > 0","filter([6, -2, -1, 4, 3], isPositive)","filter([6, -2, 0, 1, 0], x != 0)"],seealso:["sort","map","forEach"]},flatten:{name:"flatten",category:"Matrix",syntax:["flatten(x)"],description:"Flatten a multi dimensional matrix into a single dimensional matrix.",examples:["a = [1, 2, 3; 4, 5, 6]","size(a)","b = flatten(a)","size(b)"],seealso:["concat","resize","size","squeeze"]},forEach:{name:"forEach",category:"Matrix",syntax:["forEach(x, callback)"],description:"Iterates over all elements of a matrix/array, and executes the given callback function.",examples:["numberOfPets = {}","addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;",'forEach(["Dog","Cat","Cat"], addPet)',"numberOfPets"],seealso:["map","sort","filter"]},inv:{name:"inv",category:"Matrix",syntax:["inv(x)"],description:"Calculate the inverse of a matrix",examples:["inv([1, 2; 3, 4])","inv(4)","1 / 4"],seealso:["concat","det","diag","identity","ones","range","size","squeeze","subset","trace","transpose","zeros"]},pinv:{name:"pinv",category:"Matrix",syntax:["pinv(x)"],description:"Calculate the Moore–Penrose inverse of a matrix",examples:["pinv([1, 2; 3, 4])","pinv([[1, 0], [0, 1], [0, 1]])","pinv(4)"],seealso:["inv"]},eigs:{name:"eigs",category:"Matrix",syntax:["eigs(x)"],description:"Calculate the eigenvalues and optionally eigenvectors of a square matrix",examples:["eigs([[5, 2.3], [2.3, 1]])","eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false })"],seealso:["inv"]},kron:{name:"kron",category:"Matrix",syntax:["kron(x, y)"],description:"Calculates the kronecker product of 2 matrices or vectors.",examples:["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])","kron([1,1], [2,3,4])"],seealso:["multiply","dot","cross"]},matrixFromFunction:{name:"matrixFromFunction",category:"Matrix",syntax:["matrixFromFunction(size, fn)","matrixFromFunction(size, fn, format)","matrixFromFunction(size, fn, format, datatype)","matrixFromFunction(size, format, fn)","matrixFromFunction(size, format, datatype, fn)"],description:"Create a matrix by evaluating a generating function at each index.",examples:["f(I) = I[1] - I[2]","matrixFromFunction([3,3], f)","g(I) = I[1] - I[2] == 1 ? 4 : 0",'matrixFromFunction([100, 100], "sparse", g)',"matrixFromFunction([5], random)"],seealso:["matrix","matrixFromRows","matrixFromColumns","zeros"]},matrixFromRows:{name:"matrixFromRows",category:"Matrix",syntax:["matrixFromRows(...arr)","matrixFromRows(row1, row2)","matrixFromRows(row1, row2, row3)"],description:"Create a dense matrix from vectors as individual rows.",examples:["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],seealso:["matrix","matrixFromColumns","matrixFromFunction","zeros"]},matrixFromColumns:{name:"matrixFromColumns",category:"Matrix",syntax:["matrixFromColumns(...arr)","matrixFromColumns(row1, row2)","matrixFromColumns(row1, row2, row3)"],description:"Create a dense matrix from vectors as individual columns.",examples:["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],seealso:["matrix","matrixFromRows","matrixFromFunction","zeros"]},map:{name:"map",category:"Matrix",syntax:["map(x, callback)"],description:"Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",examples:["map([1, 2, 3], square)"],seealso:["filter","forEach"]},ones:{name:"ones",category:"Matrix",syntax:["ones(m)","ones(m, n)","ones(m, n, p, ...)","ones([m])","ones([m, n])","ones([m, n, p, ...])"],description:"Create a matrix containing ones.",examples:["ones(3)","ones(3, 5)","ones([2,3]) * 4.5","a = [1, 2, 3; 4, 5, 6]","ones(size(a))"],seealso:["concat","det","diag","identity","inv","range","size","squeeze","subset","trace","transpose","zeros"]},partitionSelect:{name:"partitionSelect",category:"Matrix",syntax:["partitionSelect(x, k)","partitionSelect(x, k, compare)"],description:"Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",examples:["partitionSelect([5, 10, 1], 2)",'partitionSelect(["C", "B", "A", "D"], 1, compareText)',"arr = [5, 2, 1]","partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]","arr","partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]","arr"],seealso:["sort"]},range:{name:"range",category:"Type",syntax:["start:end","start:step:end","range(start, end)","range(start, end, step)","range(string)"],description:"Create a range. Lower bound of the range is included, upper bound is excluded.",examples:["1:5","3:-1:-3","range(3, 7)","range(0, 12, 2)",'range("4:10")',"range(1m, 1m, 3m)","a = [1, 2, 3, 4; 5, 6, 7, 8]","a[1:2, 1:2]"],seealso:["concat","det","diag","identity","inv","ones","size","squeeze","subset","trace","transpose","zeros"]},resize:{name:"resize",category:"Matrix",syntax:["resize(x, size)","resize(x, size, defaultValue)"],description:"Resize a matrix.",examples:["resize([1,2,3,4,5], [3])","resize([1,2,3], [5])","resize([1,2,3], [5], -1)","resize(2, [2, 3])",'resize("hello", [8], "!")'],seealso:["size","subset","squeeze","reshape"]},reshape:{name:"reshape",category:"Matrix",syntax:["reshape(x, sizes)"],description:"Reshape a multi dimensional array to fit the specified dimensions.",examples:["reshape([1, 2, 3, 4, 5, 6], [2, 3])","reshape([[1, 2], [3, 4]], [1, 4])","reshape([[1, 2], [3, 4]], [4])","reshape([1, 2, 3, 4], [-1, 2])"],seealso:["size","squeeze","resize"]},rotate:{name:"rotate",category:"Matrix",syntax:["rotate(w, theta)","rotate(w, theta, v)"],description:"Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",examples:["rotate([1, 0], pi / 2)",'rotate(matrix([1, 0]), unit("35deg"))','rotate([1, 0, 0], unit("90deg"), [0, 0, 1])','rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],seealso:["matrix","rotationMatrix"]},rotationMatrix:{name:"rotationMatrix",category:"Matrix",syntax:["rotationMatrix(theta)","rotationMatrix(theta, v)","rotationMatrix(theta, v, format)"],description:"Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",examples:["rotationMatrix(pi / 2)",'rotationMatrix(unit("45deg"), [0, 0, 1])','rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],seealso:["cos","sin"]},row:{name:"row",category:"Matrix",syntax:["row(x, index)"],description:"Return a row from a matrix or array.",examples:["A = [[1, 2], [3, 4]]","row(A, 1)","row(A, 2)"],seealso:["column","matrixFromRows"]},size:{name:"size",category:"Matrix",syntax:["size(x)"],description:"Calculate the size of a matrix.",examples:["size(2.3)",'size("hello world")',"a = [1, 2; 3, 4; 5, 6]","size(a)","size(1:6)"],seealso:["concat","count","det","diag","identity","inv","ones","range","squeeze","subset","trace","transpose","zeros"]},sort:{name:"sort",category:"Matrix",syntax:["sort(x)","sort(x, compare)"],description:'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',examples:["sort([5, 10, 1])",'sort(["C", "B", "A", "D"], "natural")',"sortByLength(a, b) = size(a)[1] - size(b)[1]",'sort(["Langdon", "Tom", "Sara"], sortByLength)','sort(["10", "1", "2"], "natural")'],seealso:["map","filter","forEach"]},squeeze:{name:"squeeze",category:"Matrix",syntax:["squeeze(x)"],description:"Remove inner and outer singleton dimensions from a matrix.",examples:["a = zeros(3,2,1)","size(squeeze(a))","b = zeros(1,1,3)","size(squeeze(b))"],seealso:["concat","det","diag","identity","inv","ones","range","size","subset","trace","transpose","zeros"]},subset:{name:"subset",category:"Matrix",syntax:["value(index)","value(index) = replacement","subset(value, [index])","subset(value, [index], replacement)"],description:"Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",examples:["d = [1, 2; 3, 4]","e = []","e[1, 1:2] = [5, 6]","e[2, :] = [7, 8]","f = d * e","f[2, 1]","f[:, 1]","f[[1,2], [1,3]] = [9, 10; 11, 12]","f"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","trace","transpose","zeros"]},trace:{name:"trace",category:"Matrix",syntax:["trace(A)"],description:"Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",examples:["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]","trace(A)"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","subset","transpose","zeros"]},transpose:{name:"transpose",category:"Matrix",syntax:["x'","transpose(x)"],description:"Transpose a matrix",examples:["a = [1, 2, 3; 4, 5, 6]","a'","transpose(a)"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","subset","trace","zeros"]},zeros:{name:"zeros",category:"Matrix",syntax:["zeros(m)","zeros(m, n)","zeros(m, n, p, ...)","zeros([m])","zeros([m, n])","zeros([m, n, p, ...])"],description:"Create a matrix containing zeros.",examples:["zeros(3)","zeros(3, 5)","a = [1, 2, 3; 4, 5, 6]","zeros(size(a))"],seealso:["concat","det","diag","identity","inv","ones","range","size","squeeze","subset","trace","transpose"]},fft:{name:"fft",category:"Matrix",syntax:["fft(x)"],description:"Calculate N-dimensional fourier transform",examples:["fft([[1, 0], [1, 0]])"],seealso:["ifft"]},ifft:{name:"ifft",category:"Matrix",syntax:["ifft(x)"],description:"Calculate N-dimensional inverse fourier transform",examples:["ifft([[2, 2], [0, 0]])"],seealso:["fft"]},sylvester:{name:"sylvester",category:"Algebra",syntax:["sylvester(A,B,C)"],description:"Solves the real-valued Sylvester equation AX+XB=C for X",examples:["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])","A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]","sylvester(A, B, C)"],seealso:["schur","lyap"]},schur:{name:"schur",category:"Algebra",syntax:["schur(A)"],description:"Performs a real Schur decomposition of the real matrix A = UTU'",examples:["schur([[1, 0], [-4, 3]])","A = [[1, 0], [-4, 3]]","schur(A)"],seealso:["lyap","sylvester"]},lyap:{name:"lyap",category:"Algebra",syntax:["lyap(A,Q)"],description:"Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",examples:["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])","A = [[-2, 0], [1, -4]]","Q = [[3, 1], [1, 3]]","lyap(A,Q)"],seealso:["schur","sylvester"]},solveODE:{name:"solveODE",category:"Numeric",syntax:["solveODE(func, tspan, y0)","solveODE(func, tspan, y0, options)"],description:"Numerical Integration of Ordinary Differential Equations.",examples:["f(t,y) = y","tspan = [0, 4]","solveODE(f, tspan, 1)","solveODE(f, tspan, [1, 2])",'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],seealso:["derivative","simplifyCore"]},combinations:{name:"combinations",category:"Probability",syntax:["combinations(n, k)"],description:"Compute the number of combinations of n items taken k at a time",examples:["combinations(7, 5)"],seealso:["combinationsWithRep","permutations","factorial"]},combinationsWithRep:{name:"combinationsWithRep",category:"Probability",syntax:["combinationsWithRep(n, k)"],description:"Compute the number of combinations of n items taken k at a time with replacements.",examples:["combinationsWithRep(7, 5)"],seealso:["combinations","permutations","factorial"]},factorial:{name:"factorial",category:"Probability",syntax:["n!","factorial(n)"],description:"Compute the factorial of a value",examples:["5!","5 * 4 * 3 * 2 * 1","3!"],seealso:["combinations","combinationsWithRep","permutations","gamma"]},gamma:{name:"gamma",category:"Probability",syntax:["gamma(n)"],description:"Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",examples:["gamma(4)","3!","gamma(1/2)","sqrt(pi)"],seealso:["factorial"]},kldivergence:{name:"kldivergence",category:"Probability",syntax:["kldivergence(x, y)"],description:"Calculate the Kullback-Leibler (KL) divergence  between two distributions.",examples:["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],seealso:[]},lgamma:{name:"lgamma",category:"Probability",syntax:["lgamma(n)"],description:"Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",examples:["lgamma(4)","lgamma(1/2)","lgamma(i)","lgamma(complex(1.1, 2))"],seealso:["gamma"]},multinomial:{name:"multinomial",category:"Probability",syntax:["multinomial(A)"],description:"Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",examples:["multinomial([1, 2, 1])"],seealso:["combinations","factorial"]},permutations:{name:"permutations",category:"Probability",syntax:["permutations(n)","permutations(n, k)"],description:"Compute the number of permutations of n items taken k at a time",examples:["permutations(5)","permutations(5, 3)"],seealso:["combinations","combinationsWithRep","factorial"]},pickRandom:{name:"pickRandom",category:"Probability",syntax:["pickRandom(array)","pickRandom(array, number)","pickRandom(array, weights)","pickRandom(array, number, weights)","pickRandom(array, weights, number)"],description:"Pick a random entry from a given array.",examples:["pickRandom(0:10)","pickRandom([1, 3, 1, 6])","pickRandom([1, 3, 1, 6], 2)","pickRandom([1, 3, 1, 6], [2, 3, 2, 1])","pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])","pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],seealso:["random","randomInt"]},random:{name:"random",category:"Probability",syntax:["random()","random(max)","random(min, max)","random(size)","random(size, max)","random(size, min, max)"],description:"Return a random number.",examples:["random()","random(10, 20)","random([2, 3])"],seealso:["pickRandom","randomInt"]},randomInt:{name:"randomInt",category:"Probability",syntax:["randomInt(max)","randomInt(min, max)","randomInt(size)","randomInt(size, max)","randomInt(size, min, max)"],description:"Return a random integer number",examples:["randomInt(10, 20)","randomInt([2, 3], 10)"],seealso:["pickRandom","random"]},compare:{name:"compare",category:"Relational",syntax:["compare(x, y)"],description:"Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",examples:["compare(2, 3)","compare(3, 2)","compare(2, 2)","compare(5cm, 40mm)","compare(2, [1, 2, 3])"],seealso:["equal","unequal","smaller","smallerEq","largerEq","compareNatural","compareText"]},compareNatural:{name:"compareNatural",category:"Relational",syntax:["compareNatural(x, y)"],description:"Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",examples:["compareNatural(2, 3)","compareNatural(3, 2)","compareNatural(2, 2)","compareNatural(5cm, 40mm)",'compareNatural("2", "10")',"compareNatural(2 + 3i, 2 + 4i)","compareNatural([1, 2, 4], [1, 2, 3])","compareNatural([1, 5], [1, 2, 3])","compareNatural([1, 2], [1, 2])","compareNatural({a: 2}, {a: 4})"],seealso:["equal","unequal","smaller","smallerEq","largerEq","compare","compareText"]},compareText:{name:"compareText",category:"Relational",syntax:["compareText(x, y)"],description:"Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",examples:['compareText("B", "A")','compareText("A", "B")','compareText("A", "A")','compareText("2", "10")','compare("2", "10")',"compare(2, 10)",'compareNatural("2", "10")','compareText("B", ["A", "B", "C"])'],seealso:["compare","compareNatural"]},deepEqual:{name:"deepEqual",category:"Relational",syntax:["deepEqual(x, y)"],description:"Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",examples:["deepEqual([1,3,4], [1,3,4])","deepEqual([1,3,4], [1,3])"],seealso:["equal","unequal","smaller","larger","smallerEq","largerEq","compare"]},equal:{name:"equal",category:"Relational",syntax:["x == y","equal(x, y)"],description:"Check equality of two values. Returns true if the values are equal, and false if not.",examples:["2+2 == 3","2+2 == 4","a = 3.2","b = 6-2.8","a == b","50cm == 0.5m"],seealso:["unequal","smaller","larger","smallerEq","largerEq","compare","deepEqual","equalText"]},equalText:{name:"equalText",category:"Relational",syntax:["equalText(x, y)"],description:"Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",examples:['equalText("Hello", "Hello")','equalText("a", "A")','equal("2e3", "2000")','equalText("2e3", "2000")','equalText("B", ["A", "B", "C"])'],seealso:["compare","compareNatural","compareText","equal"]},larger:{name:"larger",category:"Relational",syntax:["x > y","larger(x, y)"],description:"Check if value x is larger than y. Returns true if x is larger than y, and false if not.",examples:["2 > 3","5 > 2*2","a = 3.3","b = 6-2.8","(a > b)","(b < a)","5 cm > 2 inch"],seealso:["equal","unequal","smaller","smallerEq","largerEq","compare"]},largerEq:{name:"largerEq",category:"Relational",syntax:["x >= y","largerEq(x, y)"],description:"Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",examples:["2 >= 1+1","2 > 1+1","a = 3.2","b = 6-2.8","(a >= b)"],seealso:["equal","unequal","smallerEq","smaller","compare"]},smaller:{name:"smaller",category:"Relational",syntax:["x < y","smaller(x, y)"],description:"Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",examples:["2 < 3","5 < 2*2","a = 3.3","b = 6-2.8","(a < b)","5 cm < 2 inch"],seealso:["equal","unequal","larger","smallerEq","largerEq","compare"]},smallerEq:{name:"smallerEq",category:"Relational",syntax:["x <= y","smallerEq(x, y)"],description:"Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",examples:["2 <= 1+1","2 < 1+1","a = 3.2","b = 6-2.8","(a <= b)"],seealso:["equal","unequal","larger","smaller","largerEq","compare"]},unequal:{name:"unequal",category:"Relational",syntax:["x != y","unequal(x, y)"],description:"Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",examples:["2+2 != 3","2+2 != 4","a = 3.2","b = 6-2.8","a != b","50cm != 0.5m","5 cm != 2 inch"],seealso:["equal","smaller","larger","smallerEq","largerEq","compare","deepEqual"]},setCartesian:{name:"setCartesian",category:"Set",syntax:["setCartesian(set1, set2)"],description:"Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",examples:["setCartesian([1, 2], [3, 4])"],seealso:["setUnion","setIntersect","setDifference","setPowerset"]},setDifference:{name:"setDifference",category:"Set",syntax:["setDifference(set1, set2)"],description:"Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setDifference([1, 2, 3, 4], [3, 4, 5, 6])","setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],seealso:["setUnion","setIntersect","setSymDifference"]},setDistinct:{name:"setDistinct",category:"Set",syntax:["setDistinct(set)"],description:"Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",examples:["setDistinct([1, 1, 1, 2, 2, 3])"],seealso:["setMultiplicity"]},setIntersect:{name:"setIntersect",category:"Set",syntax:["setIntersect(set1, set2)"],description:"Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])","setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],seealso:["setUnion","setDifference"]},setIsSubset:{name:"setIsSubset",category:"Set",syntax:["setIsSubset(set1, set2)"],description:"Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setIsSubset([1, 2], [3, 4, 5, 6])","setIsSubset([3, 4], [3, 4, 5, 6])"],seealso:["setUnion","setIntersect","setDifference"]},setMultiplicity:{name:"setMultiplicity",category:"Set",syntax:["setMultiplicity(element, set)"],description:"Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",examples:["setMultiplicity(1, [1, 2, 2, 4])","setMultiplicity(2, [1, 2, 2, 4])"],seealso:["setDistinct","setSize"]},setPowerset:{name:"setPowerset",category:"Set",syntax:["setPowerset(set)"],description:"Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",examples:["setPowerset([1, 2, 3])"],seealso:["setCartesian"]},setSize:{name:"setSize",category:"Set",syntax:["setSize(set)","setSize(set, unique)"],description:'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',examples:["setSize([1, 2, 2, 4])","setSize([1, 2, 2, 4], true)"],seealso:["setUnion","setIntersect","setDifference"]},setSymDifference:{name:"setSymDifference",category:"Set",syntax:["setSymDifference(set1, set2)"],description:"Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])","setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],seealso:["setUnion","setIntersect","setDifference"]},setUnion:{name:"setUnion",category:"Set",syntax:["setUnion(set1, set2)"],description:"Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",examples:["setUnion([1, 2, 3, 4], [3, 4, 5, 6])","setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],seealso:["setIntersect","setDifference"]},zpk2tf:{name:"zpk2tf",category:"Signal",syntax:["zpk2tf(z, p, k)"],description:"Compute the transfer function of a zero-pole-gain model.",examples:["zpk2tf([1, 2], [-1, -2], 1)","zpk2tf([1, 2], [-1, -2])","zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],seealso:[]},freqz:{name:"freqz",category:"Signal",syntax:["freqz(b, a)","freqz(b, a, w)"],description:"Calculates the frequency response of a filter given its numerator and denominator coefficients.",examples:["freqz([1, 2], [1, 2, 3])","freqz([1, 2], [1, 2, 3], [0, 1])","freqz([1, 2], [1, 2, 3], 512)"],seealso:[]},erf:{name:"erf",category:"Special",syntax:["erf(x)"],description:"Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",examples:["erf(0.2)","erf(-0.5)","erf(4)"],seealso:[]},zeta:{name:"zeta",category:"Special",syntax:["zeta(s)"],description:"Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",examples:["zeta(0.2)","zeta(-0.5)","zeta(4)"],seealso:[]},cumsum:{name:"cumsum",category:"Statistics",syntax:["cumsum(a, b, c, ...)","cumsum(A)"],description:"Compute the cumulative sum of all values.",examples:["cumsum(2, 3, 4, 1)","cumsum([2, 3, 4, 1])","cumsum([1, 2; 3, 4])","cumsum([1, 2; 3, 4], 1)","cumsum([1, 2; 3, 4], 2)"],seealso:["max","mean","median","min","prod","std","sum","variance"]},mad:{name:"mad",category:"Statistics",syntax:["mad(a, b, c, ...)","mad(A)"],description:"Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",examples:["mad(10, 20, 30)","mad([1, 2, 3])"],seealso:["mean","median","std","abs"]},max:{name:"max",category:"Statistics",syntax:["max(a, b, c, ...)","max(A)","max(A, dimension)"],description:"Compute the maximum value of a list of values.",examples:["max(2, 3, 4, 1)","max([2, 3, 4, 1])","max([2, 5; 4, 3])","max([2, 5; 4, 3], 1)","max([2, 5; 4, 3], 2)","max(2.7, 7.1, -4.5, 2.0, 4.1)","min(2.7, 7.1, -4.5, 2.0, 4.1)"],seealso:["mean","median","min","prod","std","sum","variance"]},mean:{name:"mean",category:"Statistics",syntax:["mean(a, b, c, ...)","mean(A)","mean(A, dimension)"],description:"Compute the arithmetic mean of a list of values.",examples:["mean(2, 3, 4, 1)","mean([2, 3, 4, 1])","mean([2, 5; 4, 3])","mean([2, 5; 4, 3], 1)","mean([2, 5; 4, 3], 2)","mean([1.0, 2.7, 3.2, 4.0])"],seealso:["max","median","min","prod","std","sum","variance"]},median:{name:"median",category:"Statistics",syntax:["median(a, b, c, ...)","median(A)"],description:"Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",examples:["median(5, 2, 7)","median([3, -1, 5, 7])"],seealso:["max","mean","min","prod","std","sum","variance","quantileSeq"]},min:{name:"min",category:"Statistics",syntax:["min(a, b, c, ...)","min(A)","min(A, dimension)"],description:"Compute the minimum value of a list of values.",examples:["min(2, 3, 4, 1)","min([2, 3, 4, 1])","min([2, 5; 4, 3])","min([2, 5; 4, 3], 1)","min([2, 5; 4, 3], 2)","min(2.7, 7.1, -4.5, 2.0, 4.1)","max(2.7, 7.1, -4.5, 2.0, 4.1)"],seealso:["max","mean","median","prod","std","sum","variance"]},mode:{name:"mode",category:"Statistics",syntax:["mode(a, b, c, ...)","mode(A)","mode(A, a, b, B, c, ...)"],description:"Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",examples:["mode(2, 1, 4, 3, 1)","mode([1, 2.7, 3.2, 4, 2.7])","mode(1, 4, 6, 1, 6)"],seealso:["max","mean","min","median","prod","std","sum","variance"]},prod:{name:"prod",category:"Statistics",syntax:["prod(a, b, c, ...)","prod(A)"],description:"Compute the product of all values.",examples:["prod(2, 3, 4)","prod([2, 3, 4])","prod([2, 5; 4, 3])"],seealso:["max","mean","min","median","min","std","sum","variance"]},quantileSeq:{name:"quantileSeq",category:"Statistics",syntax:["quantileSeq(A, prob[, sorted])","quantileSeq(A, [prob1, prob2, ...][, sorted])","quantileSeq(A, N[, sorted])"],description:"Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",examples:["quantileSeq([3, -1, 5, 7], 0.5)","quantileSeq([3, -1, 5, 7], [1/3, 2/3])","quantileSeq([3, -1, 5, 7], 2)","quantileSeq([-1, 3, 5, 7], 0.5, true)"],seealso:["mean","median","min","max","prod","std","sum","variance"]},std:{name:"std",category:"Statistics",syntax:["std(a, b, c, ...)","std(A)","std(A, dimension)","std(A, normalization)","std(A, dimension, normalization)"],description:'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',examples:["std(2, 4, 6)","std([2, 4, 6, 8])",'std([2, 4, 6, 8], "uncorrected")','std([2, 4, 6, 8], "biased")',"std([1, 2, 3; 4, 5, 6])"],seealso:["max","mean","min","median","prod","sum","variance"]},sum:{name:"sum",category:"Statistics",syntax:["sum(a, b, c, ...)","sum(A)","sum(A, dimension)"],description:"Compute the sum of all values.",examples:["sum(2, 3, 4, 1)","sum([2, 3, 4, 1])","sum([2, 5; 4, 3])"],seealso:["max","mean","median","min","prod","std","sum","variance"]},variance:{name:"variance",category:"Statistics",syntax:["variance(a, b, c, ...)","variance(A)","variance(A, dimension)","variance(A, normalization)","variance(A, dimension, normalization)"],description:'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',examples:["variance(2, 4, 6)","variance([2, 4, 6, 8])",'variance([2, 4, 6, 8], "uncorrected")','variance([2, 4, 6, 8], "biased")',"variance([1, 2, 3; 4, 5, 6])"],seealso:["max","mean","min","median","min","prod","std","sum"]},corr:{name:"corr",category:"Statistics",syntax:["corr(A,B)"],description:"Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",examples:["corr([2, 4, 6, 8],[1, 2, 3, 6])","corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],seealso:["max","mean","min","median","min","prod","std","sum"]},acos:{name:"acos",category:"Trigonometry",syntax:["acos(x)"],description:"Compute the inverse cosine of a value in radians.",examples:["acos(0.5)","acos(cos(2.3))"],seealso:["cos","atan","asin"]},acosh:{name:"acosh",category:"Trigonometry",syntax:["acosh(x)"],description:"Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",examples:["acosh(1.5)"],seealso:["cosh","asinh","atanh"]},acot:{name:"acot",category:"Trigonometry",syntax:["acot(x)"],description:"Calculate the inverse cotangent of a value.",examples:["acot(0.5)","acot(cot(0.5))","acot(2)"],seealso:["cot","atan"]},acoth:{name:"acoth",category:"Trigonometry",syntax:["acoth(x)"],description:"Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",examples:["acoth(2)","acoth(0.5)"],seealso:["acsch","asech"]},acsc:{name:"acsc",category:"Trigonometry",syntax:["acsc(x)"],description:"Calculate the inverse cotangent of a value.",examples:["acsc(2)","acsc(csc(0.5))","acsc(0.5)"],seealso:["csc","asin","asec"]},acsch:{name:"acsch",category:"Trigonometry",syntax:["acsch(x)"],description:"Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",examples:["acsch(0.5)"],seealso:["asech","acoth"]},asec:{name:"asec",category:"Trigonometry",syntax:["asec(x)"],description:"Calculate the inverse secant of a value.",examples:["asec(0.5)","asec(sec(0.5))","asec(2)"],seealso:["acos","acot","acsc"]},asech:{name:"asech",category:"Trigonometry",syntax:["asech(x)"],description:"Calculate the inverse secant of a value.",examples:["asech(0.5)"],seealso:["acsch","acoth"]},asin:{name:"asin",category:"Trigonometry",syntax:["asin(x)"],description:"Compute the inverse sine of a value in radians.",examples:["asin(0.5)","asin(sin(0.5))"],seealso:["sin","acos","atan"]},asinh:{name:"asinh",category:"Trigonometry",syntax:["asinh(x)"],description:"Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",examples:["asinh(0.5)"],seealso:["acosh","atanh"]},atan:{name:"atan",category:"Trigonometry",syntax:["atan(x)"],description:"Compute the inverse tangent of a value in radians.",examples:["atan(0.5)","atan(tan(0.5))"],seealso:["tan","acos","asin"]},atanh:{name:"atanh",category:"Trigonometry",syntax:["atanh(x)"],description:"Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",examples:["atanh(0.5)"],seealso:["acosh","asinh"]},atan2:{name:"atan2",category:"Trigonometry",syntax:["atan2(y, x)"],description:"Computes the principal value of the arc tangent of y/x in radians.",examples:["atan2(2, 2) / pi","angle = 60 deg in rad","x = cos(angle)","y = sin(angle)","atan2(y, x)"],seealso:["sin","cos","tan"]},cos:{name:"cos",category:"Trigonometry",syntax:["cos(x)"],description:"Compute the cosine of x in radians.",examples:["cos(2)","cos(pi / 4) ^ 2","cos(180 deg)","cos(60 deg)","sin(0.2)^2 + cos(0.2)^2"],seealso:["acos","sin","tan"]},cosh:{name:"cosh",category:"Trigonometry",syntax:["cosh(x)"],description:"Compute the hyperbolic cosine of x in radians.",examples:["cosh(0.5)"],seealso:["sinh","tanh","coth"]},cot:{name:"cot",category:"Trigonometry",syntax:["cot(x)"],description:"Compute the cotangent of x in radians. Defined as 1/tan(x)",examples:["cot(2)","1 / tan(2)"],seealso:["sec","csc","tan"]},coth:{name:"coth",category:"Trigonometry",syntax:["coth(x)"],description:"Compute the hyperbolic cotangent of x in radians.",examples:["coth(2)","1 / tanh(2)"],seealso:["sech","csch","tanh"]},csc:{name:"csc",category:"Trigonometry",syntax:["csc(x)"],description:"Compute the cosecant of x in radians. Defined as 1/sin(x)",examples:["csc(2)","1 / sin(2)"],seealso:["sec","cot","sin"]},csch:{name:"csch",category:"Trigonometry",syntax:["csch(x)"],description:"Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",examples:["csch(2)","1 / sinh(2)"],seealso:["sech","coth","sinh"]},sec:{name:"sec",category:"Trigonometry",syntax:["sec(x)"],description:"Compute the secant of x in radians. Defined as 1/cos(x)",examples:["sec(2)","1 / cos(2)"],seealso:["cot","csc","cos"]},sech:{name:"sech",category:"Trigonometry",syntax:["sech(x)"],description:"Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",examples:["sech(2)","1 / cosh(2)"],seealso:["coth","csch","cosh"]},sin:{name:"sin",category:"Trigonometry",syntax:["sin(x)"],description:"Compute the sine of x in radians.",examples:["sin(2)","sin(pi / 4) ^ 2","sin(90 deg)","sin(30 deg)","sin(0.2)^2 + cos(0.2)^2"],seealso:["asin","cos","tan"]},sinh:{name:"sinh",category:"Trigonometry",syntax:["sinh(x)"],description:"Compute the hyperbolic sine of x in radians.",examples:["sinh(0.5)"],seealso:["cosh","tanh"]},tan:{name:"tan",category:"Trigonometry",syntax:["tan(x)"],description:"Compute the tangent of x in radians.",examples:["tan(0.5)","sin(0.5) / cos(0.5)","tan(pi / 4)","tan(45 deg)"],seealso:["atan","sin","cos"]},tanh:{name:"tanh",category:"Trigonometry",syntax:["tanh(x)"],description:"Compute the hyperbolic tangent of x in radians.",examples:["tanh(0.5)","sinh(0.5) / cosh(0.5)"],seealso:["sinh","cosh"]},to:{name:"to",category:"Units",syntax:["x to unit","to(x, unit)"],description:"Change the unit of a value.",examples:["5 inch to cm","3.2kg to g","16 bytes in bits"],seealso:[]},clone:{name:"clone",category:"Utils",syntax:["clone(x)"],description:"Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",examples:["clone(3.5)","clone(2 - 4i)","clone(45 deg)","clone([1, 2; 3, 4])",'clone("hello world")'],seealso:[]},format:{name:"format",category:"Utils",syntax:["format(value)","format(value, precision)"],description:"Format a value of any type as string.",examples:["format(2.3)","format(3 - 4i)","format([])","format(pi, 3)"],seealso:["print"]},bin:{name:"bin",category:"Utils",syntax:["bin(value)"],description:"Format a number as binary",examples:["bin(2)"],seealso:["oct","hex"]},oct:{name:"oct",category:"Utils",syntax:["oct(value)"],description:"Format a number as octal",examples:["oct(56)"],seealso:["bin","hex"]},hex:{name:"hex",category:"Utils",syntax:["hex(value)"],description:"Format a number as hexadecimal",examples:["hex(240)"],seealso:["bin","oct"]},isNaN:{name:"isNaN",category:"Utils",syntax:["isNaN(x)"],description:"Test whether a value is NaN (not a number)",examples:["isNaN(2)","isNaN(0 / 0)","isNaN(NaN)","isNaN(Infinity)"],seealso:["isNegative","isNumeric","isPositive","isZero"]},isInteger:{name:"isInteger",category:"Utils",syntax:["isInteger(x)"],description:"Test whether a value is an integer number.",examples:["isInteger(2)","isInteger(3.5)","isInteger([3, 0.5, -2])"],seealso:["isNegative","isNumeric","isPositive","isZero"]},isNegative:{name:"isNegative",category:"Utils",syntax:["isNegative(x)"],description:"Test whether a value is negative: smaller than zero.",examples:["isNegative(2)","isNegative(0)","isNegative(-4)","isNegative([3, 0.5, -2])"],seealso:["isInteger","isNumeric","isPositive","isZero"]},isNumeric:{name:"isNumeric",category:"Utils",syntax:["isNumeric(x)"],description:"Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",examples:["isNumeric(2)",'isNumeric("2")','hasNumericValue("2")',"isNumeric(0)","isNumeric(bignumber(500))","isNumeric(fraction(0.125))","isNumeric(2 + 3i)",'isNumeric([2.3, "foo", false])'],seealso:["isInteger","isZero","isNegative","isPositive","isNaN","hasNumericValue"]},hasNumericValue:{name:"hasNumericValue",category:"Utils",syntax:["hasNumericValue(x)"],description:"Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",examples:["hasNumericValue(2)",'hasNumericValue("2")','isNumeric("2")',"hasNumericValue(0)","hasNumericValue(bignumber(500))","hasNumericValue(fraction(0.125))","hasNumericValue(2 + 3i)",'hasNumericValue([2.3, "foo", false])'],seealso:["isInteger","isZero","isNegative","isPositive","isNaN","isNumeric"]},isPositive:{name:"isPositive",category:"Utils",syntax:["isPositive(x)"],description:"Test whether a value is positive: larger than zero.",examples:["isPositive(2)","isPositive(0)","isPositive(-4)","isPositive([3, 0.5, -2])"],seealso:["isInteger","isNumeric","isNegative","isZero"]},isPrime:{name:"isPrime",category:"Utils",syntax:["isPrime(x)"],description:"Test whether a value is prime: has no divisors other than itself and one.",examples:["isPrime(3)","isPrime(-2)","isPrime([2, 17, 100])"],seealso:["isInteger","isNumeric","isNegative","isZero"]},isZero:{name:"isZero",category:"Utils",syntax:["isZero(x)"],description:"Test whether a value is zero.",examples:["isZero(2)","isZero(0)","isZero(-4)","isZero([3, 0, -2, 0])"],seealso:["isInteger","isNumeric","isNegative","isPositive"]},print:{name:"print",category:"Utils",syntax:["print(template, values)","print(template, values, precision)"],description:"Interpolate values into a string template.",examples:['print("Lucy is $age years old", {age: 5})','print("The value of pi is $pi", {pi: pi}, 3)','print("Hello, $user.name!", {user: {name: "John"}})','print("Values: $1, $2, $3", [6, 9, 4])'],seealso:["format"]},typeOf:{name:"typeOf",category:"Utils",syntax:["typeOf(x)"],description:"Get the type of a variable.",examples:["typeOf(3.5)","typeOf(2 - 4i)","typeOf(45 deg)",'typeOf("hello world")'],seealso:["getMatrixDataType"]},numeric:{name:"numeric",category:"Utils",syntax:["numeric(x)"],description:"Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",examples:['numeric("4")','numeric("4", "number")','numeric("4", "BigNumber")','numeric("4", "Fraction")','numeric(4, "Fraction")','numeric(fraction(2, 5), "number")'],seealso:["number","fraction","bignumber","string","format"]}},Ah="help",Sh=Se(Ah,["typed","mathWithTransform","Help"],(function(e){var t=e.typed,r=e.mathWithTransform,n=e.Help;return t(Ah,{any:function(e){var t,i=e;if("string"!=typeof e)for(t in r)if(Ae(r,t)&&e===r[t]){i=t;break}var a=ze(Eh,i);if(!a){var o="function"==typeof i?i.name:i;throw new Error('No documentation found on "'+o+'"')}return new n(a)}})})),Ch="chain",Mh=Se(Ch,["typed","Chain"],(function(e){var t=e.typed,r=e.Chain;return t(Ch,{"":function(){return new r},any:function(e){return new r(e)}})})),Fh=Se("det",["typed","matrix","subtractScalar","multiply","divideScalar","isZero","unaryMinus"],(function(e){var t=e.typed,r=e.matrix,n=e.subtractScalar,i=e.multiply,a=e.divideScalar,o=e.isZero,u=e.unaryMinus;return t("det",{any:function(e){return ye(e)},"Array | Matrix":function(e){var t;switch((t=l(e)?e.size():Array.isArray(e)?(e=r(e)).size():[]).length){case 0:return ye(e);case 1:if(1===t[0])return ye(e.valueOf()[0]);if(0===t[0])return 1;throw new RangeError("Matrix must be square (size: "+en(t)+")");case 2:var s=t[0],c=t[1];if(s===c)return function(e,t,r){if(1===t)return ye(e[0][0]);if(2===t)return n(i(e[0][0],e[1][1]),i(e[1][0],e[0][1]));for(var s=!1,c=new Array(t).fill(0).map((function(e,t){return t})),f=0;f<t;f++){var l=c[f];if(o(e[l][f])){var p=void 0;for(p=f+1;p<t;p++)if(!o(e[c[p]][f])){l=c[p],c[p]=c[f],c[f]=l,s=!s;break}if(p===t)return e[l][f]}for(var m=e[l][f],h=0===f?1:e[c[f-1]][f-1],d=f+1;d<t;d++)for(var v=c[d],y=f+1;y<t;y++)e[v][y]=a(n(i(e[v][y],m),i(e[v][f],e[l][y])),h)}var g=e[c[t-1]][t-1];return s?u(g):g}(e.clone().valueOf(),s);if(0===c)return 1;throw new RangeError("Matrix must be square (size: "+en(t)+")");default:throw new RangeError("Matrix must be two dimensional (size: "+en(t)+")")}}})})),Oh=Se("inv",["typed","matrix","divideScalar","addScalar","multiply","unaryMinus","det","identity","abs"],(function(e){var t=e.typed,r=e.matrix,n=e.divideScalar,i=e.addScalar,a=e.multiply,o=e.unaryMinus,u=e.det,s=e.identity,c=e.abs;return t("inv",{"Array | Matrix":function(e){var t=l(e)?e.size():cn(e);switch(t.length){case 1:if(1===t[0])return l(e)?r([n(1,e.valueOf()[0])]):[n(1,e[0])];throw new RangeError("Matrix must be square (size: "+en(t)+")");case 2:var i=t[0],a=t[1];if(i===a)return l(e)?r(f(e.valueOf(),i,a),e.storage()):f(e,i,a);throw new RangeError("Matrix must be square (size: "+en(t)+")");default:throw new RangeError("Matrix must be two dimensional (size: "+en(t)+")")}},any:function(e){return n(1,e)}});function f(e,t,r){var f,l,p,m,h;if(1===t){if(0===(m=e[0][0]))throw Error("Cannot calculate inverse, determinant is zero");return[[n(1,m)]]}if(2===t){var d=u(e);if(0===d)throw Error("Cannot calculate inverse, determinant is zero");return[[n(e[1][1],d),n(o(e[0][1]),d)],[n(o(e[1][0]),d),n(e[0][0],d)]]}var v=e.concat();for(f=0;f<t;f++)v[f]=v[f].concat();for(var y=s(t).valueOf(),g=0;g<r;g++){var x=c(v[g][g]),b=g;for(f=g+1;f<t;)c(v[f][g])>x&&(x=c(v[f][g]),b=f),f++;if(0===x)throw Error("Cannot calculate inverse, determinant is zero");(f=b)!==g&&(h=v[g],v[g]=v[f],v[f]=h,h=y[g],y[g]=y[f],y[f]=h);var w=v[g],D=y[g];for(f=0;f<t;f++){var N=v[f],E=y[f];if(f!==g){if(0!==N[g]){for(p=n(o(N[g]),w[g]),l=g;l<r;l++)N[l]=i(N[l],a(p,w[l]));for(l=0;l<r;l++)E[l]=i(E[l],a(p,D[l]))}}else{for(p=w[g],l=g;l<r;l++)N[l]=n(N[l],p);for(l=0;l<r;l++)E[l]=n(E[l],p)}}}return y}})),Th="pinv",_h=Se(Th,["typed","matrix","inv","deepEqual","equal","dotDivide","dot","ctranspose","divideScalar","multiply","add","Complex"],(function(e){var t=e.typed,r=e.matrix,n=e.inv,i=e.deepEqual,a=e.equal,o=e.dotDivide,u=e.dot,s=e.ctranspose,c=e.divideScalar,f=e.multiply,p=e.add,m=e.Complex;return t(Th,{"Array | Matrix":function(e){var t=l(e)?e.size():cn(e);switch(t.length){case 1:return v(e)?s(e):1===t[0]?n(e):o(s(e),u(e,e));case 2:if(v(e))return s(e);var i=t[0],a=t[1];if(i===a)try{return n(e)}catch(e){if(!(e instanceof Error&&e.message.match(/Cannot calculate inverse, determinant is zero/)))throw e}return l(e)?r(h(e.valueOf(),i,a),e.storage()):h(e,i,a);default:throw new RangeError("Matrix must be two dimensional (size: "+en(t)+")")}},any:function(e){return a(e,0)?ye(e):c(1,e)}});function h(e,t,r){var i=function(e,t,r){var n=function(e,t,r){for(var n=ye(e),i=0,a=0;a<t;a++){if(r<=i)return n;for(var u=a;d(n[u][i]);)if(t===++u&&(u=a,r===++i))return n;var s=[n[a],n[u]];n[u]=s[0],n[a]=s[1];for(var c=n[a][i],l=0;l<r;l++)n[a][l]=o(n[a][l],c);for(var m=0;m<t;m++)if(m!==a){c=n[m][i];for(var h=0;h<r;h++)n[m][h]=p(n[m][h],f(-1,f(c,n[a][h])))}i++}return n}(e,t,r);return{C:e.map((function(e,r){return e.filter((function(e,r){return r<t&&!d(u(n[r],n[r]))}))})),F:n.filter((function(e,t){return!d(u(n[t],n[t]))}))}}(e,t,r),a=i.C,c=i.F,l=f(n(f(s(a),a)),s(a)),m=f(s(c),n(f(c,s(c))));return f(m,l)}function d(e){return a(p(e,m(1,1)),p(0,m(1,1)))}function v(e){return i(p(e,m(1,1)),p(f(e,0),m(1,1)))}}));function Bh(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return kh(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?kh(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,o=!0,u=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return o=e.done,e},e:function(e){u=!0,a=e},f:function(){try{o||null==r.return||r.return()}finally{if(u)throw a}}}}function kh(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var Ih=Se("eigs",["config","typed","matrix","addScalar","equal","subtract","abs","atan","cos","sin","multiplyScalar","divideScalar","inv","bignumber","multiply","add","larger","column","flatten","number","complex","sqrt","diag","size","reshape","qr","usolve","usolveAll","im","re","smaller","matrixFromColumns","dot"],(function(e){var t=e.config,r=e.typed,n=e.matrix,s=e.addScalar,c=e.subtract,f=e.equal,l=e.abs,p=e.atan,m=e.cos,h=e.sin,d=e.multiplyScalar,v=e.divideScalar,y=e.inv,g=e.bignumber,x=e.multiply,b=e.add,w=e.larger,D=e.column,N=e.flatten,E=e.number,A=e.complex,S=e.sqrt,C=e.diag,M=e.size,F=e.reshape,O=e.qr,T=e.usolve,_=e.usolveAll,B=e.im,k=e.re,I=e.smaller,z=e.matrixFromColumns,R=e.dot,q=function(e){var t=e.config,r=e.addScalar,n=e.subtract,i=e.abs,a=e.atan,o=e.cos,u=e.sin,s=e.multiplyScalar,c=e.inv,f=e.bignumber,l=e.multiply,p=e.add;function m(e,t,r,n){for(var i=e.length,a=Math.cos(t),o=Math.sin(t),u=Array(i).fill(0),s=Array(i).fill(0),c=0;c<i;c++)u[c]=a*e[c][r]-o*e[c][n],s[c]=o*e[c][r]+a*e[c][n];for(var f=0;f<i;f++)e[f][r]=u[f],e[f][n]=s[f];return e}function h(e,t,i,a){for(var c=e.length,l=o(t),p=u(t),m=Array(c).fill(f(0)),h=Array(c).fill(f(0)),d=0;d<c;d++)m[d]=n(s(l,e[d][i]),s(p,e[d][a])),h[d]=r(s(p,e[d][i]),s(l,e[d][a]));for(var v=0;v<c;v++)e[v][i]=m[v],e[v][a]=h[v];return e}function d(e,t,i,a){for(var c=e.length,m=f(o(t)),h=f(u(t)),d=s(m,m),v=s(h,h),y=Array(c).fill(f(0)),g=Array(c).fill(f(0)),x=l(f(2),m,h,e[i][a]),b=r(n(s(d,e[i][i]),x),s(v,e[a][a])),w=p(s(v,e[i][i]),x,s(d,e[a][a])),D=0;D<c;D++)y[D]=n(s(m,e[i][D]),s(h,e[a][D])),g[D]=r(s(h,e[i][D]),s(m,e[a][D]));e[i][i]=b,e[a][a]=w,e[i][a]=f(0),e[a][i]=f(0);for(var N=0;N<c;N++)N!==i&&N!==a&&(e[i][N]=y[N],e[N][i]=y[N],e[a][N]=g[N],e[N][a]=g[N]);return e}function v(e,t,r,n){for(var i=e.length,a=Math.cos(t),o=Math.sin(t),u=a*a,s=o*o,c=Array(i).fill(0),f=Array(i).fill(0),l=u*e[r][r]-2*a*o*e[r][n]+s*e[n][n],p=s*e[r][r]+2*a*o*e[r][n]+u*e[n][n],m=0;m<i;m++)c[m]=a*e[r][m]-o*e[n][m],f[m]=o*e[r][m]+a*e[n][m];e[r][r]=l,e[n][n]=p,e[r][n]=0,e[n][r]=0;for(var h=0;h<i;h++)h!==r&&h!==n&&(e[r][h]=c[h],e[h][r]=c[h],e[n][h]=f[h],e[h][n]=f[h]);return e}function y(e){for(var t=e.length,r=0,n=[0,1],i=0;i<t;i++)for(var a=i+1;a<t;a++)Math.abs(r)<Math.abs(e[i][a])&&(r=Math.abs(e[i][a]),n=[i,a]);return[n,r]}function g(e){for(var t=e.length,r=0,n=[0,1],a=0;a<t;a++)for(var o=a+1;o<t;o++)i(r)<i(e[a][o])&&(r=i(e[a][o]),n=[a,o]);return[n,r]}function x(e,t,r){var n,a=e.length,o=Array(a);if(r){n=Array(a);for(var u=0;u<a;u++)n[u]=Array(a)}for(var s=0;s<a;s++){for(var c=0,f=e[0],l=0;l<e.length;l++)i(e[l])<i(f)&&(f=e[c=l]);if(o[s]=e.splice(c,1)[0],r)for(var p=0;p<a;p++)n[s][p]=t[p][c],t[p].splice(c,1)}if(!r)return{values:o};var m=n.map((function(e,t){return{value:o[t],vector:e}}));return{values:o,eigenvectors:m}}return function(e,r){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.epsilon,u=arguments.length>3?arguments[3]:void 0,p=arguments.length>4?arguments[4]:void 0;if("number"===u)return function(e,r,n){var i,a,o=e.length,u=Math.abs(r/o);if(n){a=new Array(o);for(var s=0;s<o;s++)a[s]=Array(o).fill(0),a[s][s]=1}for(var c,f,l,p,h=y(e);Math.abs(h[1])>=Math.abs(u);){var d=h[0][0],g=h[0][1];e=v(e,(c=e[d][d],f=e[g][g],l=e[d][g],p=void 0,p=f-c,i=Math.abs(p)<=t.epsilon?Math.PI/4:.5*Math.atan(2*l/(f-c))),d,g),n&&(a=m(a,i,d,g)),h=y(e)}for(var b=Array(o).fill(0),w=0;w<o;w++)b[w]=e[w][w];return x(ye(b),a,n)}(e,o,p);if("BigNumber"===u)return function(e,r,o){var u,p,m=e.length,v=i(r/m);if(o){p=new Array(m);for(var y=0;y<m;y++)p[y]=Array(m).fill(0),p[y][y]=1}for(var b,w,D,N,E=g(e);i(E[1])>=i(v);){var A=E[0][0],S=E[0][1];e=d(e,(b=e[A][A],w=e[S][S],D=e[A][S],N=void 0,N=n(w,b),u=i(N)<=t.epsilon?f(-1).acos().div(4):s(.5,a(l(2,D,c(N))))),A,S),o&&(p=h(p,u,A,S)),E=g(e)}for(var C=Array(m).fill(0),M=0;M<m;M++)C[M]=e[M][M];return x(ye(C),p,o)}(e,o,p);throw TypeError("Unsupported data type: "+u)}}({config:t,addScalar:s,subtract:c,column:D,flatten:N,equal:f,abs:l,atan:p,cos:m,sin:h,multiplyScalar:d,inv:y,bignumber:g,complex:A,multiply:x,add:b}),j=function(e){var t=e.addScalar,r=e.subtract,n=e.flatten,i=e.multiply,a=e.multiplyScalar,o=e.divideScalar,u=e.sqrt,s=e.abs,c=e.bignumber,f=e.diag,l=e.size,p=e.reshape,m=e.inv,h=e.qr,d=e.usolve,v=e.usolveAll,y=e.equal,g=e.complex,x=e.larger,b=e.smaller,w=(e.matrixFromColumns,e.dot);function D(e,t,n,i,a,o,u,f){var l="BigNumber"===f,p="Complex"===f,m=l?c(0):p?g(0):0,h=l?c(1):p?g(1):1;if(b(s(n),u))return[[h,m],[m,h]];if(x(s(r(a,o)),u))return[[r(a,i),r(o,i)],[n,n]];var d=r(e,a),v=r(i,a);return b(s(t),u)&&b(s(v),u)?[[d,h],[n,m]]:[[t,m],[v,h]]}function N(e,t){for(var r=0;r<e.length;r++){var n;(n=e[r]).push.apply(n,Te(Array(t-e[r].length).fill(0)))}for(var i=e.length;i<t;i++)e.push(Array(t).fill(0)),e[i][i]=1;return e}function E(e,t,r){for(var n=0;n<e.length;n++)if(r(e[n],t))return n;return-1}function A(e,t,r,n,i){for(var a,o="BigNumber"===i?c(1e3):1e3,u=0;u<5;++u){a=S(t,r,i);try{a=d(e,a)}catch(e){continue}if(x(M(a),o))break}if(u>=5)return null;for(u=0;;){var s=d(e,a);if(b(M(C(a,[s])),n))break;if(++u>=10)return null;a=F(s)}return a}function S(e,t,r){var n="BigNumber"===r,i="Complex"===r,a=Array(e).fill(0).map((function(e){return 2*Math.random()-1}));return n&&(a=a.map((function(e){return c(e)}))),i&&(a=a.map((function(e){return g(e)}))),F(a=C(a,t),r)}function C(e,t){var n,a=l(e),u=Bh(t);try{for(u.s();!(n=u.n()).done;){var s=n.value;s=p(s,a),e=r(e,i(o(w(s,e),w(s,s)),s))}}catch(e){u.e(e)}finally{u.f()}return e}function M(e){return s(u(w(e,e)))}function F(e,t){var r="Complex"===t,n="BigNumber"===t?c(1):r?g(1):1;return i(o(n,M(e)),e)}return function(e,l,p,d){var w=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],S=function(e,r,n,i,u){var l,p="BigNumber"===i,m="Complex"===i,h=p?c(0):0,d=p?c(1):m?g(1):1,v=p?c(1):1,w=p?c(10):2,D=a(w,w);u&&(l=Array(r).fill(d));for(var N=!1;!N;){N=!0;for(var E=0;E<r;E++){for(var A=h,S=h,C=0;C<r;C++)E!==C&&(A=t(A,s(e[C][E])),S=t(S,s(e[E][C])));if(!y(A,0)&&!y(S,0)){for(var M=v,F=A,O=o(S,w),T=a(S,w);b(F,O);)F=a(F,D),M=a(M,w);for(;x(F,T);)F=o(F,D),M=o(M,w);if(b(o(t(F,S),M),a(t(A,S),.95))){N=!1;for(var _=o(1,M),B=0;B<r;B++)E!==B&&(e[E][B]=a(e[E][B],_),e[B][E]=a(e[B][E],M));u&&(l[E]=a(l[E],_))}}}}return u?f(l):null}(e,l,0,d,w);!function(e,n,i,u,f,l){var p="BigNumber"===u,m="Complex"===u,h=p?c(0):m?g(0):0;p&&(i=c(i));for(var d=0;d<n-2;d++){for(var v=0,y=h,x=d+1;x<n;x++){var w=e[x][d];b(s(y),s(w))&&(y=w,v=x)}if(!b(s(y),i)){if(v!==d+1){var D=e[v];e[v]=e[d+1],e[d+1]=D;for(var N=0;N<n;N++){var E=e[N][v];e[N][v]=e[N][d+1],e[N][d+1]=E}if(f){var A=l[v];l[v]=l[d+1],l[d+1]=A}}for(var S=d+2;S<n;S++){var C=o(e[S][d],y);if(0!==C){for(var M=0;M<n;M++)e[S][M]=r(e[S][M],a(C,e[d+1][M]));for(var F=0;F<n;F++)e[F][d+1]=t(e[F][d+1],a(C,e[F][S]));if(f)for(var O=0;O<n;O++)l[S][O]=r(l[S][O],a(C,l[d+1][O]))}}}}}(e,l,p,d,w,S);var C=function(e,n,o,l,p){var m="BigNumber"===l,d="Complex"===l,v=m?c(1):d?g(1):1;m&&(o=c(o));for(var y,x,w,E,A,S,C,M,F=ye(e),O=[],T=n,_=[],B=p?f(Array(n).fill(v)):void 0,k=p?f(Array(T).fill(v)):void 0,I=0;I<=100;){I+=1;for(var z=F[T-1][T-1],R=0;R<T;R++)F[R][R]=r(F[R][R],z);var q=h(F),j=q.Q,P=q.R;F=i(P,j);for(var L=0;L<T;L++)F[L][L]=t(F[L][L],z);if(p&&(k=i(k,j)),1===T||b(s(F[T-1][T-2]),o)){I=0,O.push(F[T-1][T-1]),p&&(_.unshift([[1]]),N(k,n),B=i(B,k),T>1&&(k=f(Array(T-1).fill(v)))),T-=1,F.pop();for(var U=0;U<T;U++)F[U].pop()}else if(2===T||b(s(F[T-2][T-3]),o)){I=0;var $=(y=F[T-2][T-2],x=F[T-2][T-1],w=F[T-1][T-2],E=F[T-1][T-1],A=void 0,S=void 0,C=void 0,M=void 0,A=t(y,E),S=r(a(y,E),a(x,w)),C=a(A,.5),M=a(u(r(a(A,A),a(4,S))),.5),[t(C,M),r(C,M)]);O.push.apply(O,Te($)),p&&(_.unshift(D(F[T-2][T-2],F[T-2][T-1],F[T-1][T-2],F[T-1][T-1],$[0],$[1],o,l)),N(k,n),B=i(B,k),T>2&&(k=f(Array(T-2).fill(v)))),T-=2,F.pop(),F.pop();for(var H=0;H<T;H++)F[H].pop(),F[H].pop()}if(0===T)break}if(O.sort((function(e,t){return+r(s(e),s(t))})),I>100){var G=Error("The eigenvalues failed to converge. Only found these eigenvalues: "+O.join(", "));throw G.values=O,G.vectors=[],G}var V=p?i(B,function(e,t){for(var r=[],n=0;n<t;n++)r[n]=Array(t).fill(0);var i,a=0,o=Bh(e);try{for(o.s();!(i=o.n()).done;){for(var u=i.value,s=u.length,c=0;c<s;c++)for(var f=0;f<s;f++)r[a+c][a+f]=u[c][f];a+=s}}catch(e){o.e(e)}finally{o.f()}return r}(_,n)):void 0;return{values:O,C:V}}(e,l,p,d,w),M=C.values,F=C.C;if(w){var O=function(e,t,a,o,u,s,l){var p,h=m(a),d=i(h,e,a),x="BigNumber"===l,b="Complex"===l,w=x?c(0):b?g(0):0,D=x?c(1):b?g(1):1,N=[],S=[],C=Bh(u);try{for(C.s();!(p=C.n()).done;){var M=p.value,F=E(N,M,y);-1===F?(N.push(M),S.push(1)):S[F]+=1}}catch(e){C.e(e)}finally{C.f()}for(var O=[],T=N.length,_=Array(t).fill(w),B=f(Array(t).fill(D)),k=function(){var e=N[I],u=r(d,i(e,B)),c=v(u,_);for(c.shift();c.length<S[I];){var f=A(u,t,c,s,l);if(null===f)break;c.push(f)}var p=i(m(o),a);c=c.map((function(e){return i(p,e)})),O.push.apply(O,Te(c.map((function(t){return{value:e,vector:n(t)}}))))},I=0;I<T;I++)k();return O}(e,l,F,S,M,p,d);return{values:M,eigenvectors:O}}return{values:M}}}({config:t,addScalar:s,subtract:c,multiply:x,multiplyScalar:d,flatten:N,divideScalar:v,sqrt:S,abs:l,bignumber:g,diag:C,size:M,reshape:F,qr:O,inv:y,usolve:T,usolveAll:_,equal:f,complex:A,larger:w,smaller:I,matrixFromColumns:z,dot:R});return r("eigs",{Array:function(e){return P(n(e))},"Array, number|BigNumber":function(e,t){return P(n(e),{precision:t})},"Array, Object":function(e,t){return P(n(e),t)},Matrix:function(e){return P(e,{matricize:!0})},"Matrix, number|BigNumber":function(e,t){return P(e,{precision:t,matricize:!0})},"Matrix, Object":function(e,t){var r={matricize:!0};return Yr(r,t),P(e,r)}});function P(e){var r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=!("eigenvectors"in i)||i.eigenvectors,o=function(e,t,r){var n=e.toArray(),i=e.size();if(2!==i.length||i[0]!==i[1])throw new RangeError("Matrix must be square (size: ".concat(en(i),")"));var a=i[0];if(function(e,t,r){for(var n=0;n<t;n++)for(var i=0;i<t;i++)if(w(g(l(B(e[n][i]))),r))return!1;return!0}(n,a,t)&&(function(e,t){for(var r=0;r<t;r++)for(var n=0;n<t;n++)e[r][n]=k(e[r][n])}(n,a),function(e,t,r){for(var n=0;n<t;n++)for(var i=n;i<t;i++)if(w(g(l(c(e[n][i],e[i][n]))),r))return!1;return!0}(n,a,t))){var o=L(e,n,a);return q(n,a,t,o,r)}var u=L(e,n,a);return j(n,a,t,u,r)}(e,null!==(r=i.precision)&&void 0!==r?r:t.epsilon,a);return i.matricize&&(o.values=n(o.values),a&&(o.eigenvectors=o.eigenvectors.map((function(e){var t=e.value,r=e.vector;return{value:t,vector:n(r)}})))),a&&Object.defineProperty(o,"vectors",{enumerable:!1,get:function(){throw new Error("eigs(M).vectors replaced with eigs(M).eigenvectors")}}),o}function L(e,t,r){var n=e.datatype();if("number"===n||"BigNumber"===n||"Complex"===n)return n;for(var s=!1,c=!1,f=!1,l=0;l<r;l++)for(var p=0;p<r;p++){var m=t[l][p];if(i(m)||u(m))s=!0;else if(a(m))c=!0;else{if(!o(m))throw TypeError("Unsupported type in Matrix: "+H(m));f=!0}}if(c&&f&&console.warn("Complex BigNumbers not supported, this operation will lose precission."),f){for(var h=0;h<r;h++)for(var d=0;d<r;d++)t[h][d]=A(t[h][d]);return"Complex"}if(c){for(var v=0;v<r;v++)for(var y=0;y<r;y++)t[v][y]=g(t[v][y]);return"BigNumber"}if(s){for(var x=0;x<r;x++)for(var b=0;b<r;b++)t[x][b]=E(t[x][b]);return"number"}throw TypeError("Matrix contains unsupported types only.")}})),zh="expm",Rh=Se(zh,["typed","abs","add","identity","inv","multiply"],(function(e){var t=e.typed,r=e.abs,n=e.add,i=e.identity,a=e.inv,o=e.multiply;return t(zh,{Matrix:function(e){var t=e.size();if(2!==t.length||t[0]!==t[1])throw new RangeError("Matrix must be square (size: "+en(t)+")");for(var s=t[0],c=function(e){for(var t=e.size()[0],n=0,i=0;i<t;i++){for(var a=0,o=0;o<t;o++)a+=r(e.get([i,o]));n=Math.max(a,n)}return n}(e),f=function(e,t){for(var r=0;r<30;r++)for(var n=0;n<=r;n++){var i=r-n;if(u(e,n,i)<1e-15)return{q:n,j:i}}throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)")}(c),l=f.q,p=f.j,m=o(e,Math.pow(2,-p)),d=i(s),v=i(s),y=1,g=m,x=-1,b=1;b<=l;b++)b>1&&(g=o(g,m),x=-x),d=n(d,o(y=y*(l-b+1)/((2*l-b+1)*b),g)),v=n(v,o(y*x,g));for(var w=o(a(v),d),D=0;D<p;D++)w=o(w,w);return h(e)?e.createSparseMatrix(w):w}});function u(e,t,r){for(var n=1,i=2;i<=t;i++)n*=i;for(var a=n,o=t+1;o<=2*t;o++)a*=o;var u=a*(2*t+1);return 8*Math.pow(e/Math.pow(2,r),2*t)*n*n/(a*u)}})),qh="sqrtm",jh=Se(qh,["typed","abs","add","multiply","map","sqrt","subtract","inv","size","max","identity"],(function(e){var t=e.typed,r=e.abs,n=e.add,i=e.multiply,a=e.map,o=e.sqrt,u=e.subtract,s=e.inv,c=e.size,f=e.max,p=e.identity,m=1e-6;function h(e){var t,a=0,o=e,l=p(c(e));do{var h=o;if(o=i(.5,n(h,s(l))),l=i(.5,n(l,s(h))),(t=f(r(u(o,h))))>m&&++a>1e3)throw new Error("computing square root of matrix: iterative method could not converge")}while(t>m);return o}return t(qh,{"Array | Matrix":function(e){var t=l(e)?e.size():cn(e);switch(t.length){case 1:if(1===t[0])return a(e,o);throw new RangeError("Matrix must be square (size: "+en(t)+")");case 2:if(t[0]===t[1])return h(e);throw new RangeError("Matrix must be square (size: "+en(t)+")");default:throw new RangeError("Matrix must be at most two dimensional (size: "+en(t)+")")}}})})),Ph="sylvester",Lh=Se(Ph,["typed","schur","matrixFromColumns","matrix","multiply","range","concat","transpose","index","subset","add","subtract","identity","lusolve","abs"],(function(e){var t=e.typed,r=e.schur,n=e.matrixFromColumns,i=e.matrix,a=e.multiply,o=e.range,u=e.concat,s=e.transpose,c=e.index,f=e.subset,l=e.add,p=e.subtract,m=e.identity,h=e.lusolve,d=e.abs;return t(Ph,{"Matrix, Matrix, Matrix":v,"Array, Matrix, Matrix":function(e,t,r){return v(i(e),t,r)},"Array, Array, Matrix":function(e,t,r){return v(i(e),i(t),r)},"Array, Matrix, Array":function(e,t,r){return v(i(e),t,i(r))},"Matrix, Array, Matrix":function(e,t,r){return v(e,i(t),r)},"Matrix, Array, Array":function(e,t,r){return v(e,i(t),i(r))},"Matrix, Matrix, Array":function(e,t,r){return v(e,t,i(r))},"Array, Array, Array":function(e,t,r){return v(i(e),i(t),i(r)).toArray()}});function v(e,t,v){for(var y=t.size()[0],g=e.size()[0],x=r(e),b=x.T,w=x.U,D=r(a(-1,t)),N=D.T,E=D.U,A=a(a(s(w),v),E),S=o(0,g),C=[],M=function(e,t){return u(e,t,1)},F=function(e,t){return u(e,t,0)},O=0;O<y;O++)if(O<y-1&&d(f(N,c(O+1,O)))>1e-5){for(var T=F(f(A,c(S,O)),f(A,c(S,O+1))),_=0;_<O;_++)T=l(T,F(a(C[_],f(N,c(_,O))),a(C[_],f(N,c(_,O+1)))));var B=a(m(g),a(-1,f(N,c(O,O)))),k=a(m(g),a(-1,f(N,c(O+1,O)))),I=a(m(g),a(-1,f(N,c(O,O+1)))),z=a(m(g),a(-1,f(N,c(O+1,O+1)))),R=F(M(l(b,B),k),M(I,l(b,z))),q=h(R,T);C[O]=q.subset(c(o(0,g),0)),C[O+1]=q.subset(c(o(g,2*g),0)),O++}else{for(var j=f(A,c(S,O)),P=0;P<O;P++)j=l(j,a(C[P],f(N,c(P,O))));var L=f(N,c(O,O)),U=p(b,a(L,m(g)));C[O]=h(U,j)}var $=i(n.apply(void 0,C));return a(w,a($,s(E)))}})),Uh="schur",$h=Se(Uh,["typed","matrix","identity","multiply","qr","norm","subtract"],(function(e){var t=e.typed,r=e.matrix,n=e.identity,i=e.multiply,a=e.qr,o=e.norm,u=e.subtract;return t(Uh,{Array:function(e){var t=s(r(e));return{U:t.U.valueOf(),T:t.T.valueOf()}},Matrix:function(e){return s(e)}});function s(e){var t,r=e.size()[0],s=e,c=n(r),f=0;do{t=s;var l=a(s),p=l.Q,m=l.R;if(s=i(m,p),c=i(c,p),f++>100)break}while(o(u(s,t))>1e-4);return{U:c,T:s}}})),Hh="lyap",Gh=Se(Hh,["typed","matrix","sylvester","multiply","transpose"],(function(e){var t=e.typed,r=e.matrix,n=e.sylvester,i=e.multiply,a=e.transpose;return t(Hh,{"Matrix, Matrix":function(e,t){return n(e,a(e),i(-1,t))},"Array, Matrix":function(e,t){return n(r(e),a(r(e)),i(-1,t))},"Matrix, Array":function(e,t){return n(e,a(r(e)),r(i(-1,t)))},"Array, Array":function(e,t){return n(r(e),a(r(e)),r(i(-1,t))).toArray()}})})),Vh=Se("divide",["typed","matrix","multiply","equalScalar","divideScalar","inv"],(function(e){var t=e.typed,r=e.matrix,n=e.multiply,i=e.equalScalar,a=e.divideScalar,o=e.inv,u=Sa({typed:t,equalScalar:i}),s=Ma({typed:t});return t("divide",xe({"Array | Matrix, Array | Matrix":function(e,t){return n(e,o(t))},"DenseMatrix, any":function(e,t){return s(e,t,a,!1)},"SparseMatrix, any":function(e,t){return u(e,t,a,!1)},"Array, any":function(e,t){return s(r(e),t,a,!1).valueOf()},"any, Array | Matrix":function(e,t){return n(e,o(t))}},a.signatures))})),Zh="distance",Wh=Se(Zh,["typed","addScalar","subtractScalar","divideScalar","multiplyScalar","deepEqual","sqrt","abs"],(function(e){var t=e.typed,r=e.addScalar,n=e.subtractScalar,i=e.multiplyScalar,o=e.divideScalar,u=e.deepEqual,s=e.sqrt,c=e.abs;return t(Zh,{"Array, Array, Array":function(e,t,r){if(2===e.length&&2===t.length&&2===r.length){if(!l(e))throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");if(!l(t))throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");if(!l(r))throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");if(u(t,r))throw new TypeError("LinePoint1 should not be same with LinePoint2");var a=n(r[1],t[1]),o=n(t[0],r[0]),s=n(i(r[0],t[1]),i(t[0],r[1]));return v(e[0],e[1],a,o,s)}throw new TypeError("Invalid Arguments: Try again")},"Object, Object, Object":function(e,t,r){if(2===Object.keys(e).length&&2===Object.keys(t).length&&2===Object.keys(r).length){if(!l(e))throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");if(!l(t))throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");if(!l(r))throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");if(u(d(t),d(r)))throw new TypeError("LinePoint1 should not be same with LinePoint2");if("pointX"in e&&"pointY"in e&&"lineOnePtX"in t&&"lineOnePtY"in t&&"lineTwoPtX"in r&&"lineTwoPtY"in r){var a=n(r.lineTwoPtY,t.lineOnePtY),o=n(t.lineOnePtX,r.lineTwoPtX),s=n(i(r.lineTwoPtX,t.lineOnePtY),i(t.lineOnePtX,r.lineTwoPtY));return v(e.pointX,e.pointY,a,o,s)}throw new TypeError("Key names do not match")}throw new TypeError("Invalid Arguments: Try again")},"Array, Array":function(e,t){if(2===e.length&&3===t.length){if(!l(e))throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");if(!p(t))throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");return v(e[0],e[1],t[0],t[1],t[2])}if(3===e.length&&6===t.length){if(!p(e))throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");if(!h(t))throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");return y(e[0],e[1],e[2],t[0],t[1],t[2],t[3],t[4],t[5])}if(e.length===t.length&&e.length>0){if(!m(e))throw new TypeError("All values of an array should be numbers or BigNumbers");if(!m(t))throw new TypeError("All values of an array should be numbers or BigNumbers");return g(e,t)}throw new TypeError("Invalid Arguments: Try again")},"Object, Object":function(e,t){if(2===Object.keys(e).length&&3===Object.keys(t).length){if(!l(e))throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");if(!p(t))throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");if("pointX"in e&&"pointY"in e&&"xCoeffLine"in t&&"yCoeffLine"in t&&"constant"in t)return v(e.pointX,e.pointY,t.xCoeffLine,t.yCoeffLine,t.constant);throw new TypeError("Key names do not match")}if(3===Object.keys(e).length&&6===Object.keys(t).length){if(!p(e))throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");if(!h(t))throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");if("pointX"in e&&"pointY"in e&&"x0"in t&&"y0"in t&&"z0"in t&&"a"in t&&"b"in t&&"c"in t)return y(e.pointX,e.pointY,e.pointZ,t.x0,t.y0,t.z0,t.a,t.b,t.c);throw new TypeError("Key names do not match")}if(2===Object.keys(e).length&&2===Object.keys(t).length){if(!l(e))throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");if(!l(t))throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");if("pointOneX"in e&&"pointOneY"in e&&"pointTwoX"in t&&"pointTwoY"in t)return g([e.pointOneX,e.pointOneY],[t.pointTwoX,t.pointTwoY]);throw new TypeError("Key names do not match")}if(3===Object.keys(e).length&&3===Object.keys(t).length){if(!p(e))throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");if(!p(t))throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");if("pointOneX"in e&&"pointOneY"in e&&"pointOneZ"in e&&"pointTwoX"in t&&"pointTwoY"in t&&"pointTwoZ"in t)return g([e.pointOneX,e.pointOneY,e.pointOneZ],[t.pointTwoX,t.pointTwoY,t.pointTwoZ]);throw new TypeError("Key names do not match")}throw new TypeError("Invalid Arguments: Try again")},Array:function(e){if(!function(e){if(2===e[0].length&&f(e[0][0])&&f(e[0][1])){if(e.some((function(e){return 2!==e.length||!f(e[0])||!f(e[1])})))return!1}else{if(!(3===e[0].length&&f(e[0][0])&&f(e[0][1])&&f(e[0][2])))return!1;if(e.some((function(e){return 3!==e.length||!f(e[0])||!f(e[1])||!f(e[2])})))return!1}return!0}(e))throw new TypeError("Incorrect array format entered for pairwise distance calculation");return function(e){for(var t=[],r=[],n=[],i=0;i<e.length-1;i++)for(var a=i+1;a<e.length;a++)2===e[0].length?(r=[e[i][0],e[i][1]],n=[e[a][0],e[a][1]]):3===e[0].length&&(r=[e[i][0],e[i][1],e[i][2]],n=[e[a][0],e[a][1],e[a][2]]),t.push(g(r,n));return t}(e)}});function f(e){return"number"==typeof e||a(e)}function l(e){return e.constructor!==Array&&(e=d(e)),f(e[0])&&f(e[1])}function p(e){return e.constructor!==Array&&(e=d(e)),f(e[0])&&f(e[1])&&f(e[2])}function m(e){return Array.isArray(e)||(e=d(e)),e.every(f)}function h(e){return e.constructor!==Array&&(e=d(e)),f(e[0])&&f(e[1])&&f(e[2])&&f(e[3])&&f(e[4])&&f(e[5])}function d(e){for(var t=Object.keys(e),r=[],n=0;n<t.length;n++)r.push(e[t[n]]);return r}function v(e,t,n,a,u){var f=c(r(r(i(n,e),i(a,t)),u)),l=s(r(i(n,n),i(a,a)));return o(f,l)}function y(e,t,a,u,c,f,l,p,m){var h=[n(i(n(c,t),m),i(n(f,a),p)),n(i(n(f,a),l),i(n(u,e),m)),n(i(n(u,e),p),i(n(c,t),l))];h=s(r(r(i(h[0],h[0]),i(h[1],h[1])),i(h[2],h[2])));var d=s(r(r(i(l,l),i(p,p)),i(m,m)));return o(h,d)}function g(e,t){for(var a=e.length,o=0,u=0,c=0;c<a;c++)u=n(e[c],t[c]),o=r(i(u,u),o);return s(o)}})),Yh=Se("intersect",["typed","config","abs","add","addScalar","matrix","multiply","multiplyScalar","divideScalar","subtract","smaller","equalScalar","flatten","isZero","isNumeric"],(function(e){var t=e.typed,r=e.config,n=e.abs,i=e.add,a=e.addScalar,o=e.matrix,u=e.multiply,s=e.multiplyScalar,c=e.divideScalar,f=e.subtract,l=e.smaller,p=e.equalScalar,m=e.flatten,h=e.isZero,d=e.isNumeric;return t("intersect",{"Array, Array, Array":v,"Array, Array, Array, Array":y,"Matrix, Matrix, Matrix":function(e,t,r){var n=v(e.valueOf(),t.valueOf(),r.valueOf());return null===n?null:o(n)},"Matrix, Matrix, Matrix, Matrix":function(e,t,r,n){var i=y(e.valueOf(),t.valueOf(),r.valueOf(),n.valueOf());return null===i?null:o(i)}});function v(e,t,r){if(e=g(e),t=g(t),r=g(r),!b(e))throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");if(!b(t))throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");if(!function(e){return 4===e.length&&d(e[0])&&d(e[1])&&d(e[2])&&d(e[3])}(r))throw new TypeError("Array with 4 numbers expected as third argument");return function(e,t,r,n,i,o,u,l,p,m){var h=s(e,u),d=s(n,u),v=s(t,l),y=s(i,l),g=s(r,p),x=s(o,p),b=f(f(f(m,h),v),g),w=f(f(f(a(a(d,y),x),h),v),g),D=c(b,w);return[a(e,s(D,f(n,e))),a(t,s(D,f(i,t))),a(r,s(D,f(o,r)))]}(e[0],e[1],e[2],t[0],t[1],t[2],r[0],r[1],r[2],r[3])}function y(e,t,o,m){if(e=g(e),t=g(t),o=g(o),m=g(m),2===e.length){if(!x(e))throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");if(!x(t))throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");if(!x(o))throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");if(!x(m))throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");return function(e,t,o,p){var m=e,d=o,v=f(m,t),y=f(d,p),g=f(s(v[0],y[1]),s(y[0],v[1]));if(h(g))return null;if(l(n(g),r.epsilon))return null;var x=s(y[0],m[1]),b=s(y[1],m[0]),w=s(y[0],d[1]),D=s(y[1],d[0]),N=c(a(f(f(x,b),w),D),g);return i(u(v,N),m)}(e,t,o,m)}if(3===e.length){if(!b(e))throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");if(!b(t))throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");if(!b(o))throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");if(!b(m))throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");return function(e,t,r,n,i,o,u,l,m,d,v,y){var g=w(e,u,d,u,t,l,v,l,r,m,y,m),x=w(d,u,n,e,v,l,i,t,y,m,o,r),b=w(e,u,n,e,t,l,i,t,r,m,o,r),D=w(d,u,d,u,v,l,v,l,y,m,y,m),N=w(n,e,n,e,i,t,i,t,o,r,o,r),E=f(s(g,x),s(b,D)),A=f(s(N,D),s(x,x));if(h(A))return null;var S=c(E,A),C=c(a(g,s(S,x)),D),M=a(e,s(S,f(n,e))),F=a(t,s(S,f(i,t))),O=a(r,s(S,f(o,r))),T=a(u,s(C,f(d,u))),_=a(l,s(C,f(v,l))),B=a(m,s(C,f(y,m)));return p(M,T)&&p(F,_)&&p(O,B)?[M,F,O]:null}(e[0],e[1],e[2],t[0],t[1],t[2],o[0],o[1],o[2],m[0],m[1],m[2])}throw new TypeError("Arrays with two or thee dimensional points expected")}function g(e){return 1===e.length?e[0]:e.length>1&&Array.isArray(e[0])&&e.every((function(e){return Array.isArray(e)&&1===e.length}))?m(e):e}function x(e){return 2===e.length&&d(e[0])&&d(e[1])}function b(e){return 3===e.length&&d(e[0])&&d(e[1])&&d(e[2])}function w(e,t,r,n,i,o,u,c,l,p,m,h){var d=s(f(e,t),f(r,n)),v=s(f(i,o),f(u,c)),y=s(f(l,p),f(m,h));return a(a(d,v),y)}})),Jh=Se("sum",["typed","config","add","numeric"],(function(e){var t=e.typed,r=e.config,n=e.add,i=e.numeric;return t("sum",{"Array | Matrix":a,"Array | Matrix, number | BigNumber":function(e,t){try{return Yn(e,t,n)}catch(e){throw qs(e,"sum")}},"...":function(e){if(Vn(e))throw new TypeError("Scalar values expected in function sum");return a(e)}});function a(e){var t;return Zn(e,(function(e){try{t=void 0===t?e:n(t,e)}catch(t){throw qs(t,"sum",e)}})),void 0===t&&(t=i(0,r.number)),"string"==typeof t&&(t=i(t,r.number)),t}})),Xh="cumsum",Qh=Se(Xh,["typed","add","unaryPlus"],(function(e){var t=e.typed,r=e.add,n=e.unaryPlus;return t(Xh,{Array:i,Matrix:function(e){return e.create(i(e.valueOf()))},"Array, number | BigNumber":o,"Matrix, number | BigNumber":function(e,t){return e.create(o(e.valueOf(),t))},"...":function(e){if(Vn(e))throw new TypeError("All values expected to be scalar in function cumsum");return i(e)}});function i(e){try{return a(e)}catch(e){throw qs(e,Xh)}}function a(e){if(0===e.length)return[];for(var t=[n(e[0])],i=1;i<e.length;++i)t.push(r(t[i-1],e[i]));return t}function o(e,t){var r=cn(e);if(t<0||t>=r.length)throw new sn(t,r.length);try{return u(e,t)}catch(e){throw qs(e,Xh)}}function u(e,t){var r,n,i;if(t<=0){var o=e[0][0];if(Array.isArray(o)){for(i=Gn(e),n=[],r=0;r<i.length;r++)n[r]=u(i[r],t-1);return n}return a(e)}for(n=[],r=0;r<e.length;r++)n[r]=u(e[r],t-1);return n}})),Kh="mean",ed=Se(Kh,["typed","add","divide"],(function(e){var t=e.typed,r=e.add,n=e.divide;return t(Kh,{"Array | Matrix":i,"Array | Matrix, number | BigNumber":function(e,t){try{var i=Yn(e,t,r),a=Array.isArray(e)?cn(e):e.size();return n(i,a[t])}catch(e){throw qs(e,"mean")}},"...":function(e){if(Vn(e))throw new TypeError("Scalar values expected in function mean");return i(e)}});function i(e){var t,i=0;if(Zn(e,(function(e){try{t=void 0===t?e:r(t,e),i++}catch(t){throw qs(t,"mean",e)}})),0===i)throw new Error("Cannot calculate the mean of an empty array");return n(t,i)}})),td="median",rd=Se(td,["typed","add","divide","compare","partitionSelect"],(function(e){var t=e.typed,r=e.add,n=e.divide,i=e.compare,a=e.partitionSelect;function o(e){try{var t=(e=En(e.valueOf())).length;if(0===t)throw new Error("Cannot calculate median of an empty array");if(t%2==0){for(var r=t/2-1,n=a(e,r+1),o=e[r],c=0;c<r;++c)i(e[c],o)>0&&(o=e[c]);return s(o,n)}var f=a(e,(t-1)/2);return u(f)}catch(e){throw qs(e,"median")}}var u=t({"number | BigNumber | Complex | Unit":function(e){return e}}),s=t({"number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit":function(e,t){return n(r(e,t),2)}});return t(td,{"Array | Matrix":o,"Array | Matrix, number | BigNumber":function(e,t){throw new Error("median(A, dim) is not yet supported")},"...":function(e){if(Vn(e))throw new TypeError("Scalar values expected in function median");return o(e)}})})),nd=Se("mad",["typed","abs","map","median","subtract"],(function(e){var t=e.typed,r=e.abs,n=e.map,i=e.median,a=e.subtract;return t("mad",{"Array | Matrix":o,"...":function(e){return o(e)}});function o(e){if(0===(e=En(e.valueOf())).length)throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");try{var t=i(e);return i(n(e,(function(e){return r(a(e,t))})))}catch(e){throw e instanceof TypeError&&-1!==e.message.indexOf("median")?new TypeError(e.message.replace("median","mad")):qs(e,"mad")}}})),id="unbiased",ad="variance",od=Se(ad,["typed","add","subtract","multiply","divide","apply","isNaN"],(function(e){var t=e.typed,r=e.add,n=e.subtract,i=e.multiply,o=e.divide,u=e.apply,s=e.isNaN;return t(ad,{"Array | Matrix":function(e){return c(e,id)},"Array | Matrix, string":c,"Array | Matrix, number | BigNumber":function(e,t){return f(e,t,id)},"Array | Matrix, number | BigNumber, string":f,"...":function(e){return c(e,id)}});function c(e,t){var u,c=0;if(0===e.length)throw new SyntaxError("Function variance requires one or more parameters (0 provided)");if(Zn(e,(function(e){try{u=void 0===u?e:r(u,e),c++}catch(t){throw qs(t,"variance",e)}})),0===c)throw new Error("Cannot calculate variance of an empty array");var f=o(u,c);if(u=void 0,Zn(e,(function(e){var t=n(e,f);u=void 0===u?i(t,t):r(u,i(t,t))})),s(u))return u;switch(t){case"uncorrected":return o(u,c);case"biased":return o(u,c+1);case"unbiased":var l=a(u)?u.mul(0):0;return 1===c?l:o(u,c-1);default:throw new Error('Unknown normalization "'+t+'". Choose "unbiased" (default), "uncorrected", or "biased".')}}function f(e,t,r){try{if(0===e.length)throw new SyntaxError("Function variance requires one or more parameters (0 provided)");return u(e,t,(function(e){return c(e,r)}))}catch(e){throw qs(e,"variance")}}})),ud="quantileSeq",sd=Se(ud,["typed","?bignumber","add","subtract","divide","multiply","partitionSelect","compare","isInteger","smaller","smallerEq","larger"],(function(e){var t=e.typed,r=e.bignumber,n=e.add,a=e.subtract,o=e.divide,u=e.multiply,s=e.partitionSelect,c=e.compare,f=e.isInteger,l=e.smaller,p=e.smallerEq,m=e.larger,h=ya({typed:t,isInteger:f});return t(ud,{"Array | Matrix, number | BigNumber":function(e,t){return v(e,t,!1)},"Array | Matrix, number | BigNumber, number":function(e,t,r){return d(e,t,!1,r,v)},"Array | Matrix, number | BigNumber, boolean":v,"Array | Matrix, number | BigNumber, boolean, number":function(e,t,r,n){return d(e,t,r,n,v)},"Array | Matrix, Array | Matrix":function(e,t){return y(e,t,!1)},"Array | Matrix, Array | Matrix, number":function(e,t,r){return d(e,t,!1,r,y)},"Array | Matrix, Array | Matrix, boolean":y,"Array | Matrix, Array | Matrix, boolean, number":function(e,t,r,n){return d(e,t,r,n,y)}});function d(e,t,r,n,i){return h(e,n,(function(e){return i(e,t,r)}))}function v(e,t,a){var u,s=e.valueOf();if(l(t,0))throw new Error("N/prob must be non-negative");if(p(t,1))return i(t)?g(s,t,a):r(g(s,t,a));if(m(t,1)){if(!f(t))throw new Error("N must be a positive integer");if(m(t,4294967295))throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");var c=n(t,1);u=[];for(var h=0;l(h,t);h++){var d=o(h+1,c);u.push(g(s,d,a))}return i(t)?u:r(u)}}function y(e,t,r){for(var n=e.valueOf(),i=t.valueOf(),a=[],o=0;o<i.length;++o)a.push(g(n,i[o],r));return a}function g(e,t,r){var o=En(e),l=o.length;if(0===l)throw new Error("Cannot calculate quantile of an empty sequence");var p,m,h=i(t)?t*(l-1):t.times(l-1),d=i(t)?Math.floor(h):h.floor().toNumber(),v=i(t)?h%1:h.minus(d);if(f(h))return r?o[h]:s(o,i(t)?h:h.valueOf());if(r)p=o[d],m=o[d+1];else{m=s(o,d+1),p=o[d];for(var y=0;y<d;++y)c(o[y],p)>0&&(p=o[y])}return n(u(p,a(1,v)),u(m,v))}})),cd=Se("std",["typed","map","sqrt","variance"],(function(e){var t=e.typed,r=e.map,n=e.sqrt,i=e.variance;return t("std",{"Array | Matrix":a,"Array | Matrix, string":a,"Array | Matrix, number | BigNumber":a,"Array | Matrix, number | BigNumber, string":a,"...":function(e){return a(e)}});function a(e,t){if(0===e.length)throw new SyntaxError("Function std requires one or more parameters (0 provided)");try{var a=i.apply(null,arguments);return p(a)?r(a,n):n(a)}catch(e){throw e instanceof TypeError&&-1!==e.message.indexOf(" variance")?new TypeError(e.message.replace(" variance"," std")):e}}})),fd="corr",ld=Se(fd,["typed","matrix","mean","sqrt","sum","add","subtract","multiply","pow","divide"],(function(e){var t=e.typed,r=e.matrix,n=e.sqrt,i=e.sum,a=e.add,o=e.subtract,u=e.multiply,s=e.pow,c=e.divide;return t(fd,{"Array, Array":function(e,t){return f(e,t)},"Matrix, Matrix":function(e,t){var n=f(e.toArray(),t.toArray());return Array.isArray(n)?r(n):n}});function f(e,t){var r=[];if(Array.isArray(e[0])&&Array.isArray(t[0])){if(e.length!==t.length)throw new SyntaxError("Dimension mismatch. Array A and B must have the same length.");for(var n=0;n<e.length;n++){if(e[n].length!==t[n].length)throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");r.push(l(e[n],t[n]))}return r}if(e.length!==t.length)throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");return l(e,t)}function l(e,t){var r=e.length,f=i(e),l=i(t),p=e.reduce((function(e,r,n){return a(e,u(r,t[n]))}),0),m=i(e.map((function(e){return s(e,2)}))),h=i(t.map((function(e){return s(e,2)}))),d=o(u(r,p),u(f,l)),v=n(u(o(u(r,m),s(f,2)),o(u(r,h),s(l,2))));return c(d,v)}}));function pd(e,t){if(t<e)return 1;if(t===e)return t;var r=t+e>>1;return pd(e,r)*pd(r+1,t)}function md(e,t){if(!V(e)||e<0)throw new TypeError("Positive integer value expected in function combinations");if(!V(t)||t<0)throw new TypeError("Positive integer value expected in function combinations");if(t>e)throw new TypeError("k must be less than or equal to n");for(var r=e-t,n=1,i=2,a=t<r?t:r,o=t<r?r+1:t+1;o<=e;++o)for(n*=o;i<=a&&n%i==0;)n/=i,++i;return i<=a&&(n/=pd(i,a)),n}md.signature="number, number";var hd="combinations",dd=Se(hd,["typed"],(function(e){return(0,e.typed)(hd,{"number, number":md,"BigNumber, BigNumber":function(e,t){var r,n,i=e.constructor,a=e.minus(t),o=new i(1);if(!vd(e)||!vd(t))throw new TypeError("Positive integer value expected in function combinations");if(t.gt(e))throw new TypeError("k must be less than n in function combinations");if(r=o,t.lt(a))for(n=o;n.lte(a);n=n.plus(o))r=r.times(t.plus(n)).dividedBy(n);else for(n=o;n.lte(t);n=n.plus(o))r=r.times(a.plus(n)).dividedBy(n);return r}})}));function vd(e){return e.isInteger()&&e.gte(0)}var yd="combinationsWithRep",gd=Se(yd,["typed"],(function(e){return(0,e.typed)(yd,{"number, number":function(e,t){if(!V(e)||e<0)throw new TypeError("Positive integer value expected in function combinationsWithRep");if(!V(t)||t<0)throw new TypeError("Positive integer value expected in function combinationsWithRep");if(e<1)throw new TypeError("k must be less than or equal to n + k - 1");return t<e-1?pd(e,e+t-1)/pd(1,t):pd(t+1,e+t-1)/pd(1,e-1)},"BigNumber, BigNumber":function(e,t){var r,n,i=new(0,e.constructor)(1),a=e.minus(i);if(!xd(e)||!xd(t))throw new TypeError("Positive integer value expected in function combinationsWithRep");if(e.lt(i))throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");if(r=i,t.lt(a))for(n=i;n.lte(a);n=n.plus(i))r=r.times(t.plus(n)).dividedBy(n);else for(n=i;n.lte(t);n=n.plus(i))r=r.times(a.plus(n)).dividedBy(n);return r}})}));function xd(e){return e.isInteger()&&e.gte(0)}function bd(e){var t;if(V(e))return e<=0?isFinite(e)?1/0:NaN:e>171?1/0:pd(1,e-1);if(e<.5)return Math.PI/(Math.sin(Math.PI*e)*bd(1-e));if(e>=171.35)return 1/0;if(e>85){var r=e*e,n=r*e,i=n*e,a=i*e;return Math.sqrt(2*Math.PI/e)*Math.pow(e/Math.E,e)*(1+1/(12*e)+1/(288*r)-139/(51840*n)-571/(2488320*i)+163879/(209018880*a)+5246819/(75246796800*a*e))}--e,t=Dd[0];for(var o=1;o<Dd.length;++o)t+=Dd[o]/(e+o);var u=e+wd+.5;return Math.sqrt(2*Math.PI)*Math.pow(u,e+.5)*Math.exp(-u)*t}bd.signature="number";var wd=4.7421875,Dd=[.9999999999999971,57.15623566586292,-59.59796035547549,14.136097974741746,-.4919138160976202,3399464998481189e-20,4652362892704858e-20,-9837447530487956e-20,.0001580887032249125,-.00021026444172410488,.00021743961811521265,-.0001643181065367639,8441822398385275e-20,-26190838401581408e-21,36899182659531625e-22],Nd=.9189385332046728,Ed=[1.000000000190015,76.18009172947146,-86.50532032941678,24.01409824083091,-1.231739572450155,.001208650973866179,-5395239384953e-18];function Ad(e){if(e<0)return NaN;if(0===e)return 1/0;if(!isFinite(e))return e;if(e<.5)return Math.log(Math.PI/Math.sin(Math.PI*e))-Ad(1-e);for(var t=5+(e-=1)+.5,r=Ed[0],n=6;n>=1;n--)r+=Ed[n]/(e+n);return Nd+(e+.5)*Math.log(t)-t+Math.log(r)}Ad.signature="number";var Sd="gamma",Cd=Se(Sd,["typed","config","multiplyScalar","pow","BigNumber","Complex"],(function(e){var t=e.typed,r=e.config,n=(e.multiplyScalar,e.pow,e.BigNumber),i=e.Complex;return t(Sd,{number:bd,Complex:function e(t){if(0===t.im)return bd(t.re);if(t.re<.5){var r=new i(1-t.re,-t.im),n=new i(Math.PI*t.re,Math.PI*t.im);return new i(Math.PI).div(n.sin()).div(e(r))}t=new i(t.re-1,t.im);for(var a=new i(Dd[0],0),o=1;o<Dd.length;++o){var u=new i(Dd[o],0);a=a.add(u.div(t.add(o)))}var s=new i(t.re+wd+.5,t.im),c=Math.sqrt(2*Math.PI),f=s.pow(t.add(.5)),l=s.neg().exp();return a.mul(c).mul(f).mul(l)},BigNumber:function(e){if(e.isInteger())return e.isNegative()||e.isZero()?new n(1/0):a(e.minus(1));if(!e.isFinite())return new n(e.isNegative()?NaN:1/0);throw new Error("Integer BigNumber expected")}});function a(e){if(e<8)return new n([1,1,2,6,24,120,720,5040][e]);var t=r.precision+(0|Math.log(e.toNumber())),i=n.clone({precision:t});if(e%2==1)return e.times(a(new n(e-1)));for(var o=e,u=new i(e),s=e.toNumber();o>2;)s+=o-=2,u=u.times(s);return new n(u.toPrecision(n.precision))}})),Md="lgamma",Fd=Se(Md,["Complex","typed"],(function(e){var t=e.Complex,r=e.typed,n=[-.029550653594771242,.00641025641025641,-.0019175269175269176,.0008417508417508417,-.0005952380952380953,.0007936507936507937,-.002777777777777778,.08333333333333333];return r(Md,{number:Ad,Complex:function e(r){if(r.isNaN())return new t(NaN,NaN);if(0===r.im)return new t(Ad(r.re),0);if(r.re>=7||Math.abs(r.im)>=7)return i(r);if(r.re<=.1){var n=(s=6.283185307179586,(!0^((c=r.im)>0||!(c<0)&&1/c==1/0)?-s:s)*Math.floor(.5*r.re+.25)),o=r.mul(Math.PI).sin().log(),u=e(new t(1-r.re,-r.im));return new t(1.1447298858494002,n).sub(o).sub(u)}return r.im>=0?a(r):a(r.conjugate()).conjugate();var s,c},BigNumber:function(){throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber")}});function i(e){for(var r=e.sub(.5).mul(e.log()).sub(e).add(Nd),i=new t(1,0).div(e),a=i.div(e),o=n[0],u=n[1],s=2*a.re,c=a.re*a.re+a.im*a.im,f=2;f<8;f++){var l=u;u=-c*o+n[f],o=s*o+l}var p=i.mul(a.mul(o).add(u));return r.add(p)}function a(e){var r=0,n=0,a=e;for(e=e.add(1);e.re<=7;){var o=(a=a.mul(e)).im<0?1:0;0!==o&&0===n&&r++,n=o,e=e.add(1)}return i(e).sub(a.log()).sub(new t(0,2*r*Math.PI*1))}})),Od="factorial",Td=Se(Od,["typed","gamma"],(function(e){var t=e.typed,r=e.gamma;return t(Od,{number:function(e){if(e<0)throw new Error("Value must be non-negative");return r(e+1)},BigNumber:function(e){if(e.isNegative())throw new Error("Value must be non-negative");return r(e.plus(1))},"Array | Matrix":t.referToSelf((function(e){return function(t){return Wn(t,e)}}))})})),_d="kldivergence",Bd=Se(_d,["typed","matrix","divide","sum","multiply","map","dotDivide","log","isNumeric"],(function(e){var t=e.typed,r=e.matrix,n=e.divide,i=e.sum,a=e.multiply,o=e.map,u=e.dotDivide,s=e.log,c=e.isNumeric;return t(_d,{"Array, Array":function(e,t){return f(r(e),r(t))},"Matrix, Array":function(e,t){return f(e,r(t))},"Array, Matrix":function(e,t){return f(r(e),t)},"Matrix, Matrix":function(e,t){return f(e,t)}});function f(e,t){var r=t.size().length,f=e.size().length;if(r>1)throw new Error("first object must be one dimensional");if(f>1)throw new Error("second object must be one dimensional");if(r!==f)throw new Error("Length of two vectors must be equal");if(0===i(e))throw new Error("Sum of elements in first object must be non zero");if(0===i(t))throw new Error("Sum of elements in second object must be non zero");var l=n(e,i(e)),p=n(t,i(t)),m=i(a(l,o(u(l,p),(function(e){return s(e)}))));return c(m)?m:Number.NaN}})),kd="multinomial",Id=Se(kd,["typed","add","divide","multiply","factorial","isInteger","isPositive"],(function(e){var t=e.typed,r=e.add,n=e.divide,i=e.multiply,a=e.factorial,o=e.isInteger,u=e.isPositive;return t(kd,{"Array | Matrix":function(e){var t=0,s=1;return Zn(e,(function(e){if(!o(e)||!u(e))throw new TypeError("Positive integer value expected in function multinomial");t=r(t,e),s=i(s,a(e))})),n(a(t),s)}})})),zd="permutations",Rd=Se(zd,["typed","factorial"],(function(e){var t=e.typed,r=e.factorial;return t(zd,{"number | BigNumber":r,"number, number":function(e,t){if(!V(e)||e<0)throw new TypeError("Positive integer value expected in function permutations");if(!V(t)||t<0)throw new TypeError("Positive integer value expected in function permutations");if(t>e)throw new TypeError("second argument k must be less than or equal to first argument n");return pd(e-t+1,e)},"BigNumber, BigNumber":function(e,t){var r,n;if(!qd(e)||!qd(t))throw new TypeError("Positive integer value expected in function permutations");if(t.gt(e))throw new TypeError("second argument k must be less than or equal to first argument n");for(r=e.mul(0).add(1),n=e.minus(t).plus(1);n.lte(e);n=n.plus(1))r=r.times(n);return r}})}));function qd(e){return e.isInteger()&&e.gte(0)}r(9089);var jd=r(7391),Pd=jd(Date.now());function Ld(e){var t,r;return t=null===(r=e)?Pd:jd(String(r)),function(){return t()}}var Ud="pickRandom",$d=Se(Ud,["typed","config","?on"],(function(e){var t=e.typed,r=e.config,n=e.on,a=Ld(r.randomSeed);return n&&n("config",(function(e,t){e.randomSeed!==t.randomSeed&&(a=Ld(e.randomSeed))})),t(Ud,{"Array | Matrix":function(e){return o(e,{})},"Array | Matrix, Object":function(e,t){return o(e,t)},"Array | Matrix, number":function(e,t){return o(e,{number:t})},"Array | Matrix, Array | Matrix":function(e,t){return o(e,{weights:t})},"Array | Matrix, Array | Matrix, number":function(e,t,r){return o(e,{number:r,weights:t})},"Array | Matrix, number, Array | Matrix":function(e,t,r){return o(e,{number:t,weights:r})}});function o(e,t){var r=t.number,n=t.weights,o=t.elementWise,u=void 0===o||o,s=void 0===r;s&&(r=1);var c=l(e)?e.create:l(n)?n.create:null;e=e.valueOf(),n&&(n=n.valueOf()),!0===u&&(e=En(e),n=En(n));var f=0;if(void 0!==n){if(n.length!==e.length)throw new Error("Weights must have the same length as possibles");for(var p=0,m=n.length;p<m;p++){if(!i(n[p])||n[p]<0)throw new Error("Weights must be an array of positive numbers");f+=n[p]}}for(var h,d=e.length,v=[];v.length<r;){if(void 0===n)h=e[Math.floor(a()*d)];else for(var y=a()*f,g=0,x=e.length;g<x;g++)if((y-=n[g])<0){h=e[g];break}v.push(h)}return s?v[0]:c?c(v):v}}));function Hd(e,t){var r=[];if((e=e.slice(0)).length>1)for(var n=0,i=e.shift();n<i;n++)r.push(Hd(e,t));else for(var a=0,o=e.shift();a<o;a++)r.push(t());return r}var Gd="random",Vd=Se(Gd,["typed","config","?on"],(function(e){var t=e.typed,r=e.config,n=e.on,i=Ld(r.randomSeed);return n&&n("config",(function(e,t){e.randomSeed!==t.randomSeed&&(i=Ld(e.randomSeed))})),t(Gd,{"":function(){return o(0,1)},number:function(e){return o(0,e)},"number, number":function(e,t){return o(e,t)},"Array | Matrix":function(e){return a(e,0,1)},"Array | Matrix, number":function(e,t){return a(e,0,t)},"Array | Matrix, number, number":function(e,t,r){return a(e,t,r)}});function a(e,t,r){var n=Hd(e.valueOf(),(function(){return o(t,r)}));return l(e)?e.create(n):n}function o(e,t){return e+i()*(t-e)}})),Zd="randomInt",Wd=Se(Zd,["typed","config","?on"],(function(e){var t=e.typed,r=e.config,n=e.on,i=Ld(r.randomSeed);return n&&n("config",(function(e,t){e.randomSeed!==t.randomSeed&&(i=Ld(e.randomSeed))})),t(Zd,{"":function(){return o(0,1)},number:function(e){return o(0,e)},"number, number":function(e,t){return o(e,t)},"Array | Matrix":function(e){return a(e,0,1)},"Array | Matrix, number":function(e,t){return a(e,0,t)},"Array | Matrix, number, number":function(e,t,r){return a(e,t,r)}});function a(e,t,r){var n=Hd(e.valueOf(),(function(){return o(t,r)}));return l(e)?e.create(n):n}function o(e,t){return Math.floor(e+i()*(t-e))}})),Yd="stirlingS2",Jd=Se(Yd,["typed","addScalar","subtractScalar","multiplyScalar","divideScalar","pow","factorial","combinations","isNegative","isInteger","number","?bignumber","larger"],(function(e){var t=e.typed,r=e.addScalar,n=(e.subtractScalar,e.multiplyScalar),a=(e.divideScalar,e.pow,e.factorial,e.combinations,e.isNegative),o=e.isInteger,u=e.number,s=e.bignumber,c=e.larger,f=[],l=[];return t(Yd,{"number | BigNumber, number | BigNumber":function(e,t){if(!o(e)||a(e)||!o(t)||a(t))throw new TypeError("Non-negative integer value expected in function stirlingS2");if(c(t,e))throw new TypeError("k must be less than or equal to n in function stirlingS2");var p=!(i(e)&&i(t)),m=p?l:f,h=p?s:u,d=u(e),v=u(t);if(m[d]&&m[d].length>v)return m[d][v];for(var y=0;y<=d;++y)if(m[y]||(m[y]=[h(0===y?1:0)]),0!==y)for(var g=m[y],x=m[y-1],b=g.length;b<=y&&b<=v;++b)g[b]=b===y?1:r(n(h(b),x[b]),x[b-1]);return m[d][v]}})})),Xd="bellNumbers",Qd=Se(Xd,["typed","addScalar","isNegative","isInteger","stirlingS2"],(function(e){var t=e.typed,r=e.addScalar,n=e.isNegative,i=e.isInteger,a=e.stirlingS2;return t(Xd,{"number | BigNumber":function(e){if(!i(e)||n(e))throw new TypeError("Non-negative integer value expected in function bellNumbers");for(var t=0,o=0;o<=e;o++)t=r(t,a(e,o));return t}})})),Kd="catalan",ev=Se(Kd,["typed","addScalar","divideScalar","multiplyScalar","combinations","isNegative","isInteger"],(function(e){var t=e.typed,r=e.addScalar,n=e.divideScalar,i=e.multiplyScalar,a=e.combinations,o=e.isNegative,u=e.isInteger;return t(Kd,{"number | BigNumber":function(e){if(!u(e)||o(e))throw new TypeError("Non-negative integer value expected in function catalan");return n(a(i(e,2),e),r(e,1))}})})),tv="composition",rv=Se(tv,["typed","addScalar","combinations","isNegative","isPositive","isInteger","larger"],(function(e){var t=e.typed,r=e.addScalar,n=e.combinations,i=e.isPositive,a=(e.isNegative,e.isInteger),o=e.larger;return t(tv,{"number | BigNumber, number | BigNumber":function(e,t){if(!(a(e)&&i(e)&&a(t)&&i(t)))throw new TypeError("Positive integer value expected in function composition");if(o(t,e))throw new TypeError("k must be less than or equal to n in function composition");return n(r(e,-1),r(t,-1))}})})),nv="leafCount",iv=Se(nv,["parse","typed"],(function(e){function t(e){var r=0;return e.forEach((function(e){r+=t(e)})),r||1}return e.parse,(0,e.typed)(nv,{Node:function(e){return t(e)}})}));function av(e){return T(e)||q(e)&&e.isUnary()&&T(e.args[0])}function ov(e){return!!T(e)||!(!k(e)&&!q(e)||!e.args.every(ov))||!(!j(e)||!ov(e.content))}function uv(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function sv(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?uv(Object(r),!0).forEach((function(t){Va(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):uv(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}r(2781);var cv=Se("simplifyUtil",["FunctionNode","OperatorNode","SymbolNode"],(function(e){var t=e.FunctionNode,r=e.OperatorNode,n=e.SymbolNode,i=!0,a=!1,o="defaultF",u={add:{trivial:i,total:i,commutative:i,associative:i},unaryPlus:{trivial:i,total:i,commutative:i,associative:i},subtract:{trivial:a,total:i,commutative:a,associative:a},multiply:{trivial:i,total:i,commutative:i,associative:i},divide:{trivial:a,total:i,commutative:a,associative:a},paren:{trivial:i,total:i,commutative:i,associative:a},defaultF:{trivial:a,total:i,commutative:a,associative:a}};function s(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:u,n=o;if("string"==typeof e?n=e:q(e)?n=e.fn.toString():k(e)?n=e.name:j(e)&&(n="paren"),Ae(r,n)){var i=r[n];if(Ae(i,t))return i[t];if(Ae(u,n))return u[n][t]}if(Ae(r,o)){var a=r[o];return Ae(a,t)?a[t]:u[o][t]}if(Ae(u,n)){var s=u[n];if(Ae(s,t))return s[t]}return u[o][t]}function c(e){return s(e,"associative",arguments.length>1&&void 0!==arguments[1]?arguments[1]:u)}function f(e,t){var r,n=[];return c(e,t)?(r=e.op,function e(t){for(var i=0;i<t.args.length;i++){var a=t.args[i];q(a)&&r===a.op?e(a):n.push(a)}}(e),n):e.args}function l(e){return q(e)?function(t){try{return new r(e.op,e.fn,t,e.implicit)}catch(e){return console.error(e),[]}}:function(r){return new t(new n(e.name),r)}}return{createMakeNodeFunction:l,hasProperty:s,isCommutative:function(e){return s(e,"commutative",arguments.length>1&&void 0!==arguments[1]?arguments[1]:u)},isAssociative:c,mergeContext:function(e,t){var r=sv({},e);for(var n in t)Ae(e,n)?r[n]=sv(sv({},t[n]),e[n]):r[n]=t[n];return r},flatten:function e(t,r){if(!t.args||0===t.args.length)return t;t.args=f(t,r);for(var n=0;n<t.args.length;n++)e(t.args[n],r)},allChildren:f,unflattenr:function e(t,r){if(t.args&&0!==t.args.length){for(var n=l(t),i=t.args.length,a=0;a<i;a++)e(t.args[a],r);if(i>2&&c(t,r)){for(var o=t.args.pop();t.args.length>0;)o=n([t.args.pop(),o]);t.args=o.args}}},unflattenl:function e(t,r){if(t.args&&0!==t.args.length){for(var n=l(t),i=t.args.length,a=0;a<i;a++)e(t.args[a],r);if(i>2&&c(t,r)){for(var o=t.args.shift();t.args.length>0;)o=n([o,t.args.shift()]);t.args=o.args}}},defaultContext:u,realContext:{divide:{total:a},log:{total:a}},positiveContext:{subtract:{total:a},abs:{trivial:i},log:{total:i}}}})),fv=Se("simplify",["config","typed","parse","add","subtract","multiply","divide","pow","isZero","equal","resolve","simplifyConstant","simplifyCore","?fraction","?bignumber","mathWithTransform","matrix","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode"],(function(e){e.config;var r=e.typed,n=e.parse,i=(e.add,e.subtract,e.multiply,e.divide,e.pow,e.isZero,e.equal),a=e.resolve,o=e.simplifyConstant,u=e.simplifyCore,s=(e.fraction,e.bignumber,e.mathWithTransform,e.matrix,e.AccessorNode),c=e.ArrayNode,f=e.ConstantNode,l=e.FunctionNode,p=e.IndexNode,m=e.ObjectNode,h=e.OperatorNode,d=e.ParenthesisNode,v=e.SymbolNode,y=cv({FunctionNode:l,OperatorNode:h,SymbolNode:v}),g=y.hasProperty,x=y.isCommutative,b=y.isAssociative,w=y.mergeContext,D=y.flatten,N=y.unflattenr,E=y.unflattenl,A=y.createMakeNodeFunction,S=y.defaultContext,C=y.realContext,M=y.positiveContext;r.addConversion({from:"Object",to:"Map",convert:Ye});var F=r("simplify",{Node:z,"Node, Map":function(e,t){return z(e,!1,t)},"Node, Map, Object":function(e,t,r){return z(e,!1,t,r)},"Node, Array":z,"Node, Array, Map":z,"Node, Array, Map, Object":z});function O(e){return e.transform((function(e,t,r){return j(e)?O(e.content):e}))}r.removeConversion({from:"Object",to:"Map",convert:Ye}),F.defaultContext=S,F.realContext=C,F.positiveContext=M;var _={true:!0,false:!0,e:!0,i:!0,Infinity:!0,LN2:!0,LN10:!0,LOG2E:!0,LOG10E:!0,NaN:!0,phi:!0,pi:!0,SQRT1_2:!0,SQRT2:!0,tau:!0};function B(e,t){var r={};if(e.s){var i=e.s.split("->");if(2!==i.length)throw SyntaxError("Could not parse rule: "+e.s);r.l=i[0],r.r=i[1]}else r.l=e.l,r.r=e.r;r.l=O(n(r.l)),r.r=O(n(r.r));for(var a=0,o=["imposeContext","repeat","assuming"];a<o.length;a++){var u=o[a];u in e&&(r[u]=e[u])}if(e.evaluate&&(r.evaluate=n(e.evaluate)),b(r.l,t)){var s,c=!x(r.l,t);c&&(s=I());var f=A(r.l),l=I();r.expanded={},r.expanded.l=f([r.l,l]),D(r.expanded.l,t),N(r.expanded.l,t),r.expanded.r=f([r.r,l]),c&&(r.expandedNC1={},r.expandedNC1.l=f([s,r.l]),r.expandedNC1.r=f([s,r.r]),r.expandedNC2={},r.expandedNC2.l=f([s,r.expanded.l]),r.expandedNC2.r=f([s,r.expanded.r]))}return r}F.rules=[u,{l:"log(e)",r:"1"},{s:"n-n1 -> n+-n1",assuming:{subtract:{total:!0}}},{s:"n-n -> 0",assuming:{subtract:{total:!1}}},{s:"-(cl*v) -> v * (-cl)",assuming:{multiply:{commutative:!0},subtract:{total:!0}}},{s:"-(cl*v) -> (-cl) * v",assuming:{multiply:{commutative:!1},subtract:{total:!0}}},{s:"-(v*cl) -> v * (-cl)",assuming:{multiply:{commutative:!1},subtract:{total:!0}}},{l:"-(n1/n2)",r:"-n1/n2"},{l:"-v",r:"v * (-1)"},{l:"(n1 + n2)*(-1)",r:"n1*(-1) + n2*(-1)",repeat:!0},{l:"n/n1^n2",r:"n*n1^-n2"},{l:"n/n1",r:"n*n1^-1"},{s:"(n1*n2)^n3 -> n1^n3 * n2^n3",assuming:{multiply:{commutative:!0}}},{s:"(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",assuming:{multiply:{commutative:!1}}},{s:"(n ^ n1) ^ n2 -> n ^ (n1 * n2)",assuming:{divide:{total:!0}}},{l:" vd   * ( vd   * n1 + n2)",r:"vd^2       * n1 +  vd   * n2"},{s:" vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",assuming:{divide:{total:!0}}},{s:"vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",assuming:{divide:{total:!0}}},{s:"vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",assuming:{divide:{total:!0}}},{l:"n*n",r:"n^2"},{s:"n * n^n1 -> n^(n1+1)",assuming:{divide:{total:!0}}},{s:"n^n1 * n^n2 -> n^(n1+n2)",assuming:{divide:{total:!0}}},o,{s:"n+n -> 2*n",assuming:{add:{total:!0}}},{l:"n+-n",r:"0"},{l:"vd*n + vd",r:"vd*(n+1)"},{l:"n3*n1 + n3*n2",r:"n3*(n1+n2)"},{l:"n3^(-n4)*n1 +   n3  * n2",r:"n3^(-n4)*(n1 + n3^(n4+1) *n2)"},{l:"n3^(-n4)*n1 + n3^n5 * n2",r:"n3^(-n4)*(n1 + n3^(n4+n5)*n2)"},{s:"n*vd + vd -> (n+1)*vd",assuming:{multiply:{commutative:!1}}},{s:"vd + n*vd -> (1+n)*vd",assuming:{multiply:{commutative:!1}}},{s:"n1*n3 + n2*n3 -> (n1+n2)*n3",assuming:{multiply:{commutative:!1}}},{s:"n^n1 * n -> n^(n1+1)",assuming:{divide:{total:!0},multiply:{commutative:!1}}},{s:"n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",assuming:{multiply:{commutative:!1}}},{s:"n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",assuming:{multiply:{commutative:!1}}},{l:"n*cd + cd",r:"(n+1)*cd"},{s:"cd*n + cd -> cd*(n+1)",assuming:{multiply:{commutative:!1}}},{s:"cd + cd*n -> cd*(1+n)",assuming:{multiply:{commutative:!1}}},o,{s:"(-n)*n1 -> -(n*n1)",assuming:{subtract:{total:!0}}},{s:"n1*(-n) -> -(n1*n)",assuming:{subtract:{total:!0},multiply:{commutative:!1}}},{s:"ce+ve -> ve+ce",assuming:{add:{commutative:!0}},imposeContext:{add:{commutative:!1}}},{s:"vd*cd -> cd*vd",assuming:{multiply:{commutative:!0}},imposeContext:{multiply:{commutative:!1}}},{l:"n+-n1",r:"n-n1"},{l:"n+-(n1)",r:"n-(n1)"},{s:"n*(n1^-1) -> n/n1",assuming:{multiply:{commutative:!0}}},{s:"n*n1^-n2 -> n/n1^n2",assuming:{multiply:{commutative:!0}}},{s:"n^-1 -> 1/n",assuming:{multiply:{commutative:!0}}},{l:"n^1",r:"n"},{s:"n*(n1/n2) -> (n*n1)/n2",assuming:{multiply:{associative:!0}}},{s:"n-(n1+n2) -> n-n1-n2",assuming:{addition:{associative:!0,commutative:!0}}},{l:"1*n",r:"n",imposeContext:{multiply:{commutative:!0}}},{s:"n1/(n2/n3) -> (n1*n3)/n2",assuming:{multiply:{associative:!0}}},{l:"n1/(-n2)",r:"-n1/n2"}];var k=0;function I(){return new v("_p"+k++)}function z(e,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:We(),i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=i.consoleDebug;r=function(e,r){for(var n=[],i=0;i<e.length;i++){var a=e[i],o=void 0,u=t(a);switch(u){case"string":a={s:a};case"object":o=B(a,r);break;case"function":o=a;break;default:throw TypeError("Unsupported type of rule: "+u)}n.push(o)}return n}(r||F.rules,i.context);for(var u=a(e,n),s={},c=(u=O(u)).toString({parenthesis:"all"});!s[c];){s[c]=!0,k=0;var f=c;o&&console.log("Working on: ",c);for(var l=0;l<r.length;l++){var p="";if("function"==typeof r[l]?(u=r[l](u,i),o&&(p=r[l].name)):(D(u,i.context),u=q(u,r[l],i.context),o&&(p="".concat(r[l].l.toString()," -> ").concat(r[l].r.toString()))),o){var m=u.toString({parenthesis:"all"});m!==f&&(console.log("Applying",p,"produced",m),f=m)}E(u,i.context)}c=u.toString({parenthesis:"all"})}return u}function R(e,t,r){var n=e;if(e)for(var i=0;i<e.length;++i){var a=q(e[i],t,r);a!==e[i]&&(n===e&&(n=e.slice()),n[i]=a)}return n}function q(e,t,r){if(t.assuming)for(var n in t.assuming)for(var i in t.assuming[n])if(g(n,i,r)!==t.assuming[n][i])return e;var a=w(t.imposeContext,r),o=e;if(o instanceof h||o instanceof l){var u=R(o.args,t,r);u!==o.args&&((o=o.clone()).args=u)}else if(o instanceof d){if(o.content){var f=q(o.content,t,r);f!==o.content&&(o=new d(f))}}else if(o instanceof c){var v=R(o.items,t,r);v!==o.items&&(o=new c(v))}else if(o instanceof s){var y=o.object;o.object&&(y=q(o.object,t,r));var x=o.index;o.index&&(x=q(o.index,t,r)),y===o.object&&x===o.index||(o=new s(y,x))}else if(o instanceof p){var b=R(o.dimensions,t,r);b!==o.dimensions&&(o=new p(b))}else if(o instanceof m){var D=!1,N={};for(var E in o.properties)N[E]=q(o.properties[E],t,r),N[E]!==o.properties[E]&&(D=!0);D&&(o=new m(N))}var A=t.r,S=$(t.l,o,a)[0];if(!S&&t.expanded&&(A=t.expanded.r,S=$(t.expanded.l,o,a)[0]),!S&&t.expandedNC1&&(A=t.expandedNC1.r,(S=$(t.expandedNC1.l,o,a)[0])||(A=t.expandedNC2.r,S=$(t.expandedNC2.l,o,a)[0])),S){var C=o.implicit;o=A.clone(),C&&"implicit"in A&&(o.implicit=!0),o=o.transform((function(e){return e.isSymbolNode&&Ae(S.placeholders,e.name)?S.placeholders[e.name].clone():e}))}return t.repeat&&o!==e&&(o=q(o,t,r)),o}function P(e,t){var r={placeholders:{}};if(!e.placeholders&&!t.placeholders)return r;if(!e.placeholders)return t;if(!t.placeholders)return e;for(var n in e.placeholders)if(Ae(e.placeholders,n)&&(r.placeholders[n]=e.placeholders[n],Ae(t.placeholders,n)&&!H(e.placeholders[n],t.placeholders[n])))return null;for(var i in t.placeholders)Ae(t.placeholders,i)&&(r.placeholders[i]=t.placeholders[i]);return r}function L(e,t){var r,n=[];if(0===e.length||0===t.length)return n;for(var i=0;i<e.length;i++)for(var a=0;a<t.length;a++)(r=P(e[i],t[a]))&&n.push(r);return n}function $(e,t,r,n){var a=[{placeholders:{}}];if(e instanceof h&&t instanceof h||e instanceof l&&t instanceof l){if(e instanceof h){if(e.op!==t.op||e.fn!==t.fn)return[]}else if(e instanceof l&&e.name!==t.name)return[];if(!(1===t.args.length&&1===e.args.length||!b(t,r)&&t.args.length===e.args.length||n)){if(t.args.length>=2&&2===e.args.length){for(var o=function(e,t){var r,n,i=[],a=A(e);if(x(e,t))for(var o=0;o<e.args.length;o++)(n=e.args.slice(0)).splice(o,1),r=1===n.length?n[0]:a(n),i.push(a([e.args[o],r]));else for(var u=1;u<e.args.length;u++){var s=e.args[0];u>1&&(s=a(e.args.slice(0,u))),r=1===(n=e.args.slice(u)).length?n[0]:a(n),i.push(a([s,r]))}return i}(t,r),u=[],s=0;s<o.length;s++){var c=$(e,o[s],r,!0);u=u.concat(c)}return u}if(e.args.length>2)throw Error("Unexpected non-binary associative function: "+e.toString());return[]}for(var p=[],m=0;m<e.args.length;m++){var d=$(e.args[m],t.args[m],r);if(0===d.length)break;p.push(d)}if(p.length!==e.args.length){if(!x(t,r)||1===e.args.length)return[];if(e.args.length>2)throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");var y=$(e.args[0],t.args[1],r);if(0===y.length)return[];var g=$(e.args[1],t.args[0],r);if(0===g.length)return[];p=[y,g]}a=function(e){if(0===e.length)return e;for(var t=e.reduce(L),r=[],n={},i=0;i<t.length;i++){var a=JSON.stringify(t[i]);n[a]||(n[a]=!0,r.push(t[i]))}return r}(p)}else if(e instanceof v){if(0===e.name.length)throw new Error("Symbol in rule has 0 length...!?");if(_[e.name]){if(e.name!==t.name)return[]}else switch(e.name[1]>="a"&&e.name[1]<="z"?e.name.substring(0,2):e.name[0]){case"n":case"_p":a[0].placeholders[e.name]=t;break;case"c":case"cl":if(!T(t))return[];a[0].placeholders[e.name]=t;break;case"v":if(T(t))return[];a[0].placeholders[e.name]=t;break;case"vl":if(!U(t))return[];a[0].placeholders[e.name]=t;break;case"cd":if(!av(t))return[];a[0].placeholders[e.name]=t;break;case"vd":if(av(t))return[];a[0].placeholders[e.name]=t;break;case"ce":if(!ov(t))return[];a[0].placeholders[e.name]=t;break;case"ve":if(ov(t))return[];a[0].placeholders[e.name]=t;break;default:throw new Error("Invalid symbol in rule: "+e.name)}}else{if(!(e instanceof f))return[];if(!i(e.value,t.value))return[]}return a}function H(e,t){if(e instanceof f&&t instanceof f){if(!i(e.value,t.value))return!1}else if(e instanceof v&&t instanceof v){if(e.name!==t.name)return!1}else{if(!(e instanceof h&&t instanceof h||e instanceof l&&t instanceof l))return!1;if(e instanceof h){if(e.op!==t.op||e.fn!==t.fn)return!1}else if(e instanceof l&&e.name!==t.name)return!1;if(e.args.length!==t.args.length)return!1;for(var r=0;r<e.args.length;r++)if(!H(e.args[r],t.args[r]))return!1}return!0}return F}));function lv(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return pv(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?pv(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,o=!0,u=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return o=e.done,e},e:function(e){u=!0,a=e},f:function(){try{o||null==r.return||r.return()}finally{if(u)throw a}}}}function pv(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}var mv=Se("simplifyConstant",["typed","config","mathWithTransform","matrix","?fraction","?bignumber","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode"],(function(e){var r=e.typed,n=e.config,i=e.mathWithTransform,a=e.matrix,o=e.fraction,s=e.bignumber,c=e.AccessorNode,f=e.ArrayNode,p=e.ConstantNode,m=e.FunctionNode,h=e.IndexNode,d=e.ObjectNode,v=e.OperatorNode,y=e.SymbolNode,g=cv({FunctionNode:m,OperatorNode:v,SymbolNode:y}),x=g.isCommutative,b=g.isAssociative,w=g.allChildren,D=g.createMakeNodeFunction,N=r("simplifyConstant",{Node:function(e){return M(k(e,{}))},"Node, Object":function(e,t){return M(k(e,t))}});function E(e){return u(e)?e.valueOf():e instanceof Array?e.map(E):l(e)?a(E(e.valueOf())):e}function A(e,t,r){try{return i[e].apply(null,t)}catch(n){return t=t.map(E),O(i[e].apply(null,t),r)}}var S=r({Fraction:function(e){var t,r=e.s*e.n;return t=r<0?new v("-","unaryMinus",[new p(-r)]):new p(r),1===e.d?t:new v("/","divide",[t,new p(e.d)])},number:function(e){return e<0?_(new p(-e)):new p(e)},BigNumber:function(e){return e<0?_(new p(-e)):new p(e)},Complex:function(e){throw new Error("Cannot convert Complex number to Node")},string:function(e){return new p(e)},Matrix:function(e){return new f(e.valueOf().map((function(e){return S(e)})))}});function M(e){return z(e)?e:S(e)}function F(e,t){if(t&&!1!==t.exactFractions&&isFinite(e)&&o){var r=o(e),n=t&&"number"==typeof t.fractionsLimit?t.fractionsLimit:1/0;if(r.valueOf()===e&&r.n<n&&r.d<n)return r}return e}var O=r({"string, Object":function(e,t){return"BigNumber"===n.number?(void 0===s&&Wu(),s(e)):"Fraction"===n.number?(void 0===o&&Yu(),o(e)):F(parseFloat(e),t)},"Fraction, Object":function(e,t){return e},"BigNumber, Object":function(e,t){return e},"number, Object":function(e,t){return F(e,t)},"Complex, Object":function(e,t){return 0!==e.im?e:F(e.re,t)},"Matrix, Object":function(e,t){return a(F(e.valueOf()))},"Array, Object":function(e,t){return e.map(F)}});function _(e){return new v("-","unaryMinus",[e])}function B(e,t,r,n){var i=t.shift(),a=t.reduce((function(t,i){if(!z(i)){var a=t.pop();if(z(a))return[a,i];try{return t.push(A(e,[a,i],n)),t}catch(e){t.push(a)}}t.push(M(t.pop()));var o=1===t.length?t[0]:r(t);return[r([o,M(i)])]}),[i]);return 1===a.length?a[0]:r([a[0],S(a[1])])}function k(e,r){switch(e.type){case"SymbolNode":return e;case"ConstantNode":switch(t(e.value)){case"number":return O(e.value,r);case"string":return e.value;default:if(!isNaN(e.value))return O(e.value,r)}return e;case"FunctionNode":if(i[e.name]&&i[e.name].rawArgs)return e;if(-1===["add","multiply"].indexOf(e.name)){var n=e.args.map((function(e){return k(e,r)}));if(!n.some(z))try{return A(e.name,n,r)}catch(e){}if("size"===e.name&&1===n.length&&C(n[0])){for(var o=[],u=n[0];C(u);)o.push(u.items.length),u=u.items[0];return a(o)}return new m(e.name,n.map(M))}case"OperatorNode":var s,v,y=e.fn.toString(),g=D(e);if(q(e)&&e.isUnary())v=z((s=[k(e.args[0],r)])[0])?g(s):A(y,s,r);else if(b(e,r.context))if(s=(s=w(e,r.context)).map((function(e){return k(e,r)})),x(y,r.context)){for(var E=[],S=[],F=0;F<s.length;F++)z(s[F])?S.push(s[F]):E.push(s[F]);E.length>1?(v=B(y,E,g,r),S.unshift(v),v=B(y,S,g,r)):v=B(y,s,g,r)}else v=B(y,s,g,r);else v=B(y,s=e.args.map((function(e){return k(e,r)})),g,r);return v;case"ParenthesisNode":return k(e.content,r);case"AccessorNode":return function(e,t,r){if(!I(t))return new c(M(e),M(t));if(C(e)||l(e)){for(var n=Array.from(t.dimensions);n.length>0;)if(T(n[0])&&"string"!=typeof n[0].value){var i=O(n.shift().value,r);C(e)?e=e.items[i-1]:(e=e.valueOf()[i-1])instanceof Array&&(e=a(e))}else{if(!(n.length>1&&T(n[1])&&"string"!=typeof n[1].value))break;var o,u=O(n[1].value,r),s=[],m=C(e)?e.items:e.valueOf(),d=lv(m);try{for(d.s();!(o=d.n()).done;){var v=o.value;if(C(v))s.push(v.items[u-1]);else{if(!l(e))break;s.push(v[u-1])}}}catch(e){d.e(e)}finally{d.f()}if(s.length!==m.length)break;e=C(e)?new f(s):a(s),n.splice(1,1)}return n.length===t.dimensions.length?new c(M(e),t):n.length>0?(t=new h(n),new c(M(e),t)):e}if(R(e)&&1===t.dimensions.length&&T(t.dimensions[0])){var y=t.dimensions[0].value;return y in e.properties?e.properties[y]:new p}return new c(M(e),t)}(k(e.object,r),k(e.index,r),r);case"ArrayNode":var _=e.items.map((function(e){return k(e,r)}));return _.some(z)?new f(_.map(M)):a(_);case"IndexNode":return new h(e.dimensions.map((function(e){return N(e,r)})));case"ObjectNode":var j={};for(var P in e.properties)j[P]=N(e.properties[P],r);return new d(j);default:throw new Error("Unimplemented node type in simplifyConstant: ".concat(e.type))}}return N})),hv="simplifyCore",dv=Se(hv,["typed","parse","equal","isZero","add","subtract","multiply","divide","pow","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode"],(function(e){var t=e.typed,r=(e.parse,e.equal),n=e.isZero,i=(e.add,e.subtract,e.multiply,e.divide,e.pow,e.AccessorNode),a=e.ArrayNode,o=e.ConstantNode,u=e.FunctionNode,s=e.IndexNode,c=e.ObjectNode,f=e.OperatorNode,l=(e.ParenthesisNode,e.SymbolNode),p=new o(0),m=new o(1),h=new o(!0),d=new o(!1);function v(e){return q(e)&&["and","not","or"].includes(e.op)}var y=cv({FunctionNode:u,OperatorNode:f,SymbolNode:l}),g=y.hasProperty,x=y.isCommutative;function b(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=t?t.context:void 0;if(g(e,"trivial",o)){if(k(e)&&1===e.args.length)return b(e.args[0],t);var l=!1,y=0;if(e.forEach((function(e){1==++y&&(l=b(e,t))})),1===y)return l}var w=e;if(k(w)){var D=function(e){var t,r="OperatorNode:"+e,n=function(e,t){var r="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!r){if(Array.isArray(e)||(r=function(e,t){if(e){if("string"==typeof e)return _p(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?_p(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){r&&(e=r);var n=0,i=function(){};return{s:i,n:function(){return n>=e.length?{done:!0}:{done:!1,value:e[n++]}},e:function(e){throw e},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,o=!0,u=!1;return{s:function(){r=r.call(e)},n:function(){var e=r.next();return o=e.done,e},e:function(e){u=!0,a=e},f:function(){try{o||null==r.return||r.return()}finally{if(u)throw a}}}}(Bp);try{for(n.s();!(t=n.n()).done;){var i=t.value;if(r in i)return i[r].op}}catch(e){n.e(e)}finally{n.f()}return null}(w.name);if(!D)return new u(b(w.fn),w.args.map((function(e){return b(e,t)})));if(w.args.length>2&&g(w,"associative",o))for(;w.args.length>2;){var N=w.args.pop(),E=w.args.pop();w.args.push(new f(D,w.name,[N,E]))}w=new f(D,w.name,w.args)}if(q(w)&&w.isUnary()){var A=b(w.args[0],t);if("~"===w.op&&q(A)&&A.isUnary()&&"~"===A.op)return A.args[0];if("not"===w.op&&q(A)&&A.isUnary()&&"not"===A.op&&v(A.args[0]))return A.args[0];var M=!0;if("-"===w.op&&q(A)&&(A.isBinary()&&"subtract"===A.fn&&(w=new f("-","subtract",[A.args[1],A.args[0]]),M=!1),A.isUnary()&&"-"===A.op))return A.args[0];if(M)return new f(w.op,w.fn,[A])}if(q(w)&&w.isBinary()){var F=b(w.args[0],t),O=b(w.args[1],t);if("+"===w.op){if(T(F)&&n(F.value))return O;if(T(O)&&n(O.value))return F;q(O)&&O.isUnary()&&"-"===O.op&&(O=O.args[0],w=new f("-","subtract",[F,O]))}if("-"===w.op)return q(O)&&O.isUnary()&&"-"===O.op?b(new f("+","add",[F,O.args[0]]),t):T(F)&&n(F.value)?b(new f("-","unaryMinus",[O])):T(O)&&n(O.value)?F:new f(w.op,w.fn,[F,O]);if("*"===w.op){if(T(F)){if(n(F.value))return p;if(r(F.value,1))return O}if(T(O)){if(n(O.value))return p;if(r(O.value,1))return F;if(x(w,o))return new f(w.op,w.fn,[O,F],w.implicit)}return new f(w.op,w.fn,[F,O],w.implicit)}if("/"===w.op)return T(F)&&n(F.value)?p:T(O)&&r(O.value,1)?F:new f(w.op,w.fn,[F,O]);if("^"===w.op&&T(O)){if(n(O.value))return m;if(r(O.value,1))return F}if("and"===w.op){if(T(F)){if(!F.value)return d;if(v(O))return O;if(T(O))return O.value?h:d}if(T(O)){if(!O.value)return d;if(v(F))return F}}if("or"===w.op){if(T(F)){if(F.value)return h;if(v(O))return O}if(T(O)){if(O.value)return h;if(v(F))return F}}return new f(w.op,w.fn,[F,O])}if(q(w))return new f(w.op,w.fn,w.args.map((function(e){return b(e,t)})));if(C(w))return new a(w.items.map((function(e){return b(e,t)})));if(S(w))return new i(b(w.object,t),b(w.index,t));if(I(w))return new s(w.dimensions.map((function(e){return b(e,t)})));if(R(w)){var _={};for(var B in w.properties)_[B]=b(w.properties[B],t);return new c(_)}return w}return t(hv,{Node:b,"Node,Object":b})})),vv=Se("resolve",["typed","parse","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode"],(function(e){var t=e.typed,r=e.parse,n=e.ConstantNode,i=e.FunctionNode,a=e.OperatorNode,o=e.ParenthesisNode;function u(e,t){var s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;if(!t)return e;if(U(e)){if(s.has(e.name)){var c=Array.from(s).join(", ");throw new ReferenceError("recursive loop of variable definitions among {".concat(c,"}"))}var f=t.get(e.name);if(z(f)){var l=new Set(s);return l.add(e.name),u(f,t,l)}return"number"==typeof f?r(String(f)):void 0!==f?new n(f):e}if(q(e)){var p=e.args.map((function(e){return u(e,t,s)}));return new a(e.op,e.fn,p,e.implicit)}if(j(e))return new o(u(e.content,t,s));if(k(e)){var m=e.args.map((function(e){return u(e,t,s)}));return new i(e.name,m)}return e.map((function(e){return u(e,t,s)}))}return t("resolve",{Node:u,"Node, Map | null | undefined":u,"Node, Object":function(e,t){return u(e,Ye(t))},"Array | Matrix":t.referToSelf((function(e){return function(t){return t.map((function(t){return e(t)}))}})),"Array | Matrix, null | undefined":t.referToSelf((function(e){return function(t){return t.map((function(t){return e(t)}))}})),"Array, Object":t.referTo("Array,Map",(function(e){return function(t,r){return e(t,Ye(r))}})),"Matrix, Object":t.referTo("Matrix,Map",(function(e){return function(t,r){return e(t,Ye(r))}})),"Array | Matrix, Map":t.referToSelf((function(e){return function(t,r){return t.map((function(t){return e(t,r)}))}}))})})),yv="symbolicEqual",gv=Se(yv,["parse","simplify","typed","OperatorNode"],(function(e){e.parse;var t=e.simplify,r=e.typed,n=e.OperatorNode;function i(e,r){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=new n("-","subtract",[e,r]),o=t(a,{},i);return T(o)&&!o.value}return r(yv,{"Node, Node":i,"Node, Node, Object":i})})),xv="derivative",bv=Se(xv,["typed","config","parse","simplify","equal","isZero","numeric","ConstantNode","FunctionNode","OperatorNode","ParenthesisNode","SymbolNode"],(function(e){var t=e.typed,r=e.config,n=e.parse,i=e.simplify,a=e.equal,o=e.isZero,u=e.numeric,s=e.ConstantNode,c=e.FunctionNode,f=e.OperatorNode,l=e.ParenthesisNode,p=e.SymbolNode;function m(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{simplify:!0},n={};v(n,e,t.name);var a=y(e,n);return r.simplify?i(a):a}t.addConversion({from:"identifier",to:"SymbolNode",convert:n});var h=t(xv,{"Node, SymbolNode":m,"Node, SymbolNode, Object":m});t.removeConversion({from:"identifier",to:"SymbolNode",convert:n}),h._simplify=!0,h.toTex=function(e){return d.apply(null,e.args)};var d=t("_derivTex",{"Node, SymbolNode":function(e,t){return T(e)&&"string"===H(e.value)?d(n(e.value).toString(),t.toString(),1):d(e.toTex(),t.toString(),1)},"Node, ConstantNode":function(e,t){if("string"===H(t.value))return d(e,n(t.value));throw new Error("The second parameter to 'derivative' is a non-string constant")},"Node, SymbolNode, ConstantNode":function(e,t,r){return d(e.toString(),t.name,r.value)},"string, string, number":function(e,t,r){return(1===r?"{d\\over d"+t+"}":"{d^{"+r+"}\\over d"+t+"^{"+r+"}}")+"\\left[".concat(e,"\\right]")}}),v=t("constTag",{"Object, ConstantNode, string":function(e,t){return e[t]=!0,!0},"Object, SymbolNode, string":function(e,t,r){return t.name!==r&&(e[t]=!0,!0)},"Object, ParenthesisNode, string":function(e,t,r){return v(e,t.content,r)},"Object, FunctionAssignmentNode, string":function(e,t,r){return-1===t.params.indexOf(r)?(e[t]=!0,!0):v(e,t.expr,r)},"Object, FunctionNode | OperatorNode, string":function(e,t,r){if(t.args.length>0){for(var n=v(e,t.args[0],r),i=1;i<t.args.length;++i)n=v(e,t.args[i],r)&&n;if(n)return e[t]=!0,!0}return!1}}),y=t("_derivative",{"ConstantNode, Object":function(e){return g(0)},"SymbolNode, Object":function(e,t){return void 0!==t[e]?g(0):g(1)},"ParenthesisNode, Object":function(e,t){return new l(y(e.content,t))},"FunctionAssignmentNode, Object":function(e,t){return void 0!==t[e]?g(0):y(e.expr,t)},"FunctionNode, Object":function(e,t){if(void 0!==t[e])return g(0);var r,n,i,a,o=e.args[0],u=!1,s=!1;switch(e.name){case"cbrt":u=!0,n=new f("*","multiply",[g(3),new f("^","pow",[o,new f("/","divide",[g(2),g(3)])])]);break;case"sqrt":case"nthRoot":if(1===e.args.length)u=!0,n=new f("*","multiply",[g(2),new c("sqrt",[o])]);else if(2===e.args.length)return t[r=new f("/","divide",[g(1),e.args[1]])]=t[e.args[1]],y(new f("^","pow",[o,r]),t);break;case"log10":r=g(10);case"log":if(r||1!==e.args.length){if(1===e.args.length&&r||2===e.args.length&&void 0!==t[e.args[1]])n=new f("*","multiply",[o.clone(),new c("log",[r||e.args[1]])]),u=!0;else if(2===e.args.length)return y(new f("/","divide",[new c("log",[o]),new c("log",[e.args[1]])]),t)}else n=o.clone(),u=!0;break;case"pow":if(2===e.args.length)return t[r]=t[e.args[1]],y(new f("^","pow",[o,e.args[1]]),t);break;case"exp":n=new c("exp",[o.clone()]);break;case"sin":n=new c("cos",[o.clone()]);break;case"cos":n=new f("-","unaryMinus",[new c("sin",[o.clone()])]);break;case"tan":n=new f("^","pow",[new c("sec",[o.clone()]),g(2)]);break;case"sec":n=new f("*","multiply",[e,new c("tan",[o.clone()])]);break;case"csc":s=!0,n=new f("*","multiply",[e,new c("cot",[o.clone()])]);break;case"cot":s=!0,n=new f("^","pow",[new c("csc",[o.clone()]),g(2)]);break;case"asin":u=!0,n=new c("sqrt",[new f("-","subtract",[g(1),new f("^","pow",[o.clone(),g(2)])])]);break;case"acos":u=!0,s=!0,n=new c("sqrt",[new f("-","subtract",[g(1),new f("^","pow",[o.clone(),g(2)])])]);break;case"atan":u=!0,n=new f("+","add",[new f("^","pow",[o.clone(),g(2)]),g(1)]);break;case"asec":u=!0,n=new f("*","multiply",[new c("abs",[o.clone()]),new c("sqrt",[new f("-","subtract",[new f("^","pow",[o.clone(),g(2)]),g(1)])])]);break;case"acsc":u=!0,s=!0,n=new f("*","multiply",[new c("abs",[o.clone()]),new c("sqrt",[new f("-","subtract",[new f("^","pow",[o.clone(),g(2)]),g(1)])])]);break;case"acot":u=!0,s=!0,n=new f("+","add",[new f("^","pow",[o.clone(),g(2)]),g(1)]);break;case"sinh":n=new c("cosh",[o.clone()]);break;case"cosh":n=new c("sinh",[o.clone()]);break;case"tanh":n=new f("^","pow",[new c("sech",[o.clone()]),g(2)]);break;case"sech":s=!0,n=new f("*","multiply",[e,new c("tanh",[o.clone()])]);break;case"csch":s=!0,n=new f("*","multiply",[e,new c("coth",[o.clone()])]);break;case"coth":s=!0,n=new f("^","pow",[new c("csch",[o.clone()]),g(2)]);break;case"asinh":u=!0,n=new c("sqrt",[new f("+","add",[new f("^","pow",[o.clone(),g(2)]),g(1)])]);break;case"acosh":u=!0,n=new c("sqrt",[new f("-","subtract",[new f("^","pow",[o.clone(),g(2)]),g(1)])]);break;case"atanh":u=!0,n=new f("-","subtract",[g(1),new f("^","pow",[o.clone(),g(2)])]);break;case"asech":u=!0,s=!0,n=new f("*","multiply",[o.clone(),new c("sqrt",[new f("-","subtract",[g(1),new f("^","pow",[o.clone(),g(2)])])])]);break;case"acsch":u=!0,s=!0,n=new f("*","multiply",[new c("abs",[o.clone()]),new c("sqrt",[new f("+","add",[new f("^","pow",[o.clone(),g(2)]),g(1)])])]);break;case"acoth":u=!0,s=!0,n=new f("-","subtract",[g(1),new f("^","pow",[o.clone(),g(2)])]);break;case"abs":n=new f("/","divide",[new c(new p("abs"),[o.clone()]),o.clone()]);break;default:throw new Error('Cannot process function "'+e.name+'" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported')}u?(i="/",a="divide"):(i="*",a="multiply");var l=y(o,t);return s&&(l=new f("-","unaryMinus",[l])),new f(i,a,[l,n])},"OperatorNode, Object":function(e,t){if(void 0!==t[e])return g(0);if("+"===e.op)return new f(e.op,e.fn,e.args.map((function(e){return y(e,t)})));if("-"===e.op){if(e.isUnary())return new f(e.op,e.fn,[y(e.args[0],t)]);if(e.isBinary())return new f(e.op,e.fn,[y(e.args[0],t),y(e.args[1],t)])}if("*"===e.op){var r=e.args.filter((function(e){return void 0!==t[e]}));if(r.length>0){var n=e.args.filter((function(e){return void 0===t[e]})),i=1===n.length?n[0]:new f("*","multiply",n),u=r.concat(y(i,t));return new f("*","multiply",u)}return new f("+","add",e.args.map((function(r){return new f("*","multiply",e.args.map((function(e){return e===r?y(e,t):e.clone()})))})))}if("/"===e.op&&e.isBinary()){var s=e.args[0],l=e.args[1];return void 0!==t[l]?new f("/","divide",[y(s,t),l]):void 0!==t[s]?new f("*","multiply",[new f("-","unaryMinus",[s]),new f("/","divide",[y(l,t),new f("^","pow",[l.clone(),g(2)])])]):new f("/","divide",[new f("-","subtract",[new f("*","multiply",[y(s,t),l.clone()]),new f("*","multiply",[s.clone(),y(l,t)])]),new f("^","pow",[l.clone(),g(2)])])}if("^"===e.op&&e.isBinary()){var p=e.args[0],m=e.args[1];if(void 0!==t[p])return T(p)&&(o(p.value)||a(p.value,1))?g(0):new f("*","multiply",[e,new f("*","multiply",[new c("log",[p.clone()]),y(m.clone(),t)])]);if(void 0!==t[m]){if(T(m)){if(o(m.value))return g(0);if(a(m.value,1))return y(p,t)}var h=new f("^","pow",[p.clone(),new f("-","subtract",[m,g(1)])]);return new f("*","multiply",[m.clone(),new f("*","multiply",[y(p,t),h])])}return new f("*","multiply",[new f("^","pow",[p.clone(),m.clone()]),new f("+","add",[new f("*","multiply",[y(p,t),new f("/","divide",[m.clone(),p.clone()])]),new f("*","multiply",[y(m,t),new c("log",[p.clone()])])])])}throw new Error('Cannot process operator "'+e.op+'" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported')}});function g(e,t){return new s(u(e,t||r.number))}return h})),wv="rationalize",Dv=Se(wv,["config","typed","equal","isZero","add","subtract","multiply","divide","pow","parse","simplifyConstant","simplifyCore","simplify","?bignumber","?fraction","mathWithTransform","matrix","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode","ParenthesisNode"],(function(e){e.config;var t=e.typed,r=(e.equal,e.isZero,e.add,e.subtract,e.multiply,e.divide,e.pow,e.parse,e.simplifyConstant),n=e.simplifyCore,i=e.simplify,a=(e.fraction,e.bignumber,e.mathWithTransform,e.matrix,e.AccessorNode,e.ArrayNode,e.ConstantNode),o=(e.FunctionNode,e.IndexNode,e.ObjectNode,e.OperatorNode),u=e.SymbolNode;function s(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=function(){var e=[n,{l:"n+n",r:"2*n"},{l:"n+-n",r:"0"},r,{l:"n*(n1^-1)",r:"n/n1"},{l:"n*n1^-n2",r:"n/n1^n2"},{l:"n1^-1",r:"1/n1"},{l:"n*(n1/n2)",r:"(n*n1)/n2"},{l:"1*n",r:"n"}],t=[{l:"(-n1)/(-n2)",r:"n1/n2"},{l:"(-n1)*(-n2)",r:"n1*n2"},{l:"n1--n2",r:"n1+n2"},{l:"n1-n2",r:"n1+(-n2)"},{l:"(n1+n2)*n3",r:"(n1*n3 + n2*n3)"},{l:"n1*(n2+n3)",r:"(n1*n2+n1*n3)"},{l:"c1*n + c2*n",r:"(c1+c2)*n"},{l:"c1*n + n",r:"(c1+1)*n"},{l:"c1*n - c2*n",r:"(c1-c2)*n"},{l:"c1*n - n",r:"(c1-1)*n"},{l:"v/c",r:"(1/c)*v"},{l:"v/-c",r:"-(1/c)*v"},{l:"-v*-c",r:"c*v"},{l:"-v*c",r:"-c*v"},{l:"v*-c",r:"-c*v"},{l:"v*c",r:"c*v"},{l:"-(-n1*n2)",r:"(n1*n2)"},{l:"-(n1*n2)",r:"(-n1*n2)"},{l:"-(-n1+n2)",r:"(n1-n2)"},{l:"-(n1+n2)",r:"(-n1-n2)"},{l:"(n1^n2)^n3",r:"(n1^(n2*n3))"},{l:"-(-n1/n2)",r:"(n1/n2)"},{l:"-(n1/n2)",r:"(-n1/n2)"}],i=[{l:"(n1/(n2/n3))",r:"((n1*n3)/n2)"},{l:"(n1/n2/n3)",r:"(n1/(n2*n3))"}],a={};return a.firstRules=e.concat(t,i),a.distrDivRules=[{l:"(n1/n2 + n3/n4)",r:"((n1*n4 + n3*n2)/(n2*n4))"},{l:"(n1/n2 + n3)",r:"((n1 + n3*n2)/n2)"},{l:"(n1 + n2/n3)",r:"((n1*n3 + n2)/n3)"}],a.sucDivRules=i,a.firstRulesAgain=e.concat(t),a.finalRules=[n,{l:"n*-n",r:"-n^2"},{l:"n*n",r:"n^2"},r,{l:"n*-n^n1",r:"-n^(n1+1)"},{l:"n*n^n1",r:"n^(n1+1)"},{l:"n^n1*-n^n2",r:"-n^(n1+n2)"},{l:"n^n1*n^n2",r:"n^(n1+n2)"},{l:"n^n1*-n",r:"-n^(n1+1)"},{l:"n^n1*n",r:"n^(n1+1)"},{l:"n^n1/-n",r:"-n^(n1-1)"},{l:"n^n1/n",r:"n^(n1-1)"},{l:"n/-n^n1",r:"-n^(1-n1)"},{l:"n/n^n1",r:"n^(1-n1)"},{l:"n^n1/-n^n2",r:"n^(n1-n2)"},{l:"n^n1/n^n2",r:"n^(n1-n2)"},{l:"n1+(-n2*n3)",r:"n1-n2*n3"},{l:"v*(-c)",r:"-c*v"},{l:"n1+-n2",r:"n1-n2"},{l:"v*c",r:"c*v"},{l:"(n1^n2)^n3",r:"(n1^(n2*n3))"}],a}(),u=function(e,t,r,n){var a=[],o=i(e,n,t,{exactFractions:!1}),u="+-*"+((r=!!r)?"/":"");!function e(t){var r=t.type;if("FunctionNode"===r)throw new Error("There is an unsolved function call");if("OperatorNode"===r)if("^"===t.op){if("ConstantNode"!==t.args[1].type||!V(parseFloat(t.args[1].value)))throw new Error("There is a non-integer exponent");e(t.args[0])}else{if(-1===u.indexOf(t.op))throw new Error("Operator "+t.op+" invalid in polynomial expression");for(var n=0;n<t.args.length;n++)e(t.args[n])}else if("SymbolNode"===r){var i=t.name;-1===a.indexOf(i)&&a.push(i)}else if("ParenthesisNode"===r)e(t.content);else if("ConstantNode"!==r)throw new Error("type "+r+" is not allowed in polynomial expression")}(o);var s={};return s.expression=o,s.variables=a,s}(e,t,!0,o.firstRules),s=u.variables.length,l={exactFractions:!1},p={exactFractions:!0};if(e=u.expression,s>=1){var m,h;e=c(e);var d,v=!0,y=!1;for(e=i(e,o.firstRules,{},l);h=v?o.distrDivRules:o.sucDivRules,v=!v,(d=(e=i(e,h,{},p)).toString())!==m;)y=!0,m=d;y&&(e=i(e,o.firstRulesAgain,{},l)),e=i(e,o.finalRules,{},l)}var g=[],x={};return"OperatorNode"===e.type&&e.isBinary()&&"/"===e.op?(1===s&&(e.args[0]=f(e.args[0],g),e.args[1]=f(e.args[1])),a&&(x.numerator=e.args[0],x.denominator=e.args[1])):(1===s&&(e=f(e,g)),a&&(x.numerator=e,x.denominator=null)),a?(x.coefficients=g,x.variables=u.variables,x.expression=e,x):e}return e.ParenthesisNode,t(wv,{Node:s,"Node, boolean":function(e,t){return s(e,{},t)},"Node, Object":s,"Node, Object, boolean":s});function c(e,t,r){var n=e.type,i=arguments.length>1;if("OperatorNode"===n&&e.isBinary()){var u,s=!1;if("^"===e.op&&("ParenthesisNode"!==e.args[0].type&&"OperatorNode"!==e.args[0].type||"ConstantNode"!==e.args[1].type||(s=(u=parseFloat(e.args[1].value))>=2&&V(u))),s){if(u>2){var f=e.args[0],l=new o("^","pow",[e.args[0].cloneDeep(),new a(u-1)]);e=new o("*","multiply",[f,l])}else e=new o("*","multiply",[e.args[0],e.args[0].cloneDeep()]);i&&("content"===r?t.content=e:t.args[r]=e)}}if("ParenthesisNode"===n)c(e.content,e,"content");else if("ConstantNode"!==n&&"SymbolNode"!==n)for(var p=0;p<e.args.length;p++)c(e.args[p],e,p);if(!i)return e}function f(e,t){void 0===t&&(t=[]),t[0]=0;var r=0,n="";!function e(i,a,o){var u=i.type;if("FunctionNode"===u)throw new Error("There is an unsolved function call");if("OperatorNode"===u){if(-1==="+-*^".indexOf(i.op))throw new Error("Operator "+i.op+" invalid");if(null!==a){if(("unaryMinus"===i.fn||"pow"===i.fn)&&"add"!==a.fn&&"subtract"!==a.fn&&"multiply"!==a.fn)throw new Error("Invalid "+i.op+" placing");if(("subtract"===i.fn||"add"===i.fn||"multiply"===i.fn)&&"add"!==a.fn&&"subtract"!==a.fn)throw new Error("Invalid "+i.op+" placing");if(("subtract"===i.fn||"add"===i.fn||"unaryMinus"===i.fn)&&0!==o.noFil)throw new Error("Invalid "+i.op+" placing")}"^"!==i.op&&"*"!==i.op||(o.fire=i.op);for(var s=0;s<i.args.length;s++)"unaryMinus"===i.fn&&(o.oper="-"),"+"!==i.op&&"subtract"!==i.fn||(o.fire="",o.cte=1,o.oper=0===s?"+":i.op),o.noFil=s,e(i.args[s],i,o)}else if("SymbolNode"===u){if(i.name!==n&&""!==n)throw new Error("There is more than one variable");if(n=i.name,null===a)return void(t[1]=1);if("^"===a.op&&0!==o.noFil)throw new Error("In power the variable should be the first parameter");if("*"===a.op&&1!==o.noFil)throw new Error("In multiply the variable should be the second parameter");""!==o.fire&&"*"!==o.fire||(r<1&&(t[1]=0),t[1]+=o.cte*("+"===o.oper?1:-1),r=Math.max(1,r))}else{if("ConstantNode"!==u)throw new Error("Type "+u+" is not allowed");var c=parseFloat(i.value);if(null===a)return void(t[0]=c);if("^"===a.op){if(1!==o.noFil)throw new Error("Constant cannot be powered");if(!V(c)||c<=0)throw new Error("Non-integer exponent is not allowed");for(var f=r+1;f<c;f++)t[f]=0;return c>r&&(t[c]=0),t[c]+=o.cte*("+"===o.oper?1:-1),void(r=Math.max(c,r))}o.cte=c,""===o.fire&&(t[0]+=o.cte*("+"===o.oper?1:-1))}}(e,null,{cte:1,oper:"+",fire:""});for(var i,s=!0,c=r=t.length-1;c>=0;c--)if(0!==t[c]){var f=new a(s?t[c]:Math.abs(t[c])),l=t[c]<0?"-":"+";if(c>0){var p=new u(n);if(c>1){var m=new a(c);p=new o("^","pow",[p,m])}f=-1===t[c]&&s?new o("-","unaryMinus",[p]):1===Math.abs(t[c])?p:new o("*","multiply",[f,p])}i=s?f:"+"===l?new o("+","add",[i,f]):new o("-","subtract",[i,f]),s=!1}return s?new a(0):i}})),Nv="zpk2tf",Ev=Se(Nv,["typed","add","multiply","Complex","number"],(function(e){var t=e.typed,r=e.add,n=e.multiply,i=e.Complex,a=e.number;return t(Nv,{"Array,Array,number":function(e,t,r){return o(e,t,r)},"Array,Array":function(e,t){return o(e,t,1)},"Matrix,Matrix,number":function(e,t,r){return o(e.valueOf(),t.valueOf(),r)},"Matrix,Matrix":function(e,t){return o(e.valueOf(),t.valueOf(),1)}});function o(e,t,r){e.some((function(e){return"BigNumber"===e.type}))&&(e=e.map((function(e){return a(e)}))),t.some((function(e){return"BigNumber"===e.type}))&&(t=t.map((function(e){return a(e)})));for(var o=[i(1,0)],s=[i(1,0)],c=0;c<e.length;c++){var f=e[c];"number"==typeof f&&(f=i(f,0)),o=u(o,[i(1,0),i(-f.re,-f.im)])}for(var l=0;l<t.length;l++){var p=t[l];"number"==typeof p&&(p=i(p,0)),s=u(s,[i(1,0),i(-p.re,-p.im)])}for(var m=0;m<o.length;m++)o[m]=n(o[m],r);return[o,s]}function u(e,t){for(var a=[],o=0;o<e.length+t.length-1;o++){a[o]=i(0,0);for(var u=0;u<e.length;u++)o-u>=0&&o-u<t.length&&(a[o]=r(a[o],n(e[u],t[o-u])))}return a}})),Av="freqz",Sv=Se(Av,["typed","add","multiply","Complex","divide","matrix"],(function(e){var t=e.typed,r=e.add,n=e.multiply,i=e.Complex,a=e.divide,o=e.matrix;return t(Av,{"Array, Array":function(e,t){return u(e,t,s(512))},"Array, Array, Array":function(e,t,r){return u(e,t,r)},"Array, Array, number":function(e,t,r){if(r<0)throw new Error("w must be a positive number");return u(e,t,s(r))},"Matrix, Matrix":function(e,t){var r=s(512),n=u(e.valueOf(),t.valueOf(),r),i=n.w,a=n.h;return{w:o(i),h:o(a)}},"Matrix, Matrix, Matrix":function(e,t,r){var n=u(e.valueOf(),t.valueOf(),r.valueOf()).h;return{h:o(n),w:o(r)}},"Matrix, Matrix, number":function(e,t,r){if(r<0)throw new Error("w must be a positive number");var n=s(r),i=u(e.valueOf(),t.valueOf(),n).h;return{h:o(i),w:o(n)}}});function u(e,t,o){for(var u=[],s=[],c=0;c<o.length;c++){for(var f=i(0,0),l=i(0,0),p=0;p<e.length;p++)f=r(f,n(e[p],i(Math.cos(-p*o[c]),Math.sin(-p*o[c]))));for(var m=0;m<t.length;m++)l=r(l,n(t[m],i(Math.cos(-m*o[c]),Math.sin(-m*o[c]))));u.push(f),s.push(l)}for(var h=[],d=0;d<u.length;d++)h.push(a(u[d],s[d]));return{h,w:o}}function s(e){for(var t=[],r=0;r<e;r++)t.push(r/e*Math.PI);return t}})),Cv=Se("reviver",["classes"],(function(e){var t=e.classes;return function(e,r){var n=t[r&&r.mathjs];return n&&"function"==typeof n.fromJSON?n.fromJSON(r):r}})),Mv=Se("replacer",[],(function(){return function(e,t){return"number"!=typeof t||isFinite(t)&&!isNaN(t)?t:{mathjs:"number",value:String(t)}}})),Fv=Math.PI,Ov=2*Math.PI,Tv=Math.E,_v=Se("true",[],(function(){return!0})),Bv=Se("false",[],(function(){return!1})),kv=Se("null",[],(function(){return null})),Iv=Xv("Infinity",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?new r(1/0):1/0})),zv=Xv("NaN",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?new r(NaN):NaN})),Rv=Xv("pi",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?Ef(r):Fv})),qv=Xv("tau",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?Af(r):Ov})),jv=Xv("e",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?Df(r):Tv})),Pv=Xv("phi",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?Nf(r):1.618033988749895})),Lv=Xv("LN2",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?new r(2).ln():Math.LN2})),Uv=Xv("LN10",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?new r(10).ln():Math.LN10})),$v=Xv("LOG2E",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?new r(1).div(new r(2).ln()):Math.LOG2E})),Hv=Xv("LOG10E",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?new r(1).div(new r(10).ln()):Math.LOG10E})),Gv=Xv("SQRT1_2",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?new r("0.5").sqrt():Math.SQRT1_2})),Vv=Xv("SQRT2",["config","?BigNumber"],(function(e){var t=e.config,r=e.BigNumber;return"BigNumber"===t.number?new r(2).sqrt():Math.SQRT2})),Zv=Xv("i",["Complex"],(function(e){return e.Complex.I})),Wv=Se("PI",["pi"],(function(e){return e.pi})),Yv=Se("E",["e"],(function(e){return e.e})),Jv=Se("version",[],(function(){return"12.4.2"}));function Xv(e,t,r){return Se(e,t,r,{recreateOnConfigChange:!0})}var Qv=Wy("speedOfLight","299792458","m s^-1"),Kv=Wy("gravitationConstant","6.67430e-11","m^3 kg^-1 s^-2"),ey=Wy("planckConstant","6.62607015e-34","J s"),ty=Wy("reducedPlanckConstant","1.0545718176461565e-34","J s"),ry=Wy("magneticConstant","1.25663706212e-6","N A^-2"),ny=Wy("electricConstant","8.8541878128e-12","F m^-1"),iy=Wy("vacuumImpedance","376.730313667","ohm"),ay=Wy("coulomb","8.987551792261171e9","N m^2 C^-2"),oy=Wy("elementaryCharge","1.602176634e-19","C"),uy=Wy("bohrMagneton","9.2740100783e-24","J T^-1"),sy=Wy("conductanceQuantum","7.748091729863649e-5","S"),cy=Wy("inverseConductanceQuantum","12906.403729652257","ohm"),fy=Wy("magneticFluxQuantum","2.0678338484619295e-15","Wb"),ly=Wy("nuclearMagneton","5.0507837461e-27","J T^-1"),py=Wy("klitzing","25812.807459304513","ohm"),my=Wy("bohrRadius","5.29177210903e-11","m"),hy=Wy("classicalElectronRadius","2.8179403262e-15","m"),dy=Wy("electronMass","9.1093837015e-31","kg"),vy=Wy("fermiCoupling","1.1663787e-5","GeV^-2"),yy=Yy("fineStructure",.0072973525693),gy=Wy("hartreeEnergy","4.3597447222071e-18","J"),xy=Wy("protonMass","1.67262192369e-27","kg"),by=Wy("deuteronMass","3.3435830926e-27","kg"),wy=Wy("neutronMass","1.6749271613e-27","kg"),Dy=Wy("quantumOfCirculation","3.6369475516e-4","m^2 s^-1"),Ny=Wy("rydberg","10973731.568160","m^-1"),Ey=Wy("thomsonCrossSection","6.6524587321e-29","m^2"),Ay=Yy("weakMixingAngle",.2229),Sy=Yy("efimovFactor",22.7),Cy=Wy("atomicMass","1.66053906660e-27","kg"),My=Wy("avogadro","6.02214076e23","mol^-1"),Fy=Wy("boltzmann","1.380649e-23","J K^-1"),Oy=Wy("faraday","96485.33212331001","C mol^-1"),Ty=Wy("firstRadiation","3.7417718521927573e-16","W m^2"),_y=Wy("loschmidt","2.686780111798444e25","m^-3"),By=Wy("gasConstant","8.31446261815324","J K^-1 mol^-1"),ky=Wy("molarPlanckConstant","3.990312712893431e-10","J s mol^-1"),Iy=Wy("molarVolume","0.022413969545014137","m^3 mol^-1"),zy=Yy("sackurTetrode",-1.16487052358),Ry=Wy("secondRadiation","0.014387768775039337","m K"),qy=Wy("stefanBoltzmann","5.67037441918443e-8","W m^-2 K^-4"),jy=Wy("wienDisplacement","2.897771955e-3","m K"),Py=Wy("molarMass","0.99999999965e-3","kg mol^-1"),Ly=Wy("molarMassC12","11.9999999958e-3","kg mol^-1"),Uy=Wy("gravity","9.80665","m s^-2"),$y=Wy("planckLength","1.616255e-35","m"),Hy=Wy("planckMass","2.176435e-8","kg"),Gy=Wy("planckTime","5.391245e-44","s"),Vy=Wy("planckCharge","1.87554603778e-18","C"),Zy=Wy("planckTemperature","1.416785e+32","K");function Wy(e,t,r){return Se(e,["config","Unit","BigNumber"],(function(e){var n=e.config,i=e.Unit,a=e.BigNumber,o=new i("BigNumber"===n.number?new a(t):parseFloat(t),r);return o.fixPrefix=!0,o}))}function Yy(e,t){return Se(e,["config","BigNumber"],(function(e){var r=e.config,n=e.BigNumber;return"BigNumber"===r.number?new n(t):t}))}var Jy=Se("apply",["typed","isInteger"],(function(e){var t=e.typed,r=e.isInteger,n=ya({typed:t,isInteger:r});return t("apply",{"...any":function(e){var t=e[1];i(t)?e[1]=t-1:a(t)&&(e[1]=t.minus(1));try{return n.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),Xy=Se("column",["typed","Index","matrix","range"],(function(e){var t=e.typed,r=e.Index,n=e.matrix,a=e.range,o=Du({typed:t,Index:r,matrix:n,range:a});return t("column",{"...any":function(e){var t=e.length-1,r=e[t];i(r)&&(e[t]=r-1);try{return o.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0});function Qy(e,t,r){var n=e.filter((function(e){return U(e)&&!(e.name in t)&&!r.has(e.name)}))[0];if(!n)throw new Error('No undefined variable found in inline expression "'+e+'"');var i=n.name,a=new Map,o=new Ve(r,a,new Set([i])),u=e.compile();return function(e){return a.set(i,e),u.evaluate(o)}}var Ky=Se("filter",["typed"],(function(e){var t=e.typed;function r(e,t,r){var i,a;return e[0]&&(i=e[0].compile().evaluate(r)),e[1]&&(a=U(e[1])||B(e[1])?e[1].compile().evaluate(r):Qy(e[1],t,r)),n(i,a)}r.rawArgs=!0;var n=t("filter",{"Array, function":eg,"Matrix, function":function(e,t){return e.create(eg(e.toArray(),t))},"Array, RegExp":Mn,"Matrix, RegExp":function(e,t){return e.create(Mn(e.toArray(),t))}});return r}),{isTransformFunction:!0});function eg(e,t){return Cn(e,(function(e,r,n){return Fu(t,e,[r+1],n,"filter")}))}var tg=Se("forEach",["typed"],(function(e){var t=e.typed;function r(e,t,r){var i,a;return e[0]&&(i=e[0].compile().evaluate(r)),e[1]&&(a=U(e[1])||B(e[1])?e[1].compile().evaluate(r):Qy(e[1],t,r)),n(i,a)}r.rawArgs=!0;var n=t("forEach",{"Array | Matrix, function":function(e,t){!function r(n,i){if(!Array.isArray(n))return Fu(t,n,i,e,"forEach");Sn(n,(function(e,t){r(e,i.concat(t+1))}))}(e.valueOf(),[])}});return r}),{isTransformFunction:!0}),rg=Se("index",["Index","getMatrixDataType"],(function(e){var t=e.Index,r=e.getMatrixDataType;return function(){for(var e=[],n=0,o=arguments.length;n<o;n++){var u=arguments[n];if(d(u))u.start--,u.end-=u.step>0?0:2;else if(u&&!0===u.isSet)u=u.map((function(e){return e-1}));else if(f(u)||l(u))"boolean"!==r(u)&&(u=u.map((function(e){return e-1})));else if(i(u))u--;else if(a(u))u=u.toNumber()-1;else if("string"!=typeof u)throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");e[n]=u}var s=new t;return t.apply(s,e),s}}),{isTransformFunction:!0}),ng=Se("map",["typed"],(function(e){var t=e.typed;function r(e,t,r){var i,a;return e[0]&&(i=e[0].compile().evaluate(r)),e[1]&&(a=U(e[1])||B(e[1])?e[1].compile().evaluate(r):Qy(e[1],t,r)),n(i,a)}r.rawArgs=!0;var n=t("map",{"Array, function":function(e,t){return ig(e,t,e)},"Matrix, function":function(e,t){return e.create(ig(e.valueOf(),t,e))}});return r}),{isTransformFunction:!0});function ig(e,t,r){return function e(n,i){return Array.isArray(n)?An(n,(function(t,r){return e(t,i.concat(r+1))})):Fu(t,n,i,r,"map")}(e,[])}function ag(e){if(2===e.length&&p(e[0])){var t=(e=e.slice())[1];i(t)?e[1]=t-1:a(t)&&(e[1]=t.minus(1))}return e}var og=Se("max",["typed","config","numeric","larger"],(function(e){var t=e.typed,r=e.config,n=e.numeric,i=e.larger,a=df({typed:t,config:r,numeric:n,larger:i});return t("max",{"...any":function(e){e=ag(e);try{return a.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),ug=Se("mean",["typed","add","divide"],(function(e){var t=e.typed,r=e.add,n=e.divide,i=ed({typed:t,add:r,divide:n});return t("mean",{"...any":function(e){e=ag(e);try{return i.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),sg=Se("min",["typed","config","numeric","smaller"],(function(e){var t=e.typed,r=e.config,n=e.numeric,i=e.smaller,a=vf({typed:t,config:r,numeric:n,smaller:i});return t("min",{"...any":function(e){e=ag(e);try{return a.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),cg=Se("range",["typed","config","?matrix","?bignumber","smaller","smallerEq","larger","largerEq","add","isPositive"],(function(e){var t=e.typed,r=e.config,n=e.matrix,i=e.bignumber,a=e.smaller,o=e.smallerEq,u=e.larger,s=e.largerEq,c=e.add,f=e.isPositive,l=Qu({typed:t,config:r,matrix:n,bignumber:i,smaller:a,smallerEq:o,larger:u,largerEq:s,add:c,isPositive:f});return t("range",{"...any":function(e){return"boolean"!=typeof e[e.length-1]&&e.push(!0),l.apply(null,e)}})}),{isTransformFunction:!0}),fg=Se("row",["typed","Index","matrix","range"],(function(e){var t=e.typed,r=e.Index,n=e.matrix,a=e.range,o=os({typed:t,Index:r,matrix:n,range:a});return t("row",{"...any":function(e){var t=e.length-1,r=e[t];i(r)&&(e[t]=r-1);try{return o.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),lg=Se("subset",["typed","matrix","zeros","add"],(function(e){var t=e.typed,r=e.matrix,n=e.zeros,i=e.add,a=ps({typed:t,matrix:r,zeros:n,add:i});return t("subset",{"...any":function(e){try{return a.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),pg=Se("concat",["typed","matrix","isInteger"],(function(e){var t=e.typed,r=e.matrix,n=e.isInteger,o=bu({typed:t,matrix:r,isInteger:n});return t("concat",{"...any":function(e){var t=e.length-1,r=e[t];i(r)?e[t]=r-1:a(r)&&(e[t]=r.minus(1));try{return o.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),mg="diff",hg=Se(mg,["typed","matrix","subtract","number","bignumber"],(function(e){var t=e.typed,r=e.matrix,n=e.subtract,i=e.number,a=e.bignumber,o=Vu({typed:t,matrix:r,subtract:n,number:i,bignumber:a});return t(mg,{"...any":function(e){e=ag(e);try{return o.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),dg=Se("std",["typed","map","sqrt","variance"],(function(e){var t=e.typed,r=e.map,n=e.sqrt,i=e.variance,a=cd({typed:t,map:r,sqrt:n,variance:i});return t("std",{"...any":function(e){e=ag(e);try{return a.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),vg=Se("sum",["typed","config","add","numeric"],(function(e){var t=e.typed,r=e.config,n=e.add,i=e.numeric,a=Jh({typed:t,config:r,add:n,numeric:i});return t("sum",{"...any":function(e){e=ag(e);try{return a.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),yg=Se("quantileSeq",["typed","bignumber","add","subtract","divide","multiply","partitionSelect","compare","isInteger","smaller","smallerEq","larger"],(function(e){var t=e.typed,r=e.bignumber,n=e.add,i=e.subtract,a=e.divide,o=e.multiply,u=e.partitionSelect,s=e.compare,c=e.isInteger,f=e.smaller,l=e.smallerEq,p=e.larger,m=sd({typed:t,bignumber:r,add:n,subtract:i,divide:a,multiply:o,partitionSelect:u,compare:s,isInteger:c,smaller:f,smallerEq:l,larger:p});return t("quantileSeq",{"Array | Matrix, number | BigNumber":m,"Array | Matrix, number | BigNumber, number":function(e,t,r){return m(e,t,h(r))},"Array | Matrix, number | BigNumber, boolean":m,"Array | Matrix, number | BigNumber, boolean, number":function(e,t,r,n){return m(e,t,r,h(n))},"Array | Matrix, Array | Matrix":m,"Array | Matrix, Array | Matrix, number":function(e,t,r){return m(e,t,h(r))},"Array | Matrix, Array | Matrix, boolean":m,"Array | Matrix, Array | Matrix, boolean, number":function(e,t,r,n){return m(e,t,r,h(n))}});function h(e){return ag([[],e])[1]}}),{isTransformFunction:!0}),gg="cumsum",xg=Se(gg,["typed","add","unaryPlus"],(function(e){var t=e.typed,r=e.add,n=e.unaryPlus,o=Qh({typed:t,add:r,unaryPlus:n});return t(gg,{"...any":function(e){if(2===e.length&&p(e[0])){var t=e[1];i(t)?e[1]=t-1:a(t)&&(e[1]=t.minus(1))}try{return o.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),bg="variance",wg=Se(bg,["typed","add","subtract","multiply","divide","apply","isNaN"],(function(e){var t=e.typed,r=e.add,n=e.subtract,i=e.multiply,a=e.divide,o=e.apply,u=e.isNaN,s=od({typed:t,add:r,subtract:n,multiply:i,divide:a,apply:o,isNaN:u});return t(bg,{"...any":function(e){e=ag(e);try{return s.apply(null,e)}catch(e){throw Dp(e)}}})}),{isTransformFunction:!0}),Dg="print",Ng=Se(Dg,["typed","matrix","zeros","add"],(function(e){var t=e.typed,r=e.matrix,n=e.zeros,i=e.add,a=Ws({typed:t,matrix:r,zeros:n,add:i});return t(Dg,{"string, Object | Array":function(e,t){return a(o(e),t)},"string, Object | Array, number | Object":function(e,t,r){return a(o(e),t,r)}});function o(e){return e.replace(Vs,(function(e){return"$"+e.slice(1).split(".").map((function(e){return!isNaN(e)&&e.length>0?parseInt(e)-1:e})).join(".")}))}}),{isTransformFunction:!0}),Eg=Se("and",["typed","matrix","zeros","add","equalScalar","not","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.zeros,a=e.not,o=e.concat,u=_c({typed:t,matrix:r,equalScalar:n,zeros:i,not:a,concat:o});function s(e,t,r){var n=e[0].compile().evaluate(r);if(!p(n)&&!u(n,!0))return!1;var i=e[1].compile().evaluate(r);return u(n,i)}return s.rawArgs=!0,s}),{isTransformFunction:!0}),Ag=Se("or",["typed","matrix","equalScalar","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.DenseMatrix,a=e.concat,o=yu({typed:t,matrix:r,equalScalar:n,DenseMatrix:i,concat:a});function u(e,t,r){var n=e[0].compile().evaluate(r);if(!p(n)&&o(n,!1))return!0;var i=e[1].compile().evaluate(r);return o(n,i)}return u.rawArgs=!0,u}),{isTransformFunction:!0}),Sg=Se("bitAnd",["typed","matrix","zeros","add","equalScalar","not","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.zeros,a=e.not,o=e.concat,u=Qo({typed:t,matrix:r,equalScalar:n,zeros:i,not:a,concat:o});function s(e,t,r){var n=e[0].compile().evaluate(r);if(!p(n)){if(isNaN(n))return NaN;if(0===n||!1===n)return 0}var i=e[1].compile().evaluate(r);return u(n,i)}return s.rawArgs=!0,s}),{isTransformFunction:!0}),Cg=Se("bitOr",["typed","matrix","equalScalar","DenseMatrix","concat"],(function(e){var t=e.typed,r=e.matrix,n=e.equalScalar,i=e.DenseMatrix,a=e.concat,o=ru({typed:t,matrix:r,equalScalar:n,DenseMatrix:i,concat:a});function u(e,t,r){var n=e[0].compile().evaluate(r);if(!p(n)){if(isNaN(n))return NaN;if(-1===n)return-1;if(!0===n)return 1}var i=e[1].compile().evaluate(r);return o(n,i)}return u.rawArgs=!0,u}),{isTransformFunction:!0}),Mg=(r(4170),r(6034),r(1504));var Fg={epsilon:1e-12,matrix:"Matrix",number:"number",precision:64,predictable:!1,randomSeed:null},Og=["Matrix","Array"],Tg=["number","BigNumber","Fraction"];function _g(e,t){function r(r){if(r){var n=ge(e,ye);Bg(r,"matrix",Og),Bg(r,"number",Tg),be(e,r);var i=ge(e,ye),a=ge(r,ye);return t("config",i,n,a),i}return ge(e,ye)}return r.MATRIX_OPTIONS=Og,r.NUMBER_OPTIONS=Tg,Object.keys(Fg).forEach((function(t){Object.defineProperty(r,t,{get:function(){return e[t]},enumerable:!0,configurable:!0})})),r}function Bg(e,t,r){var n,i;void 0!==e[t]&&(n=r,i=e[t],-1===n.indexOf(i))&&console.warn('Warning: Unknown value "'+e[t]+'" for configuration option "'+t+'". Available options: '+r.map((function(e){return JSON.stringify(e)})).join(", ")+".")}const kg=function e(r,n){var _=Yr({},Fg,n);if("function"!=typeof Object.create)throw new Error("ES5 not supported by this JavaScript engine. Please load the es5-shim and es5-sham library for compatibility.");var H,V,Z=(H={isNumber:i,isComplex:o,isBigNumber:a,isFraction:u,isUnit:s,isString:c,isArray:f,isMatrix:l,isCollection:p,isDenseMatrix:m,isSparseMatrix:h,isRange:d,isIndex:v,isBoolean:y,isResultSet:g,isHelp:x,isFunction:b,isDate:w,isRegExp:D,isObject:N,isNull:E,isUndefined:A,isAccessorNode:S,isArrayNode:C,isAssignmentNode:M,isBlockNode:F,isConditionalNode:O,isConstantNode:T,isFunctionAssignmentNode:B,isFunctionNode:k,isIndexNode:I,isNode:z,isObjectNode:R,isOperatorNode:q,isParenthesisNode:j,isRangeNode:P,isRelationalNode:L,isSymbolNode:U,isChain:$},V=new Mg,H.on=V.on.bind(V),H.off=V.off.bind(V),H.once=V.once.bind(V),H.emit=V.emit.bind(V),H);Z.config=_g(_,Z.emit),Z.expression={transform:{},mathWithTransform:{config:Z.config}};var W={};function Y(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return Z.typed.apply(Z.typed,t)}Y.isTypedFunction=G.isTypedFunction;var J=function(e,r,n,i){function c(t,r,a){var o;if(a.wrap&&"function"==typeof r&&(r=function(e){var t=function(){for(var t=[],r=0,i=arguments.length;r<i;r++){var a=arguments[r];t[r]=a&&a.valueOf()}return e.apply(n,t)};return e.transform&&(t.transform=e.transform),t}(r)),"function"==typeof(o=r)&&"string"==typeof o.signature&&(r=e(t,Va({},r.signature,r))),e.isTypedFunction(n[t])&&e.isTypedFunction(r))return r=a.override?e(t,r.signatures):e(n[t],r),n[t]=r,delete i[t],f(t,r),void n.emit("import",t,(function(){return r}));if(void 0===n[t]||a.override)return n[t]=r,delete i[t],f(t,r),void n.emit("import",t,(function(){return r}));if(!a.silent)throw new Error('Cannot import "'+t+'": already exists')}function f(e,t){t&&"function"==typeof t.transform?(n.expression.transform[e]=t.transform,h(e)&&(n.expression.mathWithTransform[e]=t.transform)):(delete n.expression.transform[e],h(e)&&(n.expression.mathWithTransform[e]=t))}function p(e){delete n.expression.transform[e],h(e)?n.expression.mathWithTransform[e]=n[e]:delete n.expression.mathWithTransform[e]}function m(t,r){var a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.fn;if(Bn(a,"."))throw new Error("Factory name should not contain a nested path. Name: "+JSON.stringify(a));var o=v(t)?n.expression.transform:n,u=a in n.expression.transform,s=Ae(o,a)?o[a]:void 0,c=function(){var i={};t.dependencies.map(Me).forEach((function(e){if(Bn(e,"."))throw new Error("Factory dependency should not contain a nested path. Name: "+JSON.stringify(e));"math"===e?i.math=n:"mathWithTransform"===e?i.mathWithTransform=n.expression.mathWithTransform:"classes"===e?i.classes=n:i[e]=n[e]}));var o=t(i);if(o&&"function"==typeof o.transform)throw new Error('Transforms cannot be attached to factory functions. Please create a separate function for it with exports.path="expression.transform"');if(void 0===s||r.override)return o;if(e.isTypedFunction(s)&&e.isTypedFunction(o))return e(s,o);if(r.silent)return s;throw new Error('Cannot import "'+a+'": already exists')};t.meta&&!1===t.meta.lazy?(o[a]=c(),s&&u?p(a):(v(t)||d(t))&&Ee(n.expression.mathWithTransform,a,(function(){return o[a]}))):(Ee(o,a,c),s&&u?p(a):(v(t)||d(t))&&Ee(n.expression.mathWithTransform,a,(function(){return o[a]}))),i[a]=t,n.emit("import",a,c)}function h(e){return!Ae(y,e)}function d(e){return!(-1!==e.fn.indexOf(".")||Ae(y,e.fn)||e.meta&&e.meta.isClass)}function v(e){return void 0!==e&&void 0!==e.meta&&!0===e.meta.isTransformFunction||!1}var y={expression:!0,type:!0,docs:!0,error:!0,json:!0,chain:!0};return function(e,r){var n=arguments.length;if(1!==n&&2!==n)throw new no("import",n,1,2);r||(r={});var i,f={};for(var p in function e(n,i,a){if(Array.isArray(i))i.forEach((function(t){return e(n,t)}));else if("object"===t(i))for(var o in i)Ae(i,o)&&e(n,i[o],o);else if(Ce(i)||void 0!==a){var u=Ce(i)?v(i)?i.fn+".transform":i.fn:a;if(Ae(n,u)&&n[u]!==i&&!r.silent)throw new Error('Cannot import "'+u+'" twice');n[u]=i}else if(!r.silent)throw new TypeError("Factory, Object, or Array expected")}(f,e),f)if(Ae(f,p)){var h=f[p];if(Ce(h))m(h,r);else if("function"==typeof(i=h)||"number"==typeof i||"string"==typeof i||"boolean"==typeof i||null===i||s(i)||o(i)||a(i)||u(i)||l(i)||Array.isArray(i))c(p,h,r);else if(!r.silent)throw new TypeError("Factory, Object, or Array expected")}}}(Y,0,Z,W);return Z.import=J,Z.on("config",(function(){Object.values(W).forEach((function(e){e&&e.meta&&e.meta.recreateOnConfigChange&&J(e,{override:!0})}))})),Z.create=e.bind(null,r),Z.factory=Se,Z.import(Object.values(De(r))),Z.ArgumentsError=no,Z.DimensionError=un,Z.IndexError=sn,Z}(e)})(),n.default})()));
//# sourceMappingURL=math.js.map

/*!
 * Chart.js v3.7.0
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chart = factory());
})(this, (function () { 'use strict';

function fontString(pixelSize, fontStyle, fontFamily) {
  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
}
const requestAnimFrame = (function() {
  if (typeof window === 'undefined') {
    return function(callback) {
      return callback();
    };
  }
  return window.requestAnimationFrame;
}());
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
const _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
const _textX = (align, left, right, rtl) => {
  const check = rtl ? 'left' : 'right';
  return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};

class Animator {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = undefined;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach(fn => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw) {
        chart.draw();
        this._notify(chart, anims, date, 'progress');
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, 'complete');
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), 'complete');
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = new Animator();

/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
const hex = '0123456789ABCDEF';
const h1 = (b) => hex[b & 0xF];
const h2 = (b) => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
const eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));
function isShort(v) {
	return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
}
function hexParse(str) {
	var len = str.length;
	var ret;
	if (str[0] === '#') {
		if (len === 4 || len === 5) {
			ret = {
				r: 255 & map$1[str[1]] * 17,
				g: 255 & map$1[str[2]] * 17,
				b: 255 & map$1[str[3]] * 17,
				a: len === 5 ? map$1[str[4]] * 17 : 255
			};
		} else if (len === 7 || len === 9) {
			ret = {
				r: map$1[str[1]] << 4 | map$1[str[2]],
				g: map$1[str[3]] << 4 | map$1[str[4]],
				b: map$1[str[5]] << 4 | map$1[str[6]],
				a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255
			};
		}
	}
	return ret;
}
function hexString(v) {
	var f = isShort(v) ? h1 : h2;
	return v
		? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')
		: v;
}
function round(v) {
	return v + 0.5 | 0;
}
const lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
	return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
	return lim(round(v * 255), 0, 255);
}
function b2n(v) {
	return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
	return lim(round(v * 100), 0, 100);
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
	const m = RGB_RE.exec(str);
	let a = 255;
	let r, g, b;
	if (!m) {
		return;
	}
	if (m[7] !== r) {
		const v = +m[7];
		a = 255 & (m[8] ? p2b(v) : v * 255);
	}
	r = +m[1];
	g = +m[3];
	b = +m[5];
	r = 255 & (m[2] ? p2b(r) : r);
	g = 255 & (m[4] ? p2b(g) : g);
	b = 255 & (m[6] ? p2b(b) : b);
	return {
		r: r,
		g: g,
		b: b,
		a: a
	};
}
function rgbString(v) {
	return v && (
		v.a < 255
			? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
			: `rgb(${v.r}, ${v.g}, ${v.b})`
	);
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
	const a = s * Math.min(l, 1 - l);
	const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
	return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
	const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
	return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
	const rgb = hsl2rgbn(h, 1, 0.5);
	let i;
	if (w + b > 1) {
		i = 1 / (w + b);
		w *= i;
		b *= i;
	}
	for (i = 0; i < 3; i++) {
		rgb[i] *= 1 - w - b;
		rgb[i] += w;
	}
	return rgb;
}
function rgb2hsl(v) {
	const range = 255;
	const r = v.r / range;
	const g = v.g / range;
	const b = v.b / range;
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l = (max + min) / 2;
	let h, s, d;
	if (max !== min) {
		d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		h = max === r
			? ((g - b) / d) + (g < b ? 6 : 0)
			: max === g
				? (b - r) / d + 2
				: (r - g) / d + 4;
		h = h * 60 + 0.5;
	}
	return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
	return (
		Array.isArray(a)
			? f(a[0], a[1], a[2])
			: f(a, b, c)
	).map(n2b);
}
function hsl2rgb(h, s, l) {
	return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
	return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
	return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
	return (h % 360 + 360) % 360;
}
function hueParse(str) {
	const m = HUE_RE.exec(str);
	let a = 255;
	let v;
	if (!m) {
		return;
	}
	if (m[5] !== v) {
		a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
	}
	const h = hue(+m[2]);
	const p1 = +m[3] / 100;
	const p2 = +m[4] / 100;
	if (m[1] === 'hwb') {
		v = hwb2rgb(h, p1, p2);
	} else if (m[1] === 'hsv') {
		v = hsv2rgb(h, p1, p2);
	} else {
		v = hsl2rgb(h, p1, p2);
	}
	return {
		r: v[0],
		g: v[1],
		b: v[2],
		a: a
	};
}
function rotate(v, deg) {
	var h = rgb2hsl(v);
	h[0] = hue(h[0] + deg);
	h = hsl2rgb(h);
	v.r = h[0];
	v.g = h[1];
	v.b = h[2];
}
function hslString(v) {
	if (!v) {
		return;
	}
	const a = rgb2hsl(v);
	const h = a[0];
	const s = n2p(a[1]);
	const l = n2p(a[2]);
	return v.a < 255
		? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
		: `hsl(${h}, ${s}%, ${l}%)`;
}
const map$1$1 = {
	x: 'dark',
	Z: 'light',
	Y: 're',
	X: 'blu',
	W: 'gr',
	V: 'medium',
	U: 'slate',
	A: 'ee',
	T: 'ol',
	S: 'or',
	B: 'ra',
	C: 'lateg',
	D: 'ights',
	R: 'in',
	Q: 'turquois',
	E: 'hi',
	P: 'ro',
	O: 'al',
	N: 'le',
	M: 'de',
	L: 'yello',
	F: 'en',
	K: 'ch',
	G: 'arks',
	H: 'ea',
	I: 'ightg',
	J: 'wh'
};
const names = {
	OiceXe: 'f0f8ff',
	antiquewEte: 'faebd7',
	aqua: 'ffff',
	aquamarRe: '7fffd4',
	azuY: 'f0ffff',
	beige: 'f5f5dc',
	bisque: 'ffe4c4',
	black: '0',
	blanKedOmond: 'ffebcd',
	Xe: 'ff',
	XeviTet: '8a2be2',
	bPwn: 'a52a2a',
	burlywood: 'deb887',
	caMtXe: '5f9ea0',
	KartYuse: '7fff00',
	KocTate: 'd2691e',
	cSO: 'ff7f50',
	cSnflowerXe: '6495ed',
	cSnsilk: 'fff8dc',
	crimson: 'dc143c',
	cyan: 'ffff',
	xXe: '8b',
	xcyan: '8b8b',
	xgTMnPd: 'b8860b',
	xWay: 'a9a9a9',
	xgYF: '6400',
	xgYy: 'a9a9a9',
	xkhaki: 'bdb76b',
	xmagFta: '8b008b',
	xTivegYF: '556b2f',
	xSange: 'ff8c00',
	xScEd: '9932cc',
	xYd: '8b0000',
	xsOmon: 'e9967a',
	xsHgYF: '8fbc8f',
	xUXe: '483d8b',
	xUWay: '2f4f4f',
	xUgYy: '2f4f4f',
	xQe: 'ced1',
	xviTet: '9400d3',
	dAppRk: 'ff1493',
	dApskyXe: 'bfff',
	dimWay: '696969',
	dimgYy: '696969',
	dodgerXe: '1e90ff',
	fiYbrick: 'b22222',
	flSOwEte: 'fffaf0',
	foYstWAn: '228b22',
	fuKsia: 'ff00ff',
	gaRsbSo: 'dcdcdc',
	ghostwEte: 'f8f8ff',
	gTd: 'ffd700',
	gTMnPd: 'daa520',
	Way: '808080',
	gYF: '8000',
	gYFLw: 'adff2f',
	gYy: '808080',
	honeyMw: 'f0fff0',
	hotpRk: 'ff69b4',
	RdianYd: 'cd5c5c',
	Rdigo: '4b0082',
	ivSy: 'fffff0',
	khaki: 'f0e68c',
	lavFMr: 'e6e6fa',
	lavFMrXsh: 'fff0f5',
	lawngYF: '7cfc00',
	NmoncEffon: 'fffacd',
	ZXe: 'add8e6',
	ZcSO: 'f08080',
	Zcyan: 'e0ffff',
	ZgTMnPdLw: 'fafad2',
	ZWay: 'd3d3d3',
	ZgYF: '90ee90',
	ZgYy: 'd3d3d3',
	ZpRk: 'ffb6c1',
	ZsOmon: 'ffa07a',
	ZsHgYF: '20b2aa',
	ZskyXe: '87cefa',
	ZUWay: '778899',
	ZUgYy: '778899',
	ZstAlXe: 'b0c4de',
	ZLw: 'ffffe0',
	lime: 'ff00',
	limegYF: '32cd32',
	lRF: 'faf0e6',
	magFta: 'ff00ff',
	maPon: '800000',
	VaquamarRe: '66cdaa',
	VXe: 'cd',
	VScEd: 'ba55d3',
	VpurpN: '9370db',
	VsHgYF: '3cb371',
	VUXe: '7b68ee',
	VsprRggYF: 'fa9a',
	VQe: '48d1cc',
	VviTetYd: 'c71585',
	midnightXe: '191970',
	mRtcYam: 'f5fffa',
	mistyPse: 'ffe4e1',
	moccasR: 'ffe4b5',
	navajowEte: 'ffdead',
	navy: '80',
	Tdlace: 'fdf5e6',
	Tive: '808000',
	TivedBb: '6b8e23',
	Sange: 'ffa500',
	SangeYd: 'ff4500',
	ScEd: 'da70d6',
	pOegTMnPd: 'eee8aa',
	pOegYF: '98fb98',
	pOeQe: 'afeeee',
	pOeviTetYd: 'db7093',
	papayawEp: 'ffefd5',
	pHKpuff: 'ffdab9',
	peru: 'cd853f',
	pRk: 'ffc0cb',
	plum: 'dda0dd',
	powMrXe: 'b0e0e6',
	purpN: '800080',
	YbeccapurpN: '663399',
	Yd: 'ff0000',
	Psybrown: 'bc8f8f',
	PyOXe: '4169e1',
	saddNbPwn: '8b4513',
	sOmon: 'fa8072',
	sandybPwn: 'f4a460',
	sHgYF: '2e8b57',
	sHshell: 'fff5ee',
	siFna: 'a0522d',
	silver: 'c0c0c0',
	skyXe: '87ceeb',
	UXe: '6a5acd',
	UWay: '708090',
	UgYy: '708090',
	snow: 'fffafa',
	sprRggYF: 'ff7f',
	stAlXe: '4682b4',
	tan: 'd2b48c',
	teO: '8080',
	tEstN: 'd8bfd8',
	tomato: 'ff6347',
	Qe: '40e0d0',
	viTet: 'ee82ee',
	JHt: 'f5deb3',
	wEte: 'ffffff',
	wEtesmoke: 'f5f5f5',
	Lw: 'ffff00',
	LwgYF: '9acd32'
};
function unpack() {
	const unpacked = {};
	const keys = Object.keys(names);
	const tkeys = Object.keys(map$1$1);
	let i, j, k, ok, nk;
	for (i = 0; i < keys.length; i++) {
		ok = nk = keys[i];
		for (j = 0; j < tkeys.length; j++) {
			k = tkeys[j];
			nk = nk.replace(k, map$1$1[k]);
		}
		k = parseInt(names[ok], 16);
		unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
	}
	return unpacked;
}
let names$1;
function nameParse(str) {
	if (!names$1) {
		names$1 = unpack();
		names$1.transparent = [0, 0, 0, 0];
	}
	const a = names$1[str.toLowerCase()];
	return a && {
		r: a[0],
		g: a[1],
		b: a[2],
		a: a.length === 4 ? a[3] : 255
	};
}
function modHSL(v, i, ratio) {
	if (v) {
		let tmp = rgb2hsl(v);
		tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
		tmp = hsl2rgb(tmp);
		v.r = tmp[0];
		v.g = tmp[1];
		v.b = tmp[2];
	}
}
function clone$1(v, proto) {
	return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
	var v = {r: 0, g: 0, b: 0, a: 255};
	if (Array.isArray(input)) {
		if (input.length >= 3) {
			v = {r: input[0], g: input[1], b: input[2], a: 255};
			if (input.length > 3) {
				v.a = n2b(input[3]);
			}
		}
	} else {
		v = clone$1(input, {r: 0, g: 0, b: 0, a: 1});
		v.a = n2b(v.a);
	}
	return v;
}
function functionParse(str) {
	if (str.charAt(0) === 'r') {
		return rgbParse(str);
	}
	return hueParse(str);
}
class Color {
	constructor(input) {
		if (input instanceof Color) {
			return input;
		}
		const type = typeof input;
		let v;
		if (type === 'object') {
			v = fromObject(input);
		} else if (type === 'string') {
			v = hexParse(input) || nameParse(input) || functionParse(input);
		}
		this._rgb = v;
		this._valid = !!v;
	}
	get valid() {
		return this._valid;
	}
	get rgb() {
		var v = clone$1(this._rgb);
		if (v) {
			v.a = b2n(v.a);
		}
		return v;
	}
	set rgb(obj) {
		this._rgb = fromObject(obj);
	}
	rgbString() {
		return this._valid ? rgbString(this._rgb) : this._rgb;
	}
	hexString() {
		return this._valid ? hexString(this._rgb) : this._rgb;
	}
	hslString() {
		return this._valid ? hslString(this._rgb) : this._rgb;
	}
	mix(color, weight) {
		const me = this;
		if (color) {
			const c1 = me.rgb;
			const c2 = color.rgb;
			let w2;
			const p = weight === w2 ? 0.5 : weight;
			const w = 2 * p - 1;
			const a = c1.a - c2.a;
			const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
			w2 = 1 - w1;
			c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
			c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
			c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
			c1.a = p * c1.a + (1 - p) * c2.a;
			me.rgb = c1;
		}
		return me;
	}
	clone() {
		return new Color(this.rgb);
	}
	alpha(a) {
		this._rgb.a = n2b(a);
		return this;
	}
	clearer(ratio) {
		const rgb = this._rgb;
		rgb.a *= 1 - ratio;
		return this;
	}
	greyscale() {
		const rgb = this._rgb;
		const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
		rgb.r = rgb.g = rgb.b = val;
		return this;
	}
	opaquer(ratio) {
		const rgb = this._rgb;
		rgb.a *= 1 + ratio;
		return this;
	}
	negate() {
		const v = this._rgb;
		v.r = 255 - v.r;
		v.g = 255 - v.g;
		v.b = 255 - v.b;
		return this;
	}
	lighten(ratio) {
		modHSL(this._rgb, 2, ratio);
		return this;
	}
	darken(ratio) {
		modHSL(this._rgb, 2, -ratio);
		return this;
	}
	saturate(ratio) {
		modHSL(this._rgb, 1, ratio);
		return this;
	}
	desaturate(ratio) {
		modHSL(this._rgb, 1, -ratio);
		return this;
	}
	rotate(deg) {
		rotate(this._rgb, deg);
		return this;
	}
}
function index_esm(input) {
	return new Color(input);
}

const isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value)
    ? value
    : index_esm(value).saturate(0.5).darken(0.1).hexString();
}

function noop() {}
const uid = (function() {
  let id = 0;
  return function() {
    return id++;
  };
}());
function isNullOrUndef(value) {
  return value === null || typeof value === 'undefined';
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
const isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === 'undefined' ? defaultValue : value;
}
const toPercentage = (value, dimension) =>
  typeof value === 'string' && value.endsWith('%') ?
    parseFloat(value) / 100
    : value / dimension;
const toDimension = (value, dimension) =>
  typeof value === 'string' && value.endsWith('%') ?
    parseFloat(value) / 100 * dimension
    : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === 'function') {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone(source) {
  if (isArray(source)) {
    return source.map(clone);
  }
  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source = sources[i];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {merger: _mergerIf});
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone(sval);
  }
}
function _deprecated(scope, value, previous, current) {
  if (value !== undefined) {
    console.warn(scope + ': "' + previous +
			'" is deprecated. Please use "' + current + '" instead');
  }
}
const emptyString = '';
const dot = '.';
function indexOfDotOrLength(key, start) {
  const idx = key.indexOf(dot, start);
  return idx === -1 ? key.length : idx;
}
function resolveObjectKey(obj, key) {
  if (key === emptyString) {
    return obj;
  }
  let pos = 0;
  let idx = indexOfDotOrLength(key, pos);
  while (obj && idx > pos) {
    obj = obj[key.substr(pos, idx - pos)];
    pos = idx + 1;
    idx = indexOfDotOrLength(key, pos);
  }
  return obj;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value) => typeof value !== 'undefined';
const isFunction = (value) => typeof value === 'function';
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
}

const overrides = Object.create(null);
const descriptors = Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split('.');
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === 'string') {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ''), scope);
}
class Defaults {
  constructor(_descriptors) {
    this.animation = undefined;
    this.backgroundColor = 'rgba(0,0,0,0.1)';
    this.borderColor = 'rgba(0,0,0,0.1)';
    this.color = '#666';
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      'mousemove',
      'mouseout',
      'click',
      'touchstart',
      'touchmove'
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: 'normal',
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = 'x';
    this.interaction = {
      mode: 'nearest',
      intersect: true
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = undefined;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = '_' + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
}
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith('on'),
  _indexable: (name) => name !== 'events',
  hover: {
    _fallback: 'interaction'
  },
  interaction: {
    _scriptable: false,
    _indexable: false,
  }
});

const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < (-0.5 * PI)) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || (sameAngleIsFullCircle && s === e)
    || (angleToStart > angleToEnd && startToAngle < endToAngle);
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}

function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + ' ' : '')
		+ (font.weight ? font.weight + ' ' : '')
		+ font.size + 'px '
		+ font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== undefined && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext('2d');
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  let type, xOffset, yOffset, size, cornerRadius;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === 'object') {
    type = style.toString();
    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
  default:
    ctx.arc(x, y, radius, 0, TAU);
    ctx.closePath();
    break;
  case 'triangle':
    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    rad += TWO_THIRDS_PI;
    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    rad += TWO_THIRDS_PI;
    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    ctx.closePath();
    break;
  case 'rectRounded':
    cornerRadius = radius * 0.516;
    size = radius - cornerRadius;
    xOffset = Math.cos(rad + QUARTER_PI) * size;
    yOffset = Math.sin(rad + QUARTER_PI) * size;
    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
    ctx.closePath();
    break;
  case 'rect':
    if (!rotation) {
      size = Math.SQRT1_2 * radius;
      ctx.rect(x - size, y - size, 2 * size, 2 * size);
      break;
    }
    rad += QUARTER_PI;
  case 'rectRot':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + yOffset, y - xOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    ctx.closePath();
    break;
  case 'crossRot':
    rad += QUARTER_PI;
  case 'cross':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    break;
  case 'star':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    rad += QUARTER_PI;
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    break;
  case 'line':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    break;
  case 'dash':
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
    break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&
		point.y > area.top - margin && point.y < area.bottom + margin);
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === 'middle') {
    const midpoint = (previous.x + target.x) / 2.0;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === 'after' !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(
    flip ? previous.cp1x : previous.cp2x,
    flip ? previous.cp1y : previous.cp2y,
    flip ? target.cp2x : target.cp1x,
    flip ? target.cp2y : target.cp1y,
    target.x,
    target.y);
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const {x, y, w, h, radius} = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}

function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = (lo + hi) >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {lo, hi};
}
const _lookupByKey = (table, key, value) =>
  _lookup(table, value, index => table[index][key] < value);
const _rlookupByKey = (table, key, value) =>
  _lookup(table, value, index => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length
    ? values.slice(start, end)
    : values;
}
const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, '_chartjs', {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = '_onData' + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === 'function') {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set = new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set.add(items[i]);
  }
  if (set.size === ilen) {
    return items;
  }
  return Array.from(set);
}

function _isDomSupported() {
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === '[object ShadowRoot]') {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === 'string') {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf('%') !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
const getComputedStyle = (element) => window.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
const positions = ['top', 'right', 'bottom', 'left'];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? '-' + suffix : '';
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(evt, canvas) {
  const e = evt.native || evt;
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const {offsetX, offsetY} = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {x, y, box};
}
function getRelativePosition$1(evt, chart) {
  const {canvas, currentDevicePixelRatio} = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === 'border-box';
  const paddings = getPositionedStyle(style, 'padding');
  const borders = getPositionedStyle(style, 'border', 'width');
  const {x, y, box} = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let {width, height} = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === undefined || height === undefined) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
      const containerPadding = getPositionedStyle(containerStyle, 'padding');
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = v => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, 'margin');
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let {width, height} = containerSize;
  if (style.boxSizing === 'content-box') {
    const borders = getPositionedStyle(style, 'border', 'width');
    const paddings = getPositionedStyle(style, 'padding');
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio
      || canvas.height !== deviceHeight
      || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
const supportsEventListenerOptions = (function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener('test', null, options);
    window.removeEventListener('test', null, options);
  } catch (e) {
  }
  return passiveSupported;
}());
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : undefined;
}

function getRelativePosition(e, chart) {
  if ('native' in e) {
    return {
      x: e.x,
      y: e.y
    };
  }
  return getRelativePosition$1(e, chart);
}
function evaluateAllVisibleItems(chart, handler) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  let index, data, element;
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    ({index, data} = metasets[i]);
    for (let j = 0, jlen = data.length; j < jlen; ++j) {
      element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function binarySearch(metaset, axis, value, intersect) {
  const {controller, data, _sorted} = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === 'function' && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {lo: start.lo, hi: end.hi};
      }
    }
  }
  return {lo: 0, hi: data.length - 1};
}
function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const {index, data} = metasets[i];
    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf('x') !== -1;
  const useY = axis.indexOf('y') !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition) {
  const items = [];
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({element, datasetIndex, index});
    }
  };
  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index) {
    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);
    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({element, datasetIndex, index});
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index) {
    const inRange = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = _isPointInArea(center, chart.chartArea, chart._minPadding);
    if (!pointInArea && !inRange) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{element, datasetIndex, index}];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({element, datasetIndex, index});
    }
  }
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
  if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
    return [];
  }
  return axis === 'r' && !intersect
    ? getNearestRadialItems(chart, position, axis, useFinalPosition)
    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition);
}
function getAxisItems(chart, e, options, useFinalPosition) {
  const position = getRelativePosition(e, chart);
  const items = [];
  const axis = options.axis;
  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
  let intersectsItem = false;
  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({element, datasetIndex, index});
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      intersectsItem = true;
    }
  });
  if (options.intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'x';
      const items = options.intersect
        ? getIntersectItems(chart, position, axis, useFinalPosition)
        : getNearestItems(chart, position, axis, false, useFinalPosition);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({element, datasetIndex: meta.index, index});
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      let items = options.intersect
        ? getIntersectItems(chart, position, axis, useFinalPosition) :
        getNearestItems(chart, position, axis, false, useFinalPosition);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({element: data[i], datasetIndex, index: i});
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      return getIntersectItems(chart, position, axis, useFinalPosition);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
    },
    x(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, {axis: 'x', intersect: options.intersect}, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      return getAxisItems(chart, e, {axis: 'y', intersect: options.intersect}, useFinalPosition);
    }
  }
};

const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ('' + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === 'normal') {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
  case 'px':
    return value;
  case '%':
    value /= 100;
    break;
  }
  return size * value;
}
const numberOrZero = v => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value)
    ? objProps
      ? prop => valueOrDefault(value[prop], value[props[prop]])
      : prop => value[prop]
    : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === 'string') {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !('' + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = '';
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ''
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === undefined) {
      continue;
    }
    if (context !== undefined && typeof value === 'function') {
      value = value(context);
      cacheable = false;
    }
    if (index !== undefined && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== undefined) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const {min, max} = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}

const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
function filterByPosition(array, position) {
  return array.filter(v => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ?
      v0.index - v1.index :
      v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({position: pos, options: {stack, stackWeight = 1}} = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && (pos + stack),
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts) {
  const stacks = {};
  for (const wrap of layouts) {
    const {stack, pos, stackWeight} = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts, params) {
  const stacks = buildStacks(layouts);
  const {vBoxMaxWidth, hBoxMaxHeight} = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts.length; i < ilen; ++i) {
    layout = layouts[i];
    const {fullSize} = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, 'chartArea'),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const {pos, box} = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {size: 0, count: 1};
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal
    ? {same: widthChanged, other: heightChanged}
    : {same: heightChanged, other: widthChanged};
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos('top');
  chartArea.x += updatePos('left');
  updatePos('right');
  updatePos('bottom');
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions) {
    const margin = {left: 0, top: 0, right: 0, bottom: 0};
    positions.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal
    ? marginForPositions(['left', 'right'])
    : marginForPositions(['top', 'bottom']);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(
      layout.width || chartArea.w,
      layout.height || chartArea.h,
      getMargins(layout.horizontal, chartArea)
    );
    const {same, other} = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let {x, y} = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};
    const weight = (layout.stackWeight / stack.weight) || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
defaults.set('layout', {
  autoPadding: true,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || 'top';
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, box => {
      if (typeof box.beforeLayout === 'function') {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>
      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w,
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});
    });
  }
};

function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve('_fallback', scopes);
  }
  const cache = {
    [Symbol.toStringTag]: 'Object',
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop,
        () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop,
        () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys
        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined
        : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {
  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters' &&
  (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const {_proxy, _context, _subProxy, _stack} = target;
  if (_stack.has(prop)) {
    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter(s => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent) => key === true ? parent
  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
function addScopes(set, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set = new Set();
  set.add(value);
  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set), [''], rootScopes, fallback,
    () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value)
        ? createSubResolver(scopes, proxy, prop, value)
        : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {
      set.add(key);
    }
  }
  return Array.from(set);
}

const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i]
      : !pointAfter ? deltaK[i - 1]
      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0
      : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === 'monotone') {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(
        prev,
        point,
        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
        options.tension
      );
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}

const atEdge = (t) => t === 0 || t === 1;
const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
const effects = {
  linear: t => t,
  easeInQuad: t => t * t,
  easeOutQuad: t => -t * (t - 2),
  easeInOutQuad: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t
    : -0.5 * ((--t) * (t - 2) - 1),
  easeInCubic: t => t * t * t,
  easeOutCubic: t => (t -= 1) * t * t + 1,
  easeInOutCubic: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t
    : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: t => t * t * t * t,
  easeOutQuart: t => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t * t
    : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: t => t * t * t * t * t,
  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t * t * t
    : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: t => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: t => Math.sin(t * HALF_PI),
  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: t => atEdge(t) ? t : t < 0.5
    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))
    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: t => ((t /= 0.5) < 1)
    ? -0.5 * (Math.sqrt(1 - t * t) - 1)
    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t :
      t < 0.5
        ? 0.5 * elasticIn(t * 2, s, p)
        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
  },
  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < (1 / d)) {
      return m * t * t;
    }
    if (t < (2 / d)) {
      return m * (t -= (1.5 / d)) * t + 0.75;
    }
    if (t < (2.5 / d)) {
      return m * (t -= (2.25 / d)) * t + 0.9375;
    }
    return m * (t -= (2.625 / d)) * t + 0.984375;
  },
  easeInOutBounce: t => (t < 0.5)
    ? effects.easeInBounce(t * 2) * 0.5
    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,
};

function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y
    : mode === 'after' ? t < 1 ? p1.y : p2.y
    : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {x: p1.cp2x, y: p1.cp2y};
  const cp2 = {x: p2.cp1x, y: p2.cp1y};
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}

const intlCache = new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}

const getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === 'center') {
        return align;
      }
      return align === 'right' ? 'left' : 'right';
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    },
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    },
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === 'ltr' || direction === 'rtl') {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue('direction'),
      style.getPropertyPriority('direction'),
    ];
    style.setProperty('direction', direction, 'important');
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== undefined) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty('direction', original[0], original[1]);
  }
}

function propertyFn(property) {
  if (property === 'angle') {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle,
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: x => x
  };
}
function normalizeSegment({start, end, count, loop, style}) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const {property, start: startBound, end: endBound} = bounds;
  const {between, normalize} = propertyFn(property);
  const count = points.length;
  let {start, end, loop} = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {start, end, loop, style: segment.style};
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const {property, start: startBound, end: endBound} = bounds;
  const count = points.length;
  const {compare, between, normalize} = propertyFn(property);
  const {start, end, loop, style} = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({start: subStart, end, loop, count, style}));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {start, end};
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({start: start % count, end: (end - 1) % count, loop});
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({start: start % count, end: last % count, loop});
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({start: s % count, end: e % count, loop: l, style: st});
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: 'segment',
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}

var helpers = /*#__PURE__*/Object.freeze({
__proto__: null,
easingEffects: effects,
color: color,
getHoverColor: getHoverColor,
noop: noop,
uid: uid,
isNullOrUndef: isNullOrUndef,
isArray: isArray,
isObject: isObject,
isFinite: isNumberFinite,
finiteOrDefault: finiteOrDefault,
valueOrDefault: valueOrDefault,
toPercentage: toPercentage,
toDimension: toDimension,
callback: callback,
each: each,
_elementsEqual: _elementsEqual,
clone: clone,
_merger: _merger,
merge: merge,
mergeIf: mergeIf,
_mergerIf: _mergerIf,
_deprecated: _deprecated,
resolveObjectKey: resolveObjectKey,
_capitalize: _capitalize,
defined: defined,
isFunction: isFunction,
setsEqual: setsEqual,
_isClickEvent: _isClickEvent,
toFontString: toFontString,
_measureText: _measureText,
_longestText: _longestText,
_alignPixel: _alignPixel,
clearCanvas: clearCanvas,
drawPoint: drawPoint,
_isPointInArea: _isPointInArea,
clipArea: clipArea,
unclipArea: unclipArea,
_steppedLineTo: _steppedLineTo,
_bezierCurveTo: _bezierCurveTo,
renderText: renderText,
addRoundedRectPath: addRoundedRectPath,
_lookup: _lookup,
_lookupByKey: _lookupByKey,
_rlookupByKey: _rlookupByKey,
_filterBetween: _filterBetween,
listenArrayEvents: listenArrayEvents,
unlistenArrayEvents: unlistenArrayEvents,
_arrayUnique: _arrayUnique,
_createResolver: _createResolver,
_attachContext: _attachContext,
_descriptors: _descriptors,
splineCurve: splineCurve,
splineCurveMonotone: splineCurveMonotone,
_updateBezierControlPoints: _updateBezierControlPoints,
_isDomSupported: _isDomSupported,
_getParentNode: _getParentNode,
getStyle: getStyle,
getRelativePosition: getRelativePosition$1,
getMaximumSize: getMaximumSize,
retinaScale: retinaScale,
supportsEventListenerOptions: supportsEventListenerOptions,
readUsedSize: readUsedSize,
fontString: fontString,
requestAnimFrame: requestAnimFrame,
throttled: throttled,
debounce: debounce,
_toLeftRightCenter: _toLeftRightCenter,
_alignStartEnd: _alignStartEnd,
_textX: _textX,
_pointInLine: _pointInLine,
_steppedInterpolation: _steppedInterpolation,
_bezierInterpolation: _bezierInterpolation,
formatNumber: formatNumber,
toLineHeight: toLineHeight,
_readValueToProps: _readValueToProps,
toTRBL: toTRBL,
toTRBLCorners: toTRBLCorners,
toPadding: toPadding,
toFont: toFont,
resolve: resolve,
_addGrace: _addGrace,
createContext: createContext,
PI: PI,
TAU: TAU,
PITAU: PITAU,
INFINITY: INFINITY,
RAD_PER_DEG: RAD_PER_DEG,
HALF_PI: HALF_PI,
QUARTER_PI: QUARTER_PI,
TWO_THIRDS_PI: TWO_THIRDS_PI,
log10: log10,
sign: sign,
niceNum: niceNum,
_factorize: _factorize,
isNumber: isNumber,
almostEquals: almostEquals,
almostWhole: almostWhole,
_setMinAndMaxByKey: _setMinAndMaxByKey,
toRadians: toRadians,
toDegrees: toDegrees,
_decimalPlaces: _decimalPlaces,
getAngleFromPoint: getAngleFromPoint,
distanceBetweenPoints: distanceBetweenPoints,
_angleDiff: _angleDiff,
_normalizeAngle: _normalizeAngle,
_angleBetween: _angleBetween,
_limitValue: _limitValue,
_int16Range: _int16Range,
_isBetween: _isBetween,
getRtlAdapter: getRtlAdapter,
overrideTextDirection: overrideTextDirection,
restoreTextDirection: restoreTextDirection,
_boundSegment: _boundSegment,
_boundSegments: _boundSegments,
_computeSegments: _computeSegments
});

class BasePlatform {
  acquireContext(canvas, aspectRatio) {}
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {}
  removeEventListener(chart, type, listener) {}
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
}

class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext('2d') || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
}

const EXPANDO_KEY = '$chartjs';
const EVENT_TYPES = {
  touchstart: 'mousedown',
  touchmove: 'mousemove',
  touchend: 'mouseup',
  pointerenter: 'mouseenter',
  pointerdown: 'mousedown',
  pointermove: 'mousemove',
  pointerup: 'mouseup',
  pointerleave: 'mouseout',
  pointerout: 'mouseout'
};
const isNullOrEmpty = value => value === null || value === '';
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute('height');
  const renderWidth = canvas.getAttribute('width');
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || 'block';
  style.boxSizing = style.boxSizing || 'border-box';
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, 'width');
    if (displayWidth !== undefined) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === '') {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, 'height');
      if (displayHeight !== undefined) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
const eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const {x, y} = getRelativePosition$1(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== undefined ? x : null,
    y: y !== undefined ? y : null,
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {childList: true, subtree: true});
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver(entries => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {childList: true, subtree: true});
  return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener('resize', onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener('resize', onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver(entries => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === 'resize') {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
class DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext('2d');
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ['height', 'width'].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = undefined;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
}

function _detectPlatform(canvas) {
  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {
    return BasicPlatform;
  }
  return DomPlatform;
}

var platforms = /*#__PURE__*/Object.freeze({
__proto__: null,
_detectPlatform: _detectPlatform,
BasePlatform: BasePlatform,
BasicPlatform: BasicPlatform,
DomPlatform: DomPlatform
});

const transparent = 'transparent';
const interpolators = {
  boolean(from, to, factor) {
    return factor > 0.5 ? to : from;
  },
  color(from, to, factor) {
    const c0 = color(from || transparent);
    const c1 = c0.valid && color(to || transparent);
    return c1 && c1.valid
      ? c1.mix(c0, factor).hexString()
      : to;
  },
  number(from, to, factor) {
    return from + (to - from) * factor;
  }
};
class Animation {
  constructor(cfg, target, prop, to) {
    const currentValue = target[prop];
    to = resolve([cfg.to, to, currentValue, cfg.from]);
    const from = resolve([cfg.from, currentValue, to]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from;
    this._to = to;
    this._promises = undefined;
  }
  active() {
    return this._active;
  }
  update(cfg, to, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([cfg.to, to, currentValue, cfg.from]);
      this._from = resolve([cfg.from, currentValue, to]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from = this._from;
    const loop = this._loop;
    const to = this._to;
    let factor;
    this._active = from !== to && (loop || (elapsed < duration));
    if (!this._active) {
      this._target[prop] = to;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from;
      return;
    }
    factor = (elapsed / duration) % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from, to, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({res, rej});
    });
  }
  _notify(resolved) {
    const method = resolved ? 'res' : 'rej';
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}

const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];
const colors = ['color', 'borderColor', 'backgroundColor'];
defaults.set('animation', {
  delay: undefined,
  duration: 1000,
  easing: 'easeOutQuart',
  fn: undefined,
  from: undefined,
  loop: undefined,
  to: undefined,
  type: undefined,
});
const animationOptions = Object.keys(defaults.animation);
defaults.describe('animation', {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',
});
defaults.set('animations', {
  colors: {
    type: 'color',
    properties: colors
  },
  numbers: {
    type: 'number',
    properties: numbers
  },
});
defaults.describe('animations', {
  _fallback: 'animation',
});
defaults.set('transitions', {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: 'transparent'
      },
      visible: {
        type: 'boolean',
        duration: 0
      },
    }
  },
  hide: {
    animations: {
      colors: {
        to: 'transparent'
      },
      visible: {
        type: 'boolean',
        easing: 'linear',
        fn: v => v | 0
      },
    }
  }
});
class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach(key => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === '$') {
        continue;
      }
      if (prop === 'options') {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});
  }
  return options;
}

function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === undefined ? allowedOverflow : 0;
  const max = opts.max === undefined ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === 'single';
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || (stacked === undefined && meta.stack !== undefined);
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const {min, max, minDefined, maxDefined} = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if ((positive && value > 0) || (!positive && value < 0)) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const {chart, _cachedMeta: meta} = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const {iScale, vScale, index: datasetIndex} = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const {[iAxis]: index, [vAxis]: value} = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return createContext(parent,
    {
      active: false,
      dataset: undefined,
      datasetIndex: index,
      index,
      mode: 'default',
      type: 'dataset'
    }
  );
}
function createDataContext(parent, index, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index,
    parsed: undefined,
    raw: undefined,
    element,
    index,
    mode: 'default',
    type: 'data'
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
const isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked
  && {keys: getSortedDatasetIndices(chart, true), values: null};
class DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = undefined;
    this._parsing = false;
    this._data = undefined;
    this._objectData = undefined;
    this._sharedOptions = undefined;
    this._drawStart = undefined;
    this._drawCount = undefined;
    this.enableOptionSharing = false;
    this.$context = undefined;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale
      ? meta.vScale
      : meta.iScale;
  }
  reset() {
    this._update('reset');
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const {_cachedMeta: meta, _data: data} = this;
    const {iScale, _stacked} = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const {iScale, vScale} = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const {xScale, yScale} = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const {xScale, yScale} = meta;
    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, {mode});
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};
    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || 'default');
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {}
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || (elements.length - start);
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? 'active' : 'default';
    return index === undefined && this._cachedMeta.dataset
      ? this.resolveDatasetElementOptions(mode)
      : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index >= 0 && index < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index];
      context = element.$context ||
        (element.$context = createDataContext(this.getContext(), index, element));
      context.parsed = this.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = this.$context ||
        (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = 'default', index) {
    const active = mode === 'active';
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + '-' + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index, active);
    const values = config.resolveNamedOptions(scopes, names, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes, this.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: (!active && this.getSharedOptions(options)) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, 'reset');
    }
  }
  updateElements(element, start, count, mode) {}
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([this.index, ...args]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(['_insertElements', this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(['_removeElements', 0, 1]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync(['_removeElements', start, count]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync(['_insertElements', start, newCount]);
    }
  }
  _onDataUnshift() {
    this._sync(['_insertElements', 0, arguments.length]);
  }
}
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;

class Element {
  constructor() {
    this.x = undefined;
    this.y = undefined;
    this.active = false;
    this.options = undefined;
    this.$animations = undefined;
  }
  tooltipPosition(useFinalPosition) {
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return {x, y};
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach(prop => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}
Element.defaults = {};
Element.defaultRoutes = undefined;

const formatters = {
  values(value) {
    return isArray(value) ? value : '' + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e+15) {
        notation = 'scientific';
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const remain = tickValue / (Math.pow(10, Math.floor(log10(tickValue))));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return '';
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {formatters};

defaults.set('scale', {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: 'ticks',
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0.0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: '',
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: '',
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: 'center',
    crossAlign: 'near',
    showLabelBackdrop: false,
    backdropColor: 'rgba(255, 255, 255, 0.75)',
    backdropPadding: 2,
  }
});
defaults.route('scale.ticks', 'color', '', 'color');
defaults.route('scale.grid', 'color', '', 'borderColor');
defaults.route('scale.grid', 'borderColor', '', 'borderColor');
defaults.route('scale.title', 'color', '', 'color');
defaults.describe('scale', {
  _fallback: false,
  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',
});
defaults.describe('scales', {
  _fallback: 'scale',
});
defaults.describe('scale.ticks', {
  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',
  _indexable: (name) => name !== 'backdropPadding',
});

function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}

const reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;
const offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
    }
    lineValue += validIndex < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return (lines * font.lineHeight) + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: 'scale'
  });
}
function createTickContext(parent, index, tick) {
  return createContext(parent, {
    tick,
    index,
    type: 'tick'
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const {top, left, bottom, right, chart} = scale;
  const {chartArea, scales} = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === 'center') {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === 'center') {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === 'left' ? -HALF_PI : HALF_PI;
  }
  return {titleX, titleY, maxWidth, rotation};
}
class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = undefined;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = undefined;
    this.maxHeight = undefined;
    this.paddingTop = undefined;
    this.paddingBottom = undefined;
    this.paddingLeft = undefined;
    this.paddingRight = undefined;
    this.axis = undefined;
    this.labelRotation = undefined;
    this.min = undefined;
    this.max = undefined;
    this._range = undefined;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = undefined;
    this._endPixel = undefined;
    this._reversePixels = false;
    this._userMax = undefined;
    this._userMin = undefined;
    this._suggestedMax = undefined;
    this._suggestedMin = undefined;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = undefined;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let {min, max, minDefined, maxDefined} = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {min, max};
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const {beginAtZero, grace, ticks: tickOpts} = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal()
      ? this.width + margins.left + margins.right
      : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [this]);
  }
  beforeDataLimits() {
    this._callHooks('beforeDataLimits');
  }
  determineDataLimits() {}
  afterDataLimits() {
    this._callHooks('afterDataLimits');
  }
  beforeBuildTicks() {
    this._callHooks('beforeBuildTicks');
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks('afterBuildTicks');
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = this.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid)
				- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(
        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))
      ));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const {first, last, widest, highest} = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const {ticks: {align, padding}, position} = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== 'top' && this.axis === 'x';
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === 'start') {
        paddingRight = last.width;
      } else if (align === 'end') {
        paddingLeft = first.width;
      } else {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === 'start') {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === 'end') {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const {axis, position} = this.options;
    return position === 'top' || position === 'bottom' || axis === 'x';
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const {ctx, _longestTextCache: caches} = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights,
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {}
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const {min, max} = this;
    return min < 0 && max < 0 ? max :
      min > 0 && max > 0 ? min :
      0;
  }
  getContext(index) {
    const ticks = this.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context ||
				(tick.$context = createTickContext(this.getContext(), index, tick));
    }
    return this.$context ||
			(this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal()
      ? h * cos > w * sin ? w / cos : h / sin
      : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== 'auto') {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const {grid, position} = options;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === 'top') {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === 'bottom') {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === 'left') {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === 'right') {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === 'x') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === 'y') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(this.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = grid.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === undefined) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset,
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const {position, ticks: optionTicks} = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const {align, crossAlign, padding, mirror} = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = 'middle';
    if (position === 'top') {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'bottom') {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === 'left') {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === 'right') {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === 'x') {
      if (position === 'center') {
        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === 'y') {
      if (position === 'center') {
        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === 'y') {
      if (align === 'start') {
        textBaseline = 'top';
      } else if (align === 'end') {
        textBaseline = 'bottom';
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      if (isHorizontal) {
        x = pixel;
        if (position === 'top') {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
        case 'middle':
          top -= height / 2;
          break;
        case 'bottom':
          top -= height;
          break;
        }
        switch (textAlign) {
        case 'center':
          left -= width / 2;
          break;
        case 'right':
          left -= width;
          break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor,
        };
      }
      items.push({
        rotation,
        label,
        font,
        color,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign,
        textBaseline,
        translation: [x, y],
        backdrop,
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const {position, ticks} = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === 'top' ? 'left' : 'right';
    }
    let align = 'center';
    if (ticks.align === 'start') {
      align = 'left';
    } else if (ticks.align === 'end') {
      align = 'right';
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const {position, ticks: {crossAlign, mirror, padding}} = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === 'left') {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += (widest / 2);
        } else {
          textAlign = 'right';
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= (widest / 2);
        } else {
          textAlign = 'left';
          x = this.left;
        }
      }
    } else if (position === 'right') {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= (widest / 2);
        } else {
          textAlign = 'left';
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += widest / 2;
        } else {
          textAlign = 'right';
          x = this.right;
        }
      }
    } else {
      textAlign = 'right';
    }
    return {textAlign, x};
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === 'left' || position === 'right') {
      return {top: 0, left: this.left, bottom: chart.height, right: this.right};
    } if (position === 'top' || position === 'bottom') {
      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};
    }
  }
  drawBackground() {
    const {ctx, options: {backgroundColor}, left, top, width, height} = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index = ticks.findIndex(t => t.value === value);
    if (index >= 0) {
      const opts = grid.setContext(this.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine(
            {x: item.x1, y: item.y1},
            {x: item.x2, y: item.y2},
            item
          );
        }
        if (grid.drawTicks) {
          drawLine(
            {x: item.tx1, y: item.ty1},
            {x: item.tx2, y: item.ty2},
            {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            }
          );
        }
      }
    }
  }
  drawBorder() {
    const {chart, ctx, options: {grid}} = this;
    const borderOpts = grid.setContext(this.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const {ctx, options: {position, title, reverse}} = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === 'bottom' || position === 'center' || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: 'middle',
      translation: [titleX, titleY],
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw: (chartArea) => {
          this.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw: (chartArea) => {
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawTitle();
      }
    }, {
      z: gz + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: tz,
      draw: (chartArea) => {
        this.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + 'AxisID';
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}

class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + '.' + id;
    if (!id) {
      throw new Error('class does not have id: ' + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach(property => {
    const propertyParts = property.split('.');
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join('.');
    const parts = routes[property].split('.');
    const targetName = parts.pop();
    const targetScope = parts.join('.');
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return 'id' in proto && 'defaults' in proto;
}

class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
    this.elements = new TypedRegistry(Element, 'elements');
    this.plugins = new TypedRegistry(Object, 'plugins');
    this.scales = new TypedRegistry(Scale, 'scales');
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each('register', args);
  }
  remove(...args) {
    this._each('unregister', args);
  }
  addControllers(...args) {
    this._each('register', args, this.controllers);
  }
  addElements(...args) {
    this._each('register', args, this.elements);
  }
  addPlugins(...args) {
    this._each('register', args, this.plugins);
  }
  addScales(...args) {
    this._each('register', args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, 'controller');
  }
  getElement(id) {
    return this._get(id, this.elements, 'element');
  }
  getPlugin(id) {
    return this._get(id, this.plugins, 'plugin');
  }
  getScale(id) {
    return this._get(id, this.scales, 'scale');
  }
  removeControllers(...args) {
    this._each('unregister', args, this.controllers);
  }
  removeElements(...args) {
    this._each('unregister', args, this.elements);
  }
  removePlugins(...args) {
    this._each('unregister', args, this.plugins);
  }
  removeScales(...args) {
    this._each('unregister', args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [...args].forEach(arg => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {
        this._exec(method, reg, arg);
      } else {
        each(arg, item => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry, component) {
    const camelMethod = _capitalize(method);
    callback(component['before' + camelMethod], [], component);
    registry[method](component);
    callback(component['after' + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === undefined) {
      throw new Error('"' + id + '" is not a registered ' + type + '.');
    }
    return item;
  }
}
var registry = new Registry();

class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === 'beforeInit') {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, 'install');
    }
    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors, chart, hook, args);
    if (hook === 'afterDestroy') {
      this._notify(descriptors, chart, 'stop');
      this._notify(this._init, chart, 'uninstall');
    }
    return result;
  }
  _notify(descriptors, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = undefined;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors = this._cache;
    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
    this._notify(diff(descriptors, previousDescriptors), chart, 'start');
  }
}
function allPlugins(config) {
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
    }
  }
  return plugins;
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, plugins, options, all) {
  const result = [];
  const context = chart.getContext();
  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, plugin, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, plugin, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});
}

function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === '_index_') {
    axis = indexAxis;
  } else if (id === '_value_') {
    axis = indexAxis === 'x' ? 'y' : 'x';
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? '_index_' : '_value_';
}
function axisFromPosition(position) {
  if (position === 'top' || position === 'bottom') {
    return 'x';
  }
  if (position === 'left' || position === 'right') {
    return 'y';
  }
}
function determineAxis(id, scaleOptions) {
  if (id === 'x' || id === 'y') {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {scales: {}};
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = Object.create(null);
  const scales = Object.create(null);
  Object.keys(configScales).forEach(id => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach(dataset => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach(defaultID => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;
      scales[id] = scales[id] || Object.create(null);
      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales).forEach(key => {
    const scale = scales[key];
    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
const addIfFound = (set, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== undefined) {
    set.add(opts);
  }
};
class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType,
      () => [[
        `datasets.${datasetType}`,
        ''
      ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`,
      () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`,
        ],
        [
          `datasets.${datasetType}`,
          ''
        ]
      ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`,
      () => [[
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ''
      ]]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`,
      () => [[
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || [],
      ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const {options, type} = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach(keys => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach(key => addIfFound(scopes, mainScope, key));
      }
      keys.forEach(key => addIfFound(scopes, options, key));
      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach(key => addIfFound(scopes, defaults, key));
      keys.forEach(key => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const {options, type} = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {type},
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names, context, prefixes = ['']) {
    const result = {$shared: true};
    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {
    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context)
      ? _attachContext(resolver, context, undefined, descriptorDefaults)
      : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = value => isObject(value)
  && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names) {
  const {isScriptable, isIndexable} = _descriptors(proxy);
  for (const prop of names) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if ((scriptable && (isFunction(value) || hasFunction(value)))
      || (indexable && isArray(value))) {
      return true;
    }
  }
  return false;
}

var version = "3.7.0";

const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
function positionIsHorizontal(position, axis) {
  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1]
      ? a[l2] - b[l2]
      : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins('afterRender');
  callback(animationOptions && animationOptions.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [context], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === 'string') {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === 'mouseout') {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
class Chart {
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error(
        'Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' +
				' must be destroyed before the canvas can be reused.'
      );
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = undefined;
    this.boxes = [];
    this.currentDevicePixelRatio = undefined;
    this.chartArea = undefined;
    this._active = [];
    this._lastEvent = undefined;
    this._listeners = {};
    this._responsiveListeners = undefined;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = undefined;
    this.$context = undefined;
    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, 'complete', onAnimationsComplete);
    animator.listen(this, 'progress', onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    this.notifyPlugins('beforeInit');
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins('afterInit');
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {width, height};
    }
  }
  _resize(width, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? 'resize' : 'attach';
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins('resize', {size: newSize});
    callback(options.onResize, [this, newSize], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales = this.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(
        Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === 'r';
          const isHorizontal = axis === 'x';
          return {
            options: scaleOptions,
            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
          };
        })
      );
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    each(scales, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
  }
  _removeUnreferencedMetasets() {
    const {_metasets: metasets, data: {datasets}} = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter(x => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = '' + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const {datasetElementType, dataElementType} = defaults.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins('reset');
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins('beforeElementsUpdate');
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const {controller} = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins('afterUpdate', {mode});
    this._layers.sort(compare2Level('z', '_idx'));
    const {_active, _lastEvent} = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const {_hiddenIndices} = this;
    const changes = this._getUniformDataChanges() || [];
    for (const {method, start, count} of changes) {
      const move = method === '_removeElements' ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(
      _dataChanges
        .filter(c => c[0] === idx)
        .map((c, i) => i + ',' + c.splice(1).join(','))
    );
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet)
      .map(c => c.split(','))
      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === 'chartArea') {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index) => {
      item._idx = index;
    });
    this.notifyPlugins('afterLayout');
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);
    }
    this.notifyPlugins('afterDatasetsUpdate', {mode});
  }
  _updateDataset(index, mode) {
    const meta = this.getDatasetMeta(index);
    const args = {meta, index, mode, cancelable: true};
    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins('afterDatasetUpdate', args);
  }
  render() {
    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({chart: this});
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const {width, height} = this._resizeBeforeDraw;
      this._resize(width, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins('afterDraw');
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins('afterDatasetsDraw');
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins('afterDatasetDraw', args);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === 'function') {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter(x => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? 'show' : 'hide';
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(undefined, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {visible});
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins('beforeDestroy');
    const {canvas, ctx} = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    this.notifyPlugins('destroy');
    delete instances[this.id];
    this.notifyPlugins('afterDestroy');
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener) => {
      platform.addEventListener(this, type, listener);
      listeners[type] = listener;
    };
    const _remove = (type, listener) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove('attach', attached);
      this.attached = true;
      this.resize();
      _add('resize', listener);
      _add('detach', detached);
    };
    detached = () => {
      this.attached = false;
      _remove('resize', listener);
      this._stop();
      this._resize(0, 0);
      _add('attach', attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = undefined;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? 'set' : 'remove';
    let meta, item, i, ilen;
    if (mode === 'dataset') {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller['_' + prefix + 'DatasetHoverStyle']();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({datasetIndex, index}) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('No dataset found at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index,
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: _isPointInArea(e, this.chartArea, this._minPadding)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins('afterEvent', args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const {_active: lastActive = [], options} = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [e, active, this], this);
      if (isClick) {
        callback(options.onClick, [e, active, this], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === 'mouseout') {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}
const invalidatePlugins = () => each(Chart.instances, (chart) => chart._plugins.invalidate());
const enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: defaults
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: overrides
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});

function abstract() {
  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
class DateAdapter {
  constructor(options) {
    this.options = options || {};
  }
  formats() {
    return abstract();
  }
  parse(value, format) {
    return abstract();
  }
  format(timestamp, format) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
}
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var _adapters = {
  _date: DateAdapter
};

function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = undefined;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - (size / 2)
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = 'left';
    end = 'right';
  } else {
    reverse = properties.base < properties.y;
    start = 'bottom';
    end = 'top';
  }
  if (reverse) {
    top = 'end';
    bottom = 'start';
  } else {
    top = 'start';
    bottom = 'end';
  }
  return {start, end, reverse, top, bottom};
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  const {start, end, reverse, top, bottom} = borderProps(properties);
  if (edge === 'middle' && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === 'start' ? start : v === 'end' ? end : v;
}
function setInflateAmount(properties, {inflateAmount}, ratio) {
  properties.inflateAmount = inflateAmount === 'auto'
    ? ratio === 1 ? 0.33 : 0
    : inflateAmount;
}
class BarController extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const {iScale, vScale} = meta;
    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const {iScale, vScale} = meta;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom)
      ? '[' + custom.start + ', ' + custom.end + ']'
      : '' + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === 'reset';
    const {index, _cachedMeta: {vScale}} = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
      }
      const options = properties.options || bars[i].options;
      setBorderSkipped(properties, options, stack, index);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const metasets = iScale.getMatchingVisibleMetas(this._type);
    const stacked = iScale.options.stacked;
    const ilen = metasets.length;
    const stacks = [];
    let i, item;
    for (i = 0; i < ilen; ++i) {
      item = metasets[i];
      if (!item.controller.options.grouped) {
        continue;
      }
      if (typeof dataIndex !== 'undefined') {
        const val = item.controller.getParsed(dataIndex)[
          item.controller._cachedMeta.vScale.axis
        ];
        if (isNullOrUndef(val) || isNaN(val)) {
          continue;
        }
      }
      if (stacked === false || stacks.indexOf(item.stack) === -1 ||
				(stacked === undefined && item.stack === undefined)) {
        stacks.push(item.stack);
      }
      if (item.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(undefined);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(undefined, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = (name !== undefined)
      ? stacks.indexOf(name)
      : -1;
    return (index === -1)
      ? stacks.length - 1
      : index;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const scale = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === 'flex'
        ? computeFlexCategoryTraits(index, ruler, options, stackCount)
        : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(this._ctx);
      }
    }
  }
}
BarController.id = 'bar';
BarController.defaults = {
  datasetElementType: false,
  dataElementType: 'bar',
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'base', 'width', 'height']
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: 'category',
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: 'linear',
      beginAtZero: true,
    }
  }
};

class BubbleController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const {xScale, yScale} = meta;
    const parsed = this.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {iScale, vScale} = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {$shared: false});
    }
    const radius = values.radius;
    if (mode !== 'active') {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
}
BubbleController.id = 'bubble';
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: 'point',
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'borderWidth', 'radius']
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: 'linear'
    },
    y: {
      type: 'linear'
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return '';
        }
      }
    }
  }
};

function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {ratioX, ratioY, offsetX, offsetY};
}
class DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.offsetX = undefined;
    this.offsetY = undefined;
  }
  linkScales() {}
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i) => +data[i];
      if (isObject(data[start])) {
        const {key = 'value'} = this._parsing;
        getter = (i) => +resolveObjectKey(data[i], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min,
    };
  }
  update(mode) {
    const chart = this.chart;
    const {chartArea} = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const {circumference, rotation} = this._getRotationExtents();
    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || '',
      value,
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== 'inner') {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
DoughnutController.id = 'doughnut';
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: 'arc',
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: 'number',
      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']
    },
  },
  cutout: '50%',
  rotation: 0,
  circumference: 360,
  radius: '100%',
  spacing: 0,
  indexAxis: 'r',
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== 'spacing',
  _indexable: (name) => name !== 'spacing',
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const {labels: {pointStyle}} = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle: pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ': ' + tooltipItem.formattedValue;
          if (isArray(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};

class LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const {dataset: line, data: points = [], _dataset} = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, undefined, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === 'reset';
    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const {spanGaps, segment} = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && (parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
LineController.id = 'line';
LineController.defaults = {
  datasetElementType: 'line',
  dataElementType: 'point',
  showLine: true,
  spanGaps: false,
};
LineController.overrides = {
  scales: {
    _index_: {
      type: 'category',
    },
    _value_: {
      type: 'linear',
    },
  }
};
function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const {iScale, _parsed} = meta;
    const axis = iScale.axis;
    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(Math.min(
        _lookupByKey(_parsed, iScale.axis, min).lo,
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),
      0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        _lookupByKey(_parsed, iScale.axis, max).hi + 1,
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1),
      start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {start, count};
}
function scaleRangesChanged(meta) {
  const {xScale, yScale, _scaleRanges} = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min
		|| _scaleRanges.xmax !== xScale.max
		|| _scaleRanges.ymin !== yScale.min
		|| _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}

class PolarAreaController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = undefined;
    this.outerRadius = undefined;
  }
  getLabelAndValue(index) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || '',
      value,
    };
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - (radiusLength * this.index);
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === 'reset';
    const chart = this.chart;
    const dataset = this.getDataset();
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const dataset = this.getDataset();
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index) => {
      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index)
      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)
      : 0;
  }
}
PolarAreaController.id = 'polarArea';
PolarAreaController.defaults = {
  dataElementType: 'arc',
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']
    },
  },
  indexAxis: 'r',
  startAngle: 0,
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const {labels: {pointStyle}} = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle: pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: 'radialLinear',
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};

class PieController extends DoughnutController {
}
PieController.id = 'pie';
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: '100%'
};

class RadarController extends DatasetController {
  getLabelAndValue(index) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: '' + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== 'resize') {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, undefined, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const dataset = this.getDataset();
    const scale = this._cachedMeta.rScale;
    const reset = mode === 'reset';
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      this.updateElement(point, i, properties, mode);
    }
  }
}
RadarController.id = 'radar';
RadarController.defaults = {
  datasetElementType: 'line',
  dataElementType: 'point',
  indexAxis: 'r',
  showLine: true,
  elements: {
    line: {
      fill: 'start'
    }
  },
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: 'radialLinear',
    }
  }
};

class ScatterController extends LineController {
}
ScatterController.id = 'scatter';
ScatterController.defaults = {
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: 'point'
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(item) {
          return '(' + item.label + ', ' + item.formattedValue + ')';
        }
      }
    }
  },
  scales: {
    x: {
      type: 'linear'
    },
    y: {
      type: 'linear'
    }
  }
};

var controllers = /*#__PURE__*/Object.freeze({
__proto__: null,
BarController: BarController,
BubbleController: BubbleController,
DoughnutController: DoughnutController,
LineController: LineController,
PolarAreaController: PolarAreaController,
PieController: PieController,
RadarController: RadarController,
ScatterController: ScatterController
});

function clipArc(ctx, element, endAngle) {
  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta),
  };
}
function pathArc(ctx, element, offset, spacing, end) {
  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }
  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
  if (outerEnd > 0) {
    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
  }
  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
  ctx.lineTo(p4.x, p4.y);
  if (innerEnd > 0) {
    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
  }
  ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);
  if (innerStart > 0) {
    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
  }
  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
  ctx.lineTo(p8.x, p8.y);
  if (outerStart > 0) {
    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing) {
  const {fullCircles, startAngle, circumference} = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, startAngle + TAU);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % TAU;
      if (circumference % TAU === 0) {
        endAngle += TAU;
      }
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const {x, y, startAngle, pixelMargin, fullCircles} = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element, startAngle + TAU);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset, spacing, endAngle) {
  const {options} = element;
  const {borderWidth, borderJoinStyle} = options;
  const inner = options.borderAlign === 'inner';
  if (!borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || 'round';
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || 'bevel';
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.stroke();
}
class ArcElement extends Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.circumference = undefined;
    this.startAngle = undefined;
    this.endAngle = undefined;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(['x', 'y'], useFinalPosition);
    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});
    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([
      'startAngle',
      'endAngle',
      'innerRadius',
      'outerRadius',
      'circumference'
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return (betweenAngles && withinRadius);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([
      'x',
      'y',
      'startAngle',
      'endAngle',
      'innerRadius',
      'outerRadius',
      'circumference',
    ], useFinalPosition);
    const {offset, spacing} = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const {options, circumference} = this;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (this.circumference >= PI) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, this, radiusOffset, spacing);
    drawBorder(ctx, this, radiusOffset, spacing, endAngle);
    ctx.restore();
  }
}
ArcElement.id = 'arc';
ArcElement.defaults = {
  borderAlign: 'center',
  borderColor: '#fff',
  borderJoinStyle: undefined,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: undefined,
};
ArcElement.defaultRoutes = {
  backgroundColor: 'backgroundColor'
};

function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;
  const {start: segmentStart, end: segmentEnd} = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const {points, options} = line;
  const {count, start, loop, ilen} = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let {move = true, reverse} = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const {count, start, ilen} = pathVars(points, segment, params);
  const {move = true, reverse} = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const {segments, options} = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === 'function';
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
class LineElement extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = undefined;
    this._chart = undefined;
    this._loop = undefined;
    this._fullLoop = undefined;
    this._path = undefined;
    this._points = undefined;
    this._segments = undefined;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
      const loop = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {property, start: value, end: value});
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const {start, end} = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || (this.points.length - start);
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = undefined;
    }
  }
}
LineElement.id = 'line';
LineElement.defaults = {
  borderCapStyle: 'butt',
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: 'miter',
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: 'default',
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0,
};
LineElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== 'borderDash' && name !== 'fill',
};

function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const {[axis]: value} = el.getProps([axis], useFinalPosition);
  return (Math.abs(pos - value) < options.radius + options.hitRadius);
}
class PointElement extends Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.parsed = undefined;
    this.skip = undefined;
    this.stop = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, 'x', useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, 'y', useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return {x, y};
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
PointElement.id = 'point';
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: 'circle',
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};

function getBarBounds(bar, useFinalPosition) {
  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {left, top, right, bottom};
}
function skipOrLimit(skip, value, min, max) {
  return skip ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip.top, o.top, 0, maxH),
    r: skipOrLimit(skip.right, o.right, 0, maxW),
    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds
		&& (skipX || _isBetween(x, bounds.left, bounds.right))
		&& (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
class BarElement extends Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.horizontal = undefined;
    this.base = undefined;
    this.width = undefined;
    this.height = undefined;
    this.inflateAmount = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const {inflateAmount, options: {borderColor, backgroundColor}} = this;
    const {inner, outer} = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill('evenodd');
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === 'x' ? this.width / 2 : this.height / 2;
  }
}
BarElement.id = 'bar';
BarElement.defaults = {
  borderSkipped: 'start',
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: 'auto',
  pointStyle: undefined
};
BarElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};

var elements = /*#__PURE__*/Object.freeze({
__proto__: null,
ArcElement: ArcElement,
LineElement: LineElement,
PointElement: PointElement,
BarElement: BarElement
});

function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const {x: pointAx, y: pointAy} = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs(
        (pointAx - avgX) * (data[j].y - pointAy) -
        (pointAx - data[j].x) * (avgY - pointAy)
      );
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX,
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, 'data', {value: data});
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const {iScale} = meta;
  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {start, count};
}
var plugin_decimation = {
  id: 'decimation',
  defaults: {
    algorithm: 'min-max',
    enabled: false,
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const {_data, indexAxis} = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {
        return;
      }
      if (meta.type !== 'line') {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, 'data', {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
      case 'lttb':
        decimated = lttbDecimation(data, start, count, availableWidth, options);
        break;
      case 'min-max':
        decimated = minMaxDecimation(data, start, count, availableWidth);
        break;
      default:
        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};

function getLineByIndex(chart, index) {
  const meta = chart.getDatasetMeta(index);
  const visible = meta && chart.isDatasetVisible(index);
  return visible ? meta.dataset : null;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill === undefined) {
    fill = !!options.backgroundColor;
  }
  if (fill === false || fill === null) {
    return false;
  }
  if (fill === true) {
    return 'origin';
  }
  return fill;
}
function decodeFill(line, index, count) {
  const fill = parseFillOption(line);
  if (isObject(fill)) {
    return isNaN(fill.value) ? false : fill;
  }
  let target = parseFloat(fill);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    if (fill[0] === '-' || fill[0] === '+') {
      target = index + target;
    }
    if (target === index || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;
}
function computeLinearBoundary(source) {
  const {scale = {}, fill} = source;
  let target = null;
  let horizontal;
  if (fill === 'start') {
    target = scale.bottom;
  } else if (fill === 'end') {
    target = scale.top;
  } else if (isObject(fill)) {
    target = scale.getPixelForValue(fill.value);
  } else if (scale.getBasePixel) {
    target = scale.getBasePixel();
  }
  if (isNumberFinite(target)) {
    horizontal = scale.isHorizontal();
    return {
      x: horizontal ? target : null,
      y: horizontal ? null : target
    };
  }
  return null;
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const {x, y, radius} = this;
    bounds = bounds || {start: 0, end: TAU};
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const {x, y, radius} = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
}
function computeCircularBoundary(source) {
  const {scale, fill} = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const target = [];
  const start = options.reverse ? scale.max : scale.min;
  const end = options.reverse ? scale.min : scale.max;
  let i, center, value;
  if (fill === 'start') {
    value = start;
  } else if (fill === 'end') {
    value = end;
  } else if (isObject(fill)) {
    value = fill.value;
  } else {
    value = scale.getBaseValue();
  }
  if (options.grid.circular) {
    center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function findSegmentEnd(start, end, points) {
  for (;end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function pointsFromSegments(boundary, line) {
  const {x = null, y = null} = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({start, end}) => {
    end = findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({x: first.x, y});
      points.push({x: last.x, y});
    } else if (x !== null) {
      points.push({x, y: first.y});
      points.push({x, y: last.y});
    }
  });
  return points;
}
function buildStackLine(source) {
  const {scale, index, line} = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index);
  linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({points, options: {}});
}
function getLinesBelow(scale, index) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas('line');
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const {first, last, point} = findPoint(line, sourcePoint, 'x');
    if (!point || (first && last)) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {first, last, point};
}
function getTarget(source) {
  const {chart, fill, line} = source;
  if (isNumberFinite(fill)) {
    return getLineByIndex(chart, fill);
  }
  if (fill === 'stack') {
    return buildStackLine(source);
  }
  if (fill === 'shape') {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return createBoundaryLine(boundary, line);
}
function createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {tension: 0},
    _loop,
    _fullLoop: _loop
  }) : null;
}
function resolveTarget(sources, index, propagate) {
  const source = sources[index];
  let fill = source.fill;
  const visited = [index];
  let target;
  if (!propagate) {
    return fill;
  }
  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!isNumberFinite(fill)) {
      return fill;
    }
    target = sources[fill];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill;
    }
    visited.push(fill);
    fill = target.fill;
  }
  return false;
}
function _clip(ctx, target, clipY) {
  ctx.beginPath();
  target.path(ctx);
  ctx.lineTo(target.last().x, clipY);
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === 'angle') {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {property, start, end};
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let {start, end} = segment;
    end = findSegmentEnd(start, end, points);
    const bounds = getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, 'start', Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, 'end', Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function clipBounds(ctx, scale, bounds) {
  const {top, bottom} = scale.chart.chartArea;
  const {property, start, end} = bounds || {};
  if (property === 'x') {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
function _fill(ctx, cfg) {
  const {line, target, property, color, scale} = cfg;
  const segments = _segments(line, target, property);
  for (const {source: src, target: tgt, start, end} of segments) {
    const {style: {backgroundColor = color} = {}} = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? 'evenodd' : 'nonzero');
    ctx.restore();
  }
}
function doFill(ctx, cfg) {
  const {line, target, above, below, area, scale} = cfg;
  const property = line._loop ? 'angle' : cfg.axis;
  ctx.save();
  if (property === 'x' && below !== above) {
    _clip(ctx, target, area.top);
    _fill(ctx, {line, target, color: above, scale, property});
    ctx.restore();
    ctx.save();
    _clip(ctx, target, area.bottom);
  }
  _fill(ctx, {line, target, color: below, scale, property});
  ctx.restore();
}
function drawfill(ctx, source, area) {
  const target = getTarget(source);
  const {line, scale, axis} = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color = lineOpts.backgroundColor;
  const {above = color, below = color} = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {line, target, above, below, area, scale, axis});
    unclipArea(ctx);
  }
}
var plugin_filler = {
  id: 'filler',
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line,
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw = options.drawTime === 'beforeDraw';
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw) {
        drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== 'beforeDatasetsDraw') {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (source) {
        drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {
      return;
    }
    drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: 'beforeDatasetDraw'
  }
};

const getBoxSize = (labelOpts, fontSize) => {
  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = undefined;
    this.columnSizes = undefined;
    this.lineWidths = undefined;
    this.maxHeight = undefined;
    this.maxWidth = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.height = undefined;
    this.width = undefined;
    this._margins = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const {options, ctx} = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const {ctx, maxWidth, options: {labels: {padding}}} = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const {ctx, maxHeight, options: {labels: {padding}}} = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({width: currentColWidth, height: currentColHeight});
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({width: currentColWidth, height: currentColHeight});
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === 'top' || this.options.position === 'bottom';
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const {options: opts, columnSizes, lineWidths, ctx} = this;
    const {align, labels: labelOpts} = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const {color: fontColor, padding} = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign('left');
    ctx.textBaseline = 'middle';
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxWidth * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some(v => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius,
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = 'middle';
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right)
      && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)
          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === 'mousemove') {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [e, previous, this], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [e, hoveredItem, this], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [e, hoveredItem, this], this);
    }
  }
}
function isListened(type, opts) {
  if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === 'click' || type === 'mouseup')) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: 'legend',
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: 'top',
    align: 'center',
    fullSize: true,
    reverse: false,
    weight: 1000,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: 'center',
      text: '',
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith('on'),
    labels: {
      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),
    }
  },
};

class Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === 'top' || pos === 'bottom';
  }
  _drawArgs(offset) {
    const {top, left, bottom, right, options} = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === 'left') {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {titleX, titleY, maxWidth, rotation};
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: 'middle',
      translation: [titleX, titleY],
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: 'title',
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'bold',
    },
    fullSize: true,
    padding: 10,
    position: 'top',
    text: '',
    weight: 2000
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false,
  },
};

const map = new WeakMap();
var plugin_subtitle = {
  id: 'subtitle',
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map.get(chart));
    map.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'normal',
    },
    fullSize: true,
    padding: 0,
    position: 'top',
    text: '',
    weight: 1500
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false,
  },
};

const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
    return str.split('\n');
  }
  return str;
}
function createTooltipItem(chart, item) {
  const {element, datasetIndex, index} = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const {label, value} = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip.chart.ctx;
  const {body, footer, title} = tooltip;
  const {boxWidth, boxHeight} = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight
			+ (titleLineCount - 1) * options.titleSpacing
			+ options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight
			+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight
			+ (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop
			+ footerLineCount * footerFont.lineHeight
			+ (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {width, height};
}
function determineYAlign(chart, size) {
  const {y, height} = size;
  if (y < height / 2) {
    return 'top';
  } else if (y > (chart.height - height / 2)) {
    return 'bottom';
  }
  return 'center';
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const {x, width} = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === 'left' && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === 'right' && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const {x, width} = size;
  const {width: chartWidth, chartArea: {left, right}} = chart;
  let xAlign = 'center';
  if (yAlign === 'center') {
    xAlign = x <= (left + right) / 2 ? 'left' : 'right';
  } else if (x <= width / 2) {
    xAlign = 'left';
  } else if (x >= chartWidth - width / 2) {
    xAlign = 'right';
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = 'center';
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let {x, width} = size;
  if (xAlign === 'right') {
    x -= width;
  } else if (xAlign === 'center') {
    x -= (width / 2);
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let {y, height} = size;
  if (yAlign === 'top') {
    y += paddingAndSize;
  } else if (yAlign === 'bottom') {
    y -= height + paddingAndSize;
  } else {
    y -= (height / 2);
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const {caretSize, caretPadding, cornerRadius} = options;
  const {xAlign, yAlign} = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === 'center') {
    if (xAlign === 'left') {
      x += paddingAndSize;
    } else if (xAlign === 'right') {
      x -= paddingAndSize;
    }
  } else if (xAlign === 'left') {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === 'right') {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = toPadding(options.padding);
  return align === 'center'
    ? tooltip.x + tooltip.width / 2
    : align === 'right'
      ? tooltip.x + tooltip.width - padding.right
      : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback) {
  return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: 'tooltip'
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
class Tooltip extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = undefined;
    this._size = undefined;
    this._cachedAnimations = undefined;
    this._tooltipItems = [];
    this.$animations = undefined;
    this.$context = undefined;
    this.chart = config.chart || config._chart;
    this._chart = this.chart;
    this.options = config.options;
    this.dataPoints = undefined;
    this.title = undefined;
    this.beforeBody = undefined;
    this.body = undefined;
    this.afterBody = undefined;
    this.footer = undefined;
    this.xAlign = undefined;
    this.yAlign = undefined;
    this.x = undefined;
    this.y = undefined;
    this.height = undefined;
    this.width = undefined;
    this.caretX = undefined;
    this.caretY = undefined;
    this.labelColors = undefined;
    this.labelPointStyles = undefined;
    this.labelTextColors = undefined;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = undefined;
    this.$context = undefined;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context ||
			(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const {callbacks} = options;
    const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
    const title = callbacks.title.apply(this, [context]);
    const afterTitle = callbacks.afterTitle.apply(this, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const {callbacks} = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const {callbacks} = options;
    const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
    const footer = callbacks.footer.apply(this, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(this, context));
      labelPointStyles.push(scoped.labelPointStyle.call(this, context));
      labelTextColors.push(scoped.labelTextColor.call(this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = undefined;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {chart: this.chart, tooltip: this, replay});
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const {xAlign, yAlign} = this;
    const {caretSize, cornerRadius} = options;
    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
    const {x: ptX, y: ptY} = tooltipPoint;
    const {width, height} = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === 'center') {
      y2 = ptY + (height / 2);
      if (xAlign === 'left') {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === 'left') {
        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);
      } else if (xAlign === 'right') {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === 'top') {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {x1, x2, x3, y1, y2, y3};
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = 'middle';
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const labelColors = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const {boxHeight, boxWidth, boxPadding} = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, 'left', options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
      const borderRadius = toTRBLCorners(labelColors.borderRadius);
      if (Object.values(borderRadius).some(v => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius,
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius,
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const {body} = this;
    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = 'middle';
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'
      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)
      : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = 'middle';
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const {xAlign, yAlign} = this;
    const {x, y} = pt;
    const {width, height} = tooltipSize;
    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === 'top') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === 'center' && xAlign === 'right') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === 'bottom') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === 'center' && xAlign === 'left') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({datasetIndex, index}) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('Cannot find a dataset at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index,
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e.type === 'mouseout') {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const {caretX, caretY, options} = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: 'tooltip',
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({chart, options});
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    const args = {
      tooltip
    };
    if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {
      return;
    }
    if (tooltip) {
      tooltip.draw(chart.ctx);
    }
    chart.notifyPlugins('afterTooltipDraw', args);
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: 'average',
    backgroundColor: 'rgba(0,0,0,0.8)',
    titleColor: '#fff',
    titleFont: {
      weight: 'bold',
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: 'left',
    bodyColor: '#fff',
    bodySpacing: 2,
    bodyFont: {
    },
    bodyAlign: 'left',
    footerColor: '#fff',
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: 'bold',
    },
    footerAlign: 'left',
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: '#fff',
    displayColors: true,
    boxPadding: 0,
    borderColor: 'rgba(0,0,0,0)',
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: 'easeOutQuart',
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],
      },
      opacity: {
        easing: 'linear',
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: noop,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === 'dataset') {
            return item.dataset.label || '';
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return '';
      },
      afterTitle: noop,
      beforeBody: noop,
      beforeLabel: noop,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === 'dataset') {
          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || '';
        if (label) {
          label += ': ';
        }
        const value = tooltipItem.formattedValue;
        if (!isNullOrUndef(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0,
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation,
        };
      },
      afterLabel: noop,
      afterBody: noop,
      beforeFooter: noop,
      footer: noop,
      afterFooter: noop
    }
  },
  defaultRoutes: {
    bodyFont: 'font',
    footerFont: 'font',
    titleFont: 'font'
  },
  descriptors: {
    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false,
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: 'animation'
    }
  },
  additionalOptionScopes: ['interaction']
};

var plugins = /*#__PURE__*/Object.freeze({
__proto__: null,
Decimation: plugin_decimation,
Filler: plugin_filler,
Legend: plugin_legend,
SubTitle: plugin_subtitle,
Title: plugin_title,
Tooltip: plugin_tooltip
});

const addIfString = (labels, raw, index, addedLabels) => {
  if (typeof raw === 'string') {
    index = labels.push(raw) - 1;
    addedLabels.unshift({index, label: raw});
  } else if (isNaN(raw)) {
    index = null;
  }
  return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
class CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = undefined;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const {index, label} of added) {
        if (labels[index] === label) {
          labels.splice(index, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index
      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const {minDefined, maxDefined} = this.getUserBounds();
    let {min, max} = this.getMinMax(true);
    if (this.options.bounds === 'ticks') {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({value});
    }
    return ticks;
  }
  getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== 'number') {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
CategoryScale.id = 'category';
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};

function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const {min: rmin, max: rmax} = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{value: rmin}, {value: rmax}];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === 'ticks') {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(
    _decimalPlaces(spacing),
    _decimalPlaces(niceMin)
  );
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({value: min});
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({value: max});
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({value: niceMax});
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
  const length = 0.75 * minSpacing * ('' + value).length;
  return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._endValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const {beginAtZero} = this.options;
    const {minDefined, maxDefined} = this.getUserBounds();
    let {min, max} = this;
    const setMin = v => (min = minDefined ? min : v);
    const setMax = v => (max = maxDefined ? max : v);
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let {maxTicksLimit, stepSize} = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1000) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1000;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === 'ticks') {
      _setMinAndMaxByKey(ticks, this, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
}

class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const {min, max} = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
LinearScale.id = 'linear';
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};

function isMajor(tickVal) {
  const remain = tickVal / (Math.pow(10, Math.floor(log10(tickVal))));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor(log10(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
  let exp = Math.floor(log10(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({value: tickVal, major: isMajor(tickVal)});
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || (exp === endExp && significand < endSignificand));
  const lastTick = finiteOrDefault(generationOptions.max, tickVal);
  ticks.push({value: lastTick, major: isMajor(tickVal)});
  return ticks;
}
class LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
    if (value === 0) {
      this._zero = true;
      return undefined;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const {min, max} = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const {minDefined, maxDefined} = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = v => (min = minDefined ? min : v);
    const setMax = v => (max = maxDefined ? max : v);
    const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, +1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, +1));
    }
    if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
      setMin(exp(min, -1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === 'ticks') {
      _setMinAndMaxByKey(ticks, this, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === undefined
      ? '0'
      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === undefined || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min
      ? 0
      : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
LogarithmicScale.id = 'logarithmic';
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};

function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [label];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - (size / 2),
      end: pos + (size / 2)
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(
    orig.l - limits.l,
    limits.r - orig.r,
    orig.t - limits.t,
    limits.b - orig.b
  );
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const extra = getTickBackdropHeight(opts) / 2;
  const outerDistance = scale.drawingArea;
  const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return 'center';
  } else if (angle < 180) {
    return 'left';
  }
  return 'right';
}
function leftForTextAlign(x, w, align) {
  if (align === 'right') {
    x -= w;
  } else if (align === 'center') {
    x -= (w / 2);
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= (h / 2);
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const {ctx, options: {pointLabels}} = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = toFont(optsAtIndex.font);
    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];
    const {backdropColor} = optsAtIndex;
    if (!isNullOrUndef(backdropColor)) {
      const padding = toPadding(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
    }
    renderText(
      ctx,
      scale._pointLabels[i],
      x,
      y + (plFont.lineHeight / 2),
      plFont,
      {
        color: optsAtIndex.color,
        textAlign: textAlign,
        textBaseline: 'middle'
      }
    );
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const {ctx} = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const {color, lineWidth} = gridLineOpts;
  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index, label) {
  return createContext(parent, {
    label,
    index,
    type: 'pointLabel'
  });
}
class RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = undefined;
    this.yCenter = undefined;
    this.drawingArea = undefined;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const {min, max} = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels()
      .map((value, index) => {
        const label = callback(this.options.pointLabels.callback, [value, index], this);
        return label || label === 0 ? label : '';
      })
      .filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const pointLabels = this._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(this.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const {left, top, right, bottom} = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom,
    };
  }
  drawBackground() {
    const {backgroundColor, grid: {circular}} = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const {angleLines, grid} = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(this.getContext(index - 1));
          drawRadiusLine(this, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const {color, lineWidth} = optsAtIndex;
        if (!lineWidth || !color) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {}
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    this.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(
          -width / 2 - padding.left,
          -offset - tickFont.size / 2 - padding.top,
          width + padding.width,
          tickFont.size + padding.height
        );
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
      });
    });
    ctx.restore();
  }
  drawTitle() {}
}
RadialLinearScale.id = 'radialLinear';
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: 'chartArea',
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0.0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: undefined,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
};
RadialLinearScale.defaultRoutes = {
  'angleLines.color': 'borderColor',
  'pointLabels.color': 'color',
  'ticks.color': 'color'
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: 'grid'
  }
};

const INTERVALS = {
  millisecond: {common: true, size: 1, steps: 1000},
  second: {common: true, size: 1000, steps: 60},
  minute: {common: true, size: 60000, steps: 60},
  hour: {common: true, size: 3600000, steps: 24},
  day: {common: true, size: 86400000, steps: 30},
  week: {common: false, size: 604800000, steps: 4},
  month: {common: true, size: 2.628e9, steps: 12},
  quarter: {common: false, size: 7.884e9, steps: 4},
  year: {common: true, size: 3.154e10}
};
const UNITS = (Object.keys(INTERVALS));
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const {parser, round, isoWeekday} = scale._parseOpts;
  let value = input;
  if (typeof parser === 'function') {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === 'string'
      ? adapter.parse(value, parser)
      : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round) {
    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)
      ? adapter.startOf(value, 'isoWeek', isoWeekday)
      : adapter.startOf(value, round);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const {lo, hi} = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
class TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = 'day';
    this._majorUnit = undefined;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = undefined;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === undefined) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || 'day';
    let {min, max, minDefined, maxDefined} = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {min, max};
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === 'ticks' && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip
      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))
      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined
      : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  initOffsets(timestamps) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {start, end, factor: 1 / (start + 1 + end)};
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(timeOpts.stepSize, 1);
    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, 'isoWeek', weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
    if (adapter.diff(max, min, minor) > 100000 * stepSize) {
      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
    }
    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === 'ticks' || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? callback(formatter, [label, index, ticks], this) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),
      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return (this._cache.data = metas[0].controller.getAllParsedValues(this));
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return (this._cache.data = this.normalize(timestamps));
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
}
TimeScale.id = 'time';
TimeScale.defaults = {
  bounds: 'data',
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: 'millisecond',
    displayFormats: {}
  },
  ticks: {
    source: 'auto',
    major: {
      enabled: false
    }
  }
};

function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({lo, hi} = _lookupByKey(table, 'pos', val));
    }
    ({pos: prevSource, time: prevTarget} = table[lo]);
    ({pos: nextSource, time: nextTarget} = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({lo, hi} = _lookupByKey(table, 'time', val));
    }
    ({time: prevSource, pos: prevTarget} = table[lo]);
    ({time: nextSource, pos: nextTarget} = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = undefined;
    this._tableRange = undefined;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const {min, max} = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {time: min, pos: 0},
        {time: max, pos: 1}
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({time: curr, pos: i / (ilen - 1)});
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
TimeSeriesScale.id = 'timeseries';
TimeSeriesScale.defaults = TimeScale.defaults;

var scales = /*#__PURE__*/Object.freeze({
__proto__: null,
CategoryScale: CategoryScale,
LinearScale: LinearScale,
LogarithmicScale: LogarithmicScale,
RadialLinearScale: RadialLinearScale,
TimeScale: TimeScale,
TimeSeriesScale: TimeSeriesScale
});

Chart.register(controllers, scales, elements, plugins);
Chart.helpers = {...helpers};
Chart._adapters = _adapters;
Chart.Animation = Animation;
Chart.Animations = Animations;
Chart.animator = animator;
Chart.controllers = registry.controllers.items;
Chart.DatasetController = DatasetController;
Chart.Element = Element;
Chart.elements = elements;
Chart.Interaction = Interaction;
Chart.layouts = layouts;
Chart.platforms = platforms;
Chart.Scale = Scale;
Chart.Ticks = Ticks;
Object.assign(Chart, controllers, scales, elements, plugins, platforms);
Chart.Chart = Chart;
if (typeof window !== 'undefined') {
  window.Chart = Chart;
}

return Chart;

}));


/*!
 * chartjs-plugin-datalabels v2.0.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2021 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('chart.js/helpers'), require('chart.js')) :
typeof define === 'function' && define.amd ? define(['chart.js/helpers', 'chart.js'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ChartDataLabels = factory(global.Chart.helpers, global.Chart));
}(this, (function (helpers, chart_js) { 'use strict';

var devicePixelRatio = (function() {
  if (typeof window !== 'undefined') {
    if (window.devicePixelRatio) {
      return window.devicePixelRatio;
    }

    // devicePixelRatio is undefined on IE10
    // https://stackoverflow.com/a/20204180/8837887
    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/85
    var screen = window.screen;
    if (screen) {
      return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
    }
  }

  return 1;
}());

var utils = {
  // @todo move this in Chart.helpers.toTextLines
  toTextLines: function(inputs) {
    var lines = [];
    var input;

    inputs = [].concat(inputs);
    while (inputs.length) {
      input = inputs.pop();
      if (typeof input === 'string') {
        lines.unshift.apply(lines, input.split('\n'));
      } else if (Array.isArray(input)) {
        inputs.push.apply(inputs, input);
      } else if (!helpers.isNullOrUndef(inputs)) {
        lines.unshift('' + input);
      }
    }

    return lines;
  },

  // @todo move this in Chart.helpers.canvas.textSize
  // @todo cache calls of measureText if font doesn't change?!
  textSize: function(ctx, lines, font) {
    var items = [].concat(lines);
    var ilen = items.length;
    var prev = ctx.font;
    var width = 0;
    var i;

    ctx.font = font.string;

    for (i = 0; i < ilen; ++i) {
      width = Math.max(ctx.measureText(items[i]).width, width);
    }

    ctx.font = prev;

    return {
      height: ilen * font.lineHeight,
      width: width
    };
  },

  /**
   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).
   * @todo move this method in Chart.helpers.bound
   * https://doc.qt.io/qt-5/qtglobal.html#qBound
   */
  bound: function(min, value, max) {
    return Math.max(min, Math.min(value, max));
  },

  /**
   * Returns an array of pair [value, state] where state is:
   * * -1: value is only in a0 (removed)
   * *  1: value is only in a1 (added)
   */
  arrayDiff: function(a0, a1) {
    var prev = a0.slice();
    var updates = [];
    var i, j, ilen, v;

    for (i = 0, ilen = a1.length; i < ilen; ++i) {
      v = a1[i];
      j = prev.indexOf(v);

      if (j === -1) {
        updates.push([v, 1]);
      } else {
        prev.splice(j, 1);
      }
    }

    for (i = 0, ilen = prev.length; i < ilen; ++i) {
      updates.push([prev[i], -1]);
    }

    return updates;
  },

  /**
   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70
   */
  rasterize: function(v) {
    return Math.round(v * devicePixelRatio) / devicePixelRatio;
  }
};

function orient(point, origin) {
  var x0 = origin.x;
  var y0 = origin.y;

  if (x0 === null) {
    return {x: 0, y: -1};
  }
  if (y0 === null) {
    return {x: 1, y: 0};
  }

  var dx = point.x - x0;
  var dy = point.y - y0;
  var ln = Math.sqrt(dx * dx + dy * dy);

  return {
    x: ln ? dx / ln : 0,
    y: ln ? dy / ln : -1
  };
}

function aligned(x, y, vx, vy, align) {
  switch (align) {
  case 'center':
    vx = vy = 0;
    break;
  case 'bottom':
    vx = 0;
    vy = 1;
    break;
  case 'right':
    vx = 1;
    vy = 0;
    break;
  case 'left':
    vx = -1;
    vy = 0;
    break;
  case 'top':
    vx = 0;
    vy = -1;
    break;
  case 'start':
    vx = -vx;
    vy = -vy;
    break;
  case 'end':
    // keep natural orientation
    break;
  default:
    // clockwise rotation (in degree)
    align *= (Math.PI / 180);
    vx = Math.cos(align);
    vy = Math.sin(align);
    break;
  }

  return {
    x: x,
    y: y,
    vx: vx,
    vy: vy
  };
}

// Line clipping (Cohen–Sutherland algorithm)
// https://en.wikipedia.org/wiki/Cohen–Sutherland_algorithm

var R_INSIDE = 0;
var R_LEFT = 1;
var R_RIGHT = 2;
var R_BOTTOM = 4;
var R_TOP = 8;

function region(x, y, rect) {
  var res = R_INSIDE;

  if (x < rect.left) {
    res |= R_LEFT;
  } else if (x > rect.right) {
    res |= R_RIGHT;
  }
  if (y < rect.top) {
    res |= R_TOP;
  } else if (y > rect.bottom) {
    res |= R_BOTTOM;
  }

  return res;
}

function clipped(segment, area) {
  var x0 = segment.x0;
  var y0 = segment.y0;
  var x1 = segment.x1;
  var y1 = segment.y1;
  var r0 = region(x0, y0, area);
  var r1 = region(x1, y1, area);
  var r, x, y;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    if (!(r0 | r1) || (r0 & r1)) {
      // both points inside or on the same side: no clipping
      break;
    }

    // at least one point is outside
    r = r0 || r1;

    if (r & R_TOP) {
      x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
      y = area.top;
    } else if (r & R_BOTTOM) {
      x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
      y = area.bottom;
    } else if (r & R_RIGHT) {
      y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
      x = area.right;
    } else if (r & R_LEFT) {
      y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
      x = area.left;
    }

    if (r === r0) {
      x0 = x;
      y0 = y;
      r0 = region(x0, y0, area);
    } else {
      x1 = x;
      y1 = y;
      r1 = region(x1, y1, area);
    }
  }

  return {
    x0: x0,
    x1: x1,
    y0: y0,
    y1: y1
  };
}

function compute$1(range, config) {
  var anchor = config.anchor;
  var segment = range;
  var x, y;

  if (config.clamp) {
    segment = clipped(segment, config.area);
  }

  if (anchor === 'start') {
    x = segment.x0;
    y = segment.y0;
  } else if (anchor === 'end') {
    x = segment.x1;
    y = segment.y1;
  } else {
    x = (segment.x0 + segment.x1) / 2;
    y = (segment.y0 + segment.y1) / 2;
  }

  return aligned(x, y, range.vx, range.vy, config.align);
}

var positioners = {
  arc: function(el, config) {
    var angle = (el.startAngle + el.endAngle) / 2;
    var vx = Math.cos(angle);
    var vy = Math.sin(angle);
    var r0 = el.innerRadius;
    var r1 = el.outerRadius;

    return compute$1({
      x0: el.x + vx * r0,
      y0: el.y + vy * r0,
      x1: el.x + vx * r1,
      y1: el.y + vy * r1,
      vx: vx,
      vy: vy
    }, config);
  },

  point: function(el, config) {
    var v = orient(el, config.origin);
    var rx = v.x * el.options.radius;
    var ry = v.y * el.options.radius;

    return compute$1({
      x0: el.x - rx,
      y0: el.y - ry,
      x1: el.x + rx,
      y1: el.y + ry,
      vx: v.x,
      vy: v.y
    }, config);
  },

  bar: function(el, config) {
    var v = orient(el, config.origin);
    var x = el.x;
    var y = el.y;
    var sx = 0;
    var sy = 0;

    if (el.horizontal) {
      x = Math.min(el.x, el.base);
      sx = Math.abs(el.base - el.x);
    } else {
      y = Math.min(el.y, el.base);
      sy = Math.abs(el.base - el.y);
    }

    return compute$1({
      x0: x,
      y0: y + sy,
      x1: x + sx,
      y1: y,
      vx: v.x,
      vy: v.y
    }, config);
  },

  fallback: function(el, config) {
    var v = orient(el, config.origin);

    return compute$1({
      x0: el.x,
      y0: el.y,
      x1: el.x,
      y1: el.y,
      vx: v.x,
      vy: v.y
    }, config);
  }
};

var rasterize = utils.rasterize;

function boundingRects(model) {
  var borderWidth = model.borderWidth || 0;
  var padding = model.padding;
  var th = model.size.height;
  var tw = model.size.width;
  var tx = -tw / 2;
  var ty = -th / 2;

  return {
    frame: {
      x: tx - padding.left - borderWidth,
      y: ty - padding.top - borderWidth,
      w: tw + padding.width + borderWidth * 2,
      h: th + padding.height + borderWidth * 2
    },
    text: {
      x: tx,
      y: ty,
      w: tw,
      h: th
    }
  };
}

function getScaleOrigin(el, context) {
  var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;

  if (!scale) {
    return null;
  }

  if (scale.xCenter !== undefined && scale.yCenter !== undefined) {
    return {x: scale.xCenter, y: scale.yCenter};
  }

  var pixel = scale.getBasePixel();
  return el.horizontal ?
    {x: pixel, y: null} :
    {x: null, y: pixel};
}

function getPositioner(el) {
  if (el instanceof chart_js.ArcElement) {
    return positioners.arc;
  }
  if (el instanceof chart_js.PointElement) {
    return positioners.point;
  }
  if (el instanceof chart_js.BarElement) {
    return positioners.bar;
  }
  return positioners.fallback;
}

function drawRoundedRect(ctx, x, y, w, h, radius) {
  var HALF_PI = Math.PI / 2;

  if (radius) {
    var r = Math.min(radius, h / 2, w / 2);
    var left = x + r;
    var top = y + r;
    var right = x + w - r;
    var bottom = y + h - r;

    ctx.moveTo(x, top);
    if (left < right && top < bottom) {
      ctx.arc(left, top, r, -Math.PI, -HALF_PI);
      ctx.arc(right, top, r, -HALF_PI, 0);
      ctx.arc(right, bottom, r, 0, HALF_PI);
      ctx.arc(left, bottom, r, HALF_PI, Math.PI);
    } else if (left < right) {
      ctx.moveTo(left, y);
      ctx.arc(right, top, r, -HALF_PI, HALF_PI);
      ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);
    } else if (top < bottom) {
      ctx.arc(left, top, r, -Math.PI, 0);
      ctx.arc(left, bottom, r, 0, Math.PI);
    } else {
      ctx.arc(left, top, r, -Math.PI, Math.PI);
    }
    ctx.closePath();
    ctx.moveTo(x, y);
  } else {
    ctx.rect(x, y, w, h);
  }
}

function drawFrame(ctx, rect, model) {
  var bgColor = model.backgroundColor;
  var borderColor = model.borderColor;
  var borderWidth = model.borderWidth;

  if (!bgColor && (!borderColor || !borderWidth)) {
    return;
  }

  ctx.beginPath();

  drawRoundedRect(
    ctx,
    rasterize(rect.x) + borderWidth / 2,
    rasterize(rect.y) + borderWidth / 2,
    rasterize(rect.w) - borderWidth,
    rasterize(rect.h) - borderWidth,
    model.borderRadius);

  ctx.closePath();

  if (bgColor) {
    ctx.fillStyle = bgColor;
    ctx.fill();
  }

  if (borderColor && borderWidth) {
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = 'miter';
    ctx.stroke();
  }
}

function textGeometry(rect, align, font) {
  var h = font.lineHeight;
  var w = rect.w;
  var x = rect.x;
  var y = rect.y + h / 2;

  if (align === 'center') {
    x += w / 2;
  } else if (align === 'end' || align === 'right') {
    x += w;
  }

  return {
    h: h,
    w: w,
    x: x,
    y: y
  };
}

function drawTextLine(ctx, text, cfg) {
  var shadow = ctx.shadowBlur;
  var stroked = cfg.stroked;
  var x = rasterize(cfg.x);
  var y = rasterize(cfg.y);
  var w = rasterize(cfg.w);

  if (stroked) {
    ctx.strokeText(text, x, y, w);
  }

  if (cfg.filled) {
    if (shadow && stroked) {
      // Prevent drawing shadow on both the text stroke and fill, so
      // if the text is stroked, remove the shadow for the text fill.
      ctx.shadowBlur = 0;
    }

    ctx.fillText(text, x, y, w);

    if (shadow && stroked) {
      ctx.shadowBlur = shadow;
    }
  }
}

function drawText(ctx, lines, rect, model) {
  var align = model.textAlign;
  var color = model.color;
  var filled = !!color;
  var font = model.font;
  var ilen = lines.length;
  var strokeColor = model.textStrokeColor;
  var strokeWidth = model.textStrokeWidth;
  var stroked = strokeColor && strokeWidth;
  var i;

  if (!ilen || (!filled && !stroked)) {
    return;
  }

  // Adjust coordinates based on text alignment and line height
  rect = textGeometry(rect, align, font);

  ctx.font = font.string;
  ctx.textAlign = align;
  ctx.textBaseline = 'middle';
  ctx.shadowBlur = model.textShadowBlur;
  ctx.shadowColor = model.textShadowColor;

  if (filled) {
    ctx.fillStyle = color;
  }
  if (stroked) {
    ctx.lineJoin = 'round';
    ctx.lineWidth = strokeWidth;
    ctx.strokeStyle = strokeColor;
  }

  for (i = 0, ilen = lines.length; i < ilen; ++i) {
    drawTextLine(ctx, lines[i], {
      stroked: stroked,
      filled: filled,
      w: rect.w,
      x: rect.x,
      y: rect.y + rect.h * i
    });
  }
}

var Label = function(config, ctx, el, index) {
  var me = this;

  me._config = config;
  me._index = index;
  me._model = null;
  me._rects = null;
  me._ctx = ctx;
  me._el = el;
};

helpers.merge(Label.prototype, {
  /**
   * @private
   */
  _modelize: function(display, lines, config, context) {
    var me = this;
    var index = me._index;
    var font = helpers.toFont(helpers.resolve([config.font, {}], context, index));
    var color = helpers.resolve([config.color, chart_js.defaults.color], context, index);

    return {
      align: helpers.resolve([config.align, 'center'], context, index),
      anchor: helpers.resolve([config.anchor, 'center'], context, index),
      area: context.chart.chartArea,
      backgroundColor: helpers.resolve([config.backgroundColor, null], context, index),
      borderColor: helpers.resolve([config.borderColor, null], context, index),
      borderRadius: helpers.resolve([config.borderRadius, 0], context, index),
      borderWidth: helpers.resolve([config.borderWidth, 0], context, index),
      clamp: helpers.resolve([config.clamp, false], context, index),
      clip: helpers.resolve([config.clip, false], context, index),
      color: color,
      display: display,
      font: font,
      lines: lines,
      offset: helpers.resolve([config.offset, 0], context, index),
      opacity: helpers.resolve([config.opacity, 1], context, index),
      origin: getScaleOrigin(me._el, context),
      padding: helpers.toPadding(helpers.resolve([config.padding, 0], context, index)),
      positioner: getPositioner(me._el),
      rotation: helpers.resolve([config.rotation, 0], context, index) * (Math.PI / 180),
      size: utils.textSize(me._ctx, lines, font),
      textAlign: helpers.resolve([config.textAlign, 'start'], context, index),
      textShadowBlur: helpers.resolve([config.textShadowBlur, 0], context, index),
      textShadowColor: helpers.resolve([config.textShadowColor, color], context, index),
      textStrokeColor: helpers.resolve([config.textStrokeColor, color], context, index),
      textStrokeWidth: helpers.resolve([config.textStrokeWidth, 0], context, index)
    };
  },

  update: function(context) {
    var me = this;
    var model = null;
    var rects = null;
    var index = me._index;
    var config = me._config;
    var value, label, lines;

    // We first resolve the display option (separately) to avoid computing
    // other options in case the label is hidden (i.e. display: false).
    var display = helpers.resolve([config.display, true], context, index);

    if (display) {
      value = context.dataset.data[index];
      label = helpers.valueOrDefault(helpers.callback(config.formatter, [value, context]), value);
      lines = helpers.isNullOrUndef(label) ? [] : utils.toTextLines(label);

      if (lines.length) {
        model = me._modelize(display, lines, config, context);
        rects = boundingRects(model);
      }
    }

    me._model = model;
    me._rects = rects;
  },

  geometry: function() {
    return this._rects ? this._rects.frame : {};
  },

  rotation: function() {
    return this._model ? this._model.rotation : 0;
  },

  visible: function() {
    return this._model && this._model.opacity;
  },

  model: function() {
    return this._model;
  },

  draw: function(chart, center) {
    var me = this;
    var ctx = chart.ctx;
    var model = me._model;
    var rects = me._rects;
    var area;

    if (!this.visible()) {
      return;
    }

    ctx.save();

    if (model.clip) {
      area = model.area;
      ctx.beginPath();
      ctx.rect(
        area.left,
        area.top,
        area.right - area.left,
        area.bottom - area.top);
      ctx.clip();
    }

    ctx.globalAlpha = utils.bound(0, model.opacity, 1);
    ctx.translate(rasterize(center.x), rasterize(center.y));
    ctx.rotate(model.rotation);

    drawFrame(ctx, rects.frame, model);
    drawText(ctx, model.lines, rects.text, model);

    ctx.restore();
  }
});

var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger
var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;  // eslint-disable-line es/no-number-maxsafeinteger

function rotated(point, center, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var cx = center.x;
  var cy = center.y;

  return {
    x: cx + cos * (point.x - cx) - sin * (point.y - cy),
    y: cy + sin * (point.x - cx) + cos * (point.y - cy)
  };
}

function projected(points, axis) {
  var min = MAX_INTEGER;
  var max = MIN_INTEGER;
  var origin = axis.origin;
  var i, pt, vx, vy, dp;

  for (i = 0; i < points.length; ++i) {
    pt = points[i];
    vx = pt.x - origin.x;
    vy = pt.y - origin.y;
    dp = axis.vx * vx + axis.vy * vy;
    min = Math.min(min, dp);
    max = Math.max(max, dp);
  }

  return {
    min: min,
    max: max
  };
}

function toAxis(p0, p1) {
  var vx = p1.x - p0.x;
  var vy = p1.y - p0.y;
  var ln = Math.sqrt(vx * vx + vy * vy);

  return {
    vx: (p1.x - p0.x) / ln,
    vy: (p1.y - p0.y) / ln,
    origin: p0,
    ln: ln
  };
}

var HitBox = function() {
  this._rotation = 0;
  this._rect = {
    x: 0,
    y: 0,
    w: 0,
    h: 0
  };
};

helpers.merge(HitBox.prototype, {
  center: function() {
    var r = this._rect;
    return {
      x: r.x + r.w / 2,
      y: r.y + r.h / 2
    };
  },

  update: function(center, rect, rotation) {
    this._rotation = rotation;
    this._rect = {
      x: rect.x + center.x,
      y: rect.y + center.y,
      w: rect.w,
      h: rect.h
    };
  },

  contains: function(point) {
    var me = this;
    var margin = 1;
    var rect = me._rect;

    point = rotated(point, me.center(), -me._rotation);

    return !(point.x < rect.x - margin
      || point.y < rect.y - margin
      || point.x > rect.x + rect.w + margin * 2
      || point.y > rect.y + rect.h + margin * 2);
  },

  // Separating Axis Theorem
  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169
  intersects: function(other) {
    var r0 = this._points();
    var r1 = other._points();
    var axes = [
      toAxis(r0[0], r0[1]),
      toAxis(r0[0], r0[3])
    ];
    var i, pr0, pr1;

    if (this._rotation !== other._rotation) {
      // Only separate with r1 axis if the rotation is different,
      // else it's enough to separate r0 and r1 with r0 axis only!
      axes.push(
        toAxis(r1[0], r1[1]),
        toAxis(r1[0], r1[3])
      );
    }

    for (i = 0; i < axes.length; ++i) {
      pr0 = projected(r0, axes[i]);
      pr1 = projected(r1, axes[i]);

      if (pr0.max < pr1.min || pr1.max < pr0.min) {
        return false;
      }
    }

    return true;
  },

  /**
   * @private
   */
  _points: function() {
    var me = this;
    var rect = me._rect;
    var angle = me._rotation;
    var center = me.center();

    return [
      rotated({x: rect.x, y: rect.y}, center, angle),
      rotated({x: rect.x + rect.w, y: rect.y}, center, angle),
      rotated({x: rect.x + rect.w, y: rect.y + rect.h}, center, angle),
      rotated({x: rect.x, y: rect.y + rect.h}, center, angle)
    ];
  }
});

function coordinates(el, model, geometry) {
  var point = model.positioner(el, model);
  var vx = point.vx;
  var vy = point.vy;

  if (!vx && !vy) {
    // if aligned center, we don't want to offset the center point
    return {x: point.x, y: point.y};
  }

  var w = geometry.w;
  var h = geometry.h;

  // take in account the label rotation
  var rotation = model.rotation;
  var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
  var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));

  // scale the unit vector (vx, vy) to get at least dx or dy equal to
  // w or h respectively (else we would calculate the distance to the
  // ellipse inscribed in the bounding rect)
  var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
  dx *= vx * vs;
  dy *= vy * vs;

  // finally, include the explicit offset
  dx += model.offset * vx;
  dy += model.offset * vy;

  return {
    x: point.x + dx,
    y: point.y + dy
  };
}

function collide(labels, collider) {
  var i, j, s0, s1;

  // IMPORTANT Iterate in the reverse order since items at the end of the
  // list have an higher weight/priority and thus should be less impacted
  // by the overlapping strategy.

  for (i = labels.length - 1; i >= 0; --i) {
    s0 = labels[i].$layout;

    for (j = i - 1; j >= 0 && s0._visible; --j) {
      s1 = labels[j].$layout;

      if (s1._visible && s0._box.intersects(s1._box)) {
        collider(s0, s1);
      }
    }
  }

  return labels;
}

function compute(labels) {
  var i, ilen, label, state, geometry, center, proxy;

  // Initialize labels for overlap detection
  for (i = 0, ilen = labels.length; i < ilen; ++i) {
    label = labels[i];
    state = label.$layout;

    if (state._visible) {
      // Chart.js 3 removed el._model in favor of getProps(), making harder to
      // abstract reading values in positioners. Also, using string arrays to
      // read values (i.e. var {a,b,c} = el.getProps(["a","b","c"])) would make
      // positioners inefficient in the normal case (i.e. not the final values)
      // and the code a bit ugly, so let's use a Proxy instead.
      proxy = new Proxy(label._el, {get: (el, p) => el.getProps([p], true)[p]});

      geometry = label.geometry();
      center = coordinates(proxy, label.model(), geometry);
      state._box.update(center, geometry, label.rotation());
    }
  }

  // Auto hide overlapping labels
  return collide(labels, function(s0, s1) {
    var h0 = s0._hidable;
    var h1 = s1._hidable;

    if ((h0 && h1) || h1) {
      s1._visible = false;
    } else if (h0) {
      s0._visible = false;
    }
  });
}

var layout = {
  prepare: function(datasets) {
    var labels = [];
    var i, j, ilen, jlen, label;

    for (i = 0, ilen = datasets.length; i < ilen; ++i) {
      for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
        label = datasets[i][j];
        labels.push(label);
        label.$layout = {
          _box: new HitBox(),
          _hidable: false,
          _visible: true,
          _set: i,
          _idx: j
        };
      }
    }

    // TODO New `z` option: labels with a higher z-index are drawn
    // of top of the ones with a lower index. Lowest z-index labels
    // are also discarded first when hiding overlapping labels.
    labels.sort(function(a, b) {
      var sa = a.$layout;
      var sb = b.$layout;

      return sa._idx === sb._idx
        ? sb._set - sa._set
        : sb._idx - sa._idx;
    });

    this.update(labels);

    return labels;
  },

  update: function(labels) {
    var dirty = false;
    var i, ilen, label, model, state;

    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      label = labels[i];
      model = label.model();
      state = label.$layout;
      state._hidable = model && model.display === 'auto';
      state._visible = label.visible();
      dirty |= state._hidable;
    }

    if (dirty) {
      compute(labels);
    }
  },

  lookup: function(labels, point) {
    var i, state;

    // IMPORTANT Iterate in the reverse order since items at the end of
    // the list have an higher z-index, thus should be picked first.

    for (i = labels.length - 1; i >= 0; --i) {
      state = labels[i].$layout;

      if (state && state._visible && state._box.contains(point)) {
        return labels[i];
      }
    }

    return null;
  },

  draw: function(chart, labels) {
    var i, ilen, label, state, geometry, center;

    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      label = labels[i];
      state = label.$layout;

      if (state._visible) {
        geometry = label.geometry();
        center = coordinates(label._el, label.model(), geometry);
        state._box.update(center, geometry, label.rotation());
        label.draw(chart, center);
      }
    }
  }
};

var formatter = function(value) {
  if (helpers.isNullOrUndef(value)) {
    return null;
  }

  var label = value;
  var keys, klen, k;
  if (helpers.isObject(value)) {
    if (!helpers.isNullOrUndef(value.label)) {
      label = value.label;
    } else if (!helpers.isNullOrUndef(value.r)) {
      label = value.r;
    } else {
      label = '';
      keys = Object.keys(value);
      for (k = 0, klen = keys.length; k < klen; ++k) {
        label += (k !== 0 ? ', ' : '') + keys[k] + ': ' + value[keys[k]];
      }
    }
  }

  return '' + label;
};

/**
 * IMPORTANT: make sure to also update tests and TypeScript definition
 * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)
 */

var defaults = {
  align: 'center',
  anchor: 'center',
  backgroundColor: null,
  borderColor: null,
  borderRadius: 0,
  borderWidth: 0,
  clamp: false,
  clip: false,
  color: undefined,
  display: true,
  font: {
    family: undefined,
    lineHeight: 1.2,
    size: undefined,
    style: undefined,
    weight: null
  },
  formatter: formatter,
  labels: undefined,
  listeners: {},
  offset: 4,
  opacity: 1,
  padding: {
    top: 4,
    right: 4,
    bottom: 4,
    left: 4
  },
  rotation: 0,
  textAlign: 'start',
  textStrokeColor: undefined,
  textStrokeWidth: 0,
  textShadowBlur: 0,
  textShadowColor: undefined
};

/**
 * @see https://github.com/chartjs/Chart.js/issues/4176
 */

var EXPANDO_KEY = '$datalabels';
var DEFAULT_KEY = '$default';

function configure(dataset, options) {
  var override = dataset.datalabels;
  var listeners = {};
  var configs = [];
  var labels, keys;

  if (override === false) {
    return null;
  }
  if (override === true) {
    override = {};
  }

  options = helpers.merge({}, [options, override]);
  labels = options.labels || {};
  keys = Object.keys(labels);
  delete options.labels;

  if (keys.length) {
    keys.forEach(function(key) {
      if (labels[key]) {
        configs.push(helpers.merge({}, [
          options,
          labels[key],
          {_key: key}
        ]));
      }
    });
  } else {
    // Default label if no "named" label defined.
    configs.push(options);
  }

  // listeners: {<event-type>: {<label-key>: <fn>}}
  listeners = configs.reduce(function(target, config) {
    helpers.each(config.listeners || {}, function(fn, event) {
      target[event] = target[event] || {};
      target[event][config._key || DEFAULT_KEY] = fn;
    });

    delete config.listeners;
    return target;
  }, {});

  return {
    labels: configs,
    listeners: listeners
  };
}

function dispatchEvent(chart, listeners, label) {
  if (!listeners) {
    return;
  }

  var context = label.$context;
  var groups = label.$groups;
  var callback;

  if (!listeners[groups._set]) {
    return;
  }

  callback = listeners[groups._set][groups._key];
  if (!callback) {
    return;
  }

  if (helpers.callback(callback, [context]) === true) {
    // Users are allowed to tweak the given context by injecting values that can be
    // used in scriptable options to display labels differently based on the current
    // event (e.g. highlight an hovered label). That's why we update the label with
    // the output context and schedule a new chart render by setting it dirty.
    chart[EXPANDO_KEY]._dirty = true;
    label.update(context);
  }
}

function dispatchMoveEvents(chart, listeners, previous, label) {
  var enter, leave;

  if (!previous && !label) {
    return;
  }

  if (!previous) {
    enter = true;
  } else if (!label) {
    leave = true;
  } else if (previous !== label) {
    leave = enter = true;
  }

  if (leave) {
    dispatchEvent(chart, listeners.leave, previous);
  }
  if (enter) {
    dispatchEvent(chart, listeners.enter, label);
  }
}

function handleMoveEvents(chart, event) {
  var expando = chart[EXPANDO_KEY];
  var listeners = expando._listeners;
  var previous, label;

  if (!listeners.enter && !listeners.leave) {
    return;
  }

  if (event.type === 'mousemove') {
    label = layout.lookup(expando._labels, event);
  } else if (event.type !== 'mouseout') {
    return;
  }

  previous = expando._hovered;
  expando._hovered = label;
  dispatchMoveEvents(chart, listeners, previous, label);
}

function handleClickEvents(chart, event) {
  var expando = chart[EXPANDO_KEY];
  var handlers = expando._listeners.click;
  var label = handlers && layout.lookup(expando._labels, event);
  if (label) {
    dispatchEvent(chart, handlers, label);
  }
}

var plugin = {
  id: 'datalabels',

  defaults: defaults,

  beforeInit: function(chart) {
    chart[EXPANDO_KEY] = {
      _actives: []
    };
  },

  beforeUpdate: function(chart) {
    var expando = chart[EXPANDO_KEY];
    expando._listened = false;
    expando._listeners = {};     // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}
    expando._datasets = [];      // per dataset labels: [Label[]]
    expando._labels = [];        // layouted labels: Label[]
  },

  afterDatasetUpdate: function(chart, args, options) {
    var datasetIndex = args.index;
    var expando = chart[EXPANDO_KEY];
    var labels = expando._datasets[datasetIndex] = [];
    var visible = chart.isDatasetVisible(datasetIndex);
    var dataset = chart.data.datasets[datasetIndex];
    var config = configure(dataset, options);
    var elements = args.meta.data || [];
    var ctx = chart.ctx;
    var i, j, ilen, jlen, cfg, key, el, label;

    ctx.save();

    for (i = 0, ilen = elements.length; i < ilen; ++i) {
      el = elements[i];
      el[EXPANDO_KEY] = [];

      if (visible && el && chart.getDataVisibility(i) && !el.skip) {
        for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
          cfg = config.labels[j];
          key = cfg._key;

          label = new Label(cfg, ctx, el, i);
          label.$groups = {
            _set: datasetIndex,
            _key: key || DEFAULT_KEY
          };
          label.$context = {
            active: false,
            chart: chart,
            dataIndex: i,
            dataset: dataset,
            datasetIndex: datasetIndex
          };

          label.update(label.$context);
          el[EXPANDO_KEY].push(label);
          labels.push(label);
        }
      }
    }

    ctx.restore();

    // Store listeners at the chart level and per event type to optimize
    // cases where no listeners are registered for a specific event.
    helpers.merge(expando._listeners, config.listeners, {
      merger: function(event, target, source) {
        target[event] = target[event] || {};
        target[event][args.index] = source[event];
        expando._listened = true;
      }
    });
  },

  afterUpdate: function(chart, options) {
    chart[EXPANDO_KEY]._labels = layout.prepare(
      chart[EXPANDO_KEY]._datasets,
      options);
  },

  // Draw labels on top of all dataset elements
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32
  afterDatasetsDraw: function(chart) {
    layout.draw(chart, chart[EXPANDO_KEY]._labels);
  },

  beforeEvent: function(chart, args) {
    // If there is no listener registered for this chart, `listened` will be false,
    // meaning we can immediately ignore the incoming event and avoid useless extra
    // computation for users who don't implement label interactions.
    if (chart[EXPANDO_KEY]._listened) {
      var event = args.event;
      switch (event.type) {
      case 'mousemove':
      case 'mouseout':
        handleMoveEvents(chart, event);
        break;
      case 'click':
        handleClickEvents(chart, event);
        break;
      }
    }
  },

  afterEvent: function(chart) {
    var expando = chart[EXPANDO_KEY];
    var previous = expando._actives;
    var actives = expando._actives = chart.getActiveElements();
    var updates = utils.arrayDiff(previous, actives);
    var i, ilen, j, jlen, update, label, labels;

    for (i = 0, ilen = updates.length; i < ilen; ++i) {
      update = updates[i];
      if (update[1]) {
        labels = update[0].element[EXPANDO_KEY] || [];
        for (j = 0, jlen = labels.length; j < jlen; ++j) {
          label = labels[j];
          label.$context.active = (update[1] === 1);
          label.update(label.$context);
        }
      }
    }

    if (expando._dirty || updates.length) {
      layout.update(expando._labels);
      chart.render();
    }

    delete expando._dirty;
  }
};

return plugin;

})));


// ===== TOOLASHA CODE =====
(function () {
    'use strict';

    window.Toolasha = window.Toolasha || {}; window.Toolasha.__buildTarget = "steam";

    /**
     * Centralized IndexedDB Storage
     * Replaces GM storage with IndexedDB for better performance and Chromium compatibility
     * Provides debounced writes to reduce I/O operations
     */

    class Storage {
        constructor() {
            this.db = null;
            this.available = false;
            this.dbName = 'ToolashaDB';
            this.dbVersion = 8; // Bumped for combatStats store
            this.saveDebounceTimers = new Map(); // Per-key debounce timers
            this.pendingWrites = new Map(); // Per-key pending write data: {value, storeName}
            this.SAVE_DEBOUNCE_DELAY = 3000; // 3 seconds
        }

        /**
         * Initialize the storage system
         * @returns {Promise<boolean>} Success status
         */
        async initialize() {
            try {
                await this.openDatabase();
                this.available = true;
                return true;
            } catch (error) {
                console.error('[Storage] Initialization failed:', error);
                this.available = false;
                return false;
            }
        }

        /**
         * Open IndexedDB database
         * @returns {Promise<void>}
         */
        openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, this.dbVersion);

                request.onerror = () => {
                    console.error('[Storage] Failed to open IndexedDB');
                    reject(request.error);
                };

                request.onsuccess = () => {
                    this.db = request.result;
                    resolve();
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // Create settings store if it doesn't exist
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings');
                    }

                    // Create rerollSpending store if it doesn't exist (for task reroll tracker)
                    if (!db.objectStoreNames.contains('rerollSpending')) {
                        db.createObjectStore('rerollSpending');
                    }

                    // Create dungeonRuns store if it doesn't exist (for dungeon tracker)
                    if (!db.objectStoreNames.contains('dungeonRuns')) {
                        db.createObjectStore('dungeonRuns');
                    }

                    // Create teamRuns store if it doesn't exist (for team-based backfill)
                    if (!db.objectStoreNames.contains('teamRuns')) {
                        db.createObjectStore('teamRuns');
                    }

                    // Create combatExport store if it doesn't exist (for combat sim/milkonomy exports)
                    if (!db.objectStoreNames.contains('combatExport')) {
                        db.createObjectStore('combatExport');
                    }

                    // Create unifiedRuns store if it doesn't exist (for dungeon tracker unified storage)
                    if (!db.objectStoreNames.contains('unifiedRuns')) {
                        db.createObjectStore('unifiedRuns');
                    }

                    // Create marketListings store if it doesn't exist (for estimated listing ages)
                    if (!db.objectStoreNames.contains('marketListings')) {
                        db.createObjectStore('marketListings');
                    }

                    // Create combatStats store if it doesn't exist (for combat statistics feature)
                    if (!db.objectStoreNames.contains('combatStats')) {
                        db.createObjectStore('combatStats');
                    }
                };
            });
        }

        /**
         * Get a value from storage
         * @param {string} key - Storage key
         * @param {string} storeName - Object store name (default: 'settings')
         * @param {*} defaultValue - Default value if key doesn't exist
         * @returns {Promise<*>} The stored value or default
         */
        async get(key, storeName = 'settings', defaultValue = null) {
            if (!this.db) {
                console.warn(`[Storage] Database not available, returning default for key: ${key}`);
                return defaultValue;
            }

            return new Promise((resolve, _reject) => {
                try {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);

                    request.onsuccess = () => {
                        resolve(request.result !== undefined ? request.result : defaultValue);
                    };

                    request.onerror = () => {
                        console.error(`[Storage] Failed to get key ${key}:`, request.error);
                        resolve(defaultValue);
                    };
                } catch (error) {
                    console.error(`[Storage] Get transaction failed for key ${key}:`, error);
                    resolve(defaultValue);
                }
            });
        }

        /**
         * Set a value in storage (debounced by default)
         * @param {string} key - Storage key
         * @param {*} value - Value to store
         * @param {string} storeName - Object store name (default: 'settings')
         * @param {boolean} immediate - If true, save immediately without debouncing
         * @returns {Promise<boolean>} Success status
         */
        async set(key, value, storeName = 'settings', immediate = false) {
            if (!this.db) {
                console.warn(`[Storage] Database not available, cannot save key: ${key}`);
                return false;
            }

            if (immediate) {
                return this._saveToIndexedDB(key, value, storeName);
            } else {
                return this._debouncedSave(key, value, storeName);
            }
        }

        /**
         * Internal: Save to IndexedDB (immediate)
         * @private
         */
        async _saveToIndexedDB(key, value, storeName) {
            return new Promise((resolve, _reject) => {
                try {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(value, key);

                    request.onsuccess = () => {
                        resolve(true);
                    };

                    request.onerror = () => {
                        console.error(`[Storage] Failed to save key ${key}:`, request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error(`[Storage] Save transaction failed for key ${key}:`, error);
                    resolve(false);
                }
            });
        }

        /**
         * Internal: Debounced save
         * @private
         */
        _debouncedSave(key, value, storeName) {
            const timerKey = `${storeName}:${key}`;

            // Store pending write data
            this.pendingWrites.set(timerKey, { value, storeName });

            // Clear existing timer for this key
            if (this.saveDebounceTimers.has(timerKey)) {
                clearTimeout(this.saveDebounceTimers.get(timerKey));
            }

            // Return a promise that resolves when save completes
            return new Promise((resolve) => {
                const timer = setTimeout(async () => {
                    const pending = this.pendingWrites.get(timerKey);
                    if (pending) {
                        const success = await this._saveToIndexedDB(key, pending.value, pending.storeName);
                        this.pendingWrites.delete(timerKey);
                        this.saveDebounceTimers.delete(timerKey);
                        resolve(success);
                    } else {
                        resolve(false);
                    }
                }, this.SAVE_DEBOUNCE_DELAY);

                this.saveDebounceTimers.set(timerKey, timer);
            });
        }

        /**
         * Get a JSON object from storage
         * @param {string} key - Storage key
         * @param {string} storeName - Object store name (default: 'settings')
         * @param {*} defaultValue - Default value if key doesn't exist
         * @returns {Promise<*>} The parsed object or default
         */
        async getJSON(key, storeName = 'settings', defaultValue = null) {
            const raw = await this.get(key, storeName, null);

            if (raw === null) {
                return defaultValue;
            }

            // If it's already an object, return it
            if (typeof raw === 'object') {
                return raw;
            }

            // Otherwise, try to parse as JSON string
            try {
                return JSON.parse(raw);
            } catch (error) {
                console.error(`[Storage] Error parsing JSON from storage (key: ${key}):`, error);
                return defaultValue;
            }
        }

        /**
         * Set a JSON object in storage
         * @param {string} key - Storage key
         * @param {*} value - Object to store
         * @param {string} storeName - Object store name (default: 'settings')
         * @param {boolean} immediate - If true, save immediately
         * @returns {Promise<boolean>} Success status
         */
        async setJSON(key, value, storeName = 'settings', immediate = false) {
            // IndexedDB can store objects directly, no need to stringify
            return this.set(key, value, storeName, immediate);
        }

        /**
         * Delete a key from storage
         * @param {string} key - Storage key to delete
         * @param {string} storeName - Object store name (default: 'settings')
         * @returns {Promise<boolean>} Success status
         */
        async delete(key, storeName = 'settings') {
            if (!this.db) {
                console.warn(`[Storage] Database not available, cannot delete key: ${key}`);
                return false;
            }

            return new Promise((resolve, _reject) => {
                try {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);

                    request.onsuccess = () => {
                        resolve(true);
                    };

                    request.onerror = () => {
                        console.error(`[Storage] Failed to delete key ${key}:`, request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error(`[Storage] Delete transaction failed for key ${key}:`, error);
                    resolve(false);
                }
            });
        }

        /**
         * Check if a key exists in storage
         * @param {string} key - Storage key to check
         * @param {string} storeName - Object store name (default: 'settings')
         * @returns {Promise<boolean>} True if key exists
         */
        async has(key, storeName = 'settings') {
            if (!this.db) {
                return false;
            }

            const value = await this.get(key, storeName, '__STORAGE_CHECK__');
            return value !== '__STORAGE_CHECK__';
        }

        /**
         * Get all keys from a store
         * @param {string} storeName - Object store name (default: 'settings')
         * @returns {Promise<Array<string>>} Array of keys
         */
        async getAllKeys(storeName = 'settings') {
            if (!this.db) {
                console.warn(`[Storage] Database not available, cannot get keys from store: ${storeName}`);
                return [];
            }

            return new Promise((resolve, _reject) => {
                try {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAllKeys();

                    request.onsuccess = () => {
                        resolve(request.result || []);
                    };

                    request.onerror = () => {
                        console.error(`[Storage] Failed to get all keys from ${storeName}:`, request.error);
                        resolve([]);
                    };
                } catch (error) {
                    console.error(`[Storage] GetAllKeys transaction failed for store ${storeName}:`, error);
                    resolve([]);
                }
            });
        }

        /**
         * Force immediate save of all pending debounced writes
         */
        async flushAll() {
            // Clear all timers first
            for (const timer of this.saveDebounceTimers.values()) {
                if (timer) {
                    clearTimeout(timer);
                }
            }
            this.saveDebounceTimers.clear();

            // Now execute all pending writes immediately
            const writes = Array.from(this.pendingWrites.entries());
            for (const [timerKey, pending] of writes) {
                // Extract actual key from timerKey (format: "storeName:key")
                const colonIndex = timerKey.indexOf(':');
                const storeName = timerKey.substring(0, colonIndex);
                const key = timerKey.substring(colonIndex + 1); // Handle keys with colons

                await this._saveToIndexedDB(key, pending.value, storeName);
            }
            this.pendingWrites.clear();
        }

        /**
         * Cleanup pending debounced writes without flushing
         */
        cleanupPendingWrites() {
            for (const timer of this.saveDebounceTimers.values()) {
                if (timer) {
                    clearTimeout(timer);
                }
            }
            this.saveDebounceTimers.clear();
            this.pendingWrites.clear();
        }
    }

    const storage$1 = new Storage();

    /**
     * Settings Configuration
     * Organizes all script settings into logical groups for the settings UI
     */

    const settingsGroups = {
        general: {
            title: 'General Settings',
            icon: '⚙️',
            settings: {
                networkAlert: {
                    id: 'networkAlert',
                    label: 'Show alert when market price data cannot be fetched',
                    type: 'checkbox',
                    default: true,
                },
            },
        },

        actionPanel: {
            title: 'Action Panel Enhancements',
            icon: '⚡',
            settings: {
                totalActionTime: {
                    id: 'totalActionTime',
                    label: 'Top left: Estimated total time and completion time',
                    type: 'checkbox',
                    default: true,
                },
                actions_compactActionBar: {
                    id: 'actions_compactActionBar',
                    label: 'Compact action bar (limit width, truncate long names)',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['totalActionTime'],
                    help: 'Limits action bar width to prevent screen-spanning on wide monitors. Long action names will be truncated with "..." - hover to see full text.',
                },
                actionPanel_totalTime: {
                    id: 'actionPanel_totalTime',
                    label: 'Action panel: Total time, times to reach target level, exp/hour',
                    type: 'checkbox',
                    default: true,
                },
                actionPanel_totalTime_quickInputs: {
                    id: 'actionPanel_totalTime_quickInputs',
                    label: 'Action panel: Quick input buttons (hours, count presets, Max)',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['actionPanel_totalTime'],
                },
                actionPanel_foragingTotal: {
                    id: 'actionPanel_foragingTotal',
                    label: 'Action panel: Overall profit for multi-outcome foraging',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['actionPanel_totalTime'],
                },
                actionQueue: {
                    id: 'actionQueue',
                    label: 'Queued actions: Show total time and completion time',
                    type: 'checkbox',
                    default: true,
                },
                actionQueue_valueMode: {
                    id: 'actionQueue_valueMode',
                    label: 'Queued actions: Value calculation mode',
                    type: 'select',
                    default: 'profit',
                    options: [
                        { value: 'profit', label: 'Total Profit (revenue - all costs)' },
                        { value: 'estimated_value', label: 'Estimated Value (revenue after tax)' },
                    ],
                    dependencies: ['actionQueue'],
                    help: 'Choose how to calculate the total value for queued actions. Profit shows net earnings after materials and drinks. Estimated Value shows gross revenue after market tax (always positive).',
                },
                actionPanel_outputTotals: {
                    id: 'actionPanel_outputTotals',
                    label: 'Action panel: Show total expected outputs below per-action outputs',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays calculated totals when you enter a quantity in the action input',
                },
                actionPanel_maxProduceable: {
                    id: 'actionPanel_maxProduceable',
                    label: 'Action panel: Show max produceable count on crafting actions',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays how many items you can make based on current inventory',
                },
                actionPanel_gatheringStats: {
                    id: 'actionPanel_gatheringStats',
                    label: 'Action panel: Show profit/exp per hour on gathering actions',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays profit/hr and exp/hr on gathering tiles (foraging, woodcutting, milking)',
                },
                actionPanel_hideNegativeProfit: {
                    id: 'actionPanel_hideNegativeProfit',
                    label: 'Action panel: Hide actions with negative profit',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['actionPanel_maxProduceable', 'actionPanel_gatheringStats'],
                    help: 'Hides action panels that would result in a loss (negative profit/hr)',
                },
                actionPanel_sortByProfit: {
                    id: 'actionPanel_sortByProfit',
                    label: 'Action panel: Sort actions by profit/hr (highest first)',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['actionPanel_maxProduceable', 'actionPanel_gatheringStats'],
                    help: 'Sorts action tiles by profit/hr in descending order. Actions without profit data appear at the end.',
                },
                requiredMaterials: {
                    id: 'requiredMaterials',
                    label: 'Action panel: Show total required and missing materials',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays total materials needed and shortfall when entering quantity',
                },
                alchemy_profitDisplay: {
                    id: 'alchemy_profitDisplay',
                    label: 'Alchemy panel: Show profit calculator',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays profit/hour and profit/day for alchemy actions based on success rate and market prices',
                },
                actions_missingMaterialsButton: {
                    id: 'actions_missingMaterialsButton',
                    label: 'Show "Missing Mats Marketplace" button on production panels',
                    type: 'checkbox',
                    default: true,
                    help: 'Adds button to production panels that opens marketplace with tabs for missing materials',
                },
                actions_missingMaterialsButton_ignoreQueue: {
                    id: 'actions_missingMaterialsButton_ignoreQueue',
                    label: 'Ignore queued actions when calculating missing materials',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['actions_missingMaterialsButton'],
                    help: 'When enabled, missing materials calculation only considers current action request, ignoring materials already reserved by queued actions. Default (off) accounts for queue.',
                },
            },
        },

        tooltips: {
            title: 'Item Tooltip Enhancements',
            icon: '💬',
            settings: {
                itemTooltip_prices: {
                    id: 'itemTooltip_prices',
                    label: 'Show 24-hour average market prices',
                    type: 'checkbox',
                    default: true,
                },
                itemTooltip_profit: {
                    id: 'itemTooltip_profit',
                    label: 'Show production cost and profit',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['itemTooltip_prices'],
                },
                itemTooltip_detailedProfit: {
                    id: 'itemTooltip_detailedProfit',
                    label: 'Show detailed materials breakdown in profit display',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['itemTooltip_profit'],
                    help: 'Shows material costs table with Ask/Bid prices, actions/hour, and profit breakdown',
                },
                itemTooltip_multiActionProfit: {
                    id: 'itemTooltip_multiActionProfit',
                    label: 'Show profit comparison for all item actions',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['itemTooltip_prices'],
                    help: 'Displays best profit/hr highlighted, with other profitable actions (craft, coinify, decompose, transmute) summarized below',
                },
                itemTooltip_expectedValue: {
                    id: 'itemTooltip_expectedValue',
                    label: 'Show expected value for openable containers',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['itemTooltip_prices'],
                },
                expectedValue_showDrops: {
                    id: 'expectedValue_showDrops',
                    label: 'Expected value drop display',
                    type: 'select',
                    default: 'All',
                    options: [
                        { value: 'Top 5', label: 'Top 5' },
                        { value: 'Top 10', label: 'Top 10' },
                        { value: 'All', label: 'All Drops' },
                        { value: 'None', label: 'Summary Only' },
                    ],
                    dependencies: ['itemTooltip_expectedValue'],
                },
                expectedValue_respectPricingMode: {
                    id: 'expectedValue_respectPricingMode',
                    label: 'Use pricing mode for expected value calculations',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['itemTooltip_expectedValue'],
                },
                showConsumTips: {
                    id: 'showConsumTips',
                    label: 'HP/MP consumables: Restore speed, cost performance',
                    type: 'checkbox',
                    default: true,
                },
                dungeonTokenTooltips: {
                    id: 'dungeonTokenTooltips',
                    label: 'Dungeon tokens: Show shop items and costs',
                    type: 'checkbox',
                    default: true,
                },
                enhanceSim: {
                    id: 'enhanceSim',
                    label: 'Show enhancement simulator calculations',
                    type: 'checkbox',
                    default: true,
                },
                enhanceSim_showConsumedItemsDetail: {
                    id: 'enhanceSim_showConsumedItemsDetail',
                    label: 'Enhancement tooltips: Show detailed breakdown for consumed items',
                    type: 'checkbox',
                    default: false,
                    help: "When enabled, shows base/materials/protection breakdown for each consumed item in Philosopher's Mirror calculations",
                    dependencies: ['enhanceSim'],
                },
                itemTooltip_gathering: {
                    id: 'itemTooltip_gathering',
                    label: 'Show gathering sources and profit',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['itemTooltip_profit'],
                    help: 'Shows gathering actions that produce this item (foraging, woodcutting, milking)',
                },
                itemTooltip_gatheringRareDrops: {
                    id: 'itemTooltip_gatheringRareDrops',
                    label: 'Show rare drops from gathering',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['itemTooltip_gathering'],
                    help: 'Shows rare find drops from gathering zones (e.g., Thread of Expertise from Asteroid Belt)',
                },
            },
        },

        enhancementSimulator: {
            title: 'Enhancement Simulator Settings',
            icon: '✨',
            settings: {
                enhanceSim_autoDetect: {
                    id: 'enhanceSim_autoDetect',
                    label: 'Auto-detect your stats (false = use market defaults)',
                    type: 'checkbox',
                    default: false,
                    help: 'Most players should use market defaults to see realistic professional enhancer costs',
                },
                enhanceSim_enhancingLevel: {
                    id: 'enhanceSim_enhancingLevel',
                    label: 'Enhancing skill level',
                    type: 'number',
                    default: 140,
                    min: 1,
                    max: 150,
                    help: 'Default: 140 (professional enhancer level)',
                },
                enhanceSim_houseLevel: {
                    id: 'enhanceSim_houseLevel',
                    label: 'Observatory house room level',
                    type: 'number',
                    default: 8,
                    min: 0,
                    max: 8,
                    help: 'Default: 8 (max level)',
                },
                enhanceSim_toolBonus: {
                    id: 'enhanceSim_toolBonus',
                    label: 'Tool success bonus %',
                    type: 'number',
                    default: 6.05,
                    min: 0,
                    max: 30,
                    step: 0.01,
                    help: 'Default: 6.05 (Celestial Enhancer +13)',
                },
                enhanceSim_speedBonus: {
                    id: 'enhanceSim_speedBonus',
                    label: 'Speed bonus %',
                    type: 'number',
                    default: 48.5,
                    min: 0,
                    max: 100,
                    step: 0.1,
                    help: "Default: 48.5 (All enhancing gear +10: Body/Legs/Hands + Philosopher's Necklace)",
                },
                enhanceSim_blessedTea: {
                    id: 'enhanceSim_blessedTea',
                    label: 'Blessed Tea active',
                    type: 'checkbox',
                    default: true,
                    help: 'Professional enhancers use this to reduce attempts',
                },
                enhanceSim_ultraEnhancingTea: {
                    id: 'enhanceSim_ultraEnhancingTea',
                    label: 'Ultra Enhancing Tea active',
                    type: 'checkbox',
                    default: true,
                    help: 'Provides +8 base skill levels (scales with drink concentration)',
                },
                enhanceSim_superEnhancingTea: {
                    id: 'enhanceSim_superEnhancingTea',
                    label: 'Super Enhancing Tea active',
                    type: 'checkbox',
                    default: false,
                    help: 'Provides +6 base skill levels (Ultra is better)',
                },
                enhanceSim_enhancingTea: {
                    id: 'enhanceSim_enhancingTea',
                    label: 'Enhancing Tea active',
                    type: 'checkbox',
                    default: false,
                    help: 'Provides +3 base skill levels (Ultra is better)',
                },
                enhanceSim_drinkConcentration: {
                    id: 'enhanceSim_drinkConcentration',
                    label: 'Drink Concentration %',
                    type: 'number',
                    default: 12.9,
                    min: 0,
                    max: 20,
                    step: 0.1,
                    help: 'Default: 12.9 (Guzzling Pouch +10)',
                },
            },
        },

        enhancementTracker: {
            title: 'Enhancement Tracker',
            icon: '📊',
            settings: {
                enhancementTracker: {
                    id: 'enhancementTracker',
                    label: 'Enable Enhancement Tracker',
                    type: 'checkbox',
                    default: false,
                    help: 'Track enhancement attempts, costs, and statistics',
                },
                enhancementTracker_showOnlyOnEnhancingScreen: {
                    id: 'enhancementTracker_showOnlyOnEnhancingScreen',
                    label: 'Show tracker only on Enhancing screen',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['enhancementTracker'],
                    help: 'Hide tracker when not on the Enhancing screen',
                },
            },
        },

        economy: {
            title: 'Economy & Inventory',
            icon: '💰',
            settings: {
                networth: {
                    id: 'networth',
                    label: 'Top right: Show current assets (net worth)',
                    type: 'checkbox',
                    default: true,
                    help: 'Enhanced items valued by enhancement simulator',
                },
                invWorth: {
                    id: 'invWorth',
                    label: 'Below inventory: Show inventory summary',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['networth'],
                },
                invSort: {
                    id: 'invSort',
                    label: 'Sort inventory items by value',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['networth'],
                },
                invSort_showBadges: {
                    id: 'invSort_showBadges',
                    label: 'Show stack value badges when sorting by Ask/Bid',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['invSort'],
                },
                invSort_badgesOnNone: {
                    id: 'invSort_badgesOnNone',
                    label: 'Badge type when "None" sort is selected',
                    type: 'select',
                    default: 'None',
                    options: ['None', 'Ask', 'Bid'],
                    dependencies: ['invSort'],
                },
                invSort_sortEquipment: {
                    id: 'invSort_sortEquipment',
                    label: 'Enable sorting for Equipment category',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['invSort'],
                },
                invBadgePrices: {
                    id: 'invBadgePrices',
                    label: 'Show price badges on item icons',
                    type: 'checkbox',
                    default: false,
                    help: 'Displays per-item ask or bid price on inventory items',
                },
                invBadgePrices_type: {
                    id: 'invBadgePrices_type',
                    label: 'Badge price type to display',
                    type: 'select',
                    default: 'Ask',
                    options: ['None', 'Ask', 'Bid'],
                    dependencies: ['invBadgePrices'],
                    help: 'Ask (instant-buy price), Bid (instant-sell price), or None',
                },
                profitCalc_pricingMode: {
                    id: 'profitCalc_pricingMode',
                    label: 'Profit calculation pricing mode',
                    type: 'select',
                    default: 'hybrid',
                    options: [
                        { value: 'conservative', label: 'Conservative (Ask/Bid - instant trading)' },
                        { value: 'hybrid', label: 'Hybrid (Ask/Ask - instant buy, patient sell)' },
                        { value: 'optimistic', label: 'Optimistic (Bid/Ask - patient trading)' },
                    ],
                },
                networth_highEnhancementUseCost: {
                    id: 'networth_highEnhancementUseCost',
                    label: 'Use enhancement cost for highly enhanced items',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['networth'],
                    help: 'Market prices are unreliable for highly enhanced items (+13 and above). Use calculated enhancement cost instead.',
                },
                networth_highEnhancementMinLevel: {
                    id: 'networth_highEnhancementMinLevel',
                    label: 'Minimum enhancement level to use cost',
                    type: 'select',
                    default: 13,
                    options: [
                        { value: 10, label: '+10 and above' },
                        { value: 11, label: '+11 and above' },
                        { value: 12, label: '+12 and above' },
                        { value: 13, label: '+13 and above (recommended)' },
                        { value: 15, label: '+15 and above' },
                    ],
                    dependencies: ['networth_highEnhancementUseCost'],
                    help: 'Enhancement level at which to stop trusting market prices',
                },
                networth_includeCowbells: {
                    id: 'networth_includeCowbells',
                    label: 'Include cowbells in net worth',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['networth'],
                    help: 'Cowbells are not tradeable, but they have a value based on Bag of 10 Cowbells market price',
                },
                networth_includeTaskTokens: {
                    id: 'networth_includeTaskTokens',
                    label: 'Include task tokens in net worth',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['networth'],
                    help: 'Value task tokens based on expected value from Task Shop chests. Disable to exclude them from net worth.',
                },
                networth_abilityBooksAsInventory: {
                    id: 'networth_abilityBooksAsInventory',
                    label: 'Count ability books as inventory (Current Assets)',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['networth'],
                    help: 'Move ability books from Fixed Assets to Current Assets inventory value. Useful if you plan to sell them.',
                },
            },
        },

        skills: {
            title: 'Skills',
            icon: '📚',
            settings: {
                skillRemainingXP: {
                    id: 'skillRemainingXP',
                    label: 'Left sidebar: Show remaining XP to next level',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays how much XP needed to reach the next level under skill progress bars',
                },
                skillRemainingXP_blackBorder: {
                    id: 'skillRemainingXP_blackBorder',
                    label: 'Remaining XP: Add black text border for better visibility',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['skillRemainingXP'],
                    help: 'Adds a black outline/shadow to the XP text for better readability against progress bars',
                },
                skillbook: {
                    id: 'skillbook',
                    label: 'Skill books: Show books needed to reach target level',
                    type: 'checkbox',
                    default: true,
                },
            },
        },

        combat: {
            title: 'Combat Features',
            icon: '⚔️',
            settings: {
                combatScore: {
                    id: 'combatScore',
                    label: 'Profile panel: Show gear score',
                    type: 'checkbox',
                    default: true,
                },
                abilitiesTriggers: {
                    id: 'abilitiesTriggers',
                    label: 'Profile panel: Show abilities & triggers',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays equipped abilities, consumables, and their combat triggers below the profile',
                },
                characterCard: {
                    id: 'characterCard',
                    label: 'Profile panel: Show View Card button',
                    type: 'checkbox',
                    default: true,
                    help: 'Adds button to open character sheet in external viewer',
                },
                dungeonTracker: {
                    id: 'dungeonTracker',
                    label: 'Dungeon Tracker: Real-time progress tracking',
                    type: 'checkbox',
                    default: true,
                    help: 'Tracks dungeon runs with server-validated duration from party messages',
                },
                dungeonTrackerUI: {
                    id: 'dungeonTrackerUI',
                    label: '  ├─ Show Dungeon Tracker UI panel',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays dungeon progress panel with wave counter, run history, and statistics',
                },
                dungeonTrackerChatAnnotations: {
                    id: 'dungeonTrackerChatAnnotations',
                    label: '  └─ Show run time in party chat',
                    type: 'checkbox',
                    default: true,
                    help: 'Adds colored timer annotations to "Key counts" messages (green if fast, red if slow)',
                },
                combatSummary: {
                    id: 'combatSummary',
                    label: 'Combat Summary: Show detailed statistics on return',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays encounters/hour, revenue, experience rates when returning from combat',
                },
                combatStats: {
                    id: 'combatStats',
                    label: 'Combat Statistics: Show Statistics tab in Combat panel',
                    type: 'checkbox',
                    default: true,
                    help: 'Adds a Statistics button to the Combat panel showing income, profit, consumable costs, EXP, and drop details',
                },
                combatStatsChatMessage: {
                    id: 'combatStatsChatMessage',
                    label: 'Combat Statistics: Chat message format',
                    type: 'template',
                    default: [
                        { type: 'text', value: 'Combat Stats: ' },
                        { type: 'variable', key: '{duration}', label: 'Duration' },
                        { type: 'text', value: ' duration | ' },
                        { type: 'variable', key: '{encountersPerHour}', label: 'Encounters/Hour' },
                        { type: 'text', value: ' EPH | ' },
                        { type: 'variable', key: '{income}', label: 'Total Income' },
                        { type: 'text', value: ' income | ' },
                        { type: 'variable', key: '{dailyIncome}', label: 'Daily Income' },
                        { type: 'text', value: ' income/d | ' },
                        { type: 'variable', key: '{dailyConsumableCosts}', label: 'Daily Consumable Costs' },
                        { type: 'text', value: ' consumables/d | ' },
                        { type: 'variable', key: '{dailyProfit}', label: 'Daily Profit' },
                        { type: 'text', value: ' profit/d | ' },
                        { type: 'variable', key: '{exp}', label: 'EXP/Hour' },
                        { type: 'text', value: ' exp/h | ' },
                        { type: 'variable', key: '{deathCount}', label: 'Deaths' },
                        { type: 'text', value: ' deaths' },
                    ],
                    help: 'Message format when Ctrl+clicking player card in Statistics. Click "Edit Template" to customize.',
                    templateVariables: [
                        { key: '{duration}', label: 'Duration', description: 'Combat session duration' },
                        { key: '{encountersPerHour}', label: 'Encounters/Hour', description: 'Encounters per hour (EPH)' },
                        { key: '{income}', label: 'Total Income', description: 'Total income from combat' },
                        { key: '{dailyIncome}', label: 'Daily Income', description: 'Income per day' },
                        {
                            key: '{dailyConsumableCosts}',
                            label: 'Daily Consumable Costs',
                            description: 'Consumable costs per day',
                        },
                        { key: '{dailyProfit}', label: 'Daily Profit', description: 'Profit per day' },
                        { key: '{exp}', label: 'EXP/Hour', description: 'Experience per hour' },
                        { key: '{deathCount}', label: 'Deaths', description: 'Number of deaths' },
                    ],
                },
            },
        },

        tasks: {
            title: 'Tasks',
            icon: '📋',
            settings: {
                taskProfitCalculator: {
                    id: 'taskProfitCalculator',
                    label: 'Show total profit for gathering/production tasks',
                    type: 'checkbox',
                    default: true,
                },
                taskEfficiencyRating: {
                    id: 'taskEfficiencyRating',
                    label: 'Show task efficiency rating (tokens/profit per hour)',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays a color-graded efficiency score based on expected completion time.',
                },
                taskEfficiencyRatingMode: {
                    id: 'taskEfficiencyRatingMode',
                    label: '  └─ Efficiency algorithm',
                    type: 'select',
                    default: 'gold',
                    options: [
                        { value: 'tokens', label: 'Task tokens per hour' },
                        { value: 'gold', label: 'Task profit per hour' },
                    ],
                    dependencies: ['taskEfficiencyRating'],
                    help: 'Choose whether to rate by task token payout or total profit.',
                },
                taskEfficiencyGradient: {
                    id: 'taskEfficiencyGradient',
                    label: '  └─ Use relative gradient colors',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['taskEfficiencyRating'],
                    help: 'Colors efficiency ratings relative to visible tasks.',
                },
                taskRerollTracker: {
                    id: 'taskRerollTracker',
                    label: 'Track task reroll costs',
                    type: 'checkbox',
                    default: true,
                    help: 'Tracks how much gold/cowbells spent rerolling each task (EXPERIMENTAL - may cause UI freezing)',
                },
                taskMapIndex: {
                    id: 'taskMapIndex',
                    label: 'Show combat zone index numbers on tasks',
                    type: 'checkbox',
                    default: true,
                },
                taskIcons: {
                    id: 'taskIcons',
                    label: 'Show visual icons on task cards',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays semi-transparent item/monster icons on task cards',
                },
                taskIconsDungeons: {
                    id: 'taskIconsDungeons',
                    label: 'Show dungeon icons on combat tasks',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['taskIcons'],
                    help: 'Shows which dungeons contain the monster (requires Task Icons enabled)',
                },
                taskSorter_autoSort: {
                    id: 'taskSorter_autoSort',
                    label: 'Automatically sort tasks when opening task panel',
                    type: 'checkbox',
                    default: false,
                    help: 'Automatically sorts tasks by skill type when you open the task panel',
                },
            },
        },

        ui: {
            title: 'UI Enhancements',
            icon: '🎨',
            settings: {
                formatting_useKMBFormat: {
                    id: 'formatting_useKMBFormat',
                    label: 'Use K/M/B number formatting (e.g., 1.5M instead of 1,500,000)',
                    type: 'checkbox',
                    default: true,
                    help: 'Applies to tooltips, action panels, profit displays, and all number formatting throughout the UI',
                },
                ui_externalLinks: {
                    id: 'ui_externalLinks',
                    label: 'Left sidebar: Show external tool links',
                    type: 'checkbox',
                    default: true,
                    help: 'Adds quick links to Combat Sim, Market Tracker, Enhancelator, and Milkonomy',
                },
                expPercentage: {
                    id: 'expPercentage',
                    label: 'Left sidebar: Show skill XP percentages',
                    type: 'checkbox',
                    default: true,
                },
                itemIconLevel: {
                    id: 'itemIconLevel',
                    label: 'Bottom left corner of icons: Show equipment level',
                    type: 'checkbox',
                    default: true,
                },
                showsKeyInfoInIcon: {
                    id: 'showsKeyInfoInIcon',
                    label: 'Bottom left corner of key icons: Show zone index',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['itemIconLevel'],
                },
                mapIndex: {
                    id: 'mapIndex',
                    label: 'Combat zones: Show zone index numbers',
                    type: 'checkbox',
                    default: true,
                },
                alchemyItemDimming: {
                    id: 'alchemyItemDimming',
                    label: 'Alchemy panel: Dim items requiring higher level',
                    type: 'checkbox',
                    default: true,
                },
                marketFilter: {
                    id: 'marketFilter',
                    label: 'Marketplace: Filter by level, class, slot',
                    type: 'checkbox',
                    default: true,
                },
                fillMarketOrderPrice: {
                    id: 'fillMarketOrderPrice',
                    label: 'Auto-fill marketplace orders with optimal price',
                    type: 'checkbox',
                    default: true,
                },
                market_autoFillSellStrategy: {
                    id: 'market_autoFillSellStrategy',
                    label: '  └─ Auto-fill sell price strategy',
                    type: 'select',
                    default: 'match',
                    options: [
                        { value: 'match', label: 'Match best sell price' },
                        { value: 'undercut', label: 'Undercut by 1 (best sell - 1)' },
                    ],
                    dependencies: ['fillMarketOrderPrice'],
                    help: 'When creating sell listings, choose whether to match or undercut the current best sell price',
                },
                market_autoClickMax: {
                    id: 'market_autoClickMax',
                    label: 'Auto-click Max button on sell listing dialogs',
                    type: 'checkbox',
                    default: true,
                    help: 'Automatically clicks the Max button in the quantity field when opening Sell listing dialogs',
                },
                market_visibleItemCount: {
                    id: 'market_visibleItemCount',
                    label: 'Market: Show inventory count on items',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays how many of each item you own when browsing the market',
                },
                market_visibleItemCountOpacity: {
                    id: 'market_visibleItemCountOpacity',
                    label: 'Market: Opacity for items not in inventory',
                    type: 'slider',
                    default: 0.25,
                    min: 0,
                    max: 1,
                    step: 0.05,
                    dependencies: ['market_visibleItemCount'],
                    help: 'How transparent item tiles appear when you own zero of that item',
                },
                market_visibleItemCountIncludeEquipped: {
                    id: 'market_visibleItemCountIncludeEquipped',
                    label: 'Market: Count equipped items',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['market_visibleItemCount'],
                    help: 'Include currently equipped items in the displayed count',
                },
                market_showListingPrices: {
                    id: 'market_showListingPrices',
                    label: 'Market: Show prices on individual listings',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays top order price and total value on each listing in My Listings table',
                },
                market_tradeHistory: {
                    id: 'market_tradeHistory',
                    label: 'Market: Show personal trade history',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays your last buy/sell prices for items in marketplace',
                },
                market_tradeHistoryComparisonMode: {
                    id: 'market_tradeHistoryComparisonMode',
                    label: 'Market: Trade history comparison mode',
                    type: 'select',
                    default: 'instant',
                    options: [
                        { value: 'instant', label: 'Instant' },
                        { value: 'listing', label: 'Orders' },
                    ],
                    dependencies: ['market_tradeHistory'],
                    help: 'Instant: Compare to instant buy/sell prices. Orders: Compare to buy/sell orders.',
                },
                market_listingPricePrecision: {
                    id: 'market_listingPricePrecision',
                    label: 'Market: Listing price decimal precision',
                    type: 'number',
                    default: 2,
                    min: 0,
                    max: 4,
                    dependencies: ['market_showListingPrices'],
                    help: 'Number of decimal places to show for listing prices',
                },
                market_showListingAge: {
                    id: 'market_showListingAge',
                    label: 'Market: Show listing age on My Listings',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['market_showListingPrices'],
                    help: 'Display how long ago each listing was created on the My Listings tab (e.g., "3h 45m")',
                },
                market_showTopOrderAge: {
                    id: 'market_showTopOrderAge',
                    label: 'Market: Show top order age on My Listings',
                    type: 'checkbox',
                    default: false,
                    dependencies: ['market_showListingPrices', 'market_showEstimatedListingAge'],
                    help: 'Display estimated age of the top competing order for each of your listings (requires estimated listing age feature to be active)',
                },
                market_showEstimatedListingAge: {
                    id: 'market_showEstimatedListingAge',
                    label: 'Market: Show estimated age on order book',
                    type: 'checkbox',
                    default: false,
                    help: 'Estimates creation time for all market listings using listing ID interpolation',
                },
                market_listingAgeFormat: {
                    id: 'market_listingAgeFormat',
                    label: 'Market: Listing age display format',
                    type: 'select',
                    default: 'datetime',
                    options: [
                        { value: 'elapsed', label: 'Elapsed Time (e.g., "3h 45m")' },
                        { value: 'datetime', label: 'Date/Time (e.g., "01-13 14:30")' },
                    ],
                    dependencies: ['market_showEstimatedListingAge'],
                    help: 'Choose how to display listing creation times',
                },
                market_listingTimeFormat: {
                    id: 'market_listingTimeFormat',
                    label: 'Market: Time format for date/time display',
                    type: 'select',
                    default: '24hour',
                    options: [
                        { value: '24hour', label: '24-hour (14:30)' },
                        { value: '12hour', label: '12-hour (2:30 PM)' },
                    ],
                    dependencies: ['market_showEstimatedListingAge'],
                    help: 'Time format when using Date/Time display (only applies if Date/Time format is selected)',
                },
                market_listingDateFormat: {
                    id: 'market_listingDateFormat',
                    label: 'Market: Date format for date/time display',
                    type: 'select',
                    default: 'MM-DD',
                    options: [
                        { value: 'MM-DD', label: 'MM-DD (01-13)' },
                        { value: 'DD-MM', label: 'DD-MM (13-01)' },
                    ],
                    dependencies: ['market_showEstimatedListingAge'],
                    help: 'Date format when using Date/Time display (only applies if Date/Time format is selected)',
                },
                market_showOrderTotals: {
                    id: 'market_showOrderTotals',
                    label: 'Market: Show order totals in header',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays buy orders (BO), sell orders (SO), and unclaimed coins (💰) in the header area below gold',
                },
                market_showHistoryViewer: {
                    id: 'market_showHistoryViewer',
                    label: 'Market: Show history viewer button in settings',
                    type: 'checkbox',
                    default: true,
                    help: 'Adds "View Market History" button to settings panel for viewing and exporting all market listing history',
                },
                market_showPhiloCalculator: {
                    id: 'market_showPhiloCalculator',
                    label: 'Market: Show Philo Gamba calculator button in settings',
                    type: 'checkbox',
                    default: true,
                    help: 'Adds "Philo Gamba" button to settings panel for calculating transmutation ROI into Philosopher\'s Stones',
                },
                itemDictionary_transmuteRates: {
                    id: 'itemDictionary_transmuteRates',
                    label: 'Item Dictionary: Show transmutation success rates',
                    type: 'checkbox',
                    default: true,
                    help: 'Displays success rate percentages in the "Transmuted From (Alchemy)" section',
                },
                itemDictionary_transmuteIncludeBaseRate: {
                    id: 'itemDictionary_transmuteIncludeBaseRate',
                    label: 'Item Dictionary: Include base success rate in transmutation percentages',
                    type: 'checkbox',
                    default: true,
                    dependencies: ['itemDictionary_transmuteRates'],
                    help: 'When enabled, shows total probability (base rate × drop rate). When disabled, shows conditional probability (drop rate only, matching "Transmutes Into" section)',
                },
            },
        },

        house: {
            title: 'House',
            icon: '🏠',
            settings: {
                houseUpgradeCosts: {
                    id: 'houseUpgradeCosts',
                    label: 'Show upgrade costs with market prices and inventory comparison',
                    type: 'checkbox',
                    default: true,
                },
            },
        },

        notifications: {
            title: 'Notifications',
            icon: '🔔',
            settings: {
                notifiEmptyAction: {
                    id: 'notifiEmptyAction',
                    label: 'Browser notification when action queue is empty',
                    type: 'checkbox',
                    default: false,
                    help: 'Only works when the game page is open',
                },
            },
        },

        colors: {
            title: 'Color Customization',
            icon: '🎨',
            settings: {
                color_profit: {
                    id: 'color_profit',
                    label: 'Profit/Positive Values',
                    type: 'color',
                    default: '#047857',
                    help: 'Color used for profit, gains, and positive values',
                },
                color_loss: {
                    id: 'color_loss',
                    label: 'Loss/Negative Values',
                    type: 'color',
                    default: '#f87171',
                    help: 'Color used for losses, costs, and negative values',
                },
                color_warning: {
                    id: 'color_warning',
                    label: 'Warnings',
                    type: 'color',
                    default: '#ffa500',
                    help: 'Color used for warnings and important notices',
                },
                color_info: {
                    id: 'color_info',
                    label: 'Informational',
                    type: 'color',
                    default: '#60a5fa',
                    help: 'Color used for informational text and highlights',
                },
                color_essence: {
                    id: 'color_essence',
                    label: 'Essences',
                    type: 'color',
                    default: '#c084fc',
                    help: 'Color used for essence drops and essence-related text',
                },
                color_tooltip_profit: {
                    id: 'color_tooltip_profit',
                    label: 'Tooltip Profit/Positive',
                    type: 'color',
                    default: '#047857',
                    help: 'Color for profit/positive values in tooltips (light backgrounds)',
                },
                color_tooltip_loss: {
                    id: 'color_tooltip_loss',
                    label: 'Tooltip Loss/Negative',
                    type: 'color',
                    default: '#dc2626',
                    help: 'Color for loss/negative values in tooltips (light backgrounds)',
                },
                color_tooltip_info: {
                    id: 'color_tooltip_info',
                    label: 'Tooltip Informational',
                    type: 'color',
                    default: '#2563eb',
                    help: 'Color for informational text in tooltips (light backgrounds)',
                },
                color_tooltip_warning: {
                    id: 'color_tooltip_warning',
                    label: 'Tooltip Warnings',
                    type: 'color',
                    default: '#ea580c',
                    help: 'Color for warnings in tooltips (light backgrounds)',
                },
                color_text_primary: {
                    id: 'color_text_primary',
                    label: 'Primary Text',
                    type: 'color',
                    default: '#ffffff',
                    help: 'Main text color',
                },
                color_text_secondary: {
                    id: 'color_text_secondary',
                    label: 'Secondary Text',
                    type: 'color',
                    default: '#888888',
                    help: 'Dimmed/secondary text color',
                },
                color_border: {
                    id: 'color_border',
                    label: 'Borders',
                    type: 'color',
                    default: '#444444',
                    help: 'Border and separator color',
                },
                color_gold: {
                    id: 'color_gold',
                    label: 'Gold/Currency',
                    type: 'color',
                    default: '#ffa500',
                    help: 'Color used for gold and currency displays',
                },
                color_accent: {
                    id: 'color_accent',
                    label: 'Script Accent Color',
                    type: 'color',
                    default: '#22c55e',
                    help: 'Primary accent color for script UI elements (buttons, headers, zone numbers, XP percentages, etc.)',
                },
                color_remaining_xp: {
                    id: 'color_remaining_xp',
                    label: 'Remaining XP Text',
                    type: 'color',
                    default: '#FFFFFF',
                    help: 'Color for remaining XP text below skill bars in left navigation',
                },
                color_invBadge_ask: {
                    id: 'color_invBadge_ask',
                    label: 'Inventory Badge: Ask Price',
                    type: 'color',
                    default: '#047857',
                    help: 'Color for Ask price badges on inventory items (seller asking price - better selling value)',
                },
                color_invBadge_bid: {
                    id: 'color_invBadge_bid',
                    label: 'Inventory Badge: Bid Price',
                    type: 'color',
                    default: '#60a5fa',
                    help: 'Color for Bid price badges on inventory items (buyer bid price - instant-sell value)',
                },
                color_transmute: {
                    id: 'color_transmute',
                    label: 'Transmutation Rates',
                    type: 'color',
                    default: '#ffffff',
                    help: 'Color used for transmutation success rate percentages in Item Dictionary',
                },
            },
        },
    };

    /**
     * Settings Storage Module
     * Handles persistence of settings to chrome.storage.local
     */


    class SettingsStorage {
        constructor() {
            this.storageKey = 'script_settingsMap'; // Legacy global key (used as template)
            this.storageArea = 'settings';
            this.currentCharacterId = null; // Current character ID (set after login)
            this.knownCharactersKey = 'known_character_ids'; // List of character IDs
        }

        /**
         * Set the current character ID
         * Must be called after character_initialized event
         * @param {string} characterId - Character ID
         */
        setCharacterId(characterId) {
            this.currentCharacterId = characterId;
        }

        /**
         * Get the storage key for current character
         * Falls back to global key if no character ID set
         * @returns {string} Storage key
         */
        getCharacterStorageKey() {
            if (this.currentCharacterId) {
                return `${this.storageKey}_${this.currentCharacterId}`;
            }
            return this.storageKey; // Fallback to global key
        }

        /**
         * Load all settings from storage
         * Merges saved values with defaults from settings-schema
         * @returns {Promise<Object>} Settings map
         */
        async loadSettings() {
            const characterKey = this.getCharacterStorageKey();
            let saved = await storage$1.getJSON(characterKey, this.storageArea, null);

            // Migration: If this is a character-specific key and it doesn't exist
            // Copy from global template (old 'script_settingsMap' key)
            if (this.currentCharacterId && !saved) {
                const globalTemplate = await storage$1.getJSON(this.storageKey, this.storageArea, null);
                if (globalTemplate) {
                    // Copy global template to this character
                    saved = globalTemplate;
                    await storage$1.setJSON(characterKey, saved, this.storageArea, true);
                }

                // Add character to known characters list
                await this.addToKnownCharacters(this.currentCharacterId);
            }

            const settings = {};

            // Build default settings from config
            for (const group of Object.values(settingsGroups)) {
                for (const [settingId, settingDef] of Object.entries(group.settings)) {
                    settings[settingId] = {
                        id: settingId,
                        desc: settingDef.label,
                        type: settingDef.type || 'checkbox',
                    };

                    // Set default value
                    if (settingDef.type === 'checkbox') {
                        settings[settingId].isTrue = settingDef.default ?? false;
                    } else {
                        settings[settingId].value = settingDef.default ?? '';
                    }

                    // Copy other properties
                    if (settingDef.options) {
                        settings[settingId].options = settingDef.options;
                    }
                    if (settingDef.min !== undefined) {
                        settings[settingId].min = settingDef.min;
                    }
                    if (settingDef.max !== undefined) {
                        settings[settingId].max = settingDef.max;
                    }
                    if (settingDef.step !== undefined) {
                        settings[settingId].step = settingDef.step;
                    }
                }
            }

            // Merge saved settings
            if (saved) {
                for (const [settingId, savedValue] of Object.entries(saved)) {
                    if (settings[settingId]) {
                        // Merge saved boolean values
                        if (savedValue.hasOwnProperty('isTrue')) {
                            settings[settingId].isTrue = savedValue.isTrue;
                        }
                        // Merge saved non-boolean values
                        if (savedValue.hasOwnProperty('value')) {
                            settings[settingId].value = savedValue.value;
                        }
                    }
                }
            }

            return settings;
        }

        /**
         * Save all settings to storage
         * @param {Object} settings - Settings map
         * @returns {Promise<void>}
         */
        async saveSettings(settings) {
            const characterKey = this.getCharacterStorageKey();
            await storage$1.setJSON(characterKey, settings, this.storageArea, true);
        }

        /**
         * Add character to known characters list
         * @param {string} characterId - Character ID
         * @returns {Promise<void>}
         */
        async addToKnownCharacters(characterId) {
            const knownCharacters = await storage$1.getJSON(this.knownCharactersKey, this.storageArea, []);
            if (!knownCharacters.includes(characterId)) {
                knownCharacters.push(characterId);
                await storage$1.setJSON(this.knownCharactersKey, knownCharacters, this.storageArea, true);
            }
        }

        /**
         * Get list of known character IDs
         * @returns {Promise<Array<string>>} Character IDs
         */
        async getKnownCharacters() {
            return await storage$1.getJSON(this.knownCharactersKey, this.storageArea, []);
        }

        /**
         * Sync current settings to all other characters
         * @param {Object} settings - Current settings to copy
         * @returns {Promise<number>} Number of characters synced
         */
        async syncSettingsToAllCharacters(settings) {
            const knownCharacters = await this.getKnownCharacters();
            let syncedCount = 0;

            for (const characterId of knownCharacters) {
                // Skip current character (already has these settings)
                if (characterId === this.currentCharacterId) {
                    continue;
                }

                // Write settings to this character's key
                const characterKey = `${this.storageKey}_${characterId}`;
                await storage$1.setJSON(characterKey, settings, this.storageArea, true);
                syncedCount++;
            }

            return syncedCount;
        }

        /**
         * Get a single setting value
         * @param {string} settingId - Setting ID
         * @param {*} defaultValue - Default value if not found
         * @returns {Promise<*>} Setting value
         */
        async getSetting(settingId, defaultValue = null) {
            const settings = await this.loadSettings();
            const setting = settings[settingId];

            if (!setting) {
                return defaultValue;
            }

            // Return boolean for checkbox settings
            if (setting.type === 'checkbox') {
                return setting.isTrue ?? defaultValue;
            }

            // Return value for other settings
            return setting.value ?? defaultValue;
        }

        /**
         * Set a single setting value
         * @param {string} settingId - Setting ID
         * @param {*} value - New value
         * @returns {Promise<void>}
         */
        async setSetting(settingId, value) {
            const settings = await this.loadSettings();

            if (!settings[settingId]) {
                console.warn(`Setting '${settingId}' not found`);
                return;
            }

            // Update value
            if (settings[settingId].type === 'checkbox') {
                settings[settingId].isTrue = value;
            } else {
                settings[settingId].value = value;
            }

            await this.saveSettings(settings);
        }

        /**
         * Reset all settings to defaults
         * @returns {Promise<void>}
         */
        async resetToDefaults() {
            // Simply clear storage - loadSettings() will return defaults
            await storage$1.remove(this.storageKey, this.storageArea);
        }

        /**
         * Export settings as JSON
         * @returns {Promise<string>} JSON string
         */
        async exportSettings() {
            const settings = await this.loadSettings();
            return JSON.stringify(settings, null, 2);
        }

        /**
         * Import settings from JSON
         * @param {string} jsonString - JSON string
         * @returns {Promise<boolean>} Success
         */
        async importSettings(jsonString) {
            try {
                const imported = JSON.parse(jsonString);
                await this.saveSettings(imported);
                return true;
            } catch (error) {
                console.error('[Settings Storage] Import failed:', error);
                return false;
            }
        }
    }

    const settingsStorage = new SettingsStorage();

    /**
     * Profile Cache Module
     * Stores current profile in memory for Steam users
     */

    // Module-level variable to hold current profile in memory
    let currentProfileCache = null;

    /**
     * Set current profile in memory
     * @param {Object} profileData - Profile data from profile_shared message
     */
    function setCurrentProfile(profileData) {
        currentProfileCache = profileData;
    }

    /**
     * Get current profile from memory
     * @returns {Object|null} Current profile or null
     */
    function getCurrentProfile() {
        return currentProfileCache;
    }

    /**
     * Clear current profile from memory
     */
    function clearCurrentProfile() {
        currentProfileCache = null;
    }

    /**
     * WebSocket Hook Module
     * Intercepts WebSocket messages from the MWI game server
     *
     * Uses WebSocket constructor wrapper for better performance than MessageEvent.prototype.data hooking
     */


    class WebSocketHook {
        constructor() {
            this.isHooked = false;
            this.messageHandlers = new Map();
            this.socketEventHandlers = new Map();
            this.attachedSockets = new WeakSet();
            /**
             * Track processed message events to avoid duplicate handling when multiple hooks fire.
             *
             * We intercept messages through three paths:
             * 1) MessageEvent.prototype.data getter
             * 2) WebSocket.prototype addEventListener/onmessage wrappers
             * 3) Direct socket listeners in attachSocketListeners
             */
            this.processedMessageEvents = new WeakSet();

            /**
             * Track processed messages by content hash to prevent duplicate JSON.parse
             * Uses message content (first 100 chars) as key since same message can have different event objects
             */
            this.processedMessages = new Map(); // message hash -> timestamp
            this.messageCleanupInterval = null;
            this.isSocketWrapped = false;
            this.originalWebSocket = null;
            this.currentWebSocket = null;
            // Detect if userscript manager is present (Tampermonkey, Greasemonkey, etc.)
            this.hasScriptManager = typeof GM_info !== 'undefined';
            this.clientDataRetryTimeout = null;
        }

        /**
         * Save combat sim export data to appropriate storage
         * Only saves if script manager is available (cross-domain sharing with Combat Sim)
         * @param {string} key - Storage key
         * @param {string} value - Value to save (JSON string)
         */
        async saveToStorage(key, value) {
            if (this.hasScriptManager) {
                // Tampermonkey: use GM storage for cross-domain sharing with Combat Sim
                // Wrap in setTimeout to make async and prevent main thread blocking
                setTimeout(() => {
                    try {
                        GM_setValue(key, value);
                    } catch (error) {
                        console.error('[WebSocket] Failed to save to GM storage:', error);
                    }
                }, 0);
            }
            // Steam/standalone: Skip saving - Combat Sim import not possible without cross-domain storage
        }

        /**
         * Load combat sim export data from appropriate storage
         * Only loads if script manager is available
         * @param {string} key - Storage key
         * @param {string} defaultValue - Default value if not found
         * @returns {string|null} Stored value or default
         */
        async loadFromStorage(key, defaultValue = null) {
            if (this.hasScriptManager) {
                // Tampermonkey: use GM storage
                return GM_getValue(key, defaultValue);
            }
            // Steam/standalone: No data available (Combat Sim import requires script manager)
            return defaultValue;
        }

        /**
         * Install the WebSocket hook
         * MUST be called before WebSocket connection is established
         * Uses MessageEvent.prototype.data hook (same method as MWI Tools)
         */
        install() {
            if (this.isHooked) {
                console.warn('[WebSocket Hook] Already installed');
                return;
            }

            this.wrapWebSocketConstructor();
            this.wrapWebSocketPrototype();

            // Capture hook instance for closure
            const hookInstance = this;

            // Hook MessageEvent.prototype.data (same as MWI Tools)
            const dataProperty = Object.getOwnPropertyDescriptor(MessageEvent.prototype, 'data');
            const originalGet = dataProperty.get;

            dataProperty.get = function hookedGet() {
                const socket = this.currentTarget;

                // Only hook WebSocket messages
                if (!(socket instanceof WebSocket)) {
                    return originalGet.call(this);
                }

                // Only hook MWI game server
                if (!hookInstance.isGameSocket(socket)) {
                    return originalGet.call(this);
                }

                hookInstance.attachSocketListeners(socket);

                const message = originalGet.call(this);

                // Anti-loop: define data property so we don't hook our own access
                Object.defineProperty(this, 'data', { value: message });

                // Process message in our hook
                hookInstance.markMessageEventProcessed(this);
                hookInstance.processMessage(message);

                return message;
            };

            Object.defineProperty(MessageEvent.prototype, 'data', dataProperty);

            this.isHooked = true;
        }

        /**
         * Wrap WebSocket prototype handlers to intercept message events
         */
        wrapWebSocketPrototype() {
            const targetWindow = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;
            if (typeof targetWindow === 'undefined' || !targetWindow.WebSocket || !targetWindow.WebSocket.prototype) {
                return;
            }

            const hookInstance = this;
            const proto = targetWindow.WebSocket.prototype;

            if (!proto.__toolashaPatched) {
                const originalAddEventListener = proto.addEventListener;
                proto.addEventListener = function toolashaAddEventListener(type, listener, options) {
                    if (type === 'message' && typeof listener === 'function') {
                        const wrappedListener = function toolashaMessageListener(event) {
                            if (!hookInstance.isMessageEventProcessed(event) && typeof event?.data === 'string') {
                                hookInstance.markMessageEventProcessed(event);
                                hookInstance.processMessage(event.data);
                            }
                            return listener.call(this, event);
                        };

                        wrappedListener.__toolashaOriginal = listener;
                        return originalAddEventListener.call(this, type, wrappedListener, options);
                    }

                    return originalAddEventListener.call(this, type, listener, options);
                };

                const originalOnMessage = Object.getOwnPropertyDescriptor(proto, 'onmessage');
                if (originalOnMessage && originalOnMessage.set) {
                    Object.defineProperty(proto, 'onmessage', {
                        configurable: true,
                        get: originalOnMessage.get,
                        set(handler) {
                            if (typeof handler !== 'function') {
                                return originalOnMessage.set.call(this, handler);
                            }

                            const wrappedHandler = function toolashaOnMessage(event) {
                                if (!hookInstance.isMessageEventProcessed(event) && typeof event?.data === 'string') {
                                    hookInstance.markMessageEventProcessed(event);
                                    hookInstance.processMessage(event.data);
                                }
                                return handler.call(this, event);
                            };

                            wrappedHandler.__toolashaOriginal = handler;
                            return originalOnMessage.set.call(this, wrappedHandler);
                        },
                    });
                }

                proto.__toolashaPatched = true;
            }
        }

        /**
         * Check if a WebSocket instance belongs to the game server
         * @param {WebSocket} socket - WebSocket instance
         * @returns {boolean} True if game socket
         */
        isGameSocket(socket) {
            if (!socket || !socket.url) {
                return false;
            }

            return (
                socket.url.indexOf('api.milkywayidle.com/ws') !== -1 ||
                socket.url.indexOf('api-test.milkywayidle.com/ws') !== -1
            );
        }

        /**
         * Wrap the WebSocket constructor to attach lifecycle listeners
         */
        wrapWebSocketConstructor() {
            if (this.isSocketWrapped) {
                return;
            }

            const targetWindow = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;
            if (typeof targetWindow === 'undefined' || !targetWindow.WebSocket) {
                return;
            }

            const hookInstance = this;

            const wrapConstructor = (OriginalWebSocket) => {
                if (!OriginalWebSocket || OriginalWebSocket.__toolashaWrapped) {
                    hookInstance.currentWebSocket = OriginalWebSocket;
                    return;
                }

                class ToolashaWebSocket extends OriginalWebSocket {
                    constructor(...args) {
                        super(...args);
                        hookInstance.attachSocketListeners(this);
                    }
                }

                ToolashaWebSocket.__toolashaWrapped = true;
                ToolashaWebSocket.__toolashaOriginal = OriginalWebSocket;

                hookInstance.originalWebSocket = OriginalWebSocket;
                hookInstance.currentWebSocket = ToolashaWebSocket;
            };

            wrapConstructor(targetWindow.WebSocket);

            Object.defineProperty(targetWindow, 'WebSocket', {
                configurable: true,
                get() {
                    return hookInstance.currentWebSocket;
                },
                set(nextWebSocket) {
                    wrapConstructor(nextWebSocket);
                },
            });
            this.isSocketWrapped = true;
        }

        /**
         * Attach lifecycle listeners to a socket
         * @param {WebSocket} socket - WebSocket instance
         */
        attachSocketListeners(socket) {
            if (!this.isGameSocket(socket)) {
                return;
            }

            if (this.attachedSockets.has(socket)) {
                return;
            }

            this.attachedSockets.add(socket);

            const events = ['open', 'close', 'error'];
            for (const eventName of events) {
                socket.addEventListener(eventName, (event) => {
                    this.emitSocketEvent(eventName, event, socket);
                });
            }

            socket.addEventListener('message', (event) => {
                if (this.isMessageEventProcessed(event)) {
                    return;
                }

                if (!event || typeof event.data !== 'string') {
                    return;
                }

                this.markMessageEventProcessed(event);
                this.processMessage(event.data);
            });
        }

        isMessageEventProcessed(event) {
            if (!event || typeof event !== 'object') {
                return false;
            }

            return this.processedMessageEvents.has(event);
        }

        markMessageEventProcessed(event) {
            if (!event || typeof event !== 'object') {
                return;
            }

            this.processedMessageEvents.add(event);
        }

        /**
         * Process intercepted message
         * @param {string} message - JSON string from WebSocket
         */
        processMessage(message) {
            // Parse message type first to determine deduplication strategy
            let messageType;
            try {
                // Quick parse to get type (avoid full parse for duplicates)
                const typeMatch = message.match(/"type":"([^"]+)"/);
                messageType = typeMatch ? typeMatch[1] : null;
            } catch {
                // If regex fails, skip deduplication and process normally
                messageType = null;
            }

            // Skip deduplication for events where consecutive messages have similar first 100 chars
            // but contain different data (counts, timestamps, etc. beyond the 100-char hash window)
            // OR events that should always trigger UI updates (profile_shared)
            const skipDedup =
                messageType === 'quests_updated' ||
                messageType === 'action_completed' ||
                messageType === 'items_updated' ||
                messageType === 'market_item_order_books_updated' ||
                messageType === 'market_listings_updated' ||
                messageType === 'profile_shared';

            if (!skipDedup) {
                // Deduplicate by message content to prevent 4x JSON.parse on same message
                // Use first 100 chars as hash (contains type + timestamp, unique enough)
                const messageHash = message.substring(0, 100);

                if (this.processedMessages.has(messageHash)) {
                    return; // Already processed this message, skip
                }

                this.processedMessages.set(messageHash, Date.now());

                // Cleanup old entries every 100 messages to prevent memory leak
                if (this.processedMessages.size > 100) {
                    this.cleanupProcessedMessages();
                }
            }

            try {
                const data = JSON.parse(message);
                const parsedMessageType = data.type;

                // Save critical data to GM storage for Combat Sim export
                this.saveCombatSimData(parsedMessageType, message);

                // Call registered handlers for this message type
                const handlers = this.messageHandlers.get(parsedMessageType) || [];

                for (const handler of handlers) {
                    try {
                        handler(data);
                    } catch (error) {
                        console.error(`[WebSocket] Handler error for ${parsedMessageType}:`, error);
                    }
                }

                // Call wildcard handlers (receive all messages)
                const wildcardHandlers = this.messageHandlers.get('*') || [];
                for (const handler of wildcardHandlers) {
                    try {
                        handler(data);
                    } catch (error) {
                        console.error('[WebSocket] Wildcard handler error:', error);
                    }
                }
            } catch (error) {
                console.error('[WebSocket] Failed to process message:', error);
            }
        }

        /**
         * Save character/battle data for Combat Simulator export
         * @param {string} messageType - Message type
         * @param {string} message - Raw message JSON string
         */
        async saveCombatSimData(messageType, message) {
            try {
                // Save full character data (on login/refresh)
                if (messageType === 'init_character_data') {
                    await this.saveToStorage('toolasha_init_character_data', message);
                }

                // Save client data (for ability special detection)
                if (messageType === 'init_client_data') {
                    await this.saveToStorage('toolasha_init_client_data', message);
                }

                // Save battle data including party members (on combat start)
                if (messageType === 'new_battle') {
                    await this.saveToStorage('toolasha_new_battle', message);
                }

                // Save profile shares (when opening party member profiles)
                if (messageType === 'profile_shared') {
                    const parsed = JSON.parse(message);

                    // Extract character info - try multiple sources for ID
                    parsed.characterID =
                        parsed.profile.sharableCharacter?.id ||
                        parsed.profile.characterSkills?.[0]?.characterID ||
                        parsed.profile.character?.id;
                    parsed.characterName = parsed.profile.sharableCharacter?.name || 'Unknown';
                    parsed.timestamp = Date.now();

                    // Validate we got a character ID
                    if (!parsed.characterID) {
                        console.error('[Toolasha] Failed to extract characterID from profile:', parsed);
                        return;
                    }

                    // Store in memory for Steam users (works without GM storage)
                    setCurrentProfile(parsed);

                    // Load existing profile list from GM storage (cross-origin accessible)
                    const profileListJson = await this.loadFromStorage('toolasha_profile_list', '[]');
                    let profileList = JSON.parse(profileListJson);

                    // Remove old entry for same character
                    profileList = profileList.filter((p) => p.characterID !== parsed.characterID);

                    // Add to front of list
                    profileList.unshift(parsed);

                    // Keep only last 20 profiles
                    if (profileList.length > 20) {
                        profileList.pop();
                    }

                    // Save updated profile list to GM storage (matches pattern of other combat sim data)
                    await this.saveToStorage('toolasha_profile_list', JSON.stringify(profileList));
                }
            } catch (error) {
                console.error('[WebSocket] Failed to save Combat Sim data:', error);
            }
        }

        /**
         * Capture init_client_data from localStorage (fallback method)
         * Called periodically since it may not come through WebSocket
         * Uses official game API to avoid manual decompression
         */
        async captureClientDataFromLocalStorage() {
            try {
                // Use official game API instead of manual localStorage access
                if (typeof localStorageUtil === 'undefined' || typeof localStorageUtil.getInitClientData !== 'function') {
                    // API not ready yet, retry
                    this.scheduleClientDataRetry();
                    return;
                }

                // API returns parsed object and handles decompression automatically
                const clientDataObj = localStorageUtil.getInitClientData();
                if (!clientDataObj || Object.keys(clientDataObj).length === 0) {
                    // Data not available yet, retry
                    this.scheduleClientDataRetry();
                    return;
                }

                // Verify it's init_client_data
                if (clientDataObj?.type === 'init_client_data') {
                    // Save as JSON string for Combat Sim export
                    const clientDataStr = JSON.stringify(clientDataObj);
                    await this.saveToStorage('toolasha_init_client_data', clientDataStr);
                    console.log('[Toolasha] Client data captured from localStorage via official API');
                    this.clearClientDataRetry();
                }
            } catch (error) {
                console.error('[WebSocket] Failed to capture client data from localStorage:', error);
                // Retry on error
                this.scheduleClientDataRetry();
            }
        }

        /**
         * Schedule a retry for client data capture
         */
        scheduleClientDataRetry() {
            this.clearClientDataRetry();
            this.clientDataRetryTimeout = setTimeout(() => this.captureClientDataFromLocalStorage(), 2000);
        }

        /**
         * Clear any pending client data retry
         */
        clearClientDataRetry() {
            if (this.clientDataRetryTimeout) {
                clearTimeout(this.clientDataRetryTimeout);
                this.clientDataRetryTimeout = null;
            }
        }

        /**
         * Cleanup old processed message entries (keep last 50, remove rest)
         */
        cleanupProcessedMessages() {
            const entries = Array.from(this.processedMessages.entries());
            // Sort by timestamp, keep newest 50
            entries.sort((a, b) => b[1] - a[1]);

            this.processedMessages.clear();
            for (let i = 0; i < Math.min(50, entries.length); i++) {
                this.processedMessages.set(entries[i][0], entries[i][1]);
            }
        }

        /**
         * Cleanup any pending retry timeouts
         */
        cleanup() {
            this.clearClientDataRetry();
            this.processedMessages.clear();
        }

        /**
         * Register a handler for a specific message type
         * @param {string} messageType - Message type to handle (e.g., "init_character_data")
         * @param {Function} handler - Function to call when message received
         */
        on(messageType, handler) {
            if (!this.messageHandlers.has(messageType)) {
                this.messageHandlers.set(messageType, []);
            }
            this.messageHandlers.get(messageType).push(handler);
        }

        /**
         * Register a handler for WebSocket lifecycle events
         * @param {string} eventType - Event type (open, close, error)
         * @param {Function} handler - Handler function
         */
        onSocketEvent(eventType, handler) {
            if (!this.socketEventHandlers.has(eventType)) {
                this.socketEventHandlers.set(eventType, []);
            }
            this.socketEventHandlers.get(eventType).push(handler);
        }

        /**
         * Unregister a handler
         * @param {string} messageType - Message type
         * @param {Function} handler - Handler function to remove
         */
        off(messageType, handler) {
            const handlers = this.messageHandlers.get(messageType);
            if (handlers) {
                const index = handlers.indexOf(handler);
                if (index > -1) {
                    handlers.splice(index, 1);
                }
            }
        }

        /**
         * Unregister a WebSocket lifecycle handler
         * @param {string} eventType - Event type
         * @param {Function} handler - Handler function
         */
        offSocketEvent(eventType, handler) {
            const handlers = this.socketEventHandlers.get(eventType);
            if (handlers) {
                const index = handlers.indexOf(handler);
                if (index > -1) {
                    handlers.splice(index, 1);
                }
            }
        }

        emitSocketEvent(eventType, event, socket) {
            const handlers = this.socketEventHandlers.get(eventType) || [];
            for (const handler of handlers) {
                try {
                    handler(event, socket);
                } catch (error) {
                    console.error(`[WebSocket] ${eventType} handler error:`, error);
                }
            }
        }
    }

    const webSocketHook$1 = new WebSocketHook();

    const CONNECTION_STATES = {
        CONNECTED: 'connected',
        DISCONNECTED: 'disconnected',
        RECONNECTING: 'reconnecting',
    };

    class ConnectionState {
        constructor() {
            this.state = CONNECTION_STATES.RECONNECTING;
            this.eventListeners = new Map();
            this.lastDisconnectedAt = null;
            this.lastConnectedAt = null;

            this.setupListeners();
        }

        /**
         * Get current connection state
         * @returns {string} Connection state (connected, disconnected, reconnecting)
         */
        getState() {
            return this.state;
        }

        /**
         * Check if currently connected
         * @returns {boolean} True if connected
         */
        isConnected() {
            return this.state === CONNECTION_STATES.CONNECTED;
        }

        /**
         * Register a listener for connection events
         * @param {string} event - Event name (disconnected, reconnected)
         * @param {Function} callback - Handler function
         */
        on(event, callback) {
            if (!this.eventListeners.has(event)) {
                this.eventListeners.set(event, []);
            }
            this.eventListeners.get(event).push(callback);
        }

        /**
         * Unregister a connection event listener
         * @param {string} event - Event name
         * @param {Function} callback - Handler function to remove
         */
        off(event, callback) {
            const listeners = this.eventListeners.get(event);
            if (listeners) {
                const index = listeners.indexOf(callback);
                if (index > -1) {
                    listeners.splice(index, 1);
                }
            }
        }

        /**
         * Notify connection state from character initialization
         * @param {Object} data - Character initialization payload
         */
        handleCharacterInitialized(data) {
            if (!data) {
                return;
            }

            this.setConnected('character_initialized');
        }

        setupListeners() {
            webSocketHook$1.onSocketEvent('open', () => {
                this.setReconnecting('socket_open', { allowConnected: true });
            });

            webSocketHook$1.onSocketEvent('close', (event) => {
                this.setDisconnected('socket_close', event);
            });

            webSocketHook$1.onSocketEvent('error', (event) => {
                this.setDisconnected('socket_error', event);
            });

            webSocketHook$1.on('init_character_data', () => {
                this.setConnected('init_character_data');
            });
        }

        setReconnecting(reason, options = {}) {
            if (this.state === CONNECTION_STATES.CONNECTED && !options.allowConnected) {
                return;
            }

            this.updateState(CONNECTION_STATES.RECONNECTING, {
                reason,
            });
        }

        setDisconnected(reason, event) {
            if (this.state === CONNECTION_STATES.DISCONNECTED) {
                return;
            }

            this.lastDisconnectedAt = Date.now();
            this.updateState(CONNECTION_STATES.DISCONNECTED, {
                reason,
                event,
                disconnectedAt: this.lastDisconnectedAt,
            });
        }

        setConnected(reason) {
            if (this.state === CONNECTION_STATES.CONNECTED) {
                return;
            }

            this.lastConnectedAt = Date.now();
            this.updateState(CONNECTION_STATES.CONNECTED, {
                reason,
                disconnectedAt: this.lastDisconnectedAt,
                connectedAt: this.lastConnectedAt,
            });
        }

        updateState(nextState, details) {
            if (this.state === nextState) {
                return;
            }

            const previousState = this.state;
            this.state = nextState;

            if (nextState === CONNECTION_STATES.DISCONNECTED) {
                this.emit('disconnected', {
                    previousState,
                    ...details,
                });
                return;
            }

            if (nextState === CONNECTION_STATES.CONNECTED) {
                this.emit('reconnected', {
                    previousState,
                    ...details,
                });
            }
        }

        emit(event, data) {
            const listeners = this.eventListeners.get(event) || [];
            for (const listener of listeners) {
                try {
                    listener(data);
                } catch (error) {
                    console.error('[ConnectionState] Listener error:', error);
                }
            }
        }
    }

    const connectionState = new ConnectionState();

    /**
     * Merge market listing updates into the current list.
     * @param {Array} currentListings - Existing market listings.
     * @param {Array} updatedListings - Updated listings from WebSocket.
     * @returns {Array} New merged listings array.
     */
    const mergeMarketListings = (currentListings = [], updatedListings = []) => {
        const safeCurrent = Array.isArray(currentListings) ? currentListings : [];
        const safeUpdates = Array.isArray(updatedListings) ? updatedListings : [];

        if (safeUpdates.length === 0) {
            return [...safeCurrent];
        }

        const indexById = new Map();
        safeCurrent.forEach((listing, index) => {
            if (!listing || listing.id === undefined || listing.id === null) {
                return;
            }
            indexById.set(listing.id, index);
        });

        const merged = [...safeCurrent];

        for (const listing of safeUpdates) {
            if (!listing || listing.id === undefined || listing.id === null) {
                continue;
            }

            const existingIndex = indexById.get(listing.id);
            if (existingIndex !== undefined) {
                merged[existingIndex] = listing;
            } else {
                merged.push(listing);
            }
        }

        return merged;
    };

    var marketListings = /*#__PURE__*/Object.freeze({
        __proto__: null,
        mergeMarketListings: mergeMarketListings
    });

    /**
     * Data Manager Module
     * Central hub for accessing game data
     *
     * Uses official API: localStorageUtil.getInitClientData()
     * Listens to WebSocket messages for player data updates
     */


    class DataManager {
        constructor() {
            this.webSocketHook = webSocketHook$1;

            // Static game data (items, actions, monsters, abilities, etc.)
            this.initClientData = null;

            // Player data (updated via WebSocket)
            this.characterData = null;
            this.characterSkills = null;
            this.characterItems = null;
            this.characterActions = [];
            this.characterQuests = []; // Active quests including tasks
            this.characterEquipment = new Map();
            this.characterHouseRooms = new Map(); // House room HRID -> {houseRoomHrid, level}
            this.actionTypeDrinkSlotsMap = new Map(); // Action type HRID -> array of drink items
            this.monsterSortIndexMap = new Map(); // Monster HRID -> combat zone sortIndex
            this.battleData = null; // Current battle data (for Combat Sim export on Steam)

            // Character tracking for switch detection
            this.currentCharacterId = null;
            this.currentCharacterName = null;
            this.isCharacterSwitching = false;
            this.lastCharacterSwitchTime = 0; // Prevent rapid-fire switch loops

            // Event listeners
            this.eventListeners = new Map();

            // Achievement buff cache (action type → buff type → flat boost)
            this.achievementBuffCache = {
                source: null,
                byActionType: new Map(),
            };

            // Retry interval for loading static game data
            this.loadRetryInterval = null;
            this.fallbackInterval = null;

            // Setup WebSocket message handlers
            this.setupMessageHandlers();
        }

        /**
         * Initialize the Data Manager
         * Call this after game loads (or immediately - will retry if needed)
         */
        initialize() {
            this.cleanupIntervals();

            // Try to load static game data using official API
            const success = this.tryLoadStaticData();

            // If failed, set up retry polling
            if (!success && !this.loadRetryInterval) {
                this.loadRetryInterval = setInterval(() => {
                    if (this.tryLoadStaticData()) {
                        this.cleanupIntervals();
                    }
                }, 500); // Retry every 500ms
            }

            // FALLBACK: Continuous polling for missed init_character_data (should not be needed with @run-at document-start)
            // Extended timeout for slower connections/computers (Steam, etc.)
            let fallbackAttempts = 0;
            const maxAttempts = 60; // Poll for up to 30 seconds (60 × 500ms)

            const stopFallbackInterval = () => {
                if (this.fallbackInterval) {
                    clearInterval(this.fallbackInterval);
                    this.fallbackInterval = null;
                }
            };

            this.fallbackInterval = setInterval(() => {
                fallbackAttempts++;

                // Stop if character data received via WebSocket
                if (this.characterData) {
                    stopFallbackInterval();
                    return;
                }

                // Give up after max attempts
                if (fallbackAttempts >= maxAttempts) {
                    console.error(
                        '[DataManager] Character data not received after 30 seconds. WebSocket hook may have failed.'
                    );
                    stopFallbackInterval();
                }
            }, 500); // Check every 500ms
        }

        /**
         * Cleanup polling intervals
         */
        cleanupIntervals() {
            if (this.loadRetryInterval) {
                clearInterval(this.loadRetryInterval);
                this.loadRetryInterval = null;
            }

            if (this.fallbackInterval) {
                clearInterval(this.fallbackInterval);
                this.fallbackInterval = null;
            }
        }

        /**
         * Attempt to load static game data
         * @returns {boolean} True if successful, false if needs retry
         * @private
         */
        tryLoadStaticData() {
            try {
                if (typeof localStorageUtil !== 'undefined' && typeof localStorageUtil.getInitClientData === 'function') {
                    const data = localStorageUtil.getInitClientData();
                    if (data && Object.keys(data).length > 0) {
                        this.initClientData = data;

                        // Build monster sort index map for task sorting
                        this.buildMonsterSortIndexMap();

                        return true;
                    }
                }
                return false;
            } catch (error) {
                console.error('[Data Manager] Failed to load init_client_data:', error);
                return false;
            }
        }

        /**
         * Setup WebSocket message handlers
         * Listens for game data updates
         */
        setupMessageHandlers() {
            // Handle init_character_data (player data on login/refresh)
            this.webSocketHook.on('init_character_data', async (data) => {
                // Detect character switch
                const newCharacterId = data.character?.id;
                const newCharacterName = data.character?.name;

                // Validate character data before processing
                if (!newCharacterId || !newCharacterName) {
                    console.error('[DataManager] Invalid character data received:', {
                        hasCharacter: !!data.character,
                        hasId: !!newCharacterId,
                        hasName: !!newCharacterName,
                    });
                    return; // Don't process invalid character data
                }

                // Track whether this is a character switch or first load
                let isCharacterSwitch = false;

                // Check if this is a character switch (not first load)
                if (this.currentCharacterId && this.currentCharacterId !== newCharacterId) {
                    isCharacterSwitch = true;
                    // Prevent rapid-fire character switches (loop protection)
                    const now = Date.now();
                    if (this.lastCharacterSwitchTime && now - this.lastCharacterSwitchTime < 1000) {
                        console.warn('[Toolasha] Ignoring rapid character switch (<1s since last), possible loop detected');
                        return;
                    }
                    this.lastCharacterSwitchTime = now;

                    // Flush all pending storage writes before cleanup (non-blocking)
                    // Use setTimeout to prevent main thread blocking during character switch
                    setTimeout(async () => {
                        try {
                            if (storage$1 && typeof storage$1.flushAll === 'function') {
                                await storage$1.flushAll();
                            }
                        } catch (error) {
                            console.error('[Toolasha] Failed to flush storage before character switch:', error);
                        }
                    }, 0);

                    // Set switching flag to block feature initialization
                    this.isCharacterSwitching = true;

                    // Emit character_switching event (cleanup phase)
                    this.emit('character_switching', {
                        oldId: this.currentCharacterId,
                        newId: newCharacterId,
                        oldName: this.currentCharacterName,
                        newName: newCharacterName,
                    });

                    // Update character tracking
                    this.currentCharacterId = newCharacterId;
                    this.currentCharacterName = newCharacterName;

                    // Clear old character data
                    this.characterData = null;
                    this.characterSkills = null;
                    this.characterItems = null;
                    this.characterActions = [];
                    this.characterQuests = [];
                    this.characterEquipment.clear();
                    this.characterHouseRooms.clear();
                    this.actionTypeDrinkSlotsMap.clear();
                    this.battleData = null;

                    // Reset switching flag (cleanup complete, ready for re-init)
                    this.isCharacterSwitching = false;

                    // Emit character_switched event (ready for re-init)
                    this.emit('character_switched', {
                        newId: newCharacterId,
                        newName: newCharacterName,
                    });
                } else if (!this.currentCharacterId) {
                    // First load - set character tracking
                    this.currentCharacterId = newCharacterId;
                    this.currentCharacterName = newCharacterName;
                }

                // Process new character data normally
                this.characterData = data;
                this.characterSkills = data.characterSkills;
                this.characterItems = data.characterItems;
                this.characterActions = [...data.characterActions];
                this.characterQuests = data.characterQuests || [];

                // Build equipment map
                this.updateEquipmentMap(data.characterItems);

                // Build house room map
                this.updateHouseRoomMap(data.characterHouseRoomMap);

                // Build drink slots map (tea buffs)
                this.updateDrinkSlotsMap(data.actionTypeDrinkSlotsMap);

                // Clear switching flag
                this.isCharacterSwitching = false;

                // Emit character_initialized event (trigger feature initialization)
                // Include flag to indicate if this is a character switch vs first load
                // IMPORTANT: Mutate data object instead of spreading to avoid copying MB of data
                data._isCharacterSwitch = isCharacterSwitch;
                this.emit('character_initialized', data);
                connectionState.handleCharacterInitialized(data);
            });

            // Handle actions_updated (action queue changes)
            this.webSocketHook.on('actions_updated', (data) => {
                // Update action list
                for (const action of data.endCharacterActions) {
                    if (action.isDone === false) {
                        this.characterActions.push(action);
                    } else {
                        this.characterActions = this.characterActions.filter((a) => a.id !== action.id);
                    }
                }

                this.emit('actions_updated', data);
            });

            // Handle action_completed (action progress)
            this.webSocketHook.on('action_completed', (data) => {
                const action = data.endCharacterAction;
                if (action.isDone === false) {
                    for (const a of this.characterActions) {
                        if (a.id === action.id) {
                            a.currentCount = action.currentCount;
                        }
                    }
                }

                // CRITICAL: Update inventory from action_completed (this is how inventory updates during gathering!)
                if (data.endCharacterItems && Array.isArray(data.endCharacterItems)) {
                    for (const endItem of data.endCharacterItems) {
                        // Only update inventory items
                        if (endItem.itemLocationHrid !== '/item_locations/inventory') {
                            continue;
                        }

                        // Find and update the item in inventory
                        const index = this.characterItems.findIndex((invItem) => invItem.id === endItem.id);
                        if (index !== -1) {
                            // Update existing item
                            this.characterItems[index].count = endItem.count;
                        } else {
                            // Add new item to inventory
                            this.characterItems.push(endItem);
                        }
                    }
                }

                // CRITICAL: Update skill experience from action_completed (this is how XP updates in real-time!)
                if (data.endCharacterSkills && Array.isArray(data.endCharacterSkills) && this.characterSkills) {
                    for (const updatedSkill of data.endCharacterSkills) {
                        const skill = this.characterSkills.find((s) => s.skillHrid === updatedSkill.skillHrid);
                        if (skill) {
                            // Update experience (and level if it changed)
                            skill.experience = updatedSkill.experience;
                            if (updatedSkill.level !== undefined) {
                                skill.level = updatedSkill.level;
                            }
                        }
                    }
                }

                this.emit('action_completed', data);
            });

            // Handle items_updated (inventory/equipment changes)
            this.webSocketHook.on('items_updated', (data) => {
                if (data.endCharacterItems) {
                    // Update inventory items in-place (endCharacterItems contains only changed items, not full inventory)
                    for (const item of data.endCharacterItems) {
                        if (item.itemLocationHrid !== '/item_locations/inventory') {
                            // Equipment items handled by updateEquipmentMap
                            continue;
                        }

                        // Update or add inventory item
                        const index = this.characterItems.findIndex((invItem) => invItem.id === item.id);
                        if (index !== -1) {
                            // Update existing item count
                            this.characterItems[index].count = item.count;
                        } else {
                            // Add new item to inventory
                            this.characterItems.push(item);
                        }
                    }

                    this.updateEquipmentMap(data.endCharacterItems);
                }

                this.emit('items_updated', data);
            });

            // Handle market_listings_updated (market order changes)
            this.webSocketHook.on('market_listings_updated', (data) => {
                if (!this.characterData || !Array.isArray(data?.endMarketListings)) {
                    return;
                }

                const currentListings = Array.isArray(this.characterData.myMarketListings)
                    ? this.characterData.myMarketListings
                    : [];
                const updatedListings = mergeMarketListings(currentListings, data.endMarketListings);

                this.characterData = {
                    ...this.characterData,
                    myMarketListings: updatedListings,
                };

                this.emit('market_listings_updated', {
                    ...data,
                    myMarketListings: updatedListings,
                });
            });

            // Handle market_item_order_books_updated (order book updates)
            this.webSocketHook.on('market_item_order_books_updated', (data) => {
                this.emit('market_item_order_books_updated', data);
            });

            // Handle action_type_consumable_slots_updated (when user changes tea assignments)
            this.webSocketHook.on('action_type_consumable_slots_updated', (data) => {
                // Update drink slots map with new consumables
                if (data.actionTypeDrinkSlotsMap) {
                    this.updateDrinkSlotsMap(data.actionTypeDrinkSlotsMap);
                }

                this.emit('consumables_updated', data);
            });

            // Handle consumable_buffs_updated (when buffs expire/refresh)
            this.webSocketHook.on('consumable_buffs_updated', (data) => {
                // Buffs updated - next hover will show updated values
                this.emit('buffs_updated', data);
            });

            // Handle house_rooms_updated (when user upgrades house rooms)
            this.webSocketHook.on('house_rooms_updated', (data) => {
                // Update house room map with new levels
                if (data.characterHouseRoomMap) {
                    this.updateHouseRoomMap(data.characterHouseRoomMap);
                }

                this.emit('house_rooms_updated', data);
            });

            // Handle skills_updated (when user gains skill levels)
            this.webSocketHook.on('skills_updated', (data) => {
                // Update character skills with new levels
                if (data.characterSkills) {
                    this.characterSkills = data.characterSkills;
                }

                this.emit('skills_updated', data);
            });

            // Handle new_battle (combat start - for Combat Sim export on Steam)
            this.webSocketHook.on('new_battle', (data) => {
                // Store battle data (includes party consumables)
                this.battleData = data;
            });
        }

        /**
         * Update equipment map from character items
         * @param {Array} items - Character items array
         */
        updateEquipmentMap(items) {
            for (const item of items) {
                if (item.itemLocationHrid !== '/item_locations/inventory') {
                    if (item.count === 0) {
                        this.characterEquipment.delete(item.itemLocationHrid);
                    } else {
                        this.characterEquipment.set(item.itemLocationHrid, item);
                    }
                }
            }
        }

        /**
         * Update house room map from character house room data
         * @param {Object} houseRoomMap - Character house room map
         */
        updateHouseRoomMap(houseRoomMap) {
            if (!houseRoomMap) {
                return;
            }

            this.characterHouseRooms.clear();
            for (const [_hrid, room] of Object.entries(houseRoomMap)) {
                this.characterHouseRooms.set(room.houseRoomHrid, room);
            }
        }

        /**
         * Update drink slots map from character data
         * @param {Object} drinkSlotsMap - Action type drink slots map
         */
        updateDrinkSlotsMap(drinkSlotsMap) {
            if (!drinkSlotsMap) {
                return;
            }

            this.actionTypeDrinkSlotsMap.clear();
            for (const [actionTypeHrid, drinks] of Object.entries(drinkSlotsMap)) {
                this.actionTypeDrinkSlotsMap.set(actionTypeHrid, drinks || []);
            }
        }

        /**
         * Get static game data
         * @returns {Object} Init client data (items, actions, monsters, etc.)
         */
        getInitClientData() {
            return this.initClientData;
        }

        /**
         * Get combined game data (static + character)
         * Used for features that need both static data and player data
         * @returns {Object} Combined data object
         */
        getCombinedData() {
            if (!this.initClientData) {
                return null;
            }

            return {
                ...this.initClientData,
                // Character-specific data
                characterItems: this.characterItems || [],
                myMarketListings: this.characterData?.myMarketListings || [],
                characterHouseRoomMap: Object.fromEntries(this.characterHouseRooms),
                characterAbilities: this.characterData?.characterAbilities || [],
                abilityCombatTriggersMap: this.characterData?.abilityCombatTriggersMap || {},
            };
        }

        /**
         * Get item details by HRID
         * @param {string} itemHrid - Item HRID (e.g., "/items/cheese")
         * @returns {Object|null} Item details
         */
        getItemDetails(itemHrid) {
            return this.initClientData?.itemDetailMap?.[itemHrid] || null;
        }

        /**
         * Get action details by HRID
         * @param {string} actionHrid - Action HRID (e.g., "/actions/milking/cow")
         * @returns {Object|null} Action details
         */
        getActionDetails(actionHrid) {
            return this.initClientData?.actionDetailMap?.[actionHrid] || null;
        }

        /**
         * Get player's current actions
         * @returns {Array} Current action queue
         */
        getCurrentActions() {
            return [...this.characterActions];
        }

        /**
         * Get player's equipped items
         * @returns {Map} Equipment map (slot HRID -> item)
         */
        getEquipment() {
            return new Map(this.characterEquipment);
        }

        /**
         * Get player's house rooms
         * @returns {Map} House room map (room HRID -> {houseRoomHrid, level})
         */
        getHouseRooms() {
            return new Map(this.characterHouseRooms);
        }

        /**
         * Get house room level
         * @param {string} houseRoomHrid - House room HRID (e.g., "/house_rooms/brewery")
         * @returns {number} Room level (0 if not found)
         */
        getHouseRoomLevel(houseRoomHrid) {
            const room = this.characterHouseRooms.get(houseRoomHrid);
            return room?.level || 0;
        }

        /**
         * Get active drink items for an action type
         * @param {string} actionTypeHrid - Action type HRID (e.g., "/action_types/brewing")
         * @returns {Array} Array of drink items (empty if none)
         */
        getActionDrinkSlots(actionTypeHrid) {
            return this.actionTypeDrinkSlotsMap.get(actionTypeHrid) || [];
        }

        /**
         * Get current character ID
         * @returns {string|null} Character ID or null
         */
        getCurrentCharacterId() {
            return this.currentCharacterId;
        }

        /**
         * Get current character name
         * @returns {string|null} Character name or null
         */
        getCurrentCharacterName() {
            return this.currentCharacterName;
        }

        /**
         * Check if character is currently switching
         * @returns {boolean} True if switching
         */
        getIsCharacterSwitching() {
            return this.isCharacterSwitching;
        }

        /**
         * Get community buff level
         * @param {string} buffTypeHrid - Buff type HRID (e.g., "/community_buff_types/production_efficiency")
         * @returns {number} Buff level (0 if not active)
         */
        getCommunityBuffLevel(buffTypeHrid) {
            if (!this.characterData?.communityBuffs) {
                return 0;
            }

            const buff = this.characterData.communityBuffs.find((b) => b.hrid === buffTypeHrid);
            return buff?.level || 0;
        }

        /**
         * Get achievement buffs for an action type
         * Achievement buffs are provided by the game based on completed achievement tiers
         * @param {string} actionTypeHrid - Action type HRID (e.g., "/action_types/foraging")
         * @returns {Object} Buff object with stat bonuses (e.g., {gatheringQuantity: 0.02}) or empty object
         */
        getAchievementBuffs(actionTypeHrid) {
            if (!this.characterData?.achievementActionTypeBuffsMap) {
                return {};
            }

            return this.characterData.achievementActionTypeBuffsMap[actionTypeHrid] || {};
        }

        /**
         * Get achievement buff flat boost for an action type and buff type
         * @param {string} actionTypeHrid - Action type HRID (e.g., "/action_types/foraging")
         * @param {string} buffTypeHrid - Buff type HRID (e.g., "/buff_types/wisdom")
         * @returns {number} Flat boost value (decimal) or 0 if not found
         */
        getAchievementBuffFlatBoost(actionTypeHrid, buffTypeHrid) {
            const achievementMap = this.characterData?.achievementActionTypeBuffsMap;
            if (!achievementMap) {
                return 0;
            }

            if (this.achievementBuffCache.source !== achievementMap) {
                this.achievementBuffCache = {
                    source: achievementMap,
                    byActionType: new Map(),
                };
            }

            const actionCache = this.achievementBuffCache.byActionType.get(actionTypeHrid) || new Map();
            if (actionCache.has(buffTypeHrid)) {
                return actionCache.get(buffTypeHrid);
            }

            const achievementBuffs = achievementMap[actionTypeHrid];
            if (!Array.isArray(achievementBuffs)) {
                actionCache.set(buffTypeHrid, 0);
                this.achievementBuffCache.byActionType.set(actionTypeHrid, actionCache);
                return 0;
            }

            const buff = achievementBuffs.find((entry) => entry?.typeHrid === buffTypeHrid);
            const flatBoost = buff?.flatBoost || 0;
            actionCache.set(buffTypeHrid, flatBoost);
            this.achievementBuffCache.byActionType.set(actionTypeHrid, actionCache);
            return flatBoost;
        }

        /**
         * Get player's skills
         * @returns {Array|null} Character skills
         */
        getSkills() {
            return this.characterSkills ? [...this.characterSkills] : null;
        }

        /**
         * Get player's inventory
         * @returns {Array|null} Character items
         */
        getInventory() {
            return this.characterItems ? [...this.characterItems] : null;
        }

        /**
         * Get player's market listings
         * @returns {Array} Market listings array
         */
        getMarketListings() {
            return this.characterData?.myMarketListings ? [...this.characterData.myMarketListings] : [];
        }

        /**
         * Get active task action HRIDs
         * @returns {Array<string>} Array of action HRIDs that are currently active tasks
         */
        getActiveTaskActionHrids() {
            if (!this.characterQuests || this.characterQuests.length === 0) {
                return [];
            }

            return this.characterQuests
                .filter(
                    (quest) =>
                        quest.category === '/quest_category/random_task' &&
                        quest.status === '/quest_status/in_progress' &&
                        quest.actionHrid
                )
                .map((quest) => quest.actionHrid);
        }

        /**
         * Check if an action is currently an active task
         * @param {string} actionHrid - Action HRID to check
         * @returns {boolean} True if action is an active task
         */
        isTaskAction(actionHrid) {
            const activeTasks = this.getActiveTaskActionHrids();
            return activeTasks.includes(actionHrid);
        }

        /**
         * Get task speed bonus from equipped task badges
         * @returns {number} Task speed percentage (e.g., 15 for 15%)
         */
        getTaskSpeedBonus() {
            if (!this.characterEquipment || !this.initClientData) {
                return 0;
            }

            let totalTaskSpeed = 0;

            // Task badges are in trinket slot
            const trinketLocation = '/item_locations/trinket';
            const equippedItem = this.characterEquipment.get(trinketLocation);

            if (!equippedItem || !equippedItem.itemHrid) {
                return 0;
            }

            const itemDetail = this.initClientData.itemDetailMap[equippedItem.itemHrid];
            if (!itemDetail || !itemDetail.equipmentDetail) {
                return 0;
            }

            const taskSpeed = itemDetail.equipmentDetail.noncombatStats?.taskSpeed || 0;
            if (taskSpeed === 0) {
                return 0;
            }

            // Calculate enhancement bonus
            // Note: noncombatEnhancementBonuses already includes slot multiplier (5× for trinket)
            const enhancementLevel = equippedItem.enhancementLevel || 0;
            const enhancementBonus = itemDetail.equipmentDetail.noncombatEnhancementBonuses?.taskSpeed || 0;
            const totalEnhancementBonus = enhancementBonus * enhancementLevel;

            // Total taskSpeed = base + enhancement
            totalTaskSpeed = (taskSpeed + totalEnhancementBonus) * 100; // Convert to percentage

            return totalTaskSpeed;
        }

        /**
         * Build monster-to-sortIndex mapping from combat zone data
         * Used for sorting combat tasks by zone progression order
         * @private
         */
        buildMonsterSortIndexMap() {
            if (!this.initClientData || !this.initClientData.actionDetailMap) {
                return;
            }

            this.monsterSortIndexMap.clear();

            // Extract combat zones (non-dungeon only)
            for (const [_zoneHrid, action] of Object.entries(this.initClientData.actionDetailMap)) {
                // Skip non-combat actions and dungeons
                if (action.type !== '/action_types/combat' || action.combatZoneInfo?.isDungeon) {
                    continue;
                }

                const sortIndex = action.sortIndex;

                // Get regular spawn monsters
                const regularMonsters = action.combatZoneInfo?.fightInfo?.randomSpawnInfo?.spawns || [];

                // Get boss monsters (every 10 battles)
                const bossMonsters = action.combatZoneInfo?.fightInfo?.bossSpawns || [];

                // Combine all monsters from this zone
                const allMonsters = [...regularMonsters, ...bossMonsters];

                // Map each monster to this zone's sortIndex
                for (const spawn of allMonsters) {
                    const monsterHrid = spawn.combatMonsterHrid;
                    if (!monsterHrid) continue;

                    // If monster appears in multiple zones, use earliest zone (lowest sortIndex)
                    if (
                        !this.monsterSortIndexMap.has(monsterHrid) ||
                        sortIndex < this.monsterSortIndexMap.get(monsterHrid)
                    ) {
                        this.monsterSortIndexMap.set(monsterHrid, sortIndex);
                    }
                }
            }
        }

        /**
         * Get zone sortIndex for a monster (for task sorting)
         * @param {string} monsterHrid - Monster HRID (e.g., "/monsters/rat")
         * @returns {number} Zone sortIndex (999 if not found)
         */
        getMonsterSortIndex(monsterHrid) {
            return this.monsterSortIndexMap.get(monsterHrid) || 999;
        }

        /**
         * Get monster HRID from display name (for task sorting)
         * @param {string} monsterName - Monster display name (e.g., "Jerry")
         * @returns {string|null} Monster HRID or null if not found
         */
        getMonsterHridFromName(monsterName) {
            if (!this.initClientData || !this.initClientData.combatMonsterDetailMap) {
                return null;
            }

            // Search for monster by display name
            for (const [hrid, monster] of Object.entries(this.initClientData.combatMonsterDetailMap)) {
                if (monster.name === monsterName) {
                    return hrid;
                }
            }

            return null;
        }

        /**
         * Register event listener
         * @param {string} event - Event name
         * @param {Function} callback - Handler function
         */
        on(event, callback) {
            if (!this.eventListeners.has(event)) {
                this.eventListeners.set(event, []);
            }
            this.eventListeners.get(event).push(callback);
        }

        /**
         * Unregister event listener
         * @param {string} event - Event name
         * @param {Function} callback - Handler function to remove
         */
        off(event, callback) {
            const listeners = this.eventListeners.get(event);
            if (listeners) {
                const index = listeners.indexOf(callback);
                if (index > -1) {
                    listeners.splice(index, 1);
                }
            }
        }

        /**
         * Emit event to all listeners
         * Only character_switching is critical (must run immediately for proper cleanup)
         * All other events including character_switched and character_initialized are deferred
         * @param {string} event - Event name
         * @param {*} data - Event data
         */
        emit(event, data) {
            const listeners = this.eventListeners.get(event) || [];

            // Only character_switching must run immediately (cleanup phase)
            // character_switched can be deferred - it just schedules re-init anyway
            const isCritical = event === 'character_switching';

            if (isCritical) {
                // Run immediately on main thread
                for (const listener of listeners) {
                    try {
                        listener(data);
                    } catch (error) {
                        console.error(`[Data Manager] Error in ${event} listener:`, error);
                    }
                }
            } else {
                // Defer all other events to prevent main thread blocking
                setTimeout(() => {
                    for (const listener of listeners) {
                        try {
                            listener(data);
                        } catch (error) {
                            console.error(`[Data Manager] Error in ${event} listener:`, error);
                        }
                    }
                }, 0);
            }
        }
    }

    const dataManager$1 = new DataManager();

    /**
     * Configuration Module
     * Manages all script constants and user settings
     */


    /**
     * Config class manages all script configuration
     * - Constants (colors, URLs, formatters)
     * - User settings with persistence
     */
    class Config {
        constructor() {
            // Number formatting separators (locale-aware)
            this.THOUSAND_SEPARATOR = new Intl.NumberFormat().format(1111).replaceAll('1', '').at(0) || '';
            this.DECIMAL_SEPARATOR = new Intl.NumberFormat().format(1.1).replaceAll('1', '').at(0);

            // Extended color palette (configurable)
            // Dark background colors (for UI elements on dark backgrounds)
            this.COLOR_PROFIT = '#047857'; // Emerald green for positive values
            this.COLOR_LOSS = '#f87171'; // Red for negative values
            this.COLOR_WARNING = '#ffa500'; // Orange for warnings
            this.COLOR_INFO = '#60a5fa'; // Blue for informational
            this.COLOR_ESSENCE = '#c084fc'; // Purple for essences

            // Tooltip colors (for text on light/tooltip backgrounds)
            this.COLOR_TOOLTIP_PROFIT = '#047857'; // Green for tooltips
            this.COLOR_TOOLTIP_LOSS = '#dc2626'; // Darker red for tooltips
            this.COLOR_TOOLTIP_INFO = '#2563eb'; // Darker blue for tooltips
            this.COLOR_TOOLTIP_WARNING = '#ea580c'; // Darker orange for tooltips

            // General colors
            this.COLOR_TEXT_PRIMARY = '#ffffff'; // Primary text color
            this.COLOR_TEXT_SECONDARY = '#888888'; // Secondary text color
            this.COLOR_BORDER = '#444444'; // Border color
            this.COLOR_GOLD = '#ffa500'; // Gold/currency color
            this.COLOR_ACCENT = '#22c55e'; // Script accent color (green)
            this.COLOR_REMAINING_XP = '#FFFFFF'; // Remaining XP text color

            // Legacy color constants (mapped to COLOR_ACCENT)
            this.SCRIPT_COLOR_MAIN = this.COLOR_ACCENT;
            this.SCRIPT_COLOR_TOOLTIP = this.COLOR_ACCENT;
            this.SCRIPT_COLOR_ALERT = 'red';

            // Market API URL
            this.MARKET_API_URL = 'https://www.milkywayidle.com/game_data/marketplace.json';

            // Settings loaded from settings-schema via settings-storage.js
            this.settingsMap = {};

            // Map of setting keys to callback functions
            this.settingChangeCallbacks = {};

            // Feature toggles with metadata for future UI
            this.features = {
                // Market Features
                tooltipPrices: {
                    enabled: true,
                    name: 'Market Prices in Tooltips',
                    category: 'Market',
                    description: 'Shows bid/ask prices in item tooltips',
                    settingKey: 'itemTooltip_prices',
                },
                tooltipProfit: {
                    enabled: true,
                    name: 'Profit Calculator in Tooltips',
                    category: 'Market',
                    description: 'Shows production cost and profit in tooltips',
                    settingKey: 'itemTooltip_profit',
                },
                tooltipConsumables: {
                    enabled: true,
                    name: 'Consumable Effects in Tooltips',
                    category: 'Market',
                    description: 'Shows buff effects and durations for food/drinks',
                    settingKey: 'showConsumTips',
                },
                expectedValueCalculator: {
                    enabled: true,
                    name: 'Expected Value Calculator',
                    category: 'Market',
                    description: 'Shows EV for openable containers (crates, chests)',
                    settingKey: 'itemTooltip_expectedValue',
                },
                market_showListingPrices: {
                    enabled: true,
                    name: 'Market Listing Price Display',
                    category: 'Market',
                    description: 'Shows top order price, total value, and listing age on My Listings',
                    settingKey: 'market_showListingPrices',
                },
                market_showEstimatedListingAge: {
                    enabled: true,
                    name: 'Estimated Listing Age',
                    category: 'Market',
                    description: 'Estimates creation time for all market listings using listing ID interpolation',
                    settingKey: 'market_showEstimatedListingAge',
                },
                market_showOrderTotals: {
                    enabled: true,
                    name: 'Market Order Totals',
                    category: 'Market',
                    description: 'Shows buy orders, sell orders, and unclaimed coins in header',
                    settingKey: 'market_showOrderTotals',
                },
                market_showHistoryViewer: {
                    enabled: true,
                    name: 'Market History Viewer',
                    category: 'Market',
                    description: 'View and export all market listing history',
                    settingKey: 'market_showHistoryViewer',
                },
                market_showPhiloCalculator: {
                    enabled: true,
                    name: 'Philo Gamba Calculator',
                    category: 'Market',
                    description: "Calculate expected value of transmuting items into Philosopher's Stones",
                    settingKey: 'market_showPhiloCalculator',
                },

                // Action Features
                actionTimeDisplay: {
                    enabled: true,
                    name: 'Action Queue Time Display',
                    category: 'Actions',
                    description: 'Shows total time and completion time for queued actions',
                    settingKey: 'totalActionTime',
                },
                quickInputButtons: {
                    enabled: true,
                    name: 'Quick Input Buttons',
                    category: 'Actions',
                    description: 'Adds 1/10/100/1000 buttons to action inputs',
                    settingKey: 'actionPanel_totalTime_quickInputs',
                },
                actionPanelProfit: {
                    enabled: true,
                    name: 'Action Profit Display',
                    category: 'Actions',
                    description: 'Shows profit/loss for gathering and production',
                    settingKey: 'actionPanel_foragingTotal',
                },
                requiredMaterials: {
                    enabled: true,
                    name: 'Required Materials Display',
                    category: 'Actions',
                    description: 'Shows total required and missing materials for production actions',
                    settingKey: 'requiredMaterials',
                },

                // Combat Features
                abilityBookCalculator: {
                    enabled: true,
                    name: 'Ability Book Requirements',
                    category: 'Combat',
                    description: 'Shows books needed to reach target level',
                    settingKey: 'skillbook',
                },
                zoneIndices: {
                    enabled: true,
                    name: 'Combat Zone Indices',
                    category: 'Combat',
                    description: 'Shows zone numbers in combat location list',
                    settingKey: 'mapIndex',
                },
                taskZoneIndices: {
                    enabled: true,
                    name: 'Task Zone Indices',
                    category: 'Tasks',
                    description: 'Shows zone numbers on combat tasks',
                    settingKey: 'taskMapIndex',
                },
                combatScore: {
                    enabled: true,
                    name: 'Profile Gear Score',
                    category: 'Combat',
                    description: 'Shows gear score on profile',
                    settingKey: 'combatScore',
                },
                dungeonTracker: {
                    enabled: true,
                    name: 'Dungeon Tracker',
                    category: 'Combat',
                    description:
                        'Real-time dungeon progress tracking in top bar with wave times, statistics, and party chat completion messages',
                    settingKey: 'dungeonTracker',
                },
                combatSimIntegration: {
                    enabled: true,
                    name: 'Combat Simulator Integration',
                    category: 'Combat',
                    description: 'Auto-import character/party data into Shykai Combat Simulator',
                    settingKey: null, // New feature, no legacy setting
                },
                enhancementSimulator: {
                    enabled: true,
                    name: 'Enhancement Simulator',
                    category: 'Market',
                    description: 'Shows enhancement cost calculations in item tooltips',
                    settingKey: 'enhanceSim',
                },

                // UI Features
                equipmentLevelDisplay: {
                    enabled: true,
                    name: 'Equipment Level on Icons',
                    category: 'UI',
                    description: 'Shows item level number on equipment icons',
                    settingKey: 'itemIconLevel',
                },
                alchemyItemDimming: {
                    enabled: true,
                    name: 'Alchemy Item Dimming',
                    category: 'UI',
                    description: 'Dims items requiring higher Alchemy level',
                    settingKey: 'alchemyItemDimming',
                },
                skillExperiencePercentage: {
                    enabled: true,
                    name: 'Skill Experience Percentage',
                    category: 'UI',
                    description: 'Shows XP progress percentage in left sidebar',
                    settingKey: 'expPercentage',
                },
                largeNumberFormatting: {
                    enabled: true,
                    name: 'Use K/M/B Number Formatting',
                    category: 'UI',
                    description: 'Display large numbers as 1.5M instead of 1,500,000',
                    settingKey: 'formatting_useKMBFormat',
                },

                // Task Features
                taskProfitDisplay: {
                    enabled: true,
                    name: 'Task Profit Calculator',
                    category: 'Tasks',
                    description: 'Shows expected profit from task rewards',
                    settingKey: 'taskProfitCalculator',
                },
                taskEfficiencyRating: {
                    enabled: true,
                    name: 'Task Efficiency Rating',
                    category: 'Tasks',
                    description: 'Shows tokens or profit per hour on task cards',
                    settingKey: 'taskEfficiencyRating',
                },
                taskRerollTracker: {
                    enabled: true,
                    name: 'Task Reroll Tracker',
                    category: 'Tasks',
                    description: 'Tracks reroll costs and history',
                    settingKey: 'taskRerollTracker',
                },
                taskSorter: {
                    enabled: true,
                    name: 'Task Sorting',
                    category: 'Tasks',
                    description: 'Adds button to sort tasks by skill type',
                    settingKey: 'taskSorter',
                },
                taskIcons: {
                    enabled: true,
                    name: 'Task Icons',
                    category: 'Tasks',
                    description: 'Shows visual icons on task cards',
                    settingKey: 'taskIcons',
                },
                taskIconsDungeons: {
                    enabled: false,
                    name: 'Task Icons - Dungeons',
                    category: 'Tasks',
                    description: 'Shows dungeon icons for combat tasks',
                    settingKey: 'taskIconsDungeons',
                    dependencies: ['taskIcons'],
                },

                // Skills Features
                skillRemainingXP: {
                    enabled: true,
                    name: 'Remaining XP Display',
                    category: 'Skills',
                    description: 'Shows remaining XP to next level on skill bars',
                    settingKey: 'skillRemainingXP',
                },

                // House Features
                houseCostDisplay: {
                    enabled: true,
                    name: 'House Upgrade Costs',
                    category: 'House',
                    description: 'Shows market value of upgrade materials',
                    settingKey: 'houseUpgradeCosts',
                },

                // Economy Features
                networth: {
                    enabled: true,
                    name: 'Net Worth Calculator',
                    category: 'Economy',
                    description: 'Shows total asset value in header (Current Assets)',
                    settingKey: 'networth',
                },
                inventorySummary: {
                    enabled: true,
                    name: 'Inventory Summary Panel',
                    category: 'Economy',
                    description: 'Shows detailed networth breakdown below inventory',
                    settingKey: 'invWorth',
                },
                inventorySort: {
                    enabled: true,
                    name: 'Inventory Sort',
                    category: 'Economy',
                    description: 'Sorts inventory by Ask/Bid price',
                    settingKey: 'invSort',
                },
                inventorySortBadges: {
                    enabled: false,
                    name: 'Inventory Sort Price Badges',
                    category: 'Economy',
                    description: 'Shows stack value badges on items when sorting',
                    settingKey: 'invSort_showBadges',
                },
                inventoryBadgePrices: {
                    enabled: false,
                    name: 'Inventory Price Badges',
                    category: 'Economy',
                    description: 'Shows stack value badges on items (independent of sorting)',
                    settingKey: 'invBadgePrices',
                },

                // Enhancement Features
                enhancementTracker: {
                    enabled: false,
                    name: 'Enhancement Tracker',
                    category: 'Enhancement',
                    description: 'Tracks enhancement attempts, costs, and statistics',
                    settingKey: 'enhancementTracker',
                },

                // Notification Features
                notifiEmptyAction: {
                    enabled: false,
                    name: 'Empty Queue Notification',
                    category: 'Notifications',
                    description: 'Browser notification when action queue becomes empty',
                    settingKey: 'notifiEmptyAction',
                },
            };

            // Note: loadSettings() must be called separately (async)
        }

        /**
         * Initialize config (async) - loads settings from storage
         * @returns {Promise<void>}
         */
        async initialize() {
            await this.loadSettings();
            this.applyColorSettings();
        }

        /**
         * Load settings from storage (async)
         * @returns {Promise<void>}
         */
        async loadSettings() {
            // Set character ID in settings storage for per-character settings
            const characterId = dataManager$1.getCurrentCharacterId();
            if (characterId) {
                settingsStorage.setCharacterId(characterId);
            }

            // Load settings from settings-storage (which uses settings-schema as source of truth)
            this.settingsMap = await settingsStorage.loadSettings();
        }

        /**
         * Clear settings cache (for character switching)
         */
        clearSettingsCache() {
            this.settingsMap = {};
        }

        /**
         * Save settings to storage (immediately)
         */
        saveSettings() {
            settingsStorage.saveSettings(this.settingsMap);
        }

        /**
         * Get a setting value
         * @param {string} key - Setting key
         * @returns {boolean} Setting value
         */
        getSetting(key) {
            // Check loaded settings first
            if (this.settingsMap[key]) {
                return this.settingsMap[key].isTrue ?? false;
            }

            // Fallback: Check settings-schema for default (fixes race condition on load)
            for (const group of Object.values(settingsGroups)) {
                if (group.settings[key]) {
                    return group.settings[key].default ?? false;
                }
            }

            // Ultimate fallback
            return false;
        }

        /**
         * Get a setting value (for non-boolean settings)
         * @param {string} key - Setting key
         * @param {*} defaultValue - Default value if key doesn't exist
         * @returns {*} Setting value
         */
        getSettingValue(key, defaultValue = null) {
            const setting = this.settingsMap[key];
            if (!setting) {
                return defaultValue;
            }
            // Handle both boolean (isTrue) and value-based settings
            if (setting.hasOwnProperty('value')) {
                return setting.value;
            } else if (setting.hasOwnProperty('isTrue')) {
                return setting.isTrue;
            }
            return defaultValue;
        }

        /**
         * Set a setting value (auto-saves)
         * @param {string} key - Setting key
         * @param {boolean} value - Setting value
         */
        setSetting(key, value) {
            if (this.settingsMap[key]) {
                this.settingsMap[key].isTrue = value;
                this.saveSettings();

                // Re-apply colors if color setting changed
                if (key === 'useOrangeAsMainColor') {
                    this.applyColorSettings();
                }

                // Trigger registered callbacks for this setting
                if (this.settingChangeCallbacks[key]) {
                    this.settingChangeCallbacks[key](value);
                }
            }
        }

        /**
         * Set a setting value (for non-boolean settings, auto-saves)
         * @param {string} key - Setting key
         * @param {*} value - Setting value
         */
        setSettingValue(key, value) {
            if (this.settingsMap[key]) {
                this.settingsMap[key].value = value;
                this.saveSettings();

                // Re-apply color settings if this is a color setting
                if (key.startsWith('color_')) {
                    this.applyColorSettings();
                }

                // Trigger registered callbacks for this setting
                if (this.settingChangeCallbacks[key]) {
                    this.settingChangeCallbacks[key](value);
                }
            }
        }

        /**
         * Register a callback to be called when a specific setting changes
         * @param {string} key - Setting key to watch
         * @param {Function} callback - Callback function to call when setting changes
         */
        onSettingChange(key, callback) {
            this.settingChangeCallbacks[key] = callback;
        }

        /**
         * Unregister a callback for a specific setting change
         * @param {string} key - Setting key to stop watching
         * @param {Function} _callback - Callback function to remove (unused, kept for API consistency)
         */
        offSettingChange(key, _callback) {
            delete this.settingChangeCallbacks[key];
        }

        /**
         * Toggle a setting (auto-saves)
         * @param {string} key - Setting key
         * @returns {boolean} New value
         */
        toggleSetting(key) {
            const newValue = !this.getSetting(key);
            this.setSetting(key, newValue);
            return newValue;
        }

        /**
         * Get all settings as an array (useful for UI)
         * @returns {Array} Array of setting objects
         */
        getAllSettings() {
            return Object.values(this.settingsMap);
        }

        /**
         * Reset all settings to defaults
         */
        resetToDefaults() {
            // Find default values from constructor (all true except notifiEmptyAction)
            for (const key in this.settingsMap) {
                this.settingsMap[key].isTrue = key !== 'notifiEmptyAction';
            }

            this.saveSettings();
            this.applyColorSettings();
        }

        /**
         * Sync current settings to all other characters
         * @returns {Promise<{success: boolean, count: number, error?: string}>} Result object
         */
        async syncSettingsToAllCharacters() {
            try {
                // Ensure character ID is set
                const characterId = dataManager$1.getCurrentCharacterId();
                if (!characterId) {
                    return {
                        success: false,
                        count: 0,
                        error: 'No character ID available',
                    };
                }

                // Set character ID in settings storage
                settingsStorage.setCharacterId(characterId);

                // Sync settings to all other characters
                const syncedCount = await settingsStorage.syncSettingsToAllCharacters(this.settingsMap);

                return {
                    success: true,
                    count: syncedCount,
                };
            } catch (error) {
                console.error('[Config] Failed to sync settings:', error);
                return {
                    success: false,
                    count: 0,
                    error: error.message,
                };
            }
        }

        /**
         * Get number of known characters (including current)
         * @returns {Promise<number>} Number of characters
         */
        async getKnownCharacterCount() {
            try {
                const knownCharacters = await settingsStorage.getKnownCharacters();
                return knownCharacters.length;
            } catch (error) {
                console.error('[Config] Failed to get character count:', error);
                return 0;
            }
        }

        /**
         * Apply color settings to color constants
         */
        applyColorSettings() {
            // Apply extended color palette from settings
            this.COLOR_PROFIT = this.getSettingValue('color_profit', '#047857');
            this.COLOR_LOSS = this.getSettingValue('color_loss', '#f87171');
            this.COLOR_WARNING = this.getSettingValue('color_warning', '#ffa500');
            this.COLOR_INFO = this.getSettingValue('color_info', '#60a5fa');
            this.COLOR_ESSENCE = this.getSettingValue('color_essence', '#c084fc');
            this.COLOR_TOOLTIP_PROFIT = this.getSettingValue('color_tooltip_profit', '#047857');
            this.COLOR_TOOLTIP_LOSS = this.getSettingValue('color_tooltip_loss', '#dc2626');
            this.COLOR_TOOLTIP_INFO = this.getSettingValue('color_tooltip_info', '#2563eb');
            this.COLOR_TOOLTIP_WARNING = this.getSettingValue('color_tooltip_warning', '#ea580c');
            this.COLOR_TEXT_PRIMARY = this.getSettingValue('color_text_primary', '#ffffff');
            this.COLOR_TEXT_SECONDARY = this.getSettingValue('color_text_secondary', '#888888');
            this.COLOR_BORDER = this.getSettingValue('color_border', '#444444');
            this.COLOR_GOLD = this.getSettingValue('color_gold', '#ffa500');
            this.COLOR_ACCENT = this.getSettingValue('color_accent', '#22c55e');
            this.COLOR_REMAINING_XP = this.getSettingValue('color_remaining_xp', '#FFFFFF');
            this.COLOR_INVBADGE_ASK = this.getSettingValue('color_invBadge_ask', '#047857');
            this.COLOR_INVBADGE_BID = this.getSettingValue('color_invBadge_bid', '#60a5fa');
            this.COLOR_TRANSMUTE = this.getSettingValue('color_transmute', '#ffffff');

            // Set legacy SCRIPT_COLOR_MAIN to accent color
            this.SCRIPT_COLOR_MAIN = this.COLOR_ACCENT;
            this.SCRIPT_COLOR_TOOLTIP = this.COLOR_ACCENT; // Keep tooltip same as main
        }

        /**
         * Check if a feature is enabled
         * Uses legacy settingKey if available, otherwise uses feature.enabled
         * @param {string} featureKey - Feature key (e.g., 'tooltipPrices')
         * @returns {boolean} Whether feature is enabled
         */
        isFeatureEnabled(featureKey) {
            const feature = this.features?.[featureKey];
            if (!feature) {
                return true; // Default to enabled if not found
            }

            // Check legacy setting first (for backward compatibility)
            if (feature.settingKey && this.settingsMap[feature.settingKey]) {
                return this.settingsMap[feature.settingKey].isTrue ?? true;
            }

            // Otherwise use feature.enabled
            return feature.enabled ?? true;
        }

        /**
         * Enable or disable a feature
         * @param {string} featureKey - Feature key
         * @param {boolean} enabled - Enable state
         */
        async setFeatureEnabled(featureKey, enabled) {
            const feature = this.features?.[featureKey];
            if (!feature) {
                console.warn(`Feature '${featureKey}' not found`);
                return;
            }

            // Update legacy setting if it exists
            if (feature.settingKey && this.settingsMap[feature.settingKey]) {
                this.settingsMap[feature.settingKey].isTrue = enabled;
            }

            // Update feature registry
            feature.enabled = enabled;

            await this.saveSettings();
        }

        /**
         * Toggle a feature
         * @param {string} featureKey - Feature key
         * @returns {boolean} New enabled state
         */
        async toggleFeature(featureKey) {
            const current = this.isFeatureEnabled(featureKey);
            await this.setFeatureEnabled(featureKey, !current);
            return !current;
        }

        /**
         * Get all features grouped by category
         * @returns {Object} Features grouped by category
         */
        getFeaturesByCategory() {
            const grouped = {};

            for (const [key, feature] of Object.entries(this.features)) {
                const category = feature.category || 'Other';
                if (!grouped[category]) {
                    grouped[category] = [];
                }
                grouped[category].push({
                    key,
                    name: feature.name,
                    description: feature.description,
                    enabled: this.isFeatureEnabled(key),
                });
            }

            return grouped;
        }

        /**
         * Get all feature keys
         * @returns {string[]} Array of feature keys
         */
        getFeatureKeys() {
            return Object.keys(this.features || {});
        }

        /**
         * Get feature info
         * @param {string} featureKey - Feature key
         * @returns {Object|null} Feature info with current enabled state
         */
        getFeatureInfo(featureKey) {
            const feature = this.features?.[featureKey];
            if (!feature) {
                return null;
            }

            return {
                key: featureKey,
                name: feature.name,
                category: feature.category,
                description: feature.description,
                enabled: this.isFeatureEnabled(featureKey),
            };
        }
    }

    const config$1 = new Config();

    /**
     * Centralized DOM Observer
     * Single MutationObserver that dispatches to registered handlers
     * Replaces 15 separate observers watching document.body
     * Supports optional debouncing to reduce CPU usage during bulk DOM changes
     */

    class DOMObserver {
        constructor() {
            this.observer = null;
            this.handlers = [];
            this.isObserving = false;
            this.debounceTimers = new Map(); // Track debounce timers per handler
            this.debouncedElements = new Map(); // Track pending elements per handler
            this.DEFAULT_DEBOUNCE_DELAY = 50; // 50ms default delay
        }

        /**
         * Start observing DOM changes
         */
        start() {
            if (this.isObserving) return;

            // Wait for document.body to exist (critical for @run-at document-start)
            const startObserver = () => {
                if (!document.body) {
                    // Body doesn't exist yet, wait and try again
                    setTimeout(startObserver, 10);
                    return;
                }

                this.observer = new MutationObserver((mutations) => {
                    for (const mutation of mutations) {
                        for (const node of mutation.addedNodes) {
                            if (node.nodeType !== Node.ELEMENT_NODE) continue;

                            // Dispatch to all registered handlers
                            this.handlers.forEach((handler) => {
                                try {
                                    if (handler.debounce) {
                                        this.debouncedCallback(handler, node, mutation);
                                    } else {
                                        handler.callback(node, mutation);
                                    }
                                } catch (error) {
                                    console.error(`[DOM Observer] Handler error (${handler.name}):`, error);
                                }
                            });
                        }
                    }
                });

                this.observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                });

                this.isObserving = true;
            };

            startObserver();
        }

        /**
         * Debounced callback handler
         * Collects elements and fires callback after delay
         * @private
         */
        debouncedCallback(handler, node, mutation) {
            const handlerName = handler.name;
            const delay = handler.debounceDelay || this.DEFAULT_DEBOUNCE_DELAY;

            // Store element for batched processing
            if (!this.debouncedElements.has(handlerName)) {
                this.debouncedElements.set(handlerName, []);
            }
            this.debouncedElements.get(handlerName).push({ node, mutation });

            // Clear existing timer
            if (this.debounceTimers.has(handlerName)) {
                clearTimeout(this.debounceTimers.get(handlerName));
            }

            // Set new timer
            const timer = setTimeout(() => {
                const elements = this.debouncedElements.get(handlerName) || [];
                this.debouncedElements.delete(handlerName);
                this.debounceTimers.delete(handlerName);

                // Process all collected elements
                // For most handlers, we only need to process the last element
                // (e.g., task list updated multiple times, we only care about final state)
                if (elements.length > 0) {
                    const lastElement = elements[elements.length - 1];
                    handler.callback(lastElement.node, lastElement.mutation);
                }
            }, delay);

            this.debounceTimers.set(handlerName, timer);
        }

        /**
         * Stop observing DOM changes
         */
        stop() {
            if (this.observer) {
                this.observer.disconnect();
                this.observer = null;
            }

            // Clear all debounce timers
            this.debounceTimers.forEach((timer) => clearTimeout(timer));
            this.debounceTimers.clear();
            this.debouncedElements.clear();

            this.isObserving = false;
        }

        /**
         * Register a handler for DOM changes
         * @param {string} name - Handler name for debugging
         * @param {Function} callback - Function to call when nodes are added (receives node, mutation)
         * @param {Object} options - Optional configuration
         * @param {boolean} options.debounce - Enable debouncing (default: false)
         * @param {number} options.debounceDelay - Debounce delay in ms (default: 50)
         * @returns {Function} Unregister function
         */
        register(name, callback, options = {}) {
            const handler = {
                name,
                callback,
                debounce: options.debounce || false,
                debounceDelay: options.debounceDelay,
            };
            this.handlers.push(handler);

            // Return unregister function
            return () => {
                const index = this.handlers.indexOf(handler);
                if (index > -1) {
                    this.handlers.splice(index, 1);

                    // Clean up any pending debounced callbacks
                    if (this.debounceTimers.has(name)) {
                        clearTimeout(this.debounceTimers.get(name));
                        this.debounceTimers.delete(name);
                        this.debouncedElements.delete(name);
                    }
                }
            };
        }

        /**
         * Register a handler for specific class names
         * @param {string} name - Handler name for debugging
         * @param {string|string[]} classNames - Class name(s) to watch for (supports partial matches)
         * @param {Function} callback - Function to call when matching elements appear
         * @param {Object} options - Optional configuration
         * @param {boolean} options.debounce - Enable debouncing (default: false for immediate response)
         * @param {number} options.debounceDelay - Debounce delay in ms (default: 50)
         * @returns {Function} Unregister function
         */
        onClass(name, classNames, callback, options = {}) {
            const classArray = Array.isArray(classNames) ? classNames : [classNames];

            return this.register(
                name,
                (node) => {
                    // Safely get className as string (handles SVG elements)
                    const className = typeof node.className === 'string' ? node.className : '';

                    // Check if node matches any of the target classes
                    for (const targetClass of classArray) {
                        if (className.includes(targetClass)) {
                            callback(node);
                            return; // Only call once per node
                        }
                    }

                    // Also check if node contains matching elements
                    if (node.querySelector) {
                        for (const targetClass of classArray) {
                            const matches = node.querySelectorAll(`[class*="${targetClass}"]`);
                            matches.forEach((match) => callback(match));
                        }
                    }
                },
                options
            );
        }

        /**
         * Get stats about registered handlers
         */
        getStats() {
            return {
                isObserving: this.isObserving,
                handlerCount: this.handlers.length,
                handlers: this.handlers.map((h) => ({
                    name: h.name,
                    debounced: h.debounce || false,
                })),
                pendingCallbacks: this.debounceTimers.size,
            };
        }
    }

    const domObserver$1 = new DOMObserver();

    /**
     * Feature Registry
     * Centralized feature initialization system
     */


    /**
     * Feature Registry
     * Populated at runtime by the entrypoint to avoid bundling feature code in core.
     */
    const featureRegistry$1 = [];

    /**
     * Initialize all enabled features
     * @returns {Promise<void>}
     */
    async function initializeFeatures() {
        // Block feature initialization during character switch
        if (dataManager$1.getIsCharacterSwitching()) {
            return;
        }

        const errors = [];

        for (const feature of featureRegistry$1) {
            try {
                const isEnabled = feature.customCheck ? feature.customCheck() : config$1.isFeatureEnabled(feature.key);

                if (!isEnabled) {
                    continue;
                }

                // Initialize feature
                if (feature.async) {
                    await feature.initialize();
                } else {
                    feature.initialize();
                }
            } catch (error) {
                errors.push({
                    feature: feature.name,
                    error: error.message,
                });
                console.error(`[Toolasha] Failed to initialize ${feature.name}:`, error);
            }
        }

        // Log errors if any occurred
        if (errors.length > 0) {
            console.error(`[Toolasha] ${errors.length} feature(s) failed to initialize`, errors);
        }
    }

    /**
     * Get feature by key
     * @param {string} key - Feature key
     * @returns {Object|null} Feature definition or null
     */
    function getFeature(key) {
        return featureRegistry$1.find((f) => f.key === key) || null;
    }

    /**
     * Get all features
     * @returns {Array} Feature registry
     */
    function getAllFeatures() {
        return [...featureRegistry$1];
    }

    /**
     * Get features by category
     * @param {string} category - Category name
     * @returns {Array} Features in category
     */
    function getFeaturesByCategory(category) {
        return featureRegistry$1.filter((f) => f.category === category);
    }

    /**
     * Check health of all initialized features
     * @returns {Array<Object>} Array of failed features with details
     */
    function checkFeatureHealth() {
        const failed = [];

        for (const feature of featureRegistry$1) {
            // Skip if feature has no health check
            if (!feature.healthCheck) continue;

            // Skip if feature is not enabled
            const isEnabled = feature.customCheck ? feature.customCheck() : config$1.isFeatureEnabled(feature.key);

            if (!isEnabled) continue;

            try {
                const result = feature.healthCheck();

                // null = can't verify (DOM not ready), false = failed, true = healthy
                if (result === false) {
                    failed.push({
                        key: feature.key,
                        name: feature.name,
                        reason: 'Health check returned false',
                    });
                }
            } catch (error) {
                failed.push({
                    key: feature.key,
                    name: feature.name,
                    reason: `Health check error: ${error.message}`,
                });
            }
        }

        return failed;
    }

    /**
     * Setup character switch handler
     * Re-initializes all features when character switches
     */
    function setupCharacterSwitchHandler() {
        // Guard against overlapping switches
        let isSwitching = false;
        let reinitScheduled = false;
        let reinitTimeoutId = null;

        // Handle character_switching event (cleanup phase)
        dataManager$1.on('character_switching', async (_data) => {
            // Prevent overlapping switches
            if (isSwitching) {
                console.warn('[FeatureRegistry] Character switch already in progress - ignoring rapid switch');
                return;
            }

            isSwitching = true;

            // Defer cleanup to next tick to prevent main thread blocking
            setTimeout(async () => {
                try {
                    // Clear config cache to prevent stale settings
                    if (config$1 && typeof config$1.clearSettingsCache === 'function') {
                        config$1.clearSettingsCache();
                    }

                    // Disable all active features (cleanup DOM elements, event listeners, etc.)
                    // Process all features without awaiting to avoid blocking
                    const cleanupPromises = [];
                    for (const feature of featureRegistry$1) {
                        try {
                            const featureInstance = getFeatureInstance(feature.key);
                            if (featureInstance && typeof featureInstance.disable === 'function') {
                                const result = featureInstance.disable();
                                // Collect promises but don't await them synchronously
                                if (result && typeof result.then === 'function') {
                                    cleanupPromises.push(
                                        result.catch((error) => {
                                            console.error(`[FeatureRegistry] Failed to disable ${feature.name}:`, error);
                                        })
                                    );
                                }
                            }
                        } catch (error) {
                            console.error(`[FeatureRegistry] Failed to disable ${feature.name}:`, error);
                        }
                    }

                    // Wait for all cleanup in parallel (non-blocking)
                    if (cleanupPromises.length > 0) {
                        await Promise.all(cleanupPromises);
                    }
                } catch (error) {
                    console.error('[FeatureRegistry] Error during character switch cleanup:', error);
                } finally {
                    // Always reset flag to allow next character switch
                    isSwitching = false;
                }
            }, 0);
        });

        // Handle character_switched event (re-initialization phase)
        dataManager$1.on('character_switched', async (_data) => {
            // Prevent multiple overlapping reinits
            if (reinitScheduled) {
                console.warn('[FeatureRegistry] Reinit already scheduled - ignoring duplicate');
                return;
            }

            reinitScheduled = true;

            // Force cleanup of dungeon tracker UI (safety measure)
            const dungeonTrackerFeature = getFeature('dungeonTrackerUI');
            if (dungeonTrackerFeature && typeof dungeonTrackerFeature.cleanup === 'function') {
                dungeonTrackerFeature.cleanup();
            }

            // Settings UI manages its own character switch lifecycle via character_initialized event
            // No need to call settingsUI.initialize() here

            // Re-initialize features
            const reinit = async () => {
                try {
                    // Reload config settings first (settings were cleared during cleanup)
                    await config$1.loadSettings();
                    config$1.applyColorSettings();

                    // Now re-initialize all features with fresh settings
                    await initializeFeatures();
                } catch (error) {
                    console.error('[FeatureRegistry] Error during feature reinitialization:', error);
                } finally {
                    // Reset flags to allow next switch
                    isSwitching = false;
                    reinitScheduled = false;
                    if (reinitTimeoutId) {
                        clearTimeout(reinitTimeoutId);
                        reinitTimeoutId = null;
                    }
                }
            };

            // Use requestIdleCallback for non-blocking re-init
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => reinit(), { timeout: 2000 });
            } else {
                // Fallback for browsers without requestIdleCallback
                if (reinitTimeoutId) {
                    clearTimeout(reinitTimeoutId);
                }
                reinitTimeoutId = setTimeout(() => reinit(), 300); // Longer delay for game to stabilize
            }
        });
    }

    /**
     * Get feature instance from imported module
     * @param {string} key - Feature key
     * @returns {Object|null} Feature instance or null
     * @private
     */
    function getFeatureInstance(key) {
        const feature = getFeature(key);
        if (!feature) {
            return null;
        }

        return feature.module || feature;
    }

    /**
     * Retry initialization for specific features
     * @param {Array<Object>} failedFeatures - Array of failed feature objects
     * @returns {Promise<void>}
     */
    async function retryFailedFeatures(failedFeatures) {
        for (const failed of failedFeatures) {
            const feature = getFeature(failed.key);
            if (!feature) continue;

            try {
                if (feature.async) {
                    await feature.initialize();
                } else {
                    feature.initialize();
                }

                // Verify the retry actually worked by running health check
                if (feature.healthCheck) {
                    const healthResult = feature.healthCheck();
                    if (healthResult === false) {
                        console.warn(`[Toolasha] ${feature.name} retry completed but health check still fails`);
                    }
                }
            } catch (error) {
                console.error(`[Toolasha] ${feature.name} retry failed:`, error);
            }
        }
    }

    /**
     * Replace the feature registry (for library split)
     * @param {Array} newFeatures - New feature registry array
     */
    function replaceFeatures(newFeatures) {
        featureRegistry$1.length = 0; // Clear existing array
        featureRegistry$1.push(...newFeatures); // Add new features
    }

    var featureRegistry$2 = {
        initializeFeatures,
        setupCharacterSwitchHandler,
        checkFeatureHealth,
        retryFailedFeatures,
        getFeature,
        getAllFeatures,
        replaceFeatures,
        getFeaturesByCategory,
    };

    /**
     * Network Alert Display
     * Shows a warning message when market data cannot be fetched
     */


    class NetworkAlert {
        constructor() {
            this.container = null;
            this.unregisterHandlers = [];
            this.isVisible = false;
        }

        /**
         * Initialize network alert display
         */
        initialize() {
            if (!config$1.getSetting('networkAlert')) {
                return;
            }

            // 1. Check if header exists already
            const existingElem = document.querySelector('[class*="Header_totalLevel"]');
            if (existingElem) {
                this.prepareContainer(existingElem);
            }

            // 2. Watch for header to appear (handles SPA navigation)
            const unregister = domObserver$1.onClass('NetworkAlert', 'Header_totalLevel', (elem) => {
                this.prepareContainer(elem);
            });
            this.unregisterHandlers.push(unregister);
        }

        /**
         * Prepare container but don't show yet
         * @param {Element} totalLevelElem - Total level element
         */
        prepareContainer(totalLevelElem) {
            // Check if already prepared
            if (this.container && document.body.contains(this.container)) {
                return;
            }

            // Remove any existing container
            if (this.container) {
                this.container.remove();
            }

            // Create container (hidden by default)
            this.container = document.createElement('div');
            this.container.className = 'mwi-network-alert';
            this.container.style.cssText = `
            display: none;
            font-size: 0.875rem;
            font-weight: 500;
            color: #ff4444;
            text-wrap: nowrap;
            margin-left: 16px;
        `;

            // Insert after total level (or after networth if it exists)
            const networthElem = totalLevelElem.parentElement.querySelector('.mwi-networth-header');
            if (networthElem) {
                networthElem.insertAdjacentElement('afterend', this.container);
            } else {
                totalLevelElem.insertAdjacentElement('afterend', this.container);
            }
        }

        /**
         * Show the network alert
         * @param {string} message - Alert message to display
         */
        show(message = '⚠️ Market data unavailable') {
            if (!config$1.getSetting('networkAlert')) {
                return;
            }

            if (!this.container || !document.body.contains(this.container)) {
                // Try to prepare container if not ready
                const totalLevelElem = document.querySelector('[class*="Header_totalLevel"]');
                if (totalLevelElem) {
                    this.prepareContainer(totalLevelElem);
                } else {
                    // Header not found, fallback to console
                    console.warn('[Network Alert]', message);
                    return;
                }
            }

            if (this.container) {
                this.container.textContent = message;
                this.container.style.display = 'block';
                this.isVisible = true;
            }
        }

        /**
         * Hide the network alert
         */
        hide() {
            if (this.container && document.body.contains(this.container)) {
                this.container.style.display = 'none';
                this.isVisible = false;
            }
        }

        /**
         * Cleanup
         */
        disable() {
            this.hide();

            if (this.container) {
                this.container.remove();
                this.container = null;
            }

            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];
        }
    }

    const networkAlert = new NetworkAlert();

    /**
     * Marketplace API Module
     * Fetches and caches market price data from the MWI marketplace API
     */


    /**
     * MarketAPI class handles fetching and caching market price data
     */
    class MarketAPI {
        constructor() {
            // API endpoint
            this.API_URL = 'https://www.milkywayidle.com/game_data/marketplace.json';

            // Cache settings
            this.CACHE_DURATION = 15 * 60 * 1000; // 15 minutes in milliseconds
            this.CACHE_KEY_DATA = 'MWITools_marketAPI_json';
            this.CACHE_KEY_TIMESTAMP = 'MWITools_marketAPI_timestamp';

            // Current market data
            this.marketData = null;
            this.lastFetchTimestamp = null;
            this.errorLog = [];
        }

        /**
         * Fetch market data from API or cache
         * @param {boolean} forceFetch - Force a fresh fetch even if cache is valid
         * @returns {Promise<Object|null>} Market data object or null if failed
         */
        async fetch(forceFetch = false) {
            // Check cache first (unless force fetch)
            if (!forceFetch) {
                const cached = await this.getCachedData();
                if (cached) {
                    this.marketData = cached.data;
                    this.lastFetchTimestamp = cached.timestamp;
                    // Hide alert on successful cache load
                    networkAlert.hide();
                    return this.marketData;
                }
            }

            if (!connectionState.isConnected()) {
                const cachedFallback = await storage$1.getJSON(this.CACHE_KEY_DATA, 'settings', null);
                if (cachedFallback?.marketData) {
                    this.marketData = cachedFallback.marketData;
                    this.lastFetchTimestamp = cachedFallback.timestamp;
                    console.warn('[MarketAPI] Skipping fetch; disconnected. Using cached data.');
                    return this.marketData;
                }

                console.warn('[MarketAPI] Skipping fetch; disconnected and no cache available');
                return null;
            }

            // Try to fetch fresh data
            try {
                const response = await this.fetchFromAPI();

                if (response) {
                    // Cache the fresh data
                    this.cacheData(response);
                    this.marketData = response.marketData;
                    this.lastFetchTimestamp = response.timestamp;
                    // Hide alert on successful fetch
                    networkAlert.hide();
                    return this.marketData;
                }
            } catch (error) {
                this.logError('Fetch failed', error);
            }

            // Fallback: Try to use expired cache
            const expiredCache = await storage$1.getJSON(this.CACHE_KEY_DATA, 'settings', null);
            if (expiredCache) {
                console.warn('[MarketAPI] Using expired cache as fallback');
                this.marketData = expiredCache.marketData;
                this.lastFetchTimestamp = expiredCache.timestamp;
                // Show alert when using expired cache
                networkAlert.show('⚠️ Using outdated market data');
                return this.marketData;
            }

            // Total failure - show alert
            console.error('[MarketAPI] ❌ No market data available');
            networkAlert.show('⚠️ Market data unavailable');
            return null;
        }

        /**
         * Fetch from API endpoint
         * @returns {Promise<Object|null>} API response or null
         */
        async fetchFromAPI() {
            try {
                const response = await fetch(this.API_URL);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                // Validate response structure
                if (!data.marketData || typeof data.marketData !== 'object') {
                    throw new Error('Invalid API response structure');
                }

                return data;
            } catch (error) {
                console.error('[MarketAPI] API fetch error:', error);
                throw error;
            }
        }

        /**
         * Get cached data if valid
         * @returns {Promise<Object|null>} { data, timestamp } or null if invalid/expired
         */
        async getCachedData() {
            const cachedTimestamp = await storage$1.get(this.CACHE_KEY_TIMESTAMP, 'settings', null);
            const cachedData = await storage$1.getJSON(this.CACHE_KEY_DATA, 'settings', null);

            if (!cachedTimestamp || !cachedData) {
                return null;
            }

            // Check if cache is still valid
            const now = Date.now();
            const age = now - cachedTimestamp;

            if (age > this.CACHE_DURATION) {
                return null;
            }

            return {
                data: cachedData.marketData,
                timestamp: cachedData.timestamp,
            };
        }

        /**
         * Cache market data
         * @param {Object} data - API response to cache
         */
        cacheData(data) {
            storage$1.setJSON(this.CACHE_KEY_DATA, data, 'settings');
            storage$1.set(this.CACHE_KEY_TIMESTAMP, Date.now(), 'settings');
        }

        /**
         * Get price for an item
         * @param {string} itemHrid - Item HRID (e.g., "/items/cheese")
         * @param {number} enhancementLevel - Enhancement level (default: 0)
         * @returns {Object|null} { ask: number, bid: number } or null if not found
         */
        getPrice(itemHrid, enhancementLevel = 0) {
            if (!this.marketData) {
                console.warn('[MarketAPI] ⚠️ No market data available');
                return null;
            }

            const priceData = this.marketData[itemHrid];

            if (!priceData || typeof priceData !== 'object') {
                // Item not in market data at all
                return null;
            }

            // Market data is organized by enhancement level
            // { 0: { a: 1000, b: 900 }, 2: { a: 5000, b: 4500 }, ... }
            const price = priceData[enhancementLevel];

            if (!price) {
                // No price data for this enhancement level
                return null;
            }

            const normalizeMarketPriceValue = (value) => {
                if (typeof value !== 'number') {
                    return null;
                }

                if (value < 0) {
                    return null;
                }

                return value;
            };

            return {
                ask: normalizeMarketPriceValue(price.a), // Sell price
                bid: normalizeMarketPriceValue(price.b), // Buy price
            };
        }

        /**
         * Get prices for multiple items
         * @param {string[]} itemHrids - Array of item HRIDs
         * @returns {Map<string, Object>} Map of HRID -> { ask, bid }
         */
        getPrices(itemHrids) {
            const prices = new Map();

            for (const hrid of itemHrids) {
                const price = this.getPrice(hrid);
                if (price) {
                    prices.set(hrid, price);
                }
            }

            return prices;
        }

        /**
         * Get prices for multiple items with enhancement levels (batch optimized)
         * @param {Array<{itemHrid: string, enhancementLevel: number}>} items - Array of items with enhancement levels
         * @returns {Map<string, Object>} Map of "hrid:level" -> { ask, bid }
         */
        getPricesBatch(items) {
            const priceMap = new Map();

            for (const { itemHrid, enhancementLevel = 0 } of items) {
                const key = `${itemHrid}:${enhancementLevel}`;
                if (!priceMap.has(key)) {
                    const price = this.getPrice(itemHrid, enhancementLevel);
                    if (price) {
                        priceMap.set(key, price);
                    }
                }
            }

            return priceMap;
        }

        /**
         * Check if market data is loaded
         * @returns {boolean} True if data is available
         */
        isLoaded() {
            return this.marketData !== null;
        }

        /**
         * Get age of current data in milliseconds
         * @returns {number|null} Age in ms or null if no data
         */
        getDataAge() {
            if (!this.lastFetchTimestamp) {
                return null;
            }

            return Date.now() - this.lastFetchTimestamp;
        }

        /**
         * Log an error
         * @param {string} message - Error message
         * @param {Error} error - Error object
         */
        logError(message, error) {
            const errorEntry = {
                timestamp: new Date().toISOString(),
                message,
                error: error?.message || String(error),
            };

            this.errorLog.push(errorEntry);
            console.error(`[MarketAPI] ${message}:`, error);
        }

        /**
         * Get error log
         * @returns {Array} Array of error entries
         */
        getErrors() {
            return [...this.errorLog];
        }

        /**
         * Clear error log
         */
        clearErrors() {
            this.errorLog = [];
        }

        /**
         * Clear cache and fetch fresh market data
         * @returns {Promise<Object|null>} Fresh market data or null if failed
         */
        async clearCacheAndRefetch() {
            // Clear storage cache
            await storage$1.delete(this.CACHE_KEY_DATA, 'settings');
            await storage$1.delete(this.CACHE_KEY_TIMESTAMP, 'settings');

            // Clear in-memory state
            this.marketData = null;
            this.lastFetchTimestamp = null;

            // Force fresh fetch
            return await this.fetch(true);
        }
    }

    const marketAPI = new MarketAPI();

    /**
     * Foundation Core Library
     * Core infrastructure and API clients only (no utilities)
     *
     * Exports to: window.Toolasha.Core
     */


    // Export to global namespace
    const toolashaRoot$5 = window.Toolasha || {};
    window.Toolasha = toolashaRoot$5;

    if (typeof unsafeWindow !== 'undefined') {
        unsafeWindow.Toolasha = toolashaRoot$5;
    }

    toolashaRoot$5.Core = {
        storage: storage$1,
        config: config$1,
        webSocketHook: webSocketHook$1,
        domObserver: domObserver$1,
        dataManager: dataManager$1,
        featureRegistry: featureRegistry$2,
        settingsStorage,
        settingsGroups,
        profileManager: {
            setCurrentProfile,
            getCurrentProfile,
            clearCurrentProfile,
        },
        marketAPI,
    };

    console.log('[Toolasha] Core library loaded');

    /**
     * Formatting Utilities
     * Pure functions for formatting numbers and time
     */


    /**
     * Format numbers with thousand separators
     * @param {number} num - The number to format
     * @param {number} digits - Number of decimal places (default: 0 for whole numbers)
     * @returns {string} Formatted number (e.g., "1,500", "1,500,000")
     *
     * @example
     * numberFormatter(1500) // "1,500"
     * numberFormatter(1500000) // "1,500,000"
     * numberFormatter(1500.5, 1) // "1,500.5"
     */
    function numberFormatter(num, digits = 0) {
        if (num === null || num === undefined) {
            return null;
        }

        // Round to specified decimal places
        const rounded = digits > 0 ? num.toFixed(digits) : Math.round(num);

        // Format with thousand separators
        return new Intl.NumberFormat().format(rounded);
    }

    /**
     * Convert seconds to human-readable time format
     * @param {number} sec - Seconds to convert
     * @returns {string} Formatted time (e.g., "1h 23m 45s" or "3 years 5 months 3 days")
     *
     * @example
     * timeReadable(3661) // "1h 01m 01s"
     * timeReadable(90000) // "1 day"
     * timeReadable(31536000) // "1 year"
     * timeReadable(100000000) // "3 years 2 months 3 days"
     */
    function timeReadable(sec) {
        // For times >= 1 year, show in years/months/days
        if (sec >= 31536000) {
            // 365 days
            const years = Math.floor(sec / 31536000);
            const remainingAfterYears = sec - years * 31536000;
            const months = Math.floor(remainingAfterYears / 2592000); // 30 days
            const remainingAfterMonths = remainingAfterYears - months * 2592000;
            const days = Math.floor(remainingAfterMonths / 86400);

            const parts = [];
            if (years > 0) parts.push(`${years} year${years !== 1 ? 's' : ''}`);
            if (months > 0) parts.push(`${months} month${months !== 1 ? 's' : ''}`);
            if (days > 0) parts.push(`${days} day${days !== 1 ? 's' : ''}`);

            return parts.join(' ');
        }

        // For times >= 1 day, show in days/hours/minutes
        if (sec >= 86400) {
            const days = Math.floor(sec / 86400);
            const remainingAfterDays = sec - days * 86400;
            const hours = Math.floor(remainingAfterDays / 3600);
            const remainingAfterHours = remainingAfterDays - hours * 3600;
            const minutes = Math.floor(remainingAfterHours / 60);

            const parts = [];
            if (days > 0) parts.push(`${days} day${days !== 1 ? 's' : ''}`);
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);

            return parts.join(' ');
        }

        // For times < 1 day, show as HH:MM:SS
        const d = new Date(Math.round(sec * 1000));
        function pad(i) {
            return ('0' + i).slice(-2);
        }

        const hours = d.getUTCHours();
        const minutes = d.getUTCMinutes();
        const seconds = d.getUTCSeconds();

        // For times < 1 minute, just show seconds
        if (hours === 0 && minutes === 0) {
            return seconds + 's';
        }

        const str = hours + 'h ' + pad(minutes) + 'm ' + pad(seconds) + 's';
        return str;
    }

    /**
     * Format a number with thousand separators based on locale
     * @param {number} num - The number to format
     * @returns {string} Formatted number with separators
     *
     * @example
     * formatWithSeparator(1000000) // "1,000,000" (US locale)
     */
    function formatWithSeparator(num) {
        return new Intl.NumberFormat().format(num);
    }

    /**
     * Format large numbers in K/M/B notation
     * @param {number} num - The number to format
     * @param {number} decimals - Number of decimal places (default: 1)
     * @returns {string} Formatted number (e.g., "1.5K", "2.3M", "1.2B")
     *
     * @example
     * formatKMB(1500) // "1.5K"
     * formatKMB(2300000) // "2.3M"
     * formatKMB(1234567890) // "1.2B"
     */
    function formatKMB(num, decimals = 1) {
        if (num === null || num === undefined) {
            return null;
        }

        const absNum = Math.abs(num);
        const sign = num < 0 ? '-' : '';

        if (absNum >= 1e9) {
            return sign + (absNum / 1e9).toFixed(decimals) + 'B';
        } else if (absNum >= 1e6) {
            return sign + (absNum / 1e6).toFixed(decimals) + 'M';
        } else if (absNum >= 1e3) {
            return sign + (absNum / 1e3).toFixed(decimals) + 'K';
        } else {
            return sign + absNum.toFixed(0);
        }
    }

    /**
     * Format large numbers in K/M/B notation with 3 significant digits
     * @param {number} num - The number to format
     * @returns {string} Formatted number (e.g., "999", "1.25K", "82.1K", "825K", "1.25M")
     *
     * Handles rounding edge cases properly:
     * - 9999 rounds to "10.0K" (not "10.00K")
     * - 99999 rounds to "100K" (not "100.0K")
     * - 999999 promotes to "1.00M" (not "1000K")
     *
     * @example
     * formatKMB3Digits(999) // "999"
     * formatKMB3Digits(1250) // "1.25K"
     * formatKMB3Digits(8210) // "8.21K"
     * formatKMB3Digits(9999) // "10.0K"
     * formatKMB3Digits(82100) // "82.1K"
     * formatKMB3Digits(99999) // "100K"
     * formatKMB3Digits(825000) // "825K"
     * formatKMB3Digits(999999) // "1.00M"
     * formatKMB3Digits(1250000) // "1.25M"
     * formatKMB3Digits(82300000) // "82.3M"
     */
    function formatKMB3Digits(num) {
        if (num === null || num === undefined) {
            return null;
        }

        const absNum = Math.abs(num);
        const sign = num < 0 ? '-' : '';

        if (absNum >= 1e9) {
            const value = absNum / 1e9;
            // Round to 2 decimals first to check actual display value
            const rounded = parseFloat(value.toFixed(2));
            let decimals = 2;
            if (rounded >= 100) decimals = 0;
            else if (rounded >= 10) decimals = 1;
            return sign + value.toFixed(decimals) + 'B';
        } else if (absNum >= 1e6) {
            const value = absNum / 1e6;
            const rounded = parseFloat(value.toFixed(2));
            if (rounded >= 1000) {
                // Promote to B (e.g., 999999999 -> 1.00B not 1000M)
                return sign + (value / 1000).toFixed(2) + 'B';
            }
            let decimals = 2;
            if (rounded >= 100) decimals = 0;
            else if (rounded >= 10) decimals = 1;
            return sign + value.toFixed(decimals) + 'M';
        } else if (absNum >= 1e3) {
            const value = absNum / 1e3;
            const rounded = parseFloat(value.toFixed(2));
            if (rounded >= 1000) {
                // Promote to M (e.g., 999999 -> 1.00M not 1000K)
                return sign + (value / 1000).toFixed(2) + 'M';
            }
            let decimals = 2;
            if (rounded >= 100) decimals = 0;
            else if (rounded >= 10) decimals = 1;
            return sign + value.toFixed(decimals) + 'K';
        } else {
            return sign + Math.floor(absNum).toString();
        }
    }

    /**
     * Format numbers using game-style coin notation (4-digit maximum display)
     * @param {number} num - The number to format
     * @returns {string} Formatted number (e.g., "999", "1,000", "10K", "9,999K", "10M")
     *
     * Game formatting rules (4-digit bounded notation):
     * - 0-999: Raw number (no formatting)
     * - 1,000-9,999: Comma format
     * - 10,000-9,999,999: K suffix (10K to 9,999K)
     * - 10,000,000-9,999,999,999: M suffix (10M to 9,999M)
     * - 10,000,000,000-9,999,999,999,999: B suffix (10B to 9,999B)
     * - 10,000,000,000,000+: T suffix (10T+)
     *
     * Key rule: Display never exceeds 4 numeric digits. When a 5th digit is needed,
     * promote to the next unit (K→M→B→T).
     *
     * @example
     * coinFormatter(999) // "999"
     * coinFormatter(1000) // "1,000"
     * coinFormatter(9999) // "9,999"
     * coinFormatter(10000) // "10K"
     * coinFormatter(999999) // "999K"
     * coinFormatter(1000000) // "1,000K"
     * coinFormatter(9999999) // "9,999K"
     * coinFormatter(10000000) // "10M"
     */
    function coinFormatter(num) {
        if (num === null || num === undefined) {
            return null;
        }

        const absNum = Math.abs(num);
        const sign = num < 0 ? '-' : '';

        // 0-999: raw number
        if (absNum < 1000) {
            return sign + Math.floor(absNum).toString();
        }
        // 1,000-9,999: comma format
        if (absNum < 10000) {
            return sign + new Intl.NumberFormat().format(Math.floor(absNum));
        }
        // 10K-9,999K (10,000 to 9,999,999)
        if (absNum < 10000000) {
            const val = Math.floor(absNum / 1000);
            const formatted = val >= 1000 ? new Intl.NumberFormat().format(val) : val;
            return sign + formatted + 'K';
        }
        // 10M-9,999M (10,000,000 to 9,999,999,999)
        if (absNum < 10000000000) {
            const val = Math.floor(absNum / 1000000);
            const formatted = val >= 1000 ? new Intl.NumberFormat().format(val) : val;
            return sign + formatted + 'M';
        }
        // 10B-9,999B (10,000,000,000 to 9,999,999,999,999)
        if (absNum < 10000000000000) {
            const val = Math.floor(absNum / 1000000000);
            const formatted = val >= 1000 ? new Intl.NumberFormat().format(val) : val;
            return sign + formatted + 'B';
        }
        // 10T+ (10,000,000,000,000+)
        const val = Math.floor(absNum / 1000000000000);
        const formatted = val >= 1000 ? new Intl.NumberFormat().format(val) : val;
        return sign + formatted + 'T';
    }

    /**
     * Format milliseconds as relative time
     * @param {number} ageMs - Age in milliseconds
     * @returns {string} Formatted relative time (e.g., "5m", "2h 30m", "3d 12h", "14d")
     *
     * @example
     * formatRelativeTime(30000) // "Just now" (< 1 min)
     * formatRelativeTime(300000) // "5m" (5 minutes)
     * formatRelativeTime(7200000) // "2h 0m" (2 hours)
     * formatRelativeTime(93600000) // "1d 2h" (26 hours)
     * formatRelativeTime(864000000) // "10d" (10 days)
     * formatRelativeTime(2678400000) // "30+ days" (31 days)
     */
    function formatRelativeTime(ageMs) {
        const minutes = Math.floor(ageMs / 60000);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        // Edge cases
        if (minutes < 1) return 'Just now';
        if (days > 30) return '30+ days';

        // Format based on age
        if (days > 7) return `${days}d`;
        if (days > 0) return `${days}d ${hours % 24}h`;
        if (hours > 0) return `${hours}h ${minutes % 60}m`;
        return `${minutes}m`;
    }

    /**
     * Format numbers for networth display with decimal precision
     * Uses 2 decimal places for better readability in detailed breakdowns
     * @param {number} num - The number to format
     * @returns {string} Formatted number (e.g., "1.23K", "45.67M", "89.01B")
     *
     * @example
     * networthFormatter(1234) // "1.23K"
     * networthFormatter(45678) // "45.68K"
     * networthFormatter(1234567) // "1.23M"
     * networthFormatter(89012345) // "89.01M"
     * networthFormatter(1234567890) // "1.23B"
     */
    function networthFormatter(num) {
        if (num === null || num === undefined) {
            return null;
        }

        const absNum = Math.abs(num);
        const sign = num < 0 ? '-' : '';

        // 0-999: raw number (no decimals needed)
        if (absNum < 1000) {
            return sign + Math.floor(absNum).toString();
        }
        // 1,000-999,999: K with 2 decimals
        if (absNum < 1000000) {
            return sign + (absNum / 1000).toFixed(2) + 'K';
        }
        // 1M-999,999,999: M with 2 decimals
        if (absNum < 1000000000) {
            return sign + (absNum / 1000000).toFixed(2) + 'M';
        }
        // 1B+: B with 2 decimals
        return sign + (absNum / 1000000000).toFixed(2) + 'B';
    }

    /**
     * Format a decimal value as a percentage
     * @param {number} value - The decimal value to format (e.g., 0.05 for 5%)
     * @param {number} decimals - Number of decimal places (default: 1)
     * @returns {string} Formatted percentage (e.g., "5.0%", "12.5%")
     *
     * @example
     * formatPercentage(0.05) // "5.0%"
     * formatPercentage(0.125, 1) // "12.5%"
     * formatPercentage(0.00123, 2) // "0.12%"
     * formatPercentage(0.00123, 3) // "0.123%"
     */
    function formatPercentage(value, decimals = 1) {
        if (value === null || value === undefined) {
            return null;
        }

        const percentage = value * 100;
        const formatted = new Intl.NumberFormat(undefined, {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals,
        }).format(percentage);

        return formatted + '%';
    }

    /**
     * Format currency/coin amounts intelligently based on context
     * @param {number} amount - The amount to format
     * @param {Object} options - Formatting options
     * @param {string} options.style - 'game' (4-digit), 'compact' (K/M/B), 'full' (thousand separators), 'networth' (2 decimals)
     * @param {number} options.decimals - Decimal places for compact style (default: 1)
     * @returns {string} Formatted currency string
     *
     * @example
     * formatCurrency(1500, {style: 'game'}) // "1,500"
     * formatCurrency(1500000, {style: 'game'}) // "1,500K"
     * formatCurrency(1500000, {style: 'compact'}) // "1.5M"
     * formatCurrency(1500000, {style: 'full'}) // "1,500,000"
     * formatCurrency(1234, {style: 'networth'}) // "1.23K"
     */
    function formatCurrency(amount, options = {}) {
        const style = options.style || 'game';
        const decimals = options.decimals !== undefined ? options.decimals : 1;

        switch (style) {
            case 'game':
                return coinFormatter(amount);
            case 'compact':
                return formatKMB(amount, decimals);
            case 'networth':
                return networthFormatter(amount);
            case 'full':
                return formatWithSeparator(amount);
            default:
                return coinFormatter(amount);
        }
    }

    /**
     * Format numbers in compact notation (K/M/B)
     * Alias for formatKMB for clearer naming
     * @param {number} value - The number to format
     * @param {number} decimals - Number of decimal places (default: 1)
     * @returns {string} Formatted number (e.g., "1.5K", "2.3M", "1.2B")
     *
     * @example
     * formatCompactNumber(1500) // "1.5K"
     * formatCompactNumber(2300000) // "2.3M"
     * formatCompactNumber(1234567890) // "1.2B"
     */
    function formatCompactNumber(value, decimals = 1) {
        return formatKMB(value, decimals);
    }

    /**
     * Format large numbers based on user preference
     * Uses K/M/B notation or full numbers depending on setting
     * @param {number} value - The number to format
     * @param {number} decimals - Number of decimal places for K/M/B format (default: 1)
     * @returns {string} Formatted number (e.g., "1.5M" or "1,500,000")
     *
     * @example
     * // With K/M/B enabled (default)
     * formatLargeNumber(1500000) // "1.5M"
     * formatLargeNumber(2300) // "2.3K"
     *
     * // With K/M/B disabled
     * formatLargeNumber(1500000) // "1,500,000"
     * formatLargeNumber(2300) // "2,300"
     */
    function formatLargeNumber(value, decimals = 1) {
        const useAbbreviations = config$1.getSetting('formatting_useKMBFormat') !== false;
        return useAbbreviations ? formatKMB(value, decimals) : formatWithSeparator(value);
    }

    var formatters = /*#__PURE__*/Object.freeze({
        __proto__: null,
        coinFormatter: coinFormatter,
        formatCompactNumber: formatCompactNumber,
        formatCurrency: formatCurrency,
        formatKMB: formatKMB,
        formatKMB3Digits: formatKMB3Digits,
        formatLargeNumber: formatLargeNumber,
        formatPercentage: formatPercentage,
        formatRelativeTime: formatRelativeTime,
        formatWithSeparator: formatWithSeparator,
        networthFormatter: networthFormatter,
        numberFormatter: numberFormatter,
        timeReadable: timeReadable
    });

    /**
     * Efficiency Utilities Module
     * Calculations for efficiency stacking and breakdowns
     */

    /**
     * Stack additive bonuses (most game bonuses)
     * @param {number[]} bonuses - Array of bonus percentages
     * @returns {number} Total stacked bonus percentage
     *
     * @example
     * stackAdditive([10, 20, 5])
     * // Returns: 35
     * // Because: 10% + 20% + 5% = 35%
     */
    function stackAdditive(...bonuses) {
        return bonuses.reduce((total, bonus) => total + bonus, 0);
    }

    /**
     * Calculate efficiency multiplier from efficiency percentage
     * Efficiency gives bonus action completions per time-consuming action
     *
     * @param {number} efficiencyPercent - Efficiency as percentage (e.g., 150 for 150%)
     * @returns {number} Multiplier (e.g., 2.5 for 150% efficiency)
     *
     * @example
     * calculateEfficiencyMultiplier(0)   // Returns 1.0 (no bonus)
     * calculateEfficiencyMultiplier(50)  // Returns 1.5
     * calculateEfficiencyMultiplier(150) // Returns 2.5
     */
    function calculateEfficiencyMultiplier(efficiencyPercent) {
        return 1 + (efficiencyPercent || 0) / 100;
    }

    /**
     * Calculate efficiency breakdown from supplied sources
     * @param {Object} params - Efficiency inputs
     * @param {number} params.requiredLevel - Action required level
     * @param {number} params.skillLevel - Player skill level
     * @param {number} [params.teaSkillLevelBonus=0] - Bonus skill levels from tea
     * @param {number} [params.actionLevelBonus=0] - Action level bonus from tea (affects requirement)
     * @param {number} [params.houseEfficiency=0] - House room efficiency bonus
     * @param {number} [params.equipmentEfficiency=0] - Equipment efficiency bonus
     * @param {number} [params.teaEfficiency=0] - Tea efficiency bonus
     * @param {number} [params.communityEfficiency=0] - Community buff efficiency bonus
     * @param {number} [params.achievementEfficiency=0] - Achievement efficiency bonus
     * @returns {Object} Efficiency breakdown
     */
    function calculateEfficiencyBreakdown({
        requiredLevel,
        skillLevel,
        teaSkillLevelBonus = 0,
        actionLevelBonus = 0,
        houseEfficiency = 0,
        equipmentEfficiency = 0,
        teaEfficiency = 0,
        communityEfficiency = 0,
        achievementEfficiency = 0,
    }) {
        const effectiveRequirement = (requiredLevel || 0) + actionLevelBonus;
        const baseSkillLevel = Math.max(skillLevel || 0, requiredLevel || 0);
        const effectiveLevel = baseSkillLevel + teaSkillLevelBonus;
        const levelEfficiency = Math.max(0, effectiveLevel - effectiveRequirement);
        const totalEfficiency = stackAdditive(
            levelEfficiency,
            houseEfficiency,
            equipmentEfficiency,
            teaEfficiency,
            communityEfficiency,
            achievementEfficiency
        );

        return {
            totalEfficiency,
            levelEfficiency,
            effectiveRequirement,
            effectiveLevel,
            breakdown: {
                houseEfficiency,
                equipmentEfficiency,
                teaEfficiency,
                communityEfficiency,
                achievementEfficiency,
                actionLevelBonus,
                teaSkillLevelBonus,
            },
        };
    }

    var efficiency = {
        stackAdditive,
        calculateEfficiencyMultiplier,
        calculateEfficiencyBreakdown,
    };

    var efficiency$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateEfficiencyBreakdown: calculateEfficiencyBreakdown,
        calculateEfficiencyMultiplier: calculateEfficiencyMultiplier,
        default: efficiency,
        stackAdditive: stackAdditive
    });

    /**
     * Profit Calculation Constants
     * Shared constants used across profit calculators
     */

    /**
     * Marketplace tax rate (2%)
     */
    const MARKET_TAX = 0.02;

    /**
     * Base drink consumption rate per hour (before Drink Concentration)
     */
    const DRINKS_PER_HOUR_BASE = 12;

    /**
     * Seconds per hour (for rate conversions)
     */
    const SECONDS_PER_HOUR = 3600;

    /**
     * Hours per day (for daily profit calculations)
     */
    const HOURS_PER_DAY = 24;

    /**
     * Gathering skill action types
     * Skills that gather raw materials from the world
     */
    const GATHERING_TYPES$2 = ['/action_types/foraging', '/action_types/woodcutting', '/action_types/milking'];

    /**
     * Production skill action types
     * Skills that craft items from materials
     */
    const PRODUCTION_TYPES$4 = [
        '/action_types/brewing',
        '/action_types/cooking',
        '/action_types/cheesesmithing',
        '/action_types/crafting',
        '/action_types/tailoring',
    ];

    /**
     * All non-combat skill action types
     */
    const ALL_SKILL_TYPES = [...GATHERING_TYPES$2, ...PRODUCTION_TYPES$4];

    var profitConstants = {
        MARKET_TAX,
        DRINKS_PER_HOUR_BASE,
        SECONDS_PER_HOUR,
        HOURS_PER_DAY,
        GATHERING_TYPES: GATHERING_TYPES$2,
        PRODUCTION_TYPES: PRODUCTION_TYPES$4,
        ALL_SKILL_TYPES,
    };

    var profitConstants$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ALL_SKILL_TYPES: ALL_SKILL_TYPES,
        DRINKS_PER_HOUR_BASE: DRINKS_PER_HOUR_BASE,
        GATHERING_TYPES: GATHERING_TYPES$2,
        HOURS_PER_DAY: HOURS_PER_DAY,
        MARKET_TAX: MARKET_TAX,
        PRODUCTION_TYPES: PRODUCTION_TYPES$4,
        SECONDS_PER_HOUR: SECONDS_PER_HOUR,
        default: profitConstants
    });

    /**
     * Profit Calculation Helpers
     * Pure functions for profit/rate calculations used across features
     *
     * These functions consolidate duplicated calculations from:
     * - profit-calculator.js
     * - gathering-profit.js
     * - task-profit-calculator.js
     * - action-time-display.js
     * - tooltip-prices.js
     */


    /**
     * Calculate actions per hour from action time
     * @param {number} actionTimeSeconds - Time per action in seconds
     * @returns {number} Actions per hour (0 if invalid input)
     *
     * @example
     * calculateActionsPerHour(6) // Returns 600 (3600 / 6)
     * calculateActionsPerHour(0) // Returns 0 (invalid)
     */
    function calculateActionsPerHour(actionTimeSeconds) {
        if (!actionTimeSeconds || actionTimeSeconds <= 0) {
            return 0;
        }
        return SECONDS_PER_HOUR / actionTimeSeconds;
    }

    /**
     * Calculate hours needed for a number of actions
     * @param {number} actionCount - Number of queued actions
     * @param {number} actionsPerHour - Actions per hour rate
     * @returns {number} Hours needed (0 if invalid input)
     *
     * @example
     * calculateHoursForActions(600, 600) // Returns 1
     * calculateHoursForActions(1200, 600) // Returns 2
     */
    function calculateHoursForActions(actionCount, actionsPerHour) {
        if (!actionsPerHour || actionsPerHour <= 0) {
            return 0;
        }
        return actionCount / actionsPerHour;
    }

    /**
     * Calculate seconds needed for a number of actions
     * @param {number} actionCount - Number of queued actions
     * @param {number} actionsPerHour - Actions per hour rate
     * @returns {number} Seconds needed (0 if invalid input)
     *
     * @example
     * calculateSecondsForActions(100, 600) // Returns 600 (100/600 * 3600)
     */
    function calculateSecondsForActions(actionCount, actionsPerHour) {
        return calculateHoursForActions(actionCount, actionsPerHour) * SECONDS_PER_HOUR;
    }

    /**
     * Calculate profit per action from hourly profit data
     *
     * IMPORTANT: This assumes profitPerHour already includes efficiency.
     * The formula works because:
     * - profitPerHour = actionsPerHour × efficiencyMultiplier × profitPerItem
     * - profitPerHour / actionsPerHour = efficiencyMultiplier × profitPerItem
     * - This gives profit per ATTEMPT (what the queue shows)
     *
     * @param {number} profitPerHour - Profit per hour (includes efficiency)
     * @param {number} actionsPerHour - Base actions per hour (without efficiency)
     * @returns {number} Profit per action (0 if invalid input)
     *
     * @example
     * // With 150% efficiency (2.5x), 600 actions/hr, 50 profit/item:
     * // profitPerHour = 600 × 2.5 × 50 = 75,000
     * calculateProfitPerAction(75000, 600) // Returns 125 (profit per action)
     */
    function calculateProfitPerAction(profitPerHour, actionsPerHour) {
        if (!actionsPerHour || actionsPerHour <= 0) {
            return 0;
        }
        return profitPerHour / actionsPerHour;
    }

    /**
     * Calculate total profit for a number of actions
     *
     * @param {number} profitPerHour - Profit per hour (includes efficiency)
     * @param {number} actionsPerHour - Base actions per hour (without efficiency)
     * @param {number} actionCount - Number of queued actions
     * @returns {number} Total profit (0 if invalid input)
     *
     * @example
     * // Queue shows "Produce 100 times" with 75,000 profit/hr and 600 actions/hr
     * calculateTotalProfitForActions(75000, 600, 100) // Returns 12,500
     */
    function calculateTotalProfitForActions(profitPerHour, actionsPerHour, actionCount) {
        const profitPerAction = calculateProfitPerAction(profitPerHour, actionsPerHour);
        return profitPerAction * actionCount;
    }

    /**
     * Calculate profit per day from hourly profit
     * @param {number} profitPerHour - Profit per hour
     * @returns {number} Profit per day
     *
     * @example
     * calculateProfitPerDay(10000) // Returns 240,000
     */
    function calculateProfitPerDay(profitPerHour) {
        return profitPerHour * HOURS_PER_DAY;
    }

    /**
     * Calculate drink consumption rate with Drink Concentration
     * @param {number} drinkConcentration - Drink Concentration stat as decimal (e.g., 0.15 for 15%)
     * @returns {number} Drinks consumed per hour
     *
     * @example
     * calculateDrinksPerHour(0)    // Returns 12 (base rate)
     * calculateDrinksPerHour(0.15) // Returns 13.8 (12 × 1.15)
     */
    function calculateDrinksPerHour(drinkConcentration = 0) {
        return DRINKS_PER_HOUR_BASE * (1 + drinkConcentration);
    }

    /**
     * Calculate tea consumption costs per hour
     * @param {Object} params - Tea cost inputs
     * @param {Array} params.drinkSlots - Equipped drink slots
     * @param {number} params.drinkConcentration - Drink Concentration stat as decimal
     * @param {Object} params.itemDetailMap - Item detail map for names
     * @param {Function} params.getItemPrice - Price resolver function
     * @returns {Object} Tea costs breakdown
     */
    function calculateTeaCostsPerHour({
        drinkSlots = [],
        drinkConcentration = 0,
        itemDetailMap = {},
        getItemPrice,
    }) {
        if (!Array.isArray(drinkSlots) || drinkSlots.length === 0) {
            return {
                costs: [],
                totalCostPerHour: 0,
                hasMissingPrices: false,
                drinksPerHour: calculateDrinksPerHour(drinkConcentration),
            };
        }

        const drinksPerHour = calculateDrinksPerHour(drinkConcentration);

        const costs = drinkSlots.reduce((entries, drink) => {
            if (!drink || !drink.itemHrid) {
                return entries;
            }

            const itemDetails = itemDetailMap[drink.itemHrid];
            const itemName = itemDetails?.name || 'Unknown';
            const price =
                typeof getItemPrice === 'function'
                    ? getItemPrice(drink.itemHrid, { context: 'profit', side: 'buy' })
                    : null;
            const isPriceMissing = price === null;
            const resolvedPrice = isPriceMissing ? 0 : price;
            const totalCost = resolvedPrice * drinksPerHour;

            entries.push({
                itemHrid: drink.itemHrid,
                itemName,
                pricePerDrink: resolvedPrice,
                drinksPerHour,
                totalCost,
                missingPrice: isPriceMissing,
            });

            return entries;
        }, []);

        const totalCostPerHour = costs.reduce((sum, entry) => sum + entry.totalCost, 0);
        const hasMissingPrices = costs.some((entry) => entry.missingPrice);

        return {
            costs,
            totalCostPerHour,
            hasMissingPrices,
            drinksPerHour,
        };
    }

    /**
     * Calculate price after marketplace tax
     * @param {number} price - Price before tax
     * @param {number} [taxRate=MARKET_TAX] - Tax rate (e.g., 0.02 for 2%)
     * @returns {number} Price after tax deduction
     *
     * @example
     * calculatePriceAfterTax(100) // Returns 98
     */
    function calculatePriceAfterTax(price, taxRate = MARKET_TAX) {
        return price * (1 - taxRate);
    }

    /**
     * Calculate action-based totals for production actions
     * Uses per-action base inputs (efficiency only affects time)
     *
     * @param {Object} params - Calculation parameters
     * @param {number} params.actionsCount - Number of queued actions
     * @param {number} params.actionsPerHour - Base actions per hour
     * @param {number} params.outputAmount - Items produced per action
     * @param {number} params.outputPrice - Output price per item (pre-tax)
     * @param {number} params.gourmetBonus - Gourmet bonus as decimal (e.g., 0.1 for 10%)
     * @param {Array} [params.bonusDrops] - Bonus drop entries with revenuePerAction
     * @param {Array} [params.materialCosts] - Material cost entries per action
     * @param {number} params.totalTeaCostPerHour - Tea cost per hour
     * @param {number} [params.efficiencyMultiplier=1] - Efficiency multiplier for time scaling
     * @returns {Object} Totals and time values
     */
    function calculateProductionActionTotalsFromBase({
        actionsCount,
        actionsPerHour,
        outputAmount,
        outputPrice,
        gourmetBonus,
        bonusDrops = [],
        materialCosts = [],
        totalTeaCostPerHour,
        efficiencyMultiplier = 1,
    }) {
        const effectiveActionsPerHour = actionsPerHour * efficiencyMultiplier;
        if (!effectiveActionsPerHour || effectiveActionsPerHour <= 0) {
            return {
                totalBaseItems: 0,
                totalGourmetItems: 0,
                totalBaseRevenue: 0,
                totalGourmetRevenue: 0,
                totalBonusRevenue: 0,
                totalRevenue: 0,
                totalMarketTax: 0,
                totalMaterialCost: 0,
                totalTeaCost: 0,
                totalCosts: 0,
                totalProfit: 0,
                hoursNeeded: 0,
            };
        }
        const totalBaseItems = outputAmount * actionsCount;
        const totalGourmetItems = outputAmount * gourmetBonus * actionsCount;
        const totalBaseRevenue = totalBaseItems * outputPrice;
        const totalGourmetRevenue = totalGourmetItems * outputPrice;
        const totalBonusRevenue = bonusDrops.reduce((sum, drop) => sum + (drop.revenuePerAction || 0) * actionsCount, 0);
        const totalRevenue = totalBaseRevenue + totalGourmetRevenue + totalBonusRevenue;
        const totalMarketTax = totalRevenue * MARKET_TAX;
        const totalMaterialCost = materialCosts.reduce((sum, material) => sum + material.totalCost * actionsCount, 0);
        const hoursNeeded = calculateHoursForActions(actionsCount, effectiveActionsPerHour);
        const totalTeaCost = totalTeaCostPerHour * hoursNeeded;
        const totalCosts = totalMaterialCost + totalTeaCost + totalMarketTax;
        const totalProfit = totalRevenue - totalCosts;

        return {
            totalBaseItems,
            totalGourmetItems,
            totalBaseRevenue,
            totalGourmetRevenue,
            totalBonusRevenue,
            totalRevenue,
            totalMarketTax,
            totalMaterialCost,
            totalTeaCost,
            totalCosts,
            totalProfit,
            hoursNeeded,
        };
    }

    /**
     * Calculate action-based totals for gathering actions
     * Uses per-action base inputs (efficiency only affects time)
     *
     * @param {Object} params - Calculation parameters
     * @param {number} params.actionsCount - Number of queued actions
     * @param {number} params.actionsPerHour - Base actions per hour
     * @param {Array} [params.baseOutputs] - Base outputs with revenuePerAction
     * @param {Array} [params.bonusDrops] - Bonus drop entries with revenuePerAction
     * @param {number} params.processingRevenueBonusPerAction - Processing bonus per action
     * @param {number} params.gourmetRevenueBonusPerAction - Gourmet bonus revenue per action
     * @param {number} params.drinkCostPerHour - Drink costs per hour
     * @param {number} [params.efficiencyMultiplier=1] - Efficiency multiplier for time scaling
     * @returns {Object} Totals and time values
     */
    function calculateGatheringActionTotalsFromBase({
        actionsCount,
        actionsPerHour,
        baseOutputs = [],
        bonusDrops = [],
        processingRevenueBonusPerAction,
        gourmetRevenueBonusPerAction,
        drinkCostPerHour,
        efficiencyMultiplier = 1,
    }) {
        const effectiveActionsPerHour = actionsPerHour * efficiencyMultiplier;
        if (!effectiveActionsPerHour || effectiveActionsPerHour <= 0) {
            return {
                totalBaseRevenue: 0,
                totalBonusRevenue: 0,
                totalProcessingRevenue: 0,
                totalGourmetRevenue: 0,
                totalRevenue: 0,
                totalMarketTax: 0,
                totalDrinkCost: 0,
                totalCosts: 0,
                totalProfit: 0,
                hoursNeeded: 0,
            };
        }
        const totalBaseRevenue = baseOutputs.reduce(
            (sum, output) => sum + (output.revenuePerAction || 0) * actionsCount,
            0
        );
        const totalBonusRevenue = bonusDrops.reduce((sum, drop) => sum + (drop.revenuePerAction || 0) * actionsCount, 0);
        const totalProcessingRevenue = (processingRevenueBonusPerAction || 0) * actionsCount;
        const totalGourmetRevenue = (gourmetRevenueBonusPerAction || 0) * actionsCount;
        const totalRevenue = totalBaseRevenue + totalGourmetRevenue + totalBonusRevenue + totalProcessingRevenue;
        const totalMarketTax = totalRevenue * MARKET_TAX;
        const hoursNeeded = calculateHoursForActions(actionsCount, effectiveActionsPerHour);
        const totalDrinkCost = drinkCostPerHour * hoursNeeded;
        const totalCosts = totalDrinkCost + totalMarketTax;
        const totalProfit = totalRevenue - totalCosts;

        return {
            totalBaseRevenue,
            totalBonusRevenue,
            totalProcessingRevenue,
            totalGourmetRevenue,
            totalRevenue,
            totalMarketTax,
            totalDrinkCost,
            totalCosts,
            totalProfit,
            hoursNeeded,
        };
    }

    var profitHelpers = {
        // Rate conversions
        calculateActionsPerHour,
        calculateHoursForActions,
        calculateSecondsForActions,

        // Profit
        calculateProfitPerAction,
        calculateTotalProfitForActions,
        calculateProfitPerDay,

        // Costs
        calculateDrinksPerHour,
        calculateTeaCostsPerHour,
        calculatePriceAfterTax,

        calculateProductionActionTotalsFromBase,
        calculateGatheringActionTotalsFromBase,
    };

    var profitHelpers$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateActionsPerHour: calculateActionsPerHour,
        calculateDrinksPerHour: calculateDrinksPerHour,
        calculateGatheringActionTotalsFromBase: calculateGatheringActionTotalsFromBase,
        calculateHoursForActions: calculateHoursForActions,
        calculatePriceAfterTax: calculatePriceAfterTax,
        calculateProductionActionTotalsFromBase: calculateProductionActionTotalsFromBase,
        calculateProfitPerAction: calculateProfitPerAction,
        calculateProfitPerDay: calculateProfitPerDay,
        calculateSecondsForActions: calculateSecondsForActions,
        calculateTeaCostsPerHour: calculateTeaCostsPerHour,
        calculateTotalProfitForActions: calculateTotalProfitForActions,
        default: profitHelpers
    });

    /**
     * DOM Utilities Module
     * Helpers for DOM manipulation and element creation
     */


    // Compiled regex pattern (created once, reused for performance)
    const REGEX_TRANSFORM3D = /translate3d\(([^,]+),\s*([^,]+),\s*([^)]+)\)/;

    /**
     * Wait for an element to appear in the DOM
     * @param {string} selector - CSS selector
     * @param {number} timeout - Max wait time in ms (default: 10000)
     * @param {number} interval - Check interval in ms (default: 100)
     * @returns {Promise<Element|null>} The element or null if timeout
     */
    function waitForElement(selector, timeout = 10000, interval = 100) {
        return new Promise((resolve) => {
            const startTime = Date.now();

            const check = () => {
                const element = document.querySelector(selector);

                if (element) {
                    resolve(element);
                } else if (Date.now() - startTime >= timeout) {
                    console.warn(`[DOM] Timeout waiting for: ${selector}`);
                    resolve(null);
                } else {
                    setTimeout(check, interval);
                }
            };

            check();
        });
    }

    /**
     * Wait for multiple elements to appear
     * @param {string} selector - CSS selector
     * @param {number} minCount - Minimum number of elements to wait for (default: 1)
     * @param {number} timeout - Max wait time in ms (default: 10000)
     * @returns {Promise<NodeList|null>} The elements or null if timeout
     */
    function waitForElements(selector, minCount = 1, timeout = 10000) {
        return new Promise((resolve) => {
            const startTime = Date.now();

            const check = () => {
                const elements = document.querySelectorAll(selector);

                if (elements.length >= minCount) {
                    resolve(elements);
                } else if (Date.now() - startTime >= timeout) {
                    console.warn(`[DOM] Timeout waiting for ${minCount}× ${selector}`);
                    resolve(null);
                } else {
                    setTimeout(check, 100);
                }
            };

            check();
        });
    }

    /**
     * Create a styled div element
     * @param {Object} styles - CSS styles object
     * @param {string} text - Optional text content
     * @param {string} className - Optional class name
     * @returns {HTMLDivElement} Created div
     */
    function createStyledDiv(styles = {}, text = '', className = '') {
        const div = document.createElement('div');

        if (className) {
            div.className = className;
        }

        if (text) {
            div.textContent = text;
        }

        Object.assign(div.style, styles);

        return div;
    }

    /**
     * Create a styled span element
     * @param {Object} styles - CSS styles object
     * @param {string} text - Text content
     * @param {string} className - Optional class name
     * @returns {HTMLSpanElement} Created span
     */
    function createStyledSpan(styles = {}, text = '', className = '') {
        const span = document.createElement('span');

        if (className) {
            span.className = className;
        }

        if (text) {
            span.textContent = text;
        }

        Object.assign(span.style, styles);

        return span;
    }

    /**
     * Create a colored text span (uses script colors from config)
     * @param {string} text - Text content
     * @param {string} colorType - 'main', 'tooltip', or 'alert' (default: 'main')
     * @returns {HTMLSpanElement} Created span with color
     */
    function createColoredText(text, colorType = 'main') {
        let color;

        switch (colorType) {
            case 'main':
                color = config$1.SCRIPT_COLOR_MAIN;
                break;
            case 'tooltip':
                color = config$1.SCRIPT_COLOR_TOOLTIP;
                break;
            case 'alert':
                color = config$1.SCRIPT_COLOR_ALERT;
                break;
            default:
                color = config$1.SCRIPT_COLOR_MAIN;
        }

        return createStyledSpan({ color }, text);
    }

    /**
     * Insert element before another element
     * @param {Element} newElement - Element to insert
     * @param {Element} referenceElement - Element to insert before
     */
    function insertBefore(newElement, referenceElement) {
        if (!referenceElement?.parentNode) {
            console.warn('[DOM] Cannot insert: reference element has no parent');
            return;
        }

        referenceElement.parentNode.insertBefore(newElement, referenceElement);
    }

    /**
     * Insert element after another element
     * @param {Element} newElement - Element to insert
     * @param {Element} referenceElement - Element to insert after
     */
    function insertAfter(newElement, referenceElement) {
        if (!referenceElement?.parentNode) {
            console.warn('[DOM] Cannot insert: reference element has no parent');
            return;
        }

        referenceElement.parentNode.insertBefore(newElement, referenceElement.nextSibling);
    }

    /**
     * Remove all elements matching selector
     * @param {string} selector - CSS selector
     * @returns {number} Number of elements removed
     */
    function removeElements(selector) {
        const elements = document.querySelectorAll(selector);
        elements.forEach((el) => el.parentNode?.removeChild(el));
        return elements.length;
    }

    /**
     * Get original text from element (strips our injected content)
     * @param {Element} element - Element to get text from
     * @returns {string} Original text content
     */
    function getOriginalText(element) {
        if (!element) return '';

        // Clone element to avoid modifying original
        const clone = element.cloneNode(true);

        // Remove inserted spans/divs (our injected content)
        clone.querySelectorAll('.insertedSpan, .script-injected').forEach((el) => el.remove());

        return clone.textContent.trim();
    }

    /**
     * Add CSS to page
     * @param {string} css - CSS rules to add
     * @param {string} id - Optional style element ID (for removal later)
     */
    function addStyles(css, id = '') {
        const style = document.createElement('style');

        if (id) {
            style.id = id;
        }

        style.textContent = css;
        document.head.appendChild(style);
    }

    /**
     * Remove CSS by ID
     * @param {string} id - Style element ID to remove
     */
    function removeStyles(id) {
        const style = document.getElementById(id);
        if (style) {
            style.remove();
        }
    }

    /**
     * Dismiss all open MUI tooltips by dispatching mouseleave events
     * Useful when DOM elements are reordered (e.g., sorting action panels)
     * which can cause tooltips to get "stuck" since no natural mouseleave fires
     */
    function dismissTooltips() {
        const tooltips = document.querySelectorAll('.MuiTooltip-popper');
        tooltips.forEach((tooltip) => {
            // Find the element that triggered this tooltip and dispatch mouseleave
            // MUI tooltips listen for mouseleave on the trigger element
            const triggerId = tooltip.id?.replace('-tooltip', '');
            if (triggerId) {
                const trigger = document.querySelector(`[aria-describedby="${tooltip.id}"]`);
                if (trigger) {
                    if (trigger.matches(':hover')) {
                        return;
                    }
                    trigger.dispatchEvent(new MouseEvent('mouseleave', { bubbles: true }));
                    trigger.dispatchEvent(new MouseEvent('mouseout', { bubbles: true }));
                }
            }
        });
    }

    /**
     * Set up scroll listener to dismiss tooltips when scrolling
     * Prevents tooltips from getting stuck when scrolling quickly
     * @returns {Function} Cleanup function to remove the listener
     */
    function setupScrollTooltipDismissal$1() {
        let scrollTimeout = null;
        let lastUserScrollTime = 0;
        const USER_SCROLL_WINDOW_MS = 200;

        const markUserScroll = () => {
            lastUserScrollTime = Date.now();
        };

        const handleUserKeyScroll = (event) => {
            const key = event.key;
            if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'PageUp' || key === 'PageDown' || key === ' ') {
                markUserScroll();
            }
        };

        const handleScroll = (event) => {
            const target = event.target;
            if (target?.closest?.('.MuiTooltip-tooltip, .MuiTooltip-popper')) {
                return;
            }

            if (Date.now() - lastUserScrollTime > USER_SCROLL_WINDOW_MS) {
                return;
            }

            // Early exit: skip if no tooltips are visible
            if (!document.querySelector('.MuiTooltip-popper')) {
                return;
            }

            // Debounce: only dismiss after scrolling stops for 50ms
            // This prevents excessive calls during continuous scrolling
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            scrollTimeout = setTimeout(() => {
                dismissTooltips();
                scrollTimeout = null;
            }, 50);
        };

        // Listen on document with capture to catch all scroll events
        // (including scrolls in nested containers)
        document.addEventListener('scroll', handleScroll, { capture: true, passive: true });

        // Track user-driven scrolling intent
        document.addEventListener('wheel', markUserScroll, { capture: true, passive: true });
        document.addEventListener('touchmove', markUserScroll, { capture: true, passive: true });
        document.addEventListener('keydown', handleUserKeyScroll, { capture: true });

        // Return cleanup function
        return () => {
            document.removeEventListener('scroll', handleScroll, { capture: true });
            document.removeEventListener('wheel', markUserScroll, { capture: true });
            document.removeEventListener('touchmove', markUserScroll, { capture: true });
            document.removeEventListener('keydown', handleUserKeyScroll, { capture: true });
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
        };
    }

    /**
     * Fix tooltip overflow to ensure it stays within viewport
     * @param {Element} tooltipElement - The tooltip popper element
     */
    function fixTooltipOverflow(tooltipElement) {
        // Use triple requestAnimationFrame to ensure MUI positioning is complete
        // Frame 1: MUI does initial positioning
        // Frame 2: Content finishes rendering (especially for long lists)
        // Frame 3: We check and fix overflow
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (!tooltipElement.isConnected) {
                        return; // Tooltip already removed
                    }

                    const bBox = tooltipElement.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;

                    // Find the actual tooltip content element (child of popper)
                    const tooltipContent = tooltipElement.querySelector('.MuiTooltip-tooltip');

                    // Check if tooltip extends beyond viewport
                    if (bBox.top < 0 || bBox.bottom > viewportHeight) {
                        // Get current transform
                        const transformString = tooltipElement.style.transform;

                        if (transformString) {
                            // Parse transform3d(x, y, z)
                            const match = transformString.match(REGEX_TRANSFORM3D);

                            if (match) {
                                const x = match[1];
                                const currentY = parseFloat(match[2]);
                                const z = match[3];

                                // Calculate how much to adjust Y
                                let newY;

                                if (bBox.height >= viewportHeight - 20) {
                                    // Tooltip is taller than viewport - position at top
                                    newY = 0;

                                    // Force max-height on the tooltip content to enable scrolling
                                    if (tooltipContent) {
                                        tooltipContent.style.maxHeight = `${viewportHeight - 20}px`;
                                        tooltipContent.style.overflowY = 'auto';
                                    }
                                } else if (bBox.top < 0) {
                                    // Tooltip extends above viewport - move it down
                                    newY = currentY - bBox.top;
                                } else if (bBox.bottom > viewportHeight) {
                                    // Tooltip extends below viewport - move it up
                                    newY = currentY - (bBox.bottom - viewportHeight) - 10;
                                }

                                if (newY !== undefined) {
                                    // Ensure tooltip never goes above viewport (minimum y=0)
                                    newY = Math.max(0, newY);
                                    tooltipElement.style.transform = `translate3d(${x}, ${newY}px, ${z})`;
                                }
                            }
                        }
                    }
                });
            });
        });
    }

    var dom = {
        waitForElement,
        waitForElements,
        createStyledDiv,
        createStyledSpan,
        createColoredText,
        insertBefore,
        insertAfter,
        removeElements,
        getOriginalText,
        addStyles,
        removeStyles,
        dismissTooltips,
        setupScrollTooltipDismissal: setupScrollTooltipDismissal$1,
        fixTooltipOverflow,
    };

    var dom$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addStyles: addStyles,
        createColoredText: createColoredText,
        createStyledDiv: createStyledDiv,
        createStyledSpan: createStyledSpan,
        default: dom,
        dismissTooltips: dismissTooltips,
        fixTooltipOverflow: fixTooltipOverflow,
        getOriginalText: getOriginalText,
        insertAfter: insertAfter,
        insertBefore: insertBefore,
        removeElements: removeElements,
        removeStyles: removeStyles,
        setupScrollTooltipDismissal: setupScrollTooltipDismissal$1,
        waitForElement: waitForElement,
        waitForElements: waitForElements
    });

    /**
     * DOM Observer Helper Utilities
     * Standardized wrappers around domObserver to reduce boilerplate
     */


    /**
     * Create a singleton observer that automatically prevents duplicate processing
     * Uses an internal WeakSet to track processed elements
     *
     * @param {string} name - Observer name for debugging
     * @param {string|string[]} classNames - Class name(s) to watch for
     * @param {Function} handler - Handler function (receives element)
     * @param {Object} options - Optional configuration
     * @param {boolean} options.debounce - Enable debouncing
     * @param {number} options.debounceDelay - Debounce delay in ms
     * @returns {Function} Unregister function
     *
     * @example
     * // Before (20 lines)
     * this.processedDivs = new WeakSet();
     * this.unregister = domObserver.onClass('MyFeature', 'selector', (elem) => {
     *     if (this.processedDivs.has(elem)) return;
     *     this.processedDivs.add(elem);
     *     // do work
     * });
     *
     * // After (5 lines)
     * this.unregister = createSingletonObserver('MyFeature', 'selector', (elem) => {
     *     // do work (processed flag automatic)
     * });
     */
    function createSingletonObserver(name, classNames, handler, options = {}) {
        const processedElements = new WeakSet();

        return domObserver$1.onClass(
            name,
            classNames,
            (element) => {
                if (processedElements.has(element)) {
                    return;
                }

                // Mark as processed
                processedElements.add(element);

                // Call user handler
                handler(element);
            },
            options
        );
    }

    /**
     * Create a tracked observer that manages cleanup functions for processed elements
     * Uses an internal Map to track element → cleanup function pairs
     * Automatically calls cleanup functions when unregistered
     *
     * @param {string} name - Observer name for debugging
     * @param {string|string[]} classNames - Class name(s) to watch for
     * @param {Function} handler - Handler function (receives element, should return cleanup function or null)
     * @param {Object} options - Optional configuration
     * @param {boolean} options.debounce - Enable debouncing
     * @param {number} options.debounceDelay - Debounce delay in ms
     * @returns {Function} Unregister function (also calls all cleanup functions)
     *
     * @example
     * // Before (15 lines)
     * this.trackedElements = new Map();
     * this.unregister = domObserver.onClass('MyFeature', 'selector', (elem) => {
     *     if (this.trackedElements.has(elem)) return;
     *     const cleanup = attachListeners(...);
     *     this.trackedElements.set(elem, cleanup);
     * });
     *
     * // After (5 lines)
     * this.unregister = createTrackedObserver('MyFeature', 'selector', (elem) => {
     *     return attachListeners(...); // Return cleanup function
     * });
     */
    function createTrackedObserver(name, classNames, handler, options = {}) {
        const trackedElements = new Map();

        const unregister = domObserver$1.onClass(
            name,
            classNames,
            (element) => {
                // Skip if already tracked
                if (trackedElements.has(element)) {
                    return;
                }

                // Call user handler and store cleanup function
                const cleanup = handler(element);
                if (cleanup && typeof cleanup === 'function') {
                    trackedElements.set(element, cleanup);
                } else {
                    // Mark as tracked even if no cleanup function returned
                    trackedElements.set(element, null);
                }
            },
            options
        );

        // Return enhanced unregister that also calls all cleanup functions
        return () => {
            // Call all cleanup functions
            for (const [_element, cleanup] of trackedElements.entries()) {
                if (cleanup && typeof cleanup === 'function') {
                    try {
                        cleanup();
                    } catch (error) {
                        console.error(`[DOM Observer Helpers] Cleanup error for ${name}:`, error);
                    }
                }
            }

            // Clear tracked elements
            trackedElements.clear();

            unregister();
        };
    }

    /**
     * Create a simplified MutationObserver with automatic cleanup
     * Wrapper around native MutationObserver that returns unwatch function
     *
     * @param {Element} element - Element to observe
     * @param {Function} callback - Callback function (receives mutations, observer)
     * @param {Object} options - MutationObserver options (default: { childList: true, subtree: true })
     * @returns {Function} Unwatch function (disconnects observer)
     *
     * @example
     * // Before (25 lines)
     * let observer = null;
     * const cleanup = () => {
     *     if (observer) {
     *         observer.disconnect();
     *         observer = null;
     *     }
     * };
     * observer = new MutationObserver(() => { ... });
     * observer.observe(element, { childList: true });
     *
     * // After (5 lines)
     * const unwatch = createMutationWatcher(element, () => {
     *     // callback
     * }, { childList: true });
     */
    function createMutationWatcher(element, callback, options = null) {
        if (!element) {
            console.warn('[DOM Observer Helpers] createMutationWatcher called with null element');
            return () => {}; // Return no-op unwatch function
        }

        // Default options
        const observerOptions = options || {
            childList: true,
            subtree: true,
        };

        const observer = new MutationObserver((mutations) => {
            callback(mutations, observer);
        });

        observer.observe(element, observerOptions);

        // Return unwatch function
        return () => {
            observer.disconnect();
        };
    }

    /**
     * Create a persistent display helper
     * Handles cleanup and re-creation of DOM elements on re-render
     *
     * @param {string} name - Helper name for debugging
     * @param {string|string[]} classNames - Class name(s) to watch for
     * @param {Function} createFn - Function to create display element (receives container)
     * @param {Object} options - Optional configuration
     * @param {boolean} options.debounce - Enable debouncing
     * @param {number} options.debounceDelay - Debounce delay in ms
     * @returns {Function} Unregister function
     *
     * @example
     * this.unregister = createPersistentDisplay(
     *     'MyDisplay',
     *     'container-class',
     *     (container) => {
     *         const display = document.createElement('div');
     *         display.className = 'my-display';
     *         display.textContent = 'Hello';
     *         container.appendChild(display);
     *     }
     * );
     */
    function createPersistentDisplay(name, classNames, createFn, options = {}) {
        return createSingletonObserver(
            name,
            classNames,
            (container) => {
                try {
                    createFn(container);
                } catch (error) {
                    console.error(`[DOM Observer Helpers] createPersistentDisplay error for ${name}:`, error);
                }
            },
            options
        );
    }

    var domObserverHelpers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createMutationWatcher: createMutationWatcher,
        createPersistentDisplay: createPersistentDisplay,
        createSingletonObserver: createSingletonObserver,
        createTrackedObserver: createTrackedObserver
    });

    /**
     * Timer Registry Utility
     * Centralized registration for intervals and timeouts.
     */

    /**
     * Create a timer registry for deterministic teardown.
     * @returns {{
     *   registerInterval: (intervalId: number) => void,
     *   registerTimeout: (timeoutId: number) => void,
     *   clearAll: () => void
     * }} Timer registry API
     */
    function createTimerRegistry() {
        const intervals = [];
        const timeouts = [];

        const registerInterval = (intervalId) => {
            if (!intervalId) {
                console.warn('[TimerRegistry] registerInterval called with invalid interval id');
                return;
            }

            intervals.push(intervalId);
        };

        const registerTimeout = (timeoutId) => {
            if (!timeoutId) {
                console.warn('[TimerRegistry] registerTimeout called with invalid timeout id');
                return;
            }

            timeouts.push(timeoutId);
        };

        const clearAll = () => {
            intervals.forEach((intervalId) => {
                try {
                    clearInterval(intervalId);
                } catch (error) {
                    console.error('[TimerRegistry] Failed to clear interval:', error);
                }
            });
            intervals.length = 0;

            timeouts.forEach((timeoutId) => {
                try {
                    clearTimeout(timeoutId);
                } catch (error) {
                    console.error('[TimerRegistry] Failed to clear timeout:', error);
                }
            });
            timeouts.length = 0;
        };

        return {
            registerInterval,
            registerTimeout,
            clearAll,
        };
    }

    var timerRegistry$3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createTimerRegistry: createTimerRegistry
    });

    /**
     * Token Valuation Utility
     * Shared logic for calculating dungeon token and task token values
     */


    /**
     * Calculate dungeon token value based on best shop item value
     * Uses "best market value per token" approach: finds the shop item with highest (market price / token cost)
     * @param {string} tokenHrid - Token HRID (e.g., '/items/chimerical_token')
     * @param {string} pricingModeSetting - Config setting key for pricing mode (default: 'profitCalc_pricingMode')
     * @param {string} respectModeSetting - Config setting key for respect pricing mode flag (default: 'expectedValue_respectPricingMode')
     * @returns {number|null} Value per token, or null if no data
     */
    function calculateDungeonTokenValue(
        tokenHrid,
        pricingModeSetting = 'profitCalc_pricingMode',
        respectModeSetting = 'expectedValue_respectPricingMode'
    ) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return null;

        // Get all shop items for this token type
        const shopItems = Object.values(gameData.shopItemDetailMap || {}).filter(
            (item) => item.costs && item.costs[0]?.itemHrid === tokenHrid
        );

        if (shopItems.length === 0) return null;

        let bestValuePerToken = 0;

        // For each shop item, calculate market price / token cost
        for (const shopItem of shopItems) {
            const itemHrid = shopItem.itemHrid;
            const tokenCost = shopItem.costs[0].count;

            // Get market price for this item
            const prices = marketAPI.getPrice(itemHrid, 0);
            if (!prices) continue;

            // Use pricing mode to determine which price to use
            const pricingMode = config$1.getSettingValue(pricingModeSetting, 'conservative');
            const respectPricingMode = config$1.getSettingValue(respectModeSetting, true);

            let marketPrice = 0;
            if (respectPricingMode) {
                // Conservative: Bid, Hybrid/Optimistic: Ask
                marketPrice = pricingMode === 'conservative' ? prices.bid : prices.ask;
            } else {
                // Always conservative
                marketPrice = prices.bid;
            }

            if (marketPrice <= 0) continue;

            // Calculate value per token
            const valuePerToken = marketPrice / tokenCost;

            // Keep track of best value
            if (valuePerToken > bestValuePerToken) {
                bestValuePerToken = valuePerToken;
            }
        }

        // Fallback to essence price if no shop items found
        if (bestValuePerToken === 0) {
            const essenceMap = {
                '/items/chimerical_token': '/items/chimerical_essence',
                '/items/sinister_token': '/items/sinister_essence',
                '/items/enchanted_token': '/items/enchanted_essence',
                '/items/pirate_token': '/items/pirate_essence',
            };

            const essenceHrid = essenceMap[tokenHrid];
            if (essenceHrid) {
                const essencePrice = marketAPI.getPrice(essenceHrid, 0);
                if (essencePrice) {
                    const pricingMode = config$1.getSettingValue(pricingModeSetting, 'conservative');
                    const respectPricingMode = config$1.getSettingValue(respectModeSetting, true);

                    let marketPrice = 0;
                    if (respectPricingMode) {
                        marketPrice = pricingMode === 'conservative' ? essencePrice.bid : essencePrice.ask;
                    } else {
                        marketPrice = essencePrice.bid;
                    }

                    return marketPrice > 0 ? marketPrice : null;
                }
            }
        }

        return bestValuePerToken > 0 ? bestValuePerToken : null;
    }

    /**
     * Calculate task token value based on best chest expected value
     * @returns {number} Value per token, or 0 if no data
     */
    function calculateTaskTokenValue$1() {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return 0;

        // Get all chest items (Large Artisan's Crate, Large Meteorite Cache, Large Treasure Chest)
        const chestHrids = ['/items/large_artisans_crate', '/items/large_meteorite_cache', '/items/large_treasure_chest'];

        const bestChestValue = 0;

        for (const chestHrid of chestHrids) {
            const itemDetails = dataManager$1.getItemDetails(chestHrid);
            if (!itemDetails || !itemDetails.isOpenable) continue;

            // Calculate expected value for this chest
            // Note: This would require expectedValueCalculator, but to avoid circular dependency,
            // we'll let the caller handle this or import it locally where needed
            // For now, return 0 as placeholder
        }

        // Task Token cost for chests is 30
        const tokenCost = 30;

        return bestChestValue / tokenCost;
    }

    var tokenValuation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateDungeonTokenValue: calculateDungeonTokenValue,
        calculateTaskTokenValue: calculateTaskTokenValue$1
    });

    /**
     * Market Data Utility
     * Centralized access to market prices with smart pricing mode handling
     */


    // Track logged warnings to prevent console spam
    const loggedWarnings = new Set();

    /**
     * Get item price based on pricing mode and context
     * @param {string} itemHrid - Item HRID
     * @param {Object} options - Configuration options
     * @param {number} [options.enhancementLevel=0] - Enhancement level
     * @param {string} [options.mode] - Pricing mode ('ask'|'bid'|'average'). If not provided, uses context or user settings
     * @param {string} [options.context] - Context hint ('profit'|'networth'|null). Used to determine pricing mode from settings
     * @param {string} [options.side='sell'] - Transaction side ('buy'|'sell') - used with 'profit' context to determine correct price
     * @returns {number|null} Price in gold, or null if no market data
     */
    function getItemPrice(itemHrid, options = {}) {
        // Validate inputs
        if (!itemHrid || typeof itemHrid !== 'string') {
            return null;
        }

        // Handle case where someone passes enhancementLevel as second arg (old API)
        if (typeof options === 'number') {
            options = { enhancementLevel: options };
        }

        // Ensure options is an object
        if (typeof options !== 'object' || options === null) {
            options = {};
        }

        const { enhancementLevel = 0, mode, context, side = 'sell' } = options;

        // Get raw price data from API
        const priceData = marketAPI.getPrice(itemHrid, enhancementLevel);

        if (!priceData) {
            return null;
        }

        // Determine pricing mode
        const pricingMode = mode || getPricingMode(context, side);

        // Validate pricing mode
        const validModes = ['ask', 'bid', 'average'];
        if (!validModes.includes(pricingMode)) {
            const warningKey = `mode:${pricingMode}`;
            if (!loggedWarnings.has(warningKey)) {
                console.warn(`[Market Data] Unknown pricing mode: ${pricingMode}, defaulting to ask`);
                loggedWarnings.add(warningKey);
            }
            return priceData.ask || 0;
        }

        const resolvePrice = (value) => {
            if (typeof value !== 'number') {
                return null;
            }

            if (value < 0) {
                return null;
            }

            return value;
        };

        // Return price based on mode
        switch (pricingMode) {
            case 'ask':
                return resolvePrice(priceData.ask);
            case 'bid':
                return resolvePrice(priceData.bid);
            case 'average':
                if (typeof priceData.ask !== 'number' || typeof priceData.bid !== 'number') {
                    return null;
                }

                if (priceData.ask < 0 || priceData.bid < 0) {
                    return null;
                }

                return (priceData.ask + priceData.bid) / 2;
            default:
                return resolvePrice(priceData.ask);
        }
    }

    /**
     * Get all price variants for an item
     * @param {string} itemHrid - Item HRID
     * @param {number} [enhancementLevel=0] - Enhancement level
     * @returns {Object|null} Object with {ask, bid, average} or null if no market data
     */
    function getItemPrices(itemHrid, enhancementLevel = 0) {
        const priceData = marketAPI.getPrice(itemHrid, enhancementLevel);

        if (!priceData) {
            return null;
        }

        return {
            ask: priceData.ask,
            bid: priceData.bid,
            average: (priceData.ask + priceData.bid) / 2,
        };
    }

    /**
     * Format price with K/M/B suffixes
     * @param {number} amount - Amount to format
     * @param {Object} options - Formatting options
     * @param {number} [options.decimals=1] - Number of decimal places
     * @param {boolean} [options.showZero=true] - Whether to show '0' for zero values
     * @returns {string} Formatted price string
     */
    function formatPrice(amount, options = {}) {
        const { decimals = 1, showZero = true } = options;

        if (amount === null || amount === undefined) {
            return '--';
        }

        if (amount === 0) {
            return showZero ? '0' : '--';
        }

        const absAmount = Math.abs(amount);
        const sign = amount < 0 ? '-' : '';

        if (absAmount >= 1_000_000_000) {
            return `${sign}${(absAmount / 1_000_000_000).toFixed(decimals)}B`;
        } else if (absAmount >= 1_000_000) {
            return `${sign}${(absAmount / 1_000_000).toFixed(decimals)}M`;
        } else if (absAmount >= 1_000) {
            return `${sign}${(absAmount / 1_000).toFixed(decimals)}K`;
        } else {
            return `${sign}${absAmount.toFixed(decimals)}`;
        }
    }

    /**
     * Determine pricing mode from context and user settings
     * @param {string} [context] - Context hint ('profit'|'networth'|null)
     * @param {string} [side='sell'] - Transaction side ('buy'|'sell') - used with 'profit' context
     * @returns {string} Pricing mode ('ask'|'bid'|'average')
     */
    function getPricingMode(context, side = 'sell') {
        // If no context, default to 'ask'
        if (!context) {
            return 'ask';
        }

        // Validate context is a string
        if (typeof context !== 'string') {
            return 'ask';
        }

        // Get pricing mode from settings based on context
        switch (context) {
            case 'profit': {
                const profitMode = config$1.getSettingValue('profitCalc_pricingMode');

                // Convert profit calculation modes to price types based on transaction side
                // Conservative: Ask/Bid (instant buy materials, instant sell output)
                // Hybrid: Ask/Ask (instant buy materials, patient sell output)
                // Optimistic: Bid/Ask (patient buy materials, patient sell output)
                switch (profitMode) {
                    case 'conservative':
                        return side === 'buy' ? 'ask' : 'bid';
                    case 'hybrid':
                        return 'ask'; // Ask for both buy and sell
                    case 'optimistic':
                        return side === 'buy' ? 'bid' : 'ask';
                    default:
                        return 'ask';
                }
            }
            default: {
                const warningKey = `context:${context}`;
                if (!loggedWarnings.has(warningKey)) {
                    console.warn(`[Market Data] Unknown context: ${context}, defaulting to ask`);
                    loggedWarnings.add(warningKey);
                }
                return 'ask';
            }
        }
    }

    /**
     * Get prices for multiple items in batch
     * @param {Array<{itemHrid: string, enhancementLevel?: number}>} items - Array of items to price
     * @param {Object} options - Configuration options
     * @param {string} [options.mode] - Pricing mode ('ask'|'bid'|'average')
     * @param {string} [options.context] - Context hint ('profit'|'networth'|null)
     * @param {string} [options.side='sell'] - Transaction side ('buy'|'sell')
     * @returns {Map<string, number>} Map of itemHrid+enhancementLevel to price
     */
    function getItemPricesBatch(items, options = {}) {
        const result = new Map();

        for (const item of items) {
            const key = `${item.itemHrid}:${item.enhancementLevel || 0}`;
            const price = getItemPrice(item.itemHrid, {
                enhancementLevel: item.enhancementLevel || 0,
                mode: options.mode,
                context: options.context,
                side: options.side,
            });

            if (price !== null) {
                result.set(key, price);
            }
        }

        return result;
    }

    var marketData = {
        getItemPrice,
        getItemPrices,
        formatPrice,
        getPricingMode,
        getItemPricesBatch,
    };

    var marketData$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        default: marketData,
        formatPrice: formatPrice,
        getItemPrice: getItemPrice,
        getItemPrices: getItemPrices,
        getItemPricesBatch: getItemPricesBatch,
        getPricingMode: getPricingMode
    });

    /**
     * Expected Value Calculator Module
     * Calculates expected value for openable containers
     */


    /**
     * ExpectedValueCalculator class handles EV calculations for openable containers
     */
    class ExpectedValueCalculator {
        constructor() {
            // Constants
            this.MARKET_TAX = 0.02; // 2% marketplace tax
            this.CONVERGENCE_ITERATIONS = 4; // Nested container convergence

            // Cache for container EVs
            this.containerCache = new Map();

            // Special item HRIDs
            this.COIN_HRID = '/items/coin';
            this.COWBELL_HRID = '/items/cowbell';
            this.COWBELL_BAG_HRID = '/items/bag_of_10_cowbells';

            // Dungeon token HRIDs
            this.DUNGEON_TOKENS = [
                '/items/chimerical_token',
                '/items/sinister_token',
                '/items/enchanted_token',
                '/items/pirate_token',
            ];

            // Flag to track if initialized
            this.isInitialized = false;

            // Retry handler reference for cleanup
            this.retryHandler = null;
        }

        /**
         * Initialize the calculator
         * Pre-calculates all openable containers with nested convergence
         */
        async initialize() {
            if (!dataManager$1.getInitClientData()) {
                // Init data not yet available - set up retry on next character update
                if (!this.retryHandler) {
                    this.retryHandler = () => {
                        this.initialize(); // Retry initialization
                    };
                    dataManager$1.on('character_initialized', this.retryHandler);
                }
                return false;
            }

            // Data is available - remove retry handler if it exists
            if (this.retryHandler) {
                dataManager$1.off('character_initialized', this.retryHandler);
                this.retryHandler = null;
            }

            // Wait for market data to load
            if (!marketAPI.isLoaded()) {
                await marketAPI.fetch(true); // Force fresh fetch on init
            }

            // Calculate all containers with 4-iteration convergence for nesting
            this.calculateNestedContainers();

            this.isInitialized = true;

            // Notify listeners that calculator is ready
            dataManager$1.emit('expected_value_initialized', { timestamp: Date.now() });

            return true;
        }

        /**
         * Calculate all containers with nested convergence
         * Iterates 4 times to resolve nested container values
         */
        calculateNestedContainers() {
            const initData = dataManager$1.getInitClientData();
            if (!initData || !initData.openableLootDropMap) {
                return;
            }

            // Get all openable container HRIDs
            const containerHrids = Object.keys(initData.openableLootDropMap);

            // Iterate 4 times for convergence (handles nesting depth)
            for (let iteration = 0; iteration < this.CONVERGENCE_ITERATIONS; iteration++) {
                for (const containerHrid of containerHrids) {
                    // Calculate and cache EV for this container (pass cached initData)
                    const ev = this.calculateSingleContainer(containerHrid, initData);
                    if (ev !== null) {
                        this.containerCache.set(containerHrid, ev);
                    }
                }
            }
        }

        /**
         * Calculate expected value for a single container
         * @param {string} containerHrid - Container item HRID
         * @param {Object} initData - Cached game data (optional, will fetch if not provided)
         * @returns {number|null} Expected value or null if unavailable
         */
        calculateSingleContainer(containerHrid, initData = null) {
            // Use cached data if provided, otherwise fetch
            if (!initData) {
                initData = dataManager$1.getInitClientData();
            }
            if (!initData || !initData.openableLootDropMap) {
                return null;
            }

            // Get drop table for this container
            const dropTable = initData.openableLootDropMap[containerHrid];
            if (!dropTable || dropTable.length === 0) {
                return null;
            }

            let totalExpectedValue = 0;

            // Calculate expected value for each drop
            for (const drop of dropTable) {
                const itemHrid = drop.itemHrid;
                const dropRate = drop.dropRate || 0;
                const minCount = drop.minCount || 0;
                const maxCount = drop.maxCount || 0;

                // Skip invalid drops
                if (dropRate <= 0 || (minCount === 0 && maxCount === 0)) {
                    continue;
                }

                // Calculate average drop count
                const avgCount = (minCount + maxCount) / 2;

                // Get price for this drop
                const price = this.getDropPrice(itemHrid);

                if (price === null) {
                    continue; // Skip drops with missing data
                }

                // Check if item is tradeable (for tax calculation)
                const itemDetails = dataManager$1.getItemDetails(itemHrid);
                const canBeSold = itemDetails?.tradeable !== false;
                const dropValue = canBeSold
                    ? calculatePriceAfterTax(avgCount * dropRate * price, this.MARKET_TAX)
                    : avgCount * dropRate * price;
                totalExpectedValue += dropValue;
            }

            // Cache the result for future lookups
            if (totalExpectedValue > 0) {
                this.containerCache.set(containerHrid, totalExpectedValue);
            }

            return totalExpectedValue;
        }

        /**
         * Get price for a drop item
         * Handles special cases (Coin, Cowbell, Dungeon Tokens, nested containers)
         * @param {string} itemHrid - Item HRID
         * @returns {number|null} Price or null if unavailable
         */
        getDropPrice(itemHrid) {
            // Special case: Coin (face value = 1)
            if (itemHrid === this.COIN_HRID) {
                return 1;
            }

            // Special case: Cowbell (use bag price ÷ 10, with 18% tax)
            if (itemHrid === this.COWBELL_HRID) {
                // Get Cowbell Bag price using profit context (sell side - you're selling the bag)
                const bagValue = getItemPrice(this.COWBELL_BAG_HRID, { context: 'profit', side: 'sell' }) || 0;

                if (bagValue > 0) {
                    // Apply 18% market tax (Cowbell Bag only), then divide by 10
                    return calculatePriceAfterTax(bagValue, 0.18) / 10;
                }
                return null; // No bag price available
            }

            // Special case: Dungeon Tokens (calculate value from shop items)
            if (this.DUNGEON_TOKENS.includes(itemHrid)) {
                return calculateDungeonTokenValue(itemHrid, 'profitCalc_pricingMode', 'expectedValue_respectPricingMode');
            }

            // Check if this is a nested container (use cached EV)
            if (this.containerCache.has(itemHrid)) {
                return this.containerCache.get(itemHrid);
            }

            // Regular market item - get price based on pricing mode (sell side - you're selling drops)
            const dropPrice = getItemPrice(itemHrid, { enhancementLevel: 0, context: 'profit', side: 'sell' });
            return dropPrice > 0 ? dropPrice : null;
        }

        /**
         * Calculate expected value for an openable container
         * @param {string} itemHrid - Container item HRID
         * @returns {Object|null} EV data or null
         */
        calculateExpectedValue(itemHrid) {
            if (!this.isInitialized) {
                console.warn('[ExpectedValueCalculator] Not initialized');
                return null;
            }

            // Get item details
            const itemDetails = dataManager$1.getItemDetails(itemHrid);
            if (!itemDetails) {
                return null;
            }

            // Verify this is an openable container
            if (!itemDetails.isOpenable) {
                return null; // Not an openable container
            }

            // Get detailed drop breakdown (calculates with fresh market prices)
            const drops = this.getDropBreakdown(itemHrid);

            // Calculate total expected value from fresh drop data
            const expectedReturn = drops.reduce((sum, drop) => sum + drop.expectedValue, 0);

            return {
                itemName: itemDetails.name,
                itemHrid,
                expectedValue: expectedReturn,
                drops,
            };
        }

        /**
         * Get cached expected value for a container (for use by other modules)
         * @param {string} itemHrid - Container item HRID
         * @returns {number|null} Cached EV or null
         */
        getCachedValue(itemHrid) {
            return this.containerCache.get(itemHrid) || null;
        }

        /**
         * Get detailed drop breakdown for display
         * @param {string} containerHrid - Container HRID
         * @returns {Array} Array of drop objects
         */
        getDropBreakdown(containerHrid) {
            const initData = dataManager$1.getInitClientData();
            if (!initData || !initData.openableLootDropMap) {
                return [];
            }

            const dropTable = initData.openableLootDropMap[containerHrid];
            if (!dropTable) {
                return [];
            }

            const drops = [];

            for (const drop of dropTable) {
                const itemHrid = drop.itemHrid;
                const dropRate = drop.dropRate || 0;
                const minCount = drop.minCount || 0;
                const maxCount = drop.maxCount || 0;

                if (dropRate <= 0) {
                    continue;
                }

                // Get item details
                const itemDetails = dataManager$1.getItemDetails(itemHrid);
                if (!itemDetails) {
                    continue;
                }

                // Calculate average count
                const avgCount = (minCount + maxCount) / 2;

                // Get price
                const price = this.getDropPrice(itemHrid);

                // Calculate expected value for this drop
                const itemCanBeSold = itemDetails.tradeable !== false;
                const dropValue =
                    price !== null
                        ? itemCanBeSold
                            ? calculatePriceAfterTax(avgCount * dropRate * price, this.MARKET_TAX)
                            : avgCount * dropRate * price
                        : 0;

                drops.push({
                    itemHrid,
                    itemName: itemDetails.name,
                    dropRate,
                    avgCount,
                    priceEach: price || 0,
                    expectedValue: dropValue,
                    hasPriceData: price !== null,
                });
            }

            // Sort by expected value (highest first)
            drops.sort((a, b) => b.expectedValue - a.expectedValue);

            return drops;
        }

        /**
         * Invalidate cache (call when market data refreshes)
         */
        invalidateCache() {
            this.containerCache.clear();
            this.isInitialized = false;

            // Re-initialize if data is available
            if (dataManager$1.getInitClientData() && marketAPI.isLoaded()) {
                this.initialize();
            }
        }

        /**
         * Cleanup calculator state and handlers
         */
        cleanup() {
            if (this.retryHandler) {
                dataManager$1.off('character_initialized', this.retryHandler);
                this.retryHandler = null;
            }

            this.containerCache.clear();
            this.isInitialized = false;
        }

        disable() {
            this.cleanup();
        }
    }

    const expectedValueCalculator = new ExpectedValueCalculator();

    /**
     * Equipment Parser Utility
     * Parses equipment bonuses for action calculations
     *
     * PART OF EFFICIENCY SYSTEM (Phase 1 of 3):
     * - Phase 1 ✅: Equipment speed bonuses (this module) + level advantage
     * - Phase 2 ✅: Community buffs + house rooms (WebSocket integration)
     * - Phase 3 ✅: Consumable buffs (tea parser integration)
     *
     * Speed bonuses are MULTIPLICATIVE with time (reduce duration).
     * Efficiency bonuses are ADDITIVE with each other, then MULTIPLICATIVE with time.
     *
     * Formula: actionTime = baseTime / (1 + totalEfficiency + totalSpeed)
     */

    /**
     * Map action type HRID to equipment field name
     * @param {string} actionTypeHrid - Action type HRID (e.g., "/action_types/cheesesmithing")
     * @param {string} suffix - Field suffix (e.g., "Speed", "Efficiency", "RareFind")
     * @param {Array<string>} validFields - Array of valid field names
     * @returns {string|null} Field name (e.g., "cheesesmithingSpeed") or null
     */
    function getFieldForActionType(actionTypeHrid, suffix, validFields) {
        if (!actionTypeHrid) {
            return null;
        }

        // Extract skill name from action type HRID
        // e.g., "/action_types/cheesesmithing" -> "cheesesmithing"
        const skillName = actionTypeHrid.replace('/action_types/', '');

        // Map to field name with suffix
        // e.g., "cheesesmithing" + "Speed" -> "cheesesmithingSpeed"
        const fieldName = skillName + suffix;

        return validFields.includes(fieldName) ? fieldName : null;
    }

    /**
     * Enhancement percentage table (based on game mechanics)
     * Each enhancement level provides a percentage boost to base stats
     */
    const ENHANCEMENT_PERCENTAGES = {
        0: 0.0,
        1: 0.02, // 2.0%
        2: 0.042, // 4.2%
        3: 0.066, // 6.6%
        4: 0.092, // 9.2%
        5: 0.12, // 12.0%
        6: 0.15, // 15.0%
        7: 0.182, // 18.2%
        8: 0.216, // 21.6%
        9: 0.252, // 25.2%
        10: 0.29, // 29.0%
        11: 0.334, // 33.4%
        12: 0.384, // 38.4%
        13: 0.44, // 44.0%
        14: 0.502, // 50.2%
        15: 0.57, // 57.0%
        16: 0.644, // 64.4%
        17: 0.724, // 72.4%
        18: 0.81, // 81.0%
        19: 0.902, // 90.2%
        20: 1.0, // 100.0%
    };

    /**
     * Slot multipliers for enhancement bonuses
     * Accessories get 5× bonus, weapons/armor get 1× bonus
     * Keys use item_locations (not equipment_types) to match characterEquipment map keys
     */
    const SLOT_MULTIPLIERS = {
        '/item_locations/neck': 5, // Necklace
        '/item_locations/ring': 5, // Ring
        '/item_locations/earrings': 5, // Earrings
        '/item_locations/back': 5, // Back/Cape
        '/item_locations/trinket': 5, // Trinket
        '/item_locations/charm': 5, // Charm
        '/item_locations/main_hand': 1, // Main hand weapon
        '/item_locations/two_hand': 1, // Two-handed weapon
        '/item_locations/off_hand': 1, // Off-hand/shield
        '/item_locations/head': 1, // Head armor
        '/item_locations/body': 1, // Body armor
        '/item_locations/legs': 1, // Leg armor
        '/item_locations/hands': 1, // Hand armor
        '/item_locations/feet': 1, // Feet armor
        '/item_locations/pouch': 1, // Pouch
    };

    /**
     * Calculate enhancement scaling for equipment stats
     * Uses percentage-based enhancement system with slot multipliers
     *
     * Formula: base × (1 + enhancementPercentage × slotMultiplier)
     *
     * @param {number} baseValue - Base stat value from item data
     * @param {number} enhancementLevel - Enhancement level (0-20)
     * @param {string} slotHrid - Equipment slot HRID (e.g., "/equipment_types/neck")
     * @returns {number} Scaled stat value
     *
     * @example
     * // Philosopher's Necklace +4 (4% base speed, neck slot 5×)
     * calculateEnhancementScaling(0.04, 4, '/equipment_types/neck')
     * // = 0.04 × (1 + 0.092 × 5) = 0.04 × 1.46 = 0.0584 (5.84%)
     *
     * // Lumberjack's Top +10 (10% base efficiency, body slot 1×)
     * calculateEnhancementScaling(0.10, 10, '/equipment_types/body')
     * // = 0.10 × (1 + 0.290 × 1) = 0.10 × 1.29 = 0.129 (12.9%)
     */
    function calculateEnhancementScaling(baseValue, enhancementLevel, slotHrid) {
        if (enhancementLevel === 0) {
            return baseValue;
        }

        // Get enhancement percentage from table
        const enhancementPercentage = ENHANCEMENT_PERCENTAGES[enhancementLevel] || 0;

        // Get slot multiplier (default to 1× if slot not found)
        const slotMultiplier = SLOT_MULTIPLIERS[slotHrid] || 1;

        // Apply formula: base × (1 + percentage × multiplier)
        return baseValue * (1 + enhancementPercentage * slotMultiplier);
    }

    /**
     * Generic equipment stat parser - handles all noncombat stats with consistent logic
     * @param {Map} characterEquipment - Equipment map from dataManager.getEquipment()
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {Object} config - Parser configuration
     * @param {string|null} config.skillSpecificField - Skill-specific field (e.g., "brewingSpeed")
     * @param {string|null} config.genericField - Generic skilling field (e.g., "skillingSpeed")
     * @param {boolean} config.returnAsPercentage - Whether to convert to percentage (multiply by 100)
     * @returns {number} Total stat bonus
     *
     * @example
     * // Parse speed bonuses for brewing
     * parseEquipmentStat(equipment, items, {
     *   skillSpecificField: "brewingSpeed",
     *   genericField: "skillingSpeed",
     *   returnAsPercentage: false
     * })
     */
    function parseEquipmentStat(characterEquipment, itemDetailMap, config) {
        if (!characterEquipment || characterEquipment.size === 0) {
            return 0; // No equipment
        }

        if (!itemDetailMap) {
            return 0; // Missing item data
        }

        const { skillSpecificField, genericField, returnAsPercentage } = config;

        let totalBonus = 0;

        // Iterate through all equipped items
        for (const [slotHrid, equippedItem] of characterEquipment) {
            // Get item details from game data
            const itemDetails = itemDetailMap[equippedItem.itemHrid];

            if (!itemDetails || !itemDetails.equipmentDetail) {
                continue; // Not an equipment item
            }

            // Check if item has noncombat stats
            const noncombatStats = itemDetails.equipmentDetail.noncombatStats;

            if (!noncombatStats) {
                continue; // No noncombat stats
            }

            // Get enhancement level from equipped item
            const enhancementLevel = equippedItem.enhancementLevel || 0;

            // Check for skill-specific stat (e.g., brewingSpeed, brewingEfficiency, brewingRareFind)
            if (skillSpecificField) {
                const baseValue = noncombatStats[skillSpecificField];

                if (baseValue && baseValue > 0) {
                    const scaledValue = calculateEnhancementScaling(baseValue, enhancementLevel, slotHrid);
                    totalBonus += scaledValue;
                }
            }

            // Check for generic skilling stat (e.g., skillingSpeed, skillingEfficiency, skillingRareFind, skillingEssenceFind)
            if (genericField) {
                const baseValue = noncombatStats[genericField];

                if (baseValue && baseValue > 0) {
                    const scaledValue = calculateEnhancementScaling(baseValue, enhancementLevel, slotHrid);
                    totalBonus += scaledValue;
                }
            }
        }

        // Convert to percentage if requested (0.15 -> 15%)
        return returnAsPercentage ? totalBonus * 100 : totalBonus;
    }

    /**
     * Valid speed fields from game data
     */
    const VALID_SPEED_FIELDS = [
        'milkingSpeed',
        'foragingSpeed',
        'woodcuttingSpeed',
        'cheesesmithingSpeed',
        'craftingSpeed',
        'tailoringSpeed',
        'brewingSpeed',
        'cookingSpeed',
        'alchemySpeed',
        'enhancingSpeed',
        'taskSpeed',
    ];

    /**
     * Parse equipment speed bonuses for a specific action type
     * @param {Map} characterEquipment - Equipment map from dataManager.getEquipment()
     * @param {string} actionTypeHrid - Action type HRID
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @returns {number} Total speed bonus as decimal (e.g., 0.15 for 15%)
     *
     * @example
     * parseEquipmentSpeedBonuses(equipment, "/action_types/brewing", items)
     * // Cheese Pot (base 0.15, bonus 0.003) +0: 0.15 (15%)
     * // Cheese Pot (base 0.15, bonus 0.003) +10: 0.18 (18%)
     * // Azure Pot (base 0.3, bonus 0.006) +10: 0.36 (36%)
     */
    function parseEquipmentSpeedBonuses(characterEquipment, actionTypeHrid, itemDetailMap) {
        const skillSpecificField = getFieldForActionType(actionTypeHrid, 'Speed', VALID_SPEED_FIELDS);

        return parseEquipmentStat(characterEquipment, itemDetailMap, {
            skillSpecificField,
            genericField: 'skillingSpeed',
            returnAsPercentage: false,
        });
    }

    /**
     * Valid efficiency fields from game data
     */
    const VALID_EFFICIENCY_FIELDS = [
        'milkingEfficiency',
        'foragingEfficiency',
        'woodcuttingEfficiency',
        'cheesesmithingEfficiency',
        'craftingEfficiency',
        'tailoringEfficiency',
        'brewingEfficiency',
        'cookingEfficiency',
        'alchemyEfficiency',
    ];

    /**
     * Parse equipment efficiency bonuses for a specific action type
     * @param {Map} characterEquipment - Equipment map from dataManager.getEquipment()
     * @param {string} actionTypeHrid - Action type HRID
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @returns {number} Total efficiency bonus as percentage (e.g., 12 for 12%)
     *
     * @example
     * parseEquipmentEfficiencyBonuses(equipment, "/action_types/brewing", items)
     * // Brewer's Top (base 0.1, bonus 0.002) +0: 10%
     * // Brewer's Top (base 0.1, bonus 0.002) +10: 12%
     * // Philosopher's Necklace (skillingEfficiency 0.02, bonus 0.002) +10: 4%
     * // Total: 16%
     */
    function parseEquipmentEfficiencyBonuses(characterEquipment, actionTypeHrid, itemDetailMap) {
        const skillSpecificField = getFieldForActionType(actionTypeHrid, 'Efficiency', VALID_EFFICIENCY_FIELDS);

        return parseEquipmentStat(characterEquipment, itemDetailMap, {
            skillSpecificField,
            genericField: 'skillingEfficiency',
            returnAsPercentage: true,
        });
    }

    /**
     * Parse Essence Find bonus from equipment
     * @param {Map} characterEquipment - Equipment map from dataManager.getEquipment()
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @returns {number} Total essence find bonus as percentage (e.g., 15 for 15%)
     *
     * @example
     * parseEssenceFindBonus(equipment, items)
     * // Ring of Essence Find (base 0.15, bonus 0.015) +0: 15%
     * // Ring of Essence Find (base 0.15, bonus 0.015) +10: 30%
     */
    function parseEssenceFindBonus(characterEquipment, itemDetailMap) {
        return parseEquipmentStat(characterEquipment, itemDetailMap, {
            skillSpecificField: null, // No skill-specific essence find
            genericField: 'skillingEssenceFind',
            returnAsPercentage: true,
        });
    }

    /**
     * Valid rare find fields from game data
     */
    const VALID_RARE_FIND_FIELDS = [
        'milkingRareFind',
        'foragingRareFind',
        'woodcuttingRareFind',
        'cheesesmithingRareFind',
        'craftingRareFind',
        'tailoringRareFind',
        'brewingRareFind',
        'cookingRareFind',
        'alchemyRareFind',
        'enhancingRareFind',
    ];

    /**
     * Parse Rare Find bonus from equipment
     * @param {Map} characterEquipment - Equipment map from dataManager.getEquipment()
     * @param {string} actionTypeHrid - Action type HRID (for skill-specific rare find)
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @returns {number} Total rare find bonus as percentage (e.g., 15 for 15%)
     *
     * @example
     * parseRareFindBonus(equipment, "/action_types/brewing", items)
     * // Brewer's Top (base 0.15, bonus 0.003) +0: 15%
     * // Brewer's Top (base 0.15, bonus 0.003) +10: 18%
     * // Earrings of Rare Find (base 0.08, bonus 0.002) +0: 8%
     * // Total: 26%
     */
    function parseRareFindBonus(characterEquipment, actionTypeHrid, itemDetailMap) {
        const skillSpecificField = getFieldForActionType(actionTypeHrid, 'RareFind', VALID_RARE_FIND_FIELDS);

        return parseEquipmentStat(characterEquipment, itemDetailMap, {
            skillSpecificField,
            genericField: 'skillingRareFind',
            returnAsPercentage: true,
        });
    }

    /**
     * Get all speed bonuses for debugging
     * @param {Map} characterEquipment - Equipment map
     * @param {Object} itemDetailMap - Item details
     * @returns {Array} Array of speed bonus objects
     */
    function debugEquipmentSpeedBonuses(characterEquipment, itemDetailMap) {
        if (!characterEquipment || characterEquipment.size === 0) {
            return [];
        }

        const bonuses = [];

        for (const [slotHrid, equippedItem] of characterEquipment) {
            const itemDetails = itemDetailMap[equippedItem.itemHrid];

            if (!itemDetails || !itemDetails.equipmentDetail) {
                continue;
            }

            const noncombatStats = itemDetails.equipmentDetail.noncombatStats;

            if (!noncombatStats) {
                continue;
            }

            // Find all speed bonuses on this item
            for (const [statName, value] of Object.entries(noncombatStats)) {
                if (statName.endsWith('Speed') && value > 0) {
                    const enhancementLevel = equippedItem.enhancementLevel || 0;
                    const scaledValue = calculateEnhancementScaling(value, enhancementLevel, slotHrid);

                    bonuses.push({
                        itemName: itemDetails.name,
                        itemHrid: equippedItem.itemHrid,
                        slot: slotHrid,
                        speedType: statName,
                        baseBonus: value,
                        enhancementLevel,
                        scaledBonus: scaledValue,
                    });
                }
            }
        }

        return bonuses;
    }

    var equipmentParser = /*#__PURE__*/Object.freeze({
        __proto__: null,
        debugEquipmentSpeedBonuses: debugEquipmentSpeedBonuses,
        parseEquipmentEfficiencyBonuses: parseEquipmentEfficiencyBonuses,
        parseEquipmentSpeedBonuses: parseEquipmentSpeedBonuses,
        parseEssenceFindBonus: parseEssenceFindBonus,
        parseRareFindBonus: parseRareFindBonus
    });

    /**
     * House Efficiency Utility
     * Calculates efficiency bonuses from house rooms
     *
     * PART OF EFFICIENCY SYSTEM (Phase 2):
     * - House rooms provide +1.5% efficiency per level to matching actions
     * - Formula: houseLevel × 1.5%
     * - Data source: WebSocket (characterHouseRoomMap)
     */


    /**
     * Map action type HRID to house room HRID
     * @param {string} actionTypeHrid - Action type HRID (e.g., "/action_types/brewing")
     * @returns {string|null} House room HRID or null
     */
    function getHouseRoomForActionType(actionTypeHrid) {
        // Mapping matches original MWI Tools
        const actionTypeToHouseRoomMap = {
            '/action_types/brewing': '/house_rooms/brewery',
            '/action_types/cheesesmithing': '/house_rooms/forge',
            '/action_types/cooking': '/house_rooms/kitchen',
            '/action_types/crafting': '/house_rooms/workshop',
            '/action_types/foraging': '/house_rooms/garden',
            '/action_types/milking': '/house_rooms/dairy_barn',
            '/action_types/tailoring': '/house_rooms/sewing_parlor',
            '/action_types/woodcutting': '/house_rooms/log_shed',
            '/action_types/alchemy': '/house_rooms/laboratory',
        };

        return actionTypeToHouseRoomMap[actionTypeHrid] || null;
    }

    /**
     * Calculate house efficiency bonus for an action type
     * @param {string} actionTypeHrid - Action type HRID
     * @returns {number} Efficiency bonus percentage (e.g., 12 for 12%)
     *
     * @example
     * calculateHouseEfficiency("/action_types/brewing")
     * // Returns: 12 (if brewery is level 8: 8 × 1.5% = 12%)
     */
    function calculateHouseEfficiency(actionTypeHrid) {
        // Get the house room for this action type
        const houseRoomHrid = getHouseRoomForActionType(actionTypeHrid);

        if (!houseRoomHrid) {
            return 0; // No house room for this action type
        }

        // Get house room level from game data (via dataManager)
        const roomLevel = dataManager$1.getHouseRoomLevel(houseRoomHrid);

        // Formula: houseLevel × 1.5%
        // Returns as percentage (e.g., 12 for 12%)
        return roomLevel * 1.5;
    }

    /**
     * Get friendly name for house room
     * @param {string} houseRoomHrid - House room HRID
     * @returns {string} Friendly name
     */
    function getHouseRoomName(houseRoomHrid) {
        const names = {
            '/house_rooms/brewery': 'Brewery',
            '/house_rooms/forge': 'Forge',
            '/house_rooms/kitchen': 'Kitchen',
            '/house_rooms/workshop': 'Workshop',
            '/house_rooms/garden': 'Garden',
            '/house_rooms/dairy_barn': 'Dairy Barn',
            '/house_rooms/sewing_parlor': 'Sewing Parlor',
            '/house_rooms/log_shed': 'Log Shed',
            '/house_rooms/laboratory': 'Laboratory',
        };

        return names[houseRoomHrid] || 'Unknown';
    }

    /**
     * Calculate total Rare Find bonus from all house rooms
     * @returns {number} Total rare find bonus as percentage (e.g., 1.6 for 1.6%)
     *
     * @example
     * calculateHouseRareFind()
     * // Returns: 1.6 (if total house room levels = 8: 8 × 0.2% per level = 1.6%)
     *
     * Formula from game data:
     * - flatBoostLevelBonus: 0.2% per level
     * - Total: totalLevels × 0.2%
     * - Max: 8 rooms × 8 levels = 64 × 0.2% = 12.8%
     */
    function calculateHouseRareFind() {
        // Get all house rooms
        const houseRooms = dataManager$1.getHouseRooms();

        if (!houseRooms || houseRooms.size === 0) {
            return 0; // No house rooms
        }

        // Sum all house room levels
        let totalLevels = 0;
        for (const [_hrid, room] of houseRooms) {
            totalLevels += room.level || 0;
        }

        // Formula: totalLevels × flatBoostLevelBonus
        // flatBoostLevelBonus: 0.2% per level (no base bonus)
        const flatBoostLevelBonus = 0.2;

        return totalLevels * flatBoostLevelBonus;
    }

    var houseEfficiency = {
        calculateHouseEfficiency,
        getHouseRoomName,
        calculateHouseRareFind,
    };

    var houseEfficiency$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateHouseEfficiency: calculateHouseEfficiency,
        calculateHouseRareFind: calculateHouseRareFind,
        default: houseEfficiency,
        getHouseRoomName: getHouseRoomName
    });

    /**
     * Bonus Revenue Calculator Utility
     * Calculates revenue from essence and rare find drops
     * Shared by both gathering and production profit calculators
     */


    /**
     * Calculate bonus revenue from essence and rare find drops
     * @param {Object} actionDetails - Action details from game data
     * @param {number} actionsPerHour - Base actions per hour (efficiency not applied)
     * @param {Map} characterEquipment - Equipment map
     * @param {Object} itemDetailMap - Item details map
     * @returns {Object} Bonus revenue data with essence and rare find drops
     */
    function calculateBonusRevenue(actionDetails, actionsPerHour, characterEquipment, itemDetailMap) {
        // Get Essence Find bonus from equipment
        const essenceFindBonus = parseEssenceFindBonus(characterEquipment, itemDetailMap);

        // Get Rare Find bonus from BOTH equipment and house rooms
        const equipmentRareFindBonus = parseRareFindBonus(characterEquipment, actionDetails.type, itemDetailMap);
        const houseRareFindBonus = calculateHouseRareFind();
        const achievementRareFindBonus =
            dataManager$1.getAchievementBuffFlatBoost(actionDetails.type, '/buff_types/rare_find') * 100;
        const rareFindBonus = equipmentRareFindBonus + houseRareFindBonus + achievementRareFindBonus;
        const rareFindBreakdown = {
            equipment: equipmentRareFindBonus,
            house: houseRareFindBonus,
            achievement: achievementRareFindBonus,
        };

        const bonusDrops = [];
        let totalBonusRevenue = 0;
        let hasMissingPrices = false;

        // Process essence drops
        if (actionDetails.essenceDropTable && actionDetails.essenceDropTable.length > 0) {
            for (const drop of actionDetails.essenceDropTable) {
                const itemDetails = itemDetailMap[drop.itemHrid];
                if (!itemDetails) continue;

                // Calculate average drop count
                const avgCount = (drop.minCount + drop.maxCount) / 2;

                // Apply Essence Find multiplier to drop rate
                const finalDropRate = drop.dropRate * (1 + essenceFindBonus / 100);

                // Expected drops per hour
                const dropsPerHour = actionsPerHour * finalDropRate * avgCount;

                // Get price: Check if openable container (use EV), otherwise market price
                let itemPrice = 0;
                let isMissingPrice = false;
                if (itemDetails.isOpenable) {
                    // Use expected value for openable containers
                    itemPrice = expectedValueCalculator.getCachedValue(drop.itemHrid) || 0;
                } else {
                    // Use market price for regular items
                    const price = marketAPI.getPrice(drop.itemHrid, 0);
                    itemPrice = price?.bid ?? 0; // Use bid price (instant sell)
                    isMissingPrice = price?.bid === null || price?.bid === undefined;
                }

                // Revenue per hour from this drop
                const revenuePerHour = dropsPerHour * itemPrice;
                const dropsPerAction = actionsPerHour > 0 ? dropsPerHour / actionsPerHour : 0;
                const revenuePerAction = actionsPerHour > 0 ? revenuePerHour / actionsPerHour : 0;

                bonusDrops.push({
                    itemHrid: drop.itemHrid,
                    itemName: itemDetails.name,
                    dropRate: finalDropRate,
                    dropsPerHour,
                    dropsPerAction,
                    priceEach: itemPrice,
                    revenuePerHour,
                    revenuePerAction,
                    type: 'essence',
                    missingPrice: isMissingPrice,
                });

                totalBonusRevenue += revenuePerHour;
                if (isMissingPrice) {
                    hasMissingPrices = true;
                }
            }
        }

        // Process rare find drops
        if (actionDetails.rareDropTable && actionDetails.rareDropTable.length > 0) {
            for (const drop of actionDetails.rareDropTable) {
                const itemDetails = itemDetailMap[drop.itemHrid];
                if (!itemDetails) continue;

                // Calculate average drop count
                const avgCount = (drop.minCount + drop.maxCount) / 2;

                // Apply Rare Find multiplier to drop rate
                const finalDropRate = drop.dropRate * (1 + rareFindBonus / 100);

                // Expected drops per hour
                const dropsPerHour = actionsPerHour * finalDropRate * avgCount;

                // Get price: Check if openable container (use EV), otherwise market price
                let itemPrice = 0;
                let isMissingPrice = false;
                if (itemDetails.isOpenable) {
                    // Use expected value for openable containers
                    itemPrice = expectedValueCalculator.getCachedValue(drop.itemHrid) || 0;
                } else {
                    // Use market price for regular items
                    const price = marketAPI.getPrice(drop.itemHrid, 0);
                    itemPrice = price?.bid ?? 0; // Use bid price (instant sell)
                    isMissingPrice = price?.bid === null || price?.bid === undefined;
                }

                // Revenue per hour from this drop
                const revenuePerHour = dropsPerHour * itemPrice;
                const dropsPerAction = actionsPerHour > 0 ? dropsPerHour / actionsPerHour : 0;
                const revenuePerAction = actionsPerHour > 0 ? revenuePerHour / actionsPerHour : 0;

                bonusDrops.push({
                    itemHrid: drop.itemHrid,
                    itemName: itemDetails.name,
                    dropRate: finalDropRate,
                    dropsPerHour,
                    dropsPerAction,
                    priceEach: itemPrice,
                    revenuePerHour,
                    revenuePerAction,
                    type: 'rare_find',
                    missingPrice: isMissingPrice,
                });

                totalBonusRevenue += revenuePerHour;
                if (isMissingPrice) {
                    hasMissingPrices = true;
                }
            }
        }

        return {
            essenceFindBonus, // Essence Find % from equipment
            rareFindBonus, // Rare Find % from equipment + house rooms + achievements (combined)
            rareFindBreakdown,
            bonusDrops, // Array of all bonus drops with details
            totalBonusRevenue, // Total revenue/hour from all bonus drops
            hasMissingPrices,
        };
    }

    var bonusRevenueCalculator = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateBonusRevenue: calculateBonusRevenue
    });

    /**
     * Enhancement Multiplier System
     *
     * Handles enhancement bonus calculations for equipment.
     * Different equipment slots have different multipliers:
     * - Accessories (neck/ring/earring), Back, Trinket, Charm: 5× multiplier
     * - All other slots (weapons, armor, pouch): 1× multiplier
     */

    /**
     * Enhancement multiplier by equipment slot type
     */
    const ENHANCEMENT_MULTIPLIERS = {
        '/equipment_types/neck': 5,
        '/equipment_types/ring': 5,
        '/equipment_types/earring': 5,
        '/equipment_types/back': 5,
        '/equipment_types/trinket': 5,
        '/equipment_types/charm': 5,
        // All other slots: 1× (default)
    };

    /**
     * Enhancement bonus table
     * Maps enhancement level to percentage bonus
     */
    const ENHANCEMENT_BONUSES = {
        1: 0.02,
        2: 0.042,
        3: 0.066,
        4: 0.092,
        5: 0.12,
        6: 0.15,
        7: 0.182,
        8: 0.216,
        9: 0.252,
        10: 0.29,
        11: 0.334,
        12: 0.384,
        13: 0.44,
        14: 0.502,
        15: 0.57,
        16: 0.644,
        17: 0.724,
        18: 0.81,
        19: 0.902,
        20: 1.0,
    };

    /**
     * Get enhancement multiplier for an item
     * @param {Object} itemDetails - Item details from itemDetailMap
     * @param {number} enhancementLevel - Current enhancement level of item
     * @returns {number} Multiplier to apply to bonuses
     */
    function getEnhancementMultiplier(itemDetails, enhancementLevel) {
        if (enhancementLevel === 0) {
            return 1;
        }

        const equipmentType = itemDetails?.equipmentDetail?.type;
        const slotMultiplier = ENHANCEMENT_MULTIPLIERS[equipmentType] || 1;
        const enhancementBonus = ENHANCEMENT_BONUSES[enhancementLevel] || 0;

        return 1 + enhancementBonus * slotMultiplier;
    }

    var enhancementMultipliers = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ENHANCEMENT_BONUSES: ENHANCEMENT_BONUSES,
        ENHANCEMENT_MULTIPLIERS: ENHANCEMENT_MULTIPLIERS,
        getEnhancementMultiplier: getEnhancementMultiplier
    });

    /**
     * Experience Parser Utility
     * Parses wisdom and experience bonuses from all sources
     *
     * Experience Formula (Skilling):
     * Final XP = Base XP × (1 + Wisdom + Charm Experience)
     *
     * Where Wisdom and Charm Experience are ADDITIVE
     */


    /**
     * Parse equipment wisdom bonus (skillingExperience stat)
     * @param {Map} equipment - Character equipment map
     * @param {Object} itemDetailMap - Item details from game data
     * @returns {Object} {total: number, breakdown: Array} Total wisdom and item breakdown
     */
    function parseEquipmentWisdom(equipment, itemDetailMap) {
        let totalWisdom = 0;
        const breakdown = [];

        for (const [_slot, item] of equipment) {
            const itemDetails = itemDetailMap[item.itemHrid];
            if (!itemDetails?.equipmentDetail) continue;

            const noncombatStats = itemDetails.equipmentDetail.noncombatStats || {};
            const noncombatEnhancement = itemDetails.equipmentDetail.noncombatEnhancementBonuses || {};

            // Get base skillingExperience
            const baseWisdom = noncombatStats.skillingExperience || 0;
            if (baseWisdom === 0) continue;

            // Get enhancement scaling
            const enhancementBonus = noncombatEnhancement.skillingExperience || 0;
            const enhancementLevel = item.enhancementLevel || 0;

            // Calculate total wisdom from this item
            // Enhancement scales quadratically: level × (1 + 0.05 × (level - 1))
            const enhancementTotal =
                enhancementBonus * (enhancementLevel + (0.1 * enhancementLevel * (enhancementLevel - 1)) / 2);
            const itemWisdom = (baseWisdom + enhancementTotal) * 100;
            totalWisdom += itemWisdom;

            // Add to breakdown
            breakdown.push({
                name: itemDetails.name,
                value: itemWisdom,
                enhancementLevel: enhancementLevel,
            });
        }

        return {
            total: totalWisdom,
            breakdown: breakdown,
        };
    }

    /**
     * Parse skill-specific charm experience (e.g., foragingExperience)
     * @param {Map} equipment - Character equipment map
     * @param {string} skillHrid - Skill HRID (e.g., "/skills/foraging")
     * @param {Object} itemDetailMap - Item details from game data
     * @returns {Object} {total: number, breakdown: Array} Total charm XP and item breakdown
     */
    function parseCharmExperience(equipment, skillHrid, itemDetailMap) {
        let totalCharmXP = 0;
        const breakdown = [];

        // Convert skill HRID to stat name (e.g., "/skills/foraging" → "foragingExperience")
        const skillName = skillHrid.replace('/skills/', '');
        const statName = `${skillName}Experience`;

        for (const [_slot, item] of equipment) {
            const itemDetails = itemDetailMap[item.itemHrid];
            if (!itemDetails?.equipmentDetail) continue;

            const noncombatStats = itemDetails.equipmentDetail.noncombatStats || {};
            const noncombatEnhancement = itemDetails.equipmentDetail.noncombatEnhancementBonuses || {};

            // Get base charm experience
            const baseCharmXP = noncombatStats[statName] || 0;
            if (baseCharmXP === 0) continue;

            // Get enhancement scaling
            const enhancementBonus = noncombatEnhancement[statName] || 0;
            const enhancementLevel = item.enhancementLevel || 0;

            // Calculate total charm XP from this item
            // Enhancement scales quadratically: level × (1 + 0.05 × (level - 1))
            const enhancementTotal =
                enhancementBonus * (enhancementLevel + (0.1 * enhancementLevel * (enhancementLevel - 1)) / 2);
            const itemCharmXP = (baseCharmXP + enhancementTotal) * 100;
            totalCharmXP += itemCharmXP;

            // Add to breakdown
            breakdown.push({
                name: itemDetails.name,
                value: itemCharmXP,
                enhancementLevel: enhancementLevel,
            });
        }

        return {
            total: totalCharmXP,
            breakdown: breakdown,
        };
    }

    /**
     * Parse house room wisdom bonus
     * All house rooms provide +0.05% wisdom per level
     * @returns {number} Total wisdom from house rooms (e.g., 0.4 for 8 total levels)
     */
    function parseHouseRoomWisdom() {
        const houseRooms = dataManager$1.getHouseRooms();
        if (!houseRooms || houseRooms.size === 0) {
            return 0;
        }

        // Sum all house room levels
        let totalLevels = 0;
        for (const [_hrid, room] of houseRooms) {
            totalLevels += room.level || 0;
        }

        // Formula: totalLevels × 0.05% per level
        return totalLevels * 0.05;
    }

    /**
     * Parse community buff wisdom bonus
     * Formula: 20% + ((level - 1) × 0.5%)
     * @returns {number} Wisdom percentage from community buff (e.g., 29.5 for T20)
     */
    function parseCommunityBuffWisdom() {
        const buffLevel = dataManager$1.getCommunityBuffLevel('/community_buff_types/experience');
        if (!buffLevel) {
            return 0;
        }

        // Formula: 20% base + 0.5% per level above 1
        return 20 + (buffLevel - 1) * 0.5;
    }

    /**
     * Parse wisdom from active consumables (Wisdom Tea/Coffee)
     * @param {Array} drinkSlots - Active drink slots for the action type
     * @param {Object} itemDetailMap - Item details from game data
     * @param {number} drinkConcentration - Drink concentration bonus (e.g., 12.16 for 12.16%)
     * @returns {number} Wisdom percentage from consumables (e.g., 13.46 for 12% × 1.1216)
     */
    function parseConsumableWisdom(drinkSlots, itemDetailMap, drinkConcentration) {
        if (!drinkSlots || drinkSlots.length === 0) {
            return 0;
        }

        let totalWisdom = 0;

        for (const drink of drinkSlots) {
            if (!drink || !drink.itemHrid) continue; // Skip empty slots

            const itemDetails = itemDetailMap[drink.itemHrid];
            if (!itemDetails?.consumableDetail) continue;

            // Check for wisdom buff (typeHrid === "/buff_types/wisdom")
            const buffs = itemDetails.consumableDetail.buffs || [];
            for (const buff of buffs) {
                // Check if this is a wisdom buff by typeHrid
                if (buff.typeHrid === '/buff_types/wisdom' && buff.flatBoost) {
                    // Base wisdom (e.g., 0.12 for 12%)
                    const baseWisdom = buff.flatBoost * 100;

                    // Scale with drink concentration
                    const scaledWisdom = baseWisdom * (1 + drinkConcentration / 100);

                    totalWisdom += scaledWisdom;
                }
            }
        }

        return totalWisdom;
    }

    /**
     * Calculate total experience multiplier and breakdown
     * @param {string} skillHrid - Skill HRID (e.g., "/skills/foraging")
     * @param {string} actionTypeHrid - Action type HRID (e.g., "/action_types/foraging")
     * @returns {Object} Experience data with breakdown
     */
    function calculateExperienceMultiplier(skillHrid, actionTypeHrid) {
        const equipment = dataManager$1.getEquipment();
        const gameData = dataManager$1.getInitClientData();
        const itemDetailMap = gameData?.itemDetailMap || {};

        // Get drink concentration
        const drinkConcentration = equipment ? calculateDrinkConcentration(equipment, itemDetailMap) : 0;

        // Get active drinks for this action type
        const activeDrinks = dataManager$1.getActionDrinkSlots(actionTypeHrid);

        // Parse wisdom from all sources
        const equipmentWisdomData = parseEquipmentWisdom(equipment, itemDetailMap);
        const equipmentWisdom = equipmentWisdomData.total;
        const houseWisdom = parseHouseRoomWisdom();
        const communityWisdom = parseCommunityBuffWisdom();
        const consumableWisdom = parseConsumableWisdom(activeDrinks, itemDetailMap, drinkConcentration);
        const achievementWisdom = dataManager$1.getAchievementBuffFlatBoost(actionTypeHrid, '/buff_types/wisdom') * 100;

        const totalWisdom = equipmentWisdom + houseWisdom + communityWisdom + consumableWisdom + achievementWisdom;

        // Parse charm experience (skill-specific) - now returns object with total and breakdown
        const charmData = parseCharmExperience(equipment, skillHrid, itemDetailMap);
        const charmExperience = charmData.total;

        // Total multiplier (additive)
        const totalMultiplier = 1 + totalWisdom / 100 + charmExperience / 100;

        return {
            totalMultiplier,
            totalWisdom,
            charmExperience,
            charmBreakdown: charmData.breakdown,
            wisdomBreakdown: equipmentWisdomData.breakdown,
            breakdown: {
                equipmentWisdom,
                houseWisdom,
                communityWisdom,
                consumableWisdom,
                achievementWisdom,
                charmExperience,
            },
        };
    }

    /**
     * Calculate drink concentration from Guzzling Pouch
     * @param {Map} equipment - Character equipment map
     * @param {Object} itemDetailMap - Item details from game data
     * @returns {number} Drink concentration percentage (e.g., 12.16 for 12.16%)
     */
    function calculateDrinkConcentration(equipment, itemDetailMap) {
        // Find Guzzling Pouch in equipment
        const pouchItem = equipment.get('/equipment_types/pouch');
        if (!pouchItem || !pouchItem.itemHrid.includes('guzzling_pouch')) {
            return 0;
        }

        const itemDetails = itemDetailMap[pouchItem.itemHrid];
        if (!itemDetails?.equipmentDetail) {
            return 0;
        }

        // Get base drink concentration
        const noncombatStats = itemDetails.equipmentDetail.noncombatStats || {};
        const baseDrinkConcentration = noncombatStats.drinkConcentration || 0;

        if (baseDrinkConcentration === 0) {
            return 0;
        }

        // Get enhancement scaling
        const noncombatEnhancement = itemDetails.equipmentDetail.noncombatEnhancementBonuses || {};
        const enhancementBonus = noncombatEnhancement.drinkConcentration || 0;
        const enhancementLevel = pouchItem.enhancementLevel || 0;

        // Calculate total drink concentration
        // Enhancement scales quadratically: level × (1 + 0.05 × (level - 1))
        const enhancementTotal =
            enhancementBonus * (enhancementLevel + (0.1 * enhancementLevel * (enhancementLevel - 1)) / 2);
        return (baseDrinkConcentration + enhancementTotal) * 100;
    }

    var experienceParser = {
        parseEquipmentWisdom,
        parseCharmExperience,
        parseHouseRoomWisdom,
        parseCommunityBuffWisdom,
        parseConsumableWisdom,
        calculateExperienceMultiplier,
    };

    var experienceParser$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateExperienceMultiplier: calculateExperienceMultiplier,
        default: experienceParser,
        parseCharmExperience: parseCharmExperience,
        parseCommunityBuffWisdom: parseCommunityBuffWisdom,
        parseConsumableWisdom: parseConsumableWisdom,
        parseEquipmentWisdom: parseEquipmentWisdom,
        parseHouseRoomWisdom: parseHouseRoomWisdom
    });

    /**
     * Tea Buff Parser Utility
     * Calculates efficiency bonuses from active tea buffs
     *
     * Tea efficiency comes from two buff types:
     * 1. /buff_types/efficiency - Generic efficiency (e.g., Efficiency Tea: 10%)
     * 2. /buff_types/{skill}_level - Skill level bonuses (e.g., Brewing Tea: +3 levels)
     *
     * All tea effects scale with Drink Concentration equipment stat.
     */


    /**
     * Generic tea buff parser - handles all tea buff types with consistent logic
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.12 for 12%)
     * @param {Object} config - Parser configuration
     * @param {Array<string>} config.buffTypeHrids - Buff type HRIDs to check (e.g., ['/buff_types/artisan'])
     * @returns {number} Total buff bonus
     *
     * @example
     * // Parse artisan bonus
     * parseTeaBuff(drinks, items, 0.12, { buffTypeHrids: ['/buff_types/artisan'] })
     */
    function parseTeaBuff(activeDrinks, itemDetailMap, drinkConcentration, config) {
        if (!activeDrinks || activeDrinks.length === 0) {
            return 0; // No active teas
        }

        if (!itemDetailMap) {
            return 0; // Missing required data
        }

        const { buffTypeHrids } = config;
        let totalBonus = 0;

        // Process each active tea/drink
        for (const drink of activeDrinks) {
            if (!drink || !drink.itemHrid) {
                continue; // Empty slot
            }

            const itemDetails = itemDetailMap[drink.itemHrid];
            if (!itemDetails || !itemDetails.consumableDetail || !itemDetails.consumableDetail.buffs) {
                continue; // Not a consumable or has no buffs
            }

            // Check each buff on this tea
            for (const buff of itemDetails.consumableDetail.buffs) {
                // Check if this buff matches any of the target types
                if (buffTypeHrids.includes(buff.typeHrid)) {
                    const baseValue = buff.flatBoost;
                    const scaledValue = baseValue * (1 + drinkConcentration);
                    totalBonus += scaledValue;
                }
            }
        }

        return totalBonus;
    }

    /**
     * Parse tea efficiency bonuses for a specific action type
     * @param {string} actionTypeHrid - Action type HRID (e.g., "/action_types/brewing")
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.12 for 12%)
     * @returns {number} Total tea efficiency bonus as percentage (e.g., 12 for 12%)
     *
     * @example
     * // With Efficiency Tea (10% base) and 12% Drink Concentration:
     * parseTeaEfficiency("/action_types/brewing", activeDrinks, items, 0.12)
     * // Returns: 11.2 (10% × 1.12 = 11.2%)
     */
    function parseTeaEfficiency(actionTypeHrid, activeDrinks, itemDetailMap, drinkConcentration = 0) {
        if (!activeDrinks || activeDrinks.length === 0) {
            return 0; // No active teas
        }

        if (!actionTypeHrid || !itemDetailMap) {
            return 0; // Missing required data
        }

        let totalEfficiency = 0;

        // Process each active tea/drink
        for (const drink of activeDrinks) {
            if (!drink || !drink.itemHrid) {
                continue; // Empty slot
            }

            const itemDetails = itemDetailMap[drink.itemHrid];
            if (!itemDetails || !itemDetails.consumableDetail || !itemDetails.consumableDetail.buffs) {
                continue; // Not a consumable or has no buffs
            }

            // Check each buff on this tea
            for (const buff of itemDetails.consumableDetail.buffs) {
                // Generic efficiency buff (e.g., Efficiency Tea)
                if (buff.typeHrid === '/buff_types/efficiency') {
                    const baseEfficiency = buff.flatBoost * 100; // Convert to percentage
                    const scaledEfficiency = baseEfficiency * (1 + drinkConcentration);
                    totalEfficiency += scaledEfficiency;
                }
                // Note: Skill-specific level buffs are NOT counted here
                // They affect Level Bonus calculation, not Tea Bonus
            }
        }

        return totalEfficiency;
    }

    /**
     * Parse tea efficiency bonuses with breakdown by individual tea
     * @param {string} actionTypeHrid - Action type HRID (e.g., "/action_types/brewing")
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.12 for 12%)
     * @returns {Array<{name: string, efficiency: number, baseEfficiency: number, dcContribution: number}>} Array of tea contributions
     *
     * @example
     * // With Efficiency Tea (10% base) and Ultra Cheesesmithing Tea (6% base) with 12% DC:
     * parseTeaEfficiencyBreakdown("/action_types/cheesesmithing", activeDrinks, items, 0.12)
     * // Returns: [
     * //   { name: "Efficiency Tea", efficiency: 11.2, baseEfficiency: 10.0, dcContribution: 1.2 },
     * //   { name: "Ultra Cheesesmithing Tea", efficiency: 6.72, baseEfficiency: 6.0, dcContribution: 0.72 }
     * // ]
     */
    function parseTeaEfficiencyBreakdown(actionTypeHrid, activeDrinks, itemDetailMap, drinkConcentration = 0) {
        if (!activeDrinks || activeDrinks.length === 0) {
            return []; // No active teas
        }

        if (!actionTypeHrid || !itemDetailMap) {
            return []; // Missing required data
        }

        const teaBreakdown = [];

        // Process each active tea/drink
        for (const drink of activeDrinks) {
            if (!drink || !drink.itemHrid) {
                continue; // Empty slot
            }

            const itemDetails = itemDetailMap[drink.itemHrid];
            if (!itemDetails || !itemDetails.consumableDetail || !itemDetails.consumableDetail.buffs) {
                continue; // Not a consumable or has no buffs
            }

            let baseEfficiency = 0;
            let totalEfficiency = 0;

            // Check each buff on this tea
            for (const buff of itemDetails.consumableDetail.buffs) {
                // Generic efficiency buff (e.g., Efficiency Tea)
                if (buff.typeHrid === '/buff_types/efficiency') {
                    const baseValue = buff.flatBoost * 100; // Convert to percentage
                    const scaledValue = baseValue * (1 + drinkConcentration);
                    baseEfficiency += baseValue;
                    totalEfficiency += scaledValue;
                }
                // Note: Skill-specific level buffs are NOT counted here
                // They affect Level Bonus calculation, not Tea Bonus
            }

            // Only add to breakdown if this tea contributes efficiency
            if (totalEfficiency > 0) {
                teaBreakdown.push({
                    name: itemDetails.name,
                    efficiency: totalEfficiency,
                    baseEfficiency: baseEfficiency,
                    dcContribution: totalEfficiency - baseEfficiency,
                });
            }
        }

        return teaBreakdown;
    }

    /**
     * Get Drink Concentration stat from equipped items
     * @param {Map} characterEquipment - Equipment map from dataManager.getEquipment()
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @returns {number} Total drink concentration as decimal (e.g., 0.12 for 12%)
     *
     * @example
     * getDrinkConcentration(equipment, items)
     * // Returns: 0.12 (if wearing items with 12% total drink concentration)
     */
    function getDrinkConcentration(characterEquipment, itemDetailMap) {
        if (!characterEquipment || characterEquipment.size === 0) {
            return 0; // No equipment
        }

        if (!itemDetailMap) {
            return 0; // Missing item data
        }

        let totalDrinkConcentration = 0;

        // Iterate through all equipped items
        for (const [_slotHrid, equippedItem] of characterEquipment) {
            const itemDetails = itemDetailMap[equippedItem.itemHrid];

            if (!itemDetails || !itemDetails.equipmentDetail) {
                continue; // Not an equipment item
            }

            const noncombatStats = itemDetails.equipmentDetail.noncombatStats;
            if (!noncombatStats) {
                continue; // No noncombat stats
            }

            // Check for drink concentration stat
            const baseDrinkConcentration = noncombatStats.drinkConcentration;
            if (!baseDrinkConcentration || baseDrinkConcentration <= 0) {
                continue; // No drink concentration on this item
            }

            // Get enhancement level from equipped item
            const enhancementLevel = equippedItem.enhancementLevel || 0;

            // Calculate scaled drink concentration with enhancement
            // Uses enhancement multiplier table (e.g., +10 = 1.29× for 1× slots like pouch)
            const enhancementMultiplier = getEnhancementMultiplier(itemDetails, enhancementLevel);
            const scaledDrinkConcentration = baseDrinkConcentration * enhancementMultiplier;

            totalDrinkConcentration += scaledDrinkConcentration;
        }

        return totalDrinkConcentration;
    }

    /**
     * Parse Artisan bonus from active tea buffs
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.12 for 12%)
     * @returns {number} Artisan material reduction as decimal (e.g., 0.112 for 11.2% reduction)
     *
     * @example
     * // With Artisan Tea (10% base) and 12% Drink Concentration:
     * parseArtisanBonus(activeDrinks, items, 0.12)
     * // Returns: 0.112 (10% × 1.12 = 11.2% reduction)
     */
    function parseArtisanBonus(activeDrinks, itemDetailMap, drinkConcentration = 0) {
        return parseTeaBuff(activeDrinks, itemDetailMap, drinkConcentration, {
            buffTypeHrids: ['/buff_types/artisan'],
        });
    }

    /**
     * Parse Gourmet bonus from active tea buffs
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.12 for 12%)
     * @returns {number} Gourmet bonus chance as decimal (e.g., 0.1344 for 13.44% bonus items)
     *
     * @example
     * // With Gourmet Tea (12% base) and 12% Drink Concentration:
     * parseGourmetBonus(activeDrinks, items, 0.12)
     * // Returns: 0.1344 (12% × 1.12 = 13.44% bonus items)
     */
    function parseGourmetBonus(activeDrinks, itemDetailMap, drinkConcentration = 0) {
        return parseTeaBuff(activeDrinks, itemDetailMap, drinkConcentration, {
            buffTypeHrids: ['/buff_types/gourmet'],
        });
    }

    /**
     * Parse Processing bonus from active tea buffs
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.12 for 12%)
     * @returns {number} Processing conversion chance as decimal (e.g., 0.168 for 16.8% conversion chance)
     *
     * @example
     * // With Processing Tea (15% base) and 12% Drink Concentration:
     * parseProcessingBonus(activeDrinks, items, 0.12)
     * // Returns: 0.168 (15% × 1.12 = 16.8% conversion chance)
     */
    function parseProcessingBonus(activeDrinks, itemDetailMap, drinkConcentration = 0) {
        return parseTeaBuff(activeDrinks, itemDetailMap, drinkConcentration, {
            buffTypeHrids: ['/buff_types/processing'],
        });
    }

    /**
     * Parse Action Level bonus from active tea buffs
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.12 for 12%)
     * @returns {number} Action Level bonus as flat number (e.g., 5.645 for +5.645 levels, floored to 5 when used)
     *
     * @example
     * // With Artisan Tea (+5 Action Level base) and 12% Drink Concentration:
     * parseActionLevelBonus(activeDrinks, items, 0.129)
     * // Returns: 5.645 (scales with DC, but game floors this to 5 when calculating requirement)
     */
    function parseActionLevelBonus(activeDrinks, itemDetailMap, drinkConcentration = 0) {
        // Action Level DOES scale with DC (like all other buffs)
        // However, the game floors the result when calculating effective requirement
        return parseTeaBuff(activeDrinks, itemDetailMap, drinkConcentration, {
            buffTypeHrids: ['/buff_types/action_level'],
        });
    }

    /**
     * Parse Action Level bonus with breakdown by individual tea
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.12 for 12%)
     * @returns {Array<{name: string, actionLevel: number, baseActionLevel: number, dcContribution: number}>} Array of tea contributions
     *
     * @example
     * // With Artisan Tea (+5 Action Level base) and 12.9% Drink Concentration:
     * parseActionLevelBonusBreakdown(activeDrinks, items, 0.129)
     * // Returns: [{ name: "Artisan Tea", actionLevel: 5.645, baseActionLevel: 5.0, dcContribution: 0.645 }]
     * // Note: Game floors actionLevel to 5 when calculating requirement, but we show full precision
     */
    function parseActionLevelBonusBreakdown(activeDrinks, itemDetailMap, drinkConcentration = 0) {
        if (!activeDrinks || activeDrinks.length === 0) {
            return []; // No active teas
        }

        if (!itemDetailMap) {
            return []; // Missing required data
        }

        const teaBreakdown = [];

        // Process each active tea/drink
        for (const drink of activeDrinks) {
            if (!drink || !drink.itemHrid) {
                continue; // Empty slot
            }

            const itemDetails = itemDetailMap[drink.itemHrid];
            if (!itemDetails || !itemDetails.consumableDetail || !itemDetails.consumableDetail.buffs) {
                continue; // Not a consumable or has no buffs
            }

            let baseActionLevel = 0;
            let totalActionLevel = 0;

            // Check each buff on this tea
            for (const buff of itemDetails.consumableDetail.buffs) {
                // Action Level buff (e.g., Artisan Tea: +5 Action Level)
                if (buff.typeHrid === '/buff_types/action_level') {
                    const baseValue = buff.flatBoost;
                    // Action Level DOES scale with DC (like all other buffs)
                    const scaledValue = baseValue * (1 + drinkConcentration);
                    baseActionLevel += baseValue;
                    totalActionLevel += scaledValue;
                }
            }

            // Only add to breakdown if this tea contributes action level
            if (totalActionLevel > 0) {
                teaBreakdown.push({
                    name: itemDetails.name,
                    actionLevel: totalActionLevel,
                    baseActionLevel: baseActionLevel,
                    dcContribution: totalActionLevel - baseActionLevel,
                });
            }
        }

        return teaBreakdown;
    }

    /**
     * Parse Gathering bonus from active tea buffs
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.12 for 12%)
     * @returns {number} Gathering quantity bonus as decimal (e.g., 0.168 for 16.8% more items)
     *
     * @example
     * // With Gathering Tea (+15% base) and 12% Drink Concentration:
     * parseGatheringBonus(activeDrinks, items, 0.12)
     * // Returns: 0.168 (15% × 1.12 = 16.8% gathering quantity)
     */
    function parseGatheringBonus(activeDrinks, itemDetailMap, drinkConcentration = 0) {
        return parseTeaBuff(activeDrinks, itemDetailMap, drinkConcentration, {
            buffTypeHrids: ['/buff_types/gathering'],
        });
    }

    /**
     * Parse skill level bonus from active tea buffs for a specific action type
     * @param {string} actionTypeHrid - Action type HRID (e.g., "/action_types/cheesesmithing")
     * @param {Array} activeDrinks - Array of active drink items from actionTypeDrinkSlotsMap
     * @param {Object} itemDetailMap - Item details from init_client_data
     * @param {number} drinkConcentration - Drink Concentration stat (as decimal, e.g., 0.129 for 12.9%)
     * @returns {number} Total skill level bonus (e.g., 9.032 for +8 base × 1.129 DC)
     *
     * @example
     * // With Ultra Cheesesmithing Tea (+8 Cheesesmithing base) and 12.9% DC:
     * parseTeaSkillLevelBonus("/action_types/cheesesmithing", activeDrinks, items, 0.129)
     * // Returns: 9.032 (8 × 1.129 = 9.032 levels)
     */
    function parseTeaSkillLevelBonus(actionTypeHrid, activeDrinks, itemDetailMap, drinkConcentration = 0) {
        if (!activeDrinks || activeDrinks.length === 0) {
            return 0; // No active teas
        }

        if (!actionTypeHrid || !itemDetailMap) {
            return 0; // Missing required data
        }

        // Extract skill name from action type HRID
        // "/action_types/cheesesmithing" -> "cheesesmithing"
        const skillName = actionTypeHrid.split('/').pop();
        const skillLevelBuffType = `/buff_types/${skillName}_level`;

        let totalLevelBonus = 0;

        // Process each active tea/drink
        for (const drink of activeDrinks) {
            if (!drink || !drink.itemHrid) {
                continue; // Empty slot
            }

            const itemDetails = itemDetailMap[drink.itemHrid];
            if (!itemDetails || !itemDetails.consumableDetail || !itemDetails.consumableDetail.buffs) {
                continue; // Not a consumable or has no buffs
            }

            // Check each buff on this tea
            for (const buff of itemDetails.consumableDetail.buffs) {
                // Skill-specific level buff (e.g., "/buff_types/cheesesmithing_level")
                if (buff.typeHrid === skillLevelBuffType) {
                    const baseValue = buff.flatBoost;
                    const scaledValue = baseValue * (1 + drinkConcentration);
                    totalLevelBonus += scaledValue;
                }
            }
        }

        return totalLevelBonus;
    }

    var teaParser = {
        parseTeaEfficiency,
        getDrinkConcentration,
        parseArtisanBonus,
        parseGourmetBonus,
        parseProcessingBonus,
        parseActionLevelBonus,
        parseGatheringBonus,
        parseTeaSkillLevelBonus,
    };

    var teaParser$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        default: teaParser,
        getDrinkConcentration: getDrinkConcentration,
        parseActionLevelBonus: parseActionLevelBonus,
        parseActionLevelBonusBreakdown: parseActionLevelBonusBreakdown,
        parseArtisanBonus: parseArtisanBonus,
        parseGatheringBonus: parseGatheringBonus,
        parseGourmetBonus: parseGourmetBonus,
        parseProcessingBonus: parseProcessingBonus,
        parseTeaEfficiency: parseTeaEfficiency,
        parseTeaEfficiencyBreakdown: parseTeaEfficiencyBreakdown,
        parseTeaSkillLevelBonus: parseTeaSkillLevelBonus
    });

    /**
     * Action Calculator
     * Shared calculation logic for action time and efficiency
     * Used by action-time-display.js and quick-input-buttons.js
     */


    /**
     * Calculate complete action statistics (time + efficiency)
     * @param {Object} actionDetails - Action detail object from game data
     * @param {Object} options - Configuration options
     * @param {Array} options.skills - Character skills array
     * @param {Array} options.equipment - Character equipment array
     * @param {Object} options.itemDetailMap - Item detail map from game data
     * @param {string} options.actionHrid - Action HRID for task detection (optional)
     * @param {boolean} options.includeCommunityBuff - Include community buff in efficiency (default: false)
     * @param {boolean} options.includeBreakdown - Include detailed breakdown data (default: false)
     * @param {boolean} options.floorActionLevel - Floor Action Level bonus for requirement calculation (default: true)
     * @param {number} options.levelRequirementOverride - Override base level requirement (e.g., item level for alchemy)
     * @returns {Object} { actionTime, totalEfficiency, breakdown? }
     */
    function calculateActionStats(actionDetails, options = {}) {
        const {
            skills,
            equipment,
            itemDetailMap,
            actionHrid,
            includeCommunityBuff = false,
            includeBreakdown = false,
            floorActionLevel = true,
            levelRequirementOverride,
        } = options;

        try {
            // Calculate base action time
            const baseTime = actionDetails.baseTimeCost / 1e9; // nanoseconds to seconds

            // Get equipment speed bonus
            const speedBonus = parseEquipmentSpeedBonuses(equipment, actionDetails.type, itemDetailMap);

            // Calculate action time with equipment speed
            let actionTime = baseTime / (1 + speedBonus);

            // Apply task speed multiplicatively (if action is an active task)
            if (actionHrid && dataManager$1.isTaskAction(actionHrid)) {
                const taskSpeedBonus = dataManager$1.getTaskSpeedBonus(); // Returns percentage (e.g., 15 for 15%)
                actionTime = actionTime / (1 + taskSpeedBonus / 100); // Apply multiplicatively
            }

            // Calculate efficiency
            const skillLevel = getSkillLevel$1(skills, actionDetails.type);
            const baseRequirement = levelRequirementOverride ?? actionDetails.levelRequirement?.level ?? 1;

            // Get drink concentration
            const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);

            // Get active drinks for this action type
            const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);

            // Calculate Action Level bonus from teas
            const actionLevelBonus = parseActionLevelBonus(activeDrinks, itemDetailMap, drinkConcentration);

            // Get Action Level bonus breakdown (if requested)
            let actionLevelBreakdown = null;
            if (includeBreakdown) {
                actionLevelBreakdown = parseActionLevelBonusBreakdown(activeDrinks, itemDetailMap, drinkConcentration);
            }

            // Calculate effective requirement
            // Note: floorActionLevel flag for compatibility
            // - quick-input-buttons uses Math.floor (can't have fractional level requirements)
            // - action-time-display historically didn't floor (preserving for compatibility)
            const effectiveRequirement =
                baseRequirement + (floorActionLevel ? Math.floor(actionLevelBonus) : actionLevelBonus);

            // Calculate tea skill level bonus (e.g., +8 Cheesesmithing from Ultra Cheesesmithing Tea)
            const teaSkillLevelBonus = parseTeaSkillLevelBonus(
                actionDetails.type,
                activeDrinks,
                itemDetailMap,
                drinkConcentration
            );

            // Calculate efficiency components
            // Apply tea skill level bonus to effective player level
            const effectiveLevel = skillLevel + teaSkillLevelBonus;
            const levelEfficiency = Math.max(0, effectiveLevel - effectiveRequirement);
            const houseEfficiency = calculateHouseEfficiency(actionDetails.type);
            const equipmentEfficiency = parseEquipmentEfficiencyBonuses(equipment, actionDetails.type, itemDetailMap);
            const achievementEfficiency =
                dataManager$1.getAchievementBuffFlatBoost(actionDetails.type, '/buff_types/efficiency') * 100;

            // Calculate tea efficiency
            let teaEfficiency;
            let teaBreakdown = null;
            if (includeBreakdown) {
                // Get detailed breakdown
                teaBreakdown = parseTeaEfficiencyBreakdown(
                    actionDetails.type,
                    activeDrinks,
                    itemDetailMap,
                    drinkConcentration
                );
                teaEfficiency = teaBreakdown.reduce((sum, tea) => sum + tea.efficiency, 0);
            } else {
                // Simple total
                teaEfficiency = parseTeaEfficiency(actionDetails.type, activeDrinks, itemDetailMap, drinkConcentration);
            }

            // Get community buff efficiency (if requested)
            let communityEfficiency = 0;
            if (includeCommunityBuff) {
                // Production Efficiency buff applies to production skills and alchemy
                const productionSkills = [
                    '/action_types/alchemy',
                    '/action_types/brewing',
                    '/action_types/cheesesmithing',
                    '/action_types/cooking',
                    '/action_types/crafting',
                    '/action_types/tailoring',
                ];

                if (productionSkills.includes(actionDetails.type)) {
                    const communityBuffLevel = dataManager$1.getCommunityBuffLevel(
                        '/community_buff_types/production_efficiency'
                    );
                    communityEfficiency = communityBuffLevel ? (0.14 + (communityBuffLevel - 1) * 0.003) * 100 : 0;
                }
            }

            // Total efficiency (stack all components additively)
            const totalEfficiency = stackAdditive(
                levelEfficiency,
                houseEfficiency,
                equipmentEfficiency,
                teaEfficiency,
                communityEfficiency,
                achievementEfficiency
            );

            // Build result object
            const result = {
                actionTime,
                totalEfficiency,
            };

            // Add breakdown if requested
            if (includeBreakdown) {
                result.efficiencyBreakdown = {
                    levelEfficiency,
                    houseEfficiency,
                    equipmentEfficiency,
                    teaEfficiency,
                    teaBreakdown,
                    communityEfficiency,
                    achievementEfficiency,
                    skillLevel,
                    baseRequirement,
                    actionLevelBonus,
                    actionLevelBreakdown,
                    effectiveRequirement,
                };
            }

            return result;
        } catch (error) {
            console.error('[Action Calculator] Error calculating action stats:', error);
            return null;
        }
    }

    /**
     * Get character skill level for a skill type
     * @param {Array} skills - Character skills array
     * @param {string} skillType - Skill type HRID (e.g., "/action_types/cheesesmithing")
     * @returns {number} Skill level
     */
    function getSkillLevel$1(skills, skillType) {
        // Map action type to skill HRID
        const skillHrid = skillType.replace('/action_types/', '/skills/');
        const skill = skills.find((s) => s.skillHrid === skillHrid);
        return skill?.level || 1;
    }

    var actionCalculator = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateActionStats: calculateActionStats
    });

    /**
     * Action Panel Display Helper
     * Utilities for working with action detail panels (gathering, production, enhancement)
     */

    /**
     * Find the action count input field within a panel
     * @param {HTMLElement} panel - The action detail panel
     * @returns {HTMLInputElement|null} The input element or null if not found
     */
    function findActionInput(panel) {
        const inputContainer = panel.querySelector('[class*="maxActionCountInput"]');
        if (!inputContainer) {
            return null;
        }

        const inputField = inputContainer.querySelector('input');
        return inputField || null;
    }

    /**
     * Attach input listeners to an action panel for tracking value changes
     * Sets up three listeners:
     * - keyup: For manual typing
     * - input: For quick input button clicks (React dispatches input events)
     * - panel click: For any panel interactions with 50ms delay
     *
     * @param {HTMLElement} panel - The action detail panel
     * @param {HTMLInputElement} input - The input element
     * @param {Function} updateCallback - Callback function(value) called on input changes
     * @param {Object} options - Optional configuration
     * @param {number} options.clickDelay - Delay in ms for panel click handler (default: 50)
     * @returns {Function} Cleanup function to remove all listeners
     */
    function attachInputListeners(panel, input, updateCallback, options = {}) {
        const { clickDelay = 50 } = options;

        // Handler for keyup and input events
        const updateHandler = () => {
            updateCallback(input.value);
        };

        // Handler for panel clicks (with delay to allow React updates)
        const panelClickHandler = (event) => {
            // Skip if click is on the input box itself
            if (event.target === input) {
                return;
            }
            setTimeout(() => {
                updateCallback(input.value);
            }, clickDelay);
        };

        // Attach all listeners
        input.addEventListener('keyup', updateHandler);
        input.addEventListener('input', updateHandler);
        panel.addEventListener('click', panelClickHandler);

        // Return cleanup function
        return () => {
            input.removeEventListener('keyup', updateHandler);
            input.removeEventListener('input', updateHandler);
            panel.removeEventListener('click', panelClickHandler);
        };
    }

    /**
     * Perform initial update if input already has a valid value
     * @param {HTMLInputElement} input - The input element
     * @param {Function} updateCallback - Callback function(value) called if valid
     * @returns {boolean} True if initial update was performed
     */
    function performInitialUpdate(input, updateCallback) {
        if (input.value && parseInt(input.value) > 0) {
            updateCallback(input.value);
            return true;
        }
        return false;
    }

    var actionPanelHelper = /*#__PURE__*/Object.freeze({
        __proto__: null,
        attachInputListeners: attachInputListeners,
        findActionInput: findActionInput,
        performInitialUpdate: performInitialUpdate
    });

    /**
     * Buff Parser Utilities
     * Parse active buffs from character data
     */


    /**
     * Get alchemy success rate bonus from active buffs
     * @returns {number} Alchemy success rate bonus (0-1, e.g., 0.087 for 8.7% multiplicative bonus)
     */
    function getAlchemySuccessBonus() {
        try {
            const characterData = dataManager$1.characterData;
            if (!characterData || !characterData.consumableActionTypeBuffsMap) {
                return 0;
            }

            const alchemyBuffs = characterData.consumableActionTypeBuffsMap['/action_types/alchemy'];
            if (!Array.isArray(alchemyBuffs)) {
                return 0;
            }

            let bonus = 0;
            for (const buff of alchemyBuffs) {
                if (buff.typeHrid === '/buff_types/alchemy_success') {
                    // ratioBoost is already scaled with drink concentration by the game
                    bonus += buff.ratioBoost || 0;
                }
            }

            return bonus;
        } catch (error) {
            console.error('[BuffParser] Failed to get alchemy success bonus:', error);
            return 0;
        }
    }

    var buffParser = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getAlchemySuccessBonus: getAlchemySuccessBonus
    });

    /**
     * DOM Selector Constants
     * Centralized selector strings for querying game elements
     * If game class names change, update here only
     */

    /**
     * Game UI Selectors (class names from game code)
     */
    const GAME = {
        // Header
        TOTAL_LEVEL: '[class*="Header_totalLevel"]',

        // Settings Panel
        SETTINGS_PANEL_TITLE: '[class*="SettingsPanel_title"]',
        SETTINGS_TABS_CONTAINER: 'div[class*="SettingsPanel_tabsComponentContainer"]',
        TABS_FLEX_CONTAINER: '[class*="MuiTabs-flexContainer"]',
        TAB_PANELS_CONTAINER: '[class*="TabsComponent_tabPanelsContainer"]',
        TAB_PANEL: '[class*="TabPanel_tabPanel"]',

        // Game Panel
        GAME_PANEL: 'div[class*="GamePage_gamePanel"]',

        // Skill Action Detail
        SKILL_ACTION_DETAIL: '[class*="SkillActionDetail_skillActionDetail"]',
        SKILL_ACTION_NAME: '[class*="SkillActionDetail_name"]',
        ENHANCING_COMPONENT: 'div.SkillActionDetail_enhancingComponent__17bOx',

        // Action Queue
        QUEUED_ACTIONS: '[class*="QueuedActions_action"]',
        MAX_ACTION_COUNT_INPUT: '[class*="maxActionCountInput"]',

        // Tasks
        TASK_PANEL: '[class*="TasksPanel_taskSlotCount"]',
        TASK_LIST: '[class*="TasksPanel_taskList"]',
        TASK_CARD: '[class*="RandomTask_randomTask"]',
        TASK_NAME: '[class*="RandomTask_name"]',
        TASK_INFO: '.RandomTask_taskInfo__1uasf',
        TASK_ACTION: '.RandomTask_action__3eC6o',
        TASK_REWARDS: '.RandomTask_rewards__YZk7D',
        TASK_CONTENT: '[class*="RandomTask_content"]',
        TASK_NAME_DIV: 'div[class*="RandomTask_name"]',

        // House Panel
        HOUSE_HEADER: '[class*="HousePanel_header"]',
        HOUSE_COSTS: '[class*="HousePanel_costs"]',
        HOUSE_ITEM_REQUIREMENTS: '[class*="HousePanel_itemRequirements"]',

        // Inventory
        INVENTORY_ITEMS: '[class*="Inventory_items"]',
        INVENTORY_CATEGORY_BUTTON: '.Inventory_categoryButton__35s1x',
        INVENTORY_LABEL: '.Inventory_label__XEOAx',

        // Items
        ITEM_CONTAINER: '.Item_itemContainer__x7kH1',
        ITEM_ITEM: '.Item_item__2De2O',
        ITEM_COUNT: '.Item_count__1HVvv',
        ITEM_TOOLTIP_TEXT: '.ItemTooltipText_itemTooltipText__zFq3A',

        // Navigation/Experience Bars
        NAV_LEVEL: '[class*="NavigationBar_level"]',
        NAV_CURRENT_EXPERIENCE: '[class*="NavigationBar_currentExperience"]',

        // Enhancement
        PROTECTION_ITEM_INPUT: '[class*="protectionItemInputContainer"]',

        // Tooltips
        MUI_TOOLTIP: '.MuiTooltip-tooltip',
    };

    /**
     * Toolasha-specific selectors (our injected elements)
     */
    const TOOLASHA = {
        // Settings
        SETTINGS_TAB: '#toolasha-settings-tab',
        SETTING_WITH_DEPS: '.toolasha-setting[data-dependencies]',

        // Task features
        TASK_PROFIT: '.mwi-task-profit',
        REROLL_COST_DISPLAY: '.mwi-reroll-cost-display',

        // Action features
        QUEUE_TOTAL_TIME: '#mwi-queue-total-time',
        FORAGING_PROFIT: '#mwi-foraging-profit',
        PRODUCTION_PROFIT: '#mwi-production-profit',

        // House features
        HOUSE_PRICING: '.mwi-house-pricing',
        HOUSE_PRICING_EMPTY: '.mwi-house-pricing-empty',
        HOUSE_TOTAL: '.mwi-house-total',
        HOUSE_TO_LEVEL: '.mwi-house-to-level',

        // Profile/Combat Score
        SCORE_CLOSE_BTN: '#mwi-score-close-btn',
        SCORE_TOGGLE: '#mwi-score-toggle',
        SCORE_DETAILS: '#mwi-score-details',
        HOUSE_TOGGLE: '#mwi-house-toggle',
        HOUSE_BREAKDOWN: '#mwi-house-breakdown',
        ABILITY_TOGGLE: '#mwi-ability-toggle',
        ABILITY_BREAKDOWN: '#mwi-ability-breakdown',
        EQUIPMENT_TOGGLE: '#mwi-equipment-toggle',
        EQUIPMENT_BREAKDOWN: '#mwi-equipment-breakdown',

        // Market features
        MARKET_PRICE_INJECTED: '.market-price-injected',
        MARKET_PROFIT_INJECTED: '.market-profit-injected',
        MARKET_EV_INJECTED: '.market-ev-injected',
        MARKET_ENHANCEMENT_INJECTED: '.market-enhancement-injected',

        // UI features
        ALCHEMY_DIMMED: '.mwi-alchemy-dimmed',
        EXP_PERCENTAGE: '.mwi-exp-percentage',
        STACK_PRICE: '.mwi-stack-price',
        NETWORTH_HEADER: '.mwi-networth-header',

        // Enhancement
        ENHANCEMENT_STATS: '#mwi-enhancement-stats',

        // Generic
        COLLAPSIBLE_SECTION: '.mwi-collapsible-section',
        EXPANDABLE_HEADER: '.mwi-expandable-header',
        SECTION_HEADER_NEXT: '.mwi-section-header + div',

        // Legacy/cleanup markers
        INSERTED_SPAN: '.insertedSpan',
        SCRIPT_INJECTED: '.script-injected',
        CONSUMABLE_STATS_INJECTED: '.consumable-stats-injected',
    };

    /**
     * Enhancement-specific input IDs
     */
    const ENHANCEMENT = {
        TILL_LEVEL: '#tillLevel',
        TILL_LEVEL_INPUT: '#tillLevelInput',
        TILL_LEVEL_NUMBER: '#tillLevelNumber',
    };

    /**
     * Combat Sim Integration
     */
    const COMBAT_SIM = {
        GROUP_COMBAT_TAB: 'a#group-combat-tab',
        GET_PRICES_BUTTON: 'button#buttonGetPrices',
    };

    var selectors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        COMBAT_SIM: COMBAT_SIM,
        ENHANCEMENT: ENHANCEMENT,
        GAME: GAME,
        TOOLASHA: TOOLASHA
    });

    /**
     * Experience Calculator
     * Shared utility for calculating experience per hour across features
     *
     * Calculates accurate XP/hour including:
     * - Base experience from action
     * - Experience multipliers (Wisdom + Charm Experience)
     * - Action time with speed bonuses
     * - Efficiency repeats (critical for accuracy)
     */


    /**
     * Calculate experience per hour for an action
     * @param {string} actionHrid - The action HRID (e.g., "/actions/cheesesmithing/cheese")
     * @returns {Object|null} Experience data or null if not applicable
     *   {
     *     expPerHour: number,           // Total XP per hour (with all bonuses)
     *     baseExp: number,              // Base XP per action
     *     modifiedXP: number,           // XP per action after multipliers
     *     actionsPerHour: number,       // Actions per hour (with efficiency)
     *     xpMultiplier: number,         // Total XP multiplier (Wisdom + Charm)
     *     actionTime: number,           // Time per action in seconds
     *     totalEfficiency: number       // Total efficiency percentage
     *   }
     */
    function calculateExpPerHour(actionHrid) {
        const actionDetails = dataManager$1.getActionDetails(actionHrid);

        // Validate action has experience gain
        if (!actionDetails || !actionDetails.experienceGain || !actionDetails.experienceGain.value) {
            return null;
        }

        // Get character data
        const skills = dataManager$1.getSkills();
        const equipment = dataManager$1.getEquipment();
        const gameData = dataManager$1.getInitClientData();

        if (!gameData || !skills || !equipment) {
            return null;
        }

        // Calculate action stats (time + efficiency)
        const stats = calculateActionStats(actionDetails, {
            skills,
            equipment,
            itemDetailMap: gameData.itemDetailMap,
            includeCommunityBuff: true,
            includeBreakdown: false,
            floorActionLevel: true,
        });

        if (!stats) {
            return null;
        }

        const { actionTime, totalEfficiency } = stats;

        // Calculate actions per hour (base rate)
        const baseActionsPerHour = calculateActionsPerHour(actionTime);

        // Calculate average queued actions completed per time-consuming action
        // Efficiency gives guaranteed repeats + chance for extra
        const avgActionsPerBaseAction = calculateEfficiencyMultiplier(totalEfficiency);

        // Calculate actions per hour WITH efficiency (total completions including instant repeats)
        const actionsPerHourWithEfficiency = baseActionsPerHour * avgActionsPerBaseAction;

        // Calculate experience multiplier (Wisdom + Charm Experience)
        const skillHrid = actionDetails.experienceGain.skillHrid;
        const xpData = calculateExperienceMultiplier(skillHrid, actionDetails.type);

        // Calculate exp per hour with all bonuses
        const baseExp = actionDetails.experienceGain.value;
        const modifiedXP = baseExp * xpData.totalMultiplier;
        const expPerHour = actionsPerHourWithEfficiency * modifiedXP;

        return {
            expPerHour: Math.floor(expPerHour),
            baseExp,
            modifiedXP,
            actionsPerHour: actionsPerHourWithEfficiency,
            xpMultiplier: xpData.totalMultiplier,
            actionTime,
            totalEfficiency,
        };
    }

    var experienceCalculator = {
        calculateExpPerHour,
    };

    var experienceCalculator$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateExpPerHour: calculateExpPerHour,
        default: experienceCalculator
    });

    /**
     * Ability Cost Calculator Utility
     * Calculates the cost to reach a specific ability level
     * Extracted from ability-book-calculator.js for reuse in combat score
     */


    /**
     * List of starter abilities that give 50 XP per book (others give 500)
     */
    const STARTER_ABILITIES = [
        'poke',
        'scratch',
        'smack',
        'quick_shot',
        'water_strike',
        'fireball',
        'entangle',
        'minor_heal',
    ];

    /**
     * Check if an ability is a starter ability (50 XP per book)
     * @param {string} abilityHrid - Ability HRID
     * @returns {boolean} True if starter ability
     */
    function isStarterAbility(abilityHrid) {
        return STARTER_ABILITIES.some((skill) => abilityHrid.includes(skill));
    }

    /**
     * Calculate the cost to reach a specific ability level from level 0
     * @param {string} abilityHrid - Ability HRID (e.g., '/abilities/fireball')
     * @param {number} targetLevel - Target level to reach
     * @returns {number} Total cost in coins
     */
    function calculateAbilityCost(abilityHrid, targetLevel) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return 0;

        const levelXpTable = gameData.levelExperienceTable;
        if (!levelXpTable) return 0;

        // Get XP needed to reach target level from level 0
        const targetXp = levelXpTable[targetLevel] || 0;

        // Determine XP per book (50 for starters, 500 for advanced)
        const xpPerBook = isStarterAbility(abilityHrid) ? 50 : 500;

        // Calculate books needed
        let booksNeeded = targetXp / xpPerBook;
        booksNeeded += 1; // +1 book to learn the ability initially

        // Get market price for ability book
        const itemHrid = abilityHrid.replace('/abilities/', '/items/');
        const prices = marketAPI.getPrice(itemHrid, 0);

        if (!prices) return 0;

        // Match MCS behavior: if one price is positive and other is negative, use positive for both
        let ask = prices.ask;
        let bid = prices.bid;

        if (ask > 0 && bid < 0) {
            bid = ask;
        }
        if (bid > 0 && ask < 0) {
            ask = bid;
        }

        // Use weighted average
        const weightedPrice = (ask + bid) / 2;

        return booksNeeded * weightedPrice;
    }

    /**
     * Calculate the cost to level up an ability from current level to target level
     * @param {string} abilityHrid - Ability HRID
     * @param {number} currentLevel - Current ability level
     * @param {number} currentXp - Current ability XP
     * @param {number} targetLevel - Target ability level
     * @returns {number} Cost in coins
     */
    function calculateAbilityLevelUpCost(abilityHrid, currentLevel, currentXp, targetLevel) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return 0;

        const levelXpTable = gameData.levelExperienceTable;
        if (!levelXpTable) return 0;

        // Calculate XP needed
        const targetXp = levelXpTable[targetLevel] || 0;
        const xpNeeded = targetXp - currentXp;

        // Determine XP per book
        const xpPerBook = isStarterAbility(abilityHrid) ? 50 : 500;

        // Calculate books needed
        let booksNeeded = xpNeeded / xpPerBook;

        // If starting from level 0, need +1 book to learn initially
        if (currentLevel === 0) {
            booksNeeded += 1;
        }

        // Get market price
        const itemHrid = abilityHrid.replace('/abilities/', '/items/');
        const prices = marketAPI.getPrice(itemHrid, 0);

        if (!prices) return 0;

        // Match MCS behavior: if one price is positive and other is negative, use positive for both
        let ask = prices.ask;
        let bid = prices.bid;

        if (ask > 0 && bid < 0) {
            bid = ask;
        }
        if (bid > 0 && ask < 0) {
            ask = bid;
        }

        // Weighted average
        const weightedPrice = (ask + bid) / 2;

        return booksNeeded * weightedPrice;
    }

    var abilityCalc = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateAbilityCost: calculateAbilityCost,
        calculateAbilityLevelUpCost: calculateAbilityLevelUpCost,
        isStarterAbility: isStarterAbility
    });

    /**
     * Shared UI Components
     *
     * Reusable UI component builders for MWI Tools
     */

    /**
     * Create a collapsible section with expand/collapse functionality
     * @param {string} icon - Icon/emoji for the section (optional, pass empty string to omit)
     * @param {string} title - Section title
     * @param {string} summary - Summary text shown when collapsed (optional)
     * @param {HTMLElement} content - Content element to show/hide
     * @param {boolean} defaultOpen - Whether section starts open (default: false)
     * @param {number} indent - Indentation level: 0 = root, 1 = nested, etc. (default: 0)
     * @returns {HTMLElement} Section container
     */
    function createCollapsibleSection(icon, title, summary, content, defaultOpen = false, indent = 0) {
        const section = document.createElement('div');
        section.className = 'mwi-collapsible-section';
        section.style.cssText = `
        margin-top: ${indent > 0 ? '4px' : '8px'};
        margin-bottom: ${indent > 0 ? '4px' : '8px'};
        margin-left: ${indent * 16}px;
    `;

        // Create header
        const header = document.createElement('div');
        header.className = 'mwi-section-header';
        header.style.cssText = `
        display: flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
        padding: 4px 0;
        color: var(--text-color-primary, #fff);
        font-weight: ${indent === 0 ? '500' : '400'};
        font-size: ${indent > 0 ? '0.9em' : '1em'};
    `;

        const arrow = document.createElement('span');
        arrow.textContent = defaultOpen ? '▼' : '▶';
        arrow.style.cssText = `
        margin-right: 6px;
        font-size: 0.7em;
        transition: transform 0.2s;
    `;

        const label = document.createElement('span');
        if (icon) {
            // Emojis that need spacing fix (stopwatch has rendering issues in some browsers)
            const needsSpacingFix = icon === '⏱';
            if (needsSpacingFix) {
                label.innerHTML = `<span style="display: inline-block; margin-right: 0.25em;">${icon}</span> ${title}`;
            } else {
                label.textContent = `${icon} ${title}`;
            }
        } else {
            label.textContent = title;
        }

        header.appendChild(arrow);
        header.appendChild(label);

        // Create summary (shown when collapsed)
        const summaryDiv = document.createElement('div');
        summaryDiv.style.cssText = `
        margin-left: 16px;
        margin-top: 2px;
        color: var(--text-color-secondary, #888);
        font-size: 0.9em;
        display: ${defaultOpen ? 'none' : 'block'};
    `;
        if (summary) {
            summaryDiv.textContent = summary;
        }

        // Create content wrapper
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'mwi-section-content';
        contentWrapper.style.cssText = `
        display: ${defaultOpen ? 'block' : 'none'};
        margin-left: ${indent === 0 ? '16px' : '0px'};
        margin-top: 4px;
        color: var(--text-color-secondary, #888);
        font-size: 0.9em;
        line-height: 1.6;
        text-align: left;
    `;
        contentWrapper.appendChild(content);

        // Toggle functionality
        header.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event from bubbling to parent collapsible sections
            const isOpen = contentWrapper.style.display === 'block';
            contentWrapper.style.display = isOpen ? 'none' : 'block';
            if (summary) {
                summaryDiv.style.display = isOpen ? 'block' : 'none';
            }
            arrow.textContent = isOpen ? '▶' : '▼';
        });

        section.appendChild(header);
        if (summary) {
            section.appendChild(summaryDiv);
        }
        section.appendChild(contentWrapper);

        return section;
    }

    var uiComponents = {
        createCollapsibleSection,
    };

    var uiComponents$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createCollapsibleSection: createCollapsibleSection,
        default: uiComponents
    });

    /**
     * Skill Gear Detector
     *
     * Auto-detects gear and buffs from character equipment for any skill.
     * Originally designed for enhancing, now works generically for all skills.
     */


    /**
     * Detect best gear for a specific skill by equipment slot
     * @param {string} skillName - Skill name (e.g., 'enhancing', 'cooking', 'milking')
     * @param {Map} equipment - Character equipment map (equipped items only)
     * @param {Object} itemDetailMap - Item details map from init_client_data
     * @returns {Object} Best gear per slot with bonuses
     */
    function detectSkillGear(skillName, equipment, itemDetailMap) {
        const gear = {
            // Totals for calculations
            toolBonus: 0,
            speedBonus: 0,
            rareFindBonus: 0,
            experienceBonus: 0,

            // Best items per slot for display
            toolSlot: null, // main_hand or two_hand
            bodySlot: null, // body
            legsSlot: null, // legs
            handsSlot: null, // hands
        };

        // Get items to scan - only use equipment map (already filtered to equipped items only)
        let itemsToScan = [];

        if (equipment) {
            // Scan only equipped items from equipment map
            itemsToScan = Array.from(equipment.values()).filter((item) => item && item.itemHrid);
        }

        // Track best item per slot (by item level, then enhancement level)
        const slotCandidates = {
            tool: [], // main_hand or two_hand or skill-specific tool
            body: [], // body
            legs: [], // legs
            hands: [], // hands
            neck: [], // neck (accessories have 5× multiplier)
            ring: [], // ring (accessories have 5× multiplier)
            earring: [], // earring (accessories have 5× multiplier)
        };

        // Dynamic stat names based on skill
        const successStat = `${skillName}Success`;
        const speedStat = `${skillName}Speed`;
        const rareFindStat = `${skillName}RareFind`;
        const experienceStat = `${skillName}Experience`;

        // Search all items for skill-related bonuses and group by slot
        for (const item of itemsToScan) {
            const itemDetails = itemDetailMap[item.itemHrid];
            if (!itemDetails?.equipmentDetail?.noncombatStats) continue;

            const stats = itemDetails.equipmentDetail.noncombatStats;
            const enhancementLevel = item.enhancementLevel || 0;
            const multiplier = getEnhancementMultiplier(itemDetails, enhancementLevel);
            const equipmentType = itemDetails.equipmentDetail.type;

            // Generic stat calculation: Loop over ALL stats and apply multiplier
            const allStats = {};
            for (const [statName, statValue] of Object.entries(stats)) {
                if (typeof statValue !== 'number') continue; // Skip non-numeric values
                allStats[statName] = statValue * 100 * multiplier;
            }

            // Check if item has any skill-related stats (including universal skills)
            const hasSkillStats =
                allStats[successStat] ||
                allStats[speedStat] ||
                allStats[rareFindStat] ||
                allStats[experienceStat] ||
                allStats.skillingSpeed ||
                allStats.skillingExperience;

            if (!hasSkillStats) continue;

            // Calculate bonuses for this item (backward-compatible output)
            const itemBonuses = {
                item: item,
                itemDetails: itemDetails,
                itemLevel: itemDetails.itemLevel || 0,
                enhancementLevel: enhancementLevel,
                // Named bonuses (dynamic based on skill)
                toolBonus: allStats[successStat] || 0,
                speedBonus: (allStats[speedStat] || 0) + (allStats.skillingSpeed || 0), // Combine speed sources
                rareFindBonus: allStats[rareFindStat] || 0,
                experienceBonus: (allStats[experienceStat] || 0) + (allStats.skillingExperience || 0), // Combine experience sources
                // Generic access to all stats
                allStats: allStats,
            };

            // Group by slot
            // Tool slots: skill-specific tools (e.g., enhancing_tool, cooking_tool) plus main_hand/two_hand
            const skillToolType = `/equipment_types/${skillName}_tool`;
            if (
                equipmentType === skillToolType ||
                equipmentType === '/equipment_types/main_hand' ||
                equipmentType === '/equipment_types/two_hand'
            ) {
                slotCandidates.tool.push(itemBonuses);
            } else if (equipmentType === '/equipment_types/body') {
                slotCandidates.body.push(itemBonuses);
            } else if (equipmentType === '/equipment_types/legs') {
                slotCandidates.legs.push(itemBonuses);
            } else if (equipmentType === '/equipment_types/hands') {
                slotCandidates.hands.push(itemBonuses);
            } else if (equipmentType === '/equipment_types/neck') {
                slotCandidates.neck.push(itemBonuses);
            } else if (equipmentType === '/equipment_types/ring') {
                slotCandidates.ring.push(itemBonuses);
            } else if (equipmentType === '/equipment_types/earring') {
                slotCandidates.earring.push(itemBonuses);
            }
        }

        // Select best item per slot (highest item level, then highest enhancement level)
        const selectBest = (candidates) => {
            if (candidates.length === 0) return null;

            return candidates.reduce((best, current) => {
                // Compare by item level first
                if (current.itemLevel > best.itemLevel) return current;
                if (current.itemLevel < best.itemLevel) return best;

                // If item levels are equal, compare by enhancement level
                if (current.enhancementLevel > best.enhancementLevel) return current;
                return best;
            });
        };

        const bestTool = selectBest(slotCandidates.tool);
        const bestBody = selectBest(slotCandidates.body);
        const bestLegs = selectBest(slotCandidates.legs);
        const bestHands = selectBest(slotCandidates.hands);
        const bestNeck = selectBest(slotCandidates.neck);
        const bestRing = selectBest(slotCandidates.ring);
        const bestEarring = selectBest(slotCandidates.earring);

        // Add bonuses from best items in each slot
        if (bestTool) {
            gear.toolBonus += bestTool.toolBonus;
            gear.speedBonus += bestTool.speedBonus;
            gear.rareFindBonus += bestTool.rareFindBonus;
            gear.experienceBonus += bestTool.experienceBonus;
            gear.toolSlot = {
                name: bestTool.itemDetails.name,
                enhancementLevel: bestTool.enhancementLevel,
            };
        }

        if (bestBody) {
            gear.toolBonus += bestBody.toolBonus;
            gear.speedBonus += bestBody.speedBonus;
            gear.rareFindBonus += bestBody.rareFindBonus;
            gear.experienceBonus += bestBody.experienceBonus;
            gear.bodySlot = {
                name: bestBody.itemDetails.name,
                enhancementLevel: bestBody.enhancementLevel,
            };
        }

        if (bestLegs) {
            gear.toolBonus += bestLegs.toolBonus;
            gear.speedBonus += bestLegs.speedBonus;
            gear.rareFindBonus += bestLegs.rareFindBonus;
            gear.experienceBonus += bestLegs.experienceBonus;
            gear.legsSlot = {
                name: bestLegs.itemDetails.name,
                enhancementLevel: bestLegs.enhancementLevel,
            };
        }

        if (bestHands) {
            gear.toolBonus += bestHands.toolBonus;
            gear.speedBonus += bestHands.speedBonus;
            gear.rareFindBonus += bestHands.rareFindBonus;
            gear.experienceBonus += bestHands.experienceBonus;
            gear.handsSlot = {
                name: bestHands.itemDetails.name,
                enhancementLevel: bestHands.enhancementLevel,
            };
        }

        if (bestNeck) {
            gear.toolBonus += bestNeck.toolBonus;
            gear.speedBonus += bestNeck.speedBonus;
            gear.rareFindBonus += bestNeck.rareFindBonus;
            gear.experienceBonus += bestNeck.experienceBonus;
        }

        if (bestRing) {
            gear.toolBonus += bestRing.toolBonus;
            gear.speedBonus += bestRing.speedBonus;
            gear.rareFindBonus += bestRing.rareFindBonus;
            gear.experienceBonus += bestRing.experienceBonus;
        }

        if (bestEarring) {
            gear.toolBonus += bestEarring.toolBonus;
            gear.speedBonus += bestEarring.speedBonus;
            gear.rareFindBonus += bestEarring.rareFindBonus;
            gear.experienceBonus += bestEarring.experienceBonus;
        }

        return gear;
    }

    /**
     * Detect active enhancing teas from drink slots
     * @param {Array} drinkSlots - Active drink slots for enhancing action type
     * @param {Object} itemDetailMap - Item details map from init_client_data
     * @returns {Object} Active teas { enhancing, superEnhancing, ultraEnhancing, blessed }
     */
    function detectEnhancingTeas(drinkSlots, _itemDetailMap) {
        const teas = {
            enhancing: false, // Enhancing Tea (+3 levels)
            superEnhancing: false, // Super Enhancing Tea (+6 levels)
            ultraEnhancing: false, // Ultra Enhancing Tea (+8 levels)
            blessed: false, // Blessed Tea (1% double jump)
        };

        if (!drinkSlots || drinkSlots.length === 0) {
            return teas;
        }

        // Tea HRIDs to check for
        const teaMap = {
            '/items/enhancing_tea': 'enhancing',
            '/items/super_enhancing_tea': 'superEnhancing',
            '/items/ultra_enhancing_tea': 'ultraEnhancing',
            '/items/blessed_tea': 'blessed',
        };

        for (const drink of drinkSlots) {
            if (!drink || !drink.itemHrid) continue;

            const teaKey = teaMap[drink.itemHrid];
            if (teaKey) {
                teas[teaKey] = true;
            }
        }

        return teas;
    }

    /**
     * Get enhancing tea level bonus
     * @param {Object} teas - Active teas from detectEnhancingTeas()
     * @returns {number} Total level bonus from teas
     */
    function getEnhancingTeaLevelBonus(teas) {
        // Teas don't stack - highest one wins
        if (teas.ultraEnhancing) return 8;
        if (teas.superEnhancing) return 6;
        if (teas.enhancing) return 3;

        return 0;
    }

    /**
     * Get enhancing tea speed bonus (base, before concentration)
     * @param {Object} teas - Active teas from detectEnhancingTeas()
     * @returns {number} Base speed bonus % from teas
     */
    function getEnhancingTeaSpeedBonus(teas) {
        // Teas don't stack - highest one wins
        // Base speed bonuses (before drink concentration):
        if (teas.ultraEnhancing) return 6; // +6% base
        if (teas.superEnhancing) return 4; // +4% base
        if (teas.enhancing) return 2; // +2% base

        return 0;
    }

    /**
     * Backward-compatible wrapper for enhancing gear detection
     * @param {Map} equipment - Character equipment map (equipped items only)
     * @param {Object} itemDetailMap - Item details map from init_client_data
     * @returns {Object} Best enhancing gear per slot with bonuses
     */
    function detectEnhancingGear(equipment, itemDetailMap) {
        return detectSkillGear('enhancing', equipment, itemDetailMap);
    }

    var enhancementGearDetector = /*#__PURE__*/Object.freeze({
        __proto__: null,
        detectEnhancingGear: detectEnhancingGear,
        detectEnhancingTeas: detectEnhancingTeas,
        detectSkillGear: detectSkillGear,
        getEnhancingTeaLevelBonus: getEnhancingTeaLevelBonus,
        getEnhancingTeaSpeedBonus: getEnhancingTeaSpeedBonus
    });

    /**
     * Enhancement Configuration Manager
     *
     * Combines auto-detected enhancing parameters with manual overrides from settings.
     * Provides single source of truth for enhancement simulator inputs.
     */


    /**
     * Get enhancing parameters (auto-detected or manual)
     * @returns {Object} Enhancement parameters for simulator
     */
    function getEnhancingParams() {
        const autoDetect = config$1.getSettingValue('enhanceSim_autoDetect', false);

        if (autoDetect) {
            return getAutoDetectedParams();
        } else {
            return getManualParams();
        }
    }

    /**
     * Get auto-detected enhancing parameters from character data
     * @returns {Object} Auto-detected parameters
     */
    function getAutoDetectedParams() {
        // Get character data
        const equipment = dataManager$1.getEquipment();
        const skills = dataManager$1.getSkills();
        const drinkSlots = dataManager$1.getActionDrinkSlots('/action_types/enhancing');
        const itemDetailMap = dataManager$1.getInitClientData()?.itemDetailMap || {};

        // Detect gear from equipped items only
        const gear = detectEnhancingGear(equipment, itemDetailMap);

        // Detect drink concentration from equipment (Guzzling Pouch)
        // IMPORTANT: Only scan equipped items, not entire inventory
        let drinkConcentration = 0;
        const itemsToScan = equipment ? Array.from(equipment.values()).filter((item) => item && item.itemHrid) : [];

        for (const item of itemsToScan) {
            const itemDetails = itemDetailMap[item.itemHrid];
            if (!itemDetails?.equipmentDetail?.noncombatStats?.drinkConcentration) continue;

            const concentration = itemDetails.equipmentDetail.noncombatStats.drinkConcentration;
            const enhancementLevel = item.enhancementLevel || 0;
            const multiplier = getEnhancementMultiplier(itemDetails, enhancementLevel);
            const scaledConcentration = concentration * 100 * multiplier;

            // Only keep the highest concentration (shouldn't have multiple, but just in case)
            if (scaledConcentration > drinkConcentration) {
                drinkConcentration = scaledConcentration;
            }
        }

        // Detect teas
        const teas = detectEnhancingTeas(drinkSlots);

        // Get tea level bonus (base, then scale with concentration)
        const baseTeaLevel = getEnhancingTeaLevelBonus(teas);
        const teaLevelBonus = baseTeaLevel > 0 ? baseTeaLevel * (1 + drinkConcentration / 100) : 0;

        // Get tea speed bonus (base, then scale with concentration)
        const baseTeaSpeed = getEnhancingTeaSpeedBonus(teas);
        const teaSpeedBonus = baseTeaSpeed > 0 ? baseTeaSpeed * (1 + drinkConcentration / 100) : 0;

        // Get tea wisdom bonus (base, then scale with concentration)
        // Wisdom Tea/Coffee provide 12% wisdom, scales with drink concentration
        let baseTeaWisdom = 0;
        if (drinkSlots && drinkSlots.length > 0) {
            for (const drink of drinkSlots) {
                if (!drink || !drink.itemHrid) continue;
                const drinkDetails = itemDetailMap[drink.itemHrid];
                if (!drinkDetails?.consumableDetail?.buffs) continue;

                const wisdomBuff = drinkDetails.consumableDetail.buffs.find(
                    (buff) => buff.typeHrid === '/buff_types/wisdom'
                );

                if (wisdomBuff && wisdomBuff.flatBoost) {
                    baseTeaWisdom += wisdomBuff.flatBoost * 100; // Convert to percentage
                }
            }
        }
        const teaWisdomBonus = baseTeaWisdom > 0 ? baseTeaWisdom * (1 + drinkConcentration / 100) : 0;

        // Get Enhancing skill level
        const enhancingSkill = skills.find((s) => s.skillHrid === '/skills/enhancing');
        const enhancingLevel = enhancingSkill?.level || 1;

        // Get Observatory house room level (enhancing uses observatory, NOT laboratory!)
        const houseLevel = dataManager$1.getHouseRoomLevel('/house_rooms/observatory');

        // Calculate global house buffs from ALL house rooms
        // Rare Find: 0.2% base + 0.2% per level (per room, only if level >= 1)
        // Wisdom: 0.05% base + 0.05% per level (per room, only if level >= 1)
        const houseRooms = dataManager$1.getHouseRooms();
        let houseRareFindBonus = 0;
        let houseWisdomBonus = 0;

        for (const [_hrid, room] of houseRooms) {
            const level = room.level || 0;
            if (level >= 1) {
                // Each room: 0.2% per level (NOT 0.2% base + 0.2% per level)
                houseRareFindBonus += 0.2 * level;
                // Each room: 0.05% per level (NOT 0.05% base + 0.05% per level)
                houseWisdomBonus += 0.05 * level;
            }
        }

        // Get Enhancing Speed community buff level
        const communityBuffLevel = dataManager$1.getCommunityBuffLevel('/community_buff_types/enhancing_speed');
        // Formula: 20% base + 0.5% per level
        const communitySpeedBonus = communityBuffLevel > 0 ? 20 + (communityBuffLevel - 1) * 0.5 : 0;

        // Get Experience (Wisdom) community buff level
        const communityWisdomLevel = dataManager$1.getCommunityBuffLevel('/community_buff_types/experience');
        // Formula: 20% base + 0.5% per level (same as other community buffs)
        const communityWisdomBonus = communityWisdomLevel > 0 ? 20 + (communityWisdomLevel - 1) * 0.5 : 0;

        const achievementWisdomBonus =
            dataManager$1.getAchievementBuffFlatBoost('/action_types/enhancing', '/buff_types/wisdom') * 100;
        const achievementRareFindBonus =
            dataManager$1.getAchievementBuffFlatBoost('/action_types/enhancing', '/buff_types/rare_find') * 100;

        // Calculate total success rate bonus
        // Equipment + house + (check for other sources)
        const houseSuccessBonus = houseLevel * 0.05; // 0.05% per level for success
        const equipmentSuccessBonus = gear.toolBonus;
        const totalSuccessBonus = equipmentSuccessBonus + houseSuccessBonus;

        // Calculate total speed bonus
        // Speed bonus (from equipment) + house bonus (1% per level) + community buff + tea speed
        const houseSpeedBonus = houseLevel * 1.0; // 1% per level for action speed
        const totalSpeedBonus = gear.speedBonus + houseSpeedBonus + communitySpeedBonus + teaSpeedBonus;

        // Calculate total experience bonus
        // Equipment + house wisdom + tea wisdom + community wisdom + achievement wisdom
        const totalExperienceBonus =
            gear.experienceBonus + houseWisdomBonus + teaWisdomBonus + communityWisdomBonus + achievementWisdomBonus;

        // Calculate guzzling bonus multiplier (1.0 at level 0, scales with drink concentration)
        const guzzlingBonus = 1 + drinkConcentration / 100;

        return {
            // Core values for calculations
            enhancingLevel: enhancingLevel + teaLevelBonus, // Base level + tea bonus
            houseLevel: houseLevel,
            toolBonus: totalSuccessBonus, // Tool + house combined
            speedBonus: totalSpeedBonus, // Speed + house + community + tea combined
            rareFindBonus: gear.rareFindBonus + houseRareFindBonus + achievementRareFindBonus, // Rare find (equipment + house rooms + achievements)
            experienceBonus: totalExperienceBonus, // Experience (equipment + house + tea + community wisdom)
            guzzlingBonus: guzzlingBonus, // Drink concentration multiplier for blessed tea
            teas: teas,

            // Display info (for UI) - show best item per slot
            toolSlot: gear.toolSlot,
            bodySlot: gear.bodySlot,
            legsSlot: gear.legsSlot,
            handsSlot: gear.handsSlot,
            detectedTeaBonus: teaLevelBonus,
            communityBuffLevel: communityBuffLevel, // For display (speed)
            communitySpeedBonus: communitySpeedBonus, // For display
            communityWisdomLevel: communityWisdomLevel, // For display
            communityWisdomBonus: communityWisdomBonus, // For display
            achievementWisdomBonus: achievementWisdomBonus, // For display
            teaSpeedBonus: teaSpeedBonus, // For display
            teaWisdomBonus: teaWisdomBonus, // For display
            drinkConcentration: drinkConcentration, // For display
            houseRareFindBonus: houseRareFindBonus, // For display
            achievementRareFindBonus: achievementRareFindBonus, // For display
            houseWisdomBonus: houseWisdomBonus, // For display
            equipmentRareFind: gear.rareFindBonus, // For display
            equipmentExperience: gear.experienceBonus, // For display
            equipmentSuccessBonus: equipmentSuccessBonus, // For display
            houseSuccessBonus: houseSuccessBonus, // For display
            equipmentSpeedBonus: gear.speedBonus, // For display
            houseSpeedBonus: houseSpeedBonus, // For display
        };
    }

    /**
     * Get manual enhancing parameters from config settings
     * @returns {Object} Manual parameters
     */
    function getManualParams() {
        // Get values directly from config
        const getValue = (key, defaultValue) => {
            return config$1.getSettingValue(key, defaultValue);
        };

        const houseLevel = getValue('enhanceSim_houseLevel', 8);

        // Get tea selection from dropdown (replaces 3 separate checkboxes)
        const teaSelection = getValue('enhanceSim_tea', 'ultra');
        const teas = {
            enhancing: teaSelection === 'basic',
            superEnhancing: teaSelection === 'super',
            ultraEnhancing: teaSelection === 'ultra',
            blessed: getValue('enhanceSim_blessedTea', true),
        };

        // Calculate tea bonuses based on selection
        const teaLevelBonus =
            teaSelection === 'ultra' ? 8 : teaSelection === 'super' ? 6 : teaSelection === 'basic' ? 3 : 0;
        const teaSpeedBonus =
            teaSelection === 'ultra' ? 6 : teaSelection === 'super' ? 4 : teaSelection === 'basic' ? 2 : 0;

        // Calculate house bonuses
        const houseSpeedBonus = houseLevel * 1.0; // 1% per level
        const houseSuccessBonus = houseLevel * 0.05; // 0.05% per level

        // Get community buffs
        const communityBuffLevel = dataManager$1.getCommunityBuffLevel('/community_buff_types/enhancing_speed');
        const communitySpeedBonus = communityBuffLevel > 0 ? 20 + (communityBuffLevel - 1) * 0.5 : 0;

        // Equipment speed is whatever's left after house/community/tea
        const totalSpeed = getValue('enhanceSim_speedBonus', 48.5);
        const equipmentSpeedBonus = Math.max(0, totalSpeed - houseSpeedBonus - communitySpeedBonus - teaSpeedBonus);

        const toolBonusEquipment = getValue('enhanceSim_toolBonus', 6.05);
        const totalToolBonus = toolBonusEquipment + houseSuccessBonus;

        return {
            enhancingLevel: getValue('enhanceSim_enhancingLevel', 140) + teaLevelBonus,
            houseLevel: houseLevel,
            toolBonus: totalToolBonus, // Total = equipment + house
            speedBonus: totalSpeed,
            rareFindBonus: getValue('enhanceSim_rareFindBonus', 0),
            experienceBonus: getValue('enhanceSim_experienceBonus', 0),
            guzzlingBonus: 1 + getValue('enhanceSim_drinkConcentration', 12.9) / 100,
            teas: teas,

            // Display info for manual mode
            toolSlot: null,
            bodySlot: null,
            legsSlot: null,
            handsSlot: null,
            detectedTeaBonus: teaLevelBonus,
            communityBuffLevel: communityBuffLevel,
            communitySpeedBonus: communitySpeedBonus,
            teaSpeedBonus: teaSpeedBonus,
            equipmentSpeedBonus: equipmentSpeedBonus,
            houseSpeedBonus: houseSpeedBonus,
            equipmentSuccessBonus: toolBonusEquipment, // Just equipment
            houseSuccessBonus: houseSuccessBonus,
        };
    }

    var enhancementConfig = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getEnhancingParams: getEnhancingParams
    });

    /**
     * React Input Utility
     * Handles programmatic updates to React-controlled input elements
     *
     * React uses an internal _valueTracker to detect changes. When setting
     * input values programmatically, we must manipulate this tracker to
     * ensure React recognizes the change and updates its state.
     */

    /**
     * Set value on a React-controlled input element
     * This is the critical pattern for making React recognize programmatic changes
     *
     * @param {HTMLInputElement} input - Input element (text, number, etc.)
     * @param {string|number} value - Value to set
     * @param {Object} options - Optional configuration
     * @param {boolean} options.focus - Whether to focus the input after setting (default: true)
     * @param {boolean} options.dispatchInput - Whether to dispatch input event (default: true)
     * @param {boolean} options.dispatchChange - Whether to dispatch change event (default: false)
     */
    function setReactInputValue(input, value, options = {}) {
        const { focus = true, dispatchInput = true, dispatchChange = false } = options;

        if (!input) {
            console.warn('[React Input] No input element provided');
            return;
        }

        // Save the current value
        const lastValue = input.value;

        // Set the new value directly on the DOM
        input.value = value;

        // This is the critical part: React stores an internal _valueTracker
        // We need to set it to the old value before dispatching the event
        // so React sees the difference and updates its state
        const tracker = input._valueTracker;
        if (tracker) {
            tracker.setValue(lastValue);
        }

        // Dispatch events based on options
        if (dispatchInput) {
            const inputEvent = new Event('input', { bubbles: true });
            inputEvent.simulated = true;
            input.dispatchEvent(inputEvent);
        }

        if (dispatchChange) {
            const changeEvent = new Event('change', { bubbles: true });
            changeEvent.simulated = true;
            input.dispatchEvent(changeEvent);
        }

        // Focus the input to show the value
        if (focus) {
            input.focus();
        }
    }

    /**
     * Check if an input element is React-controlled
     * React-controlled inputs have an internal _valueTracker property
     *
     * @param {HTMLInputElement} input - Input element to check
     * @returns {boolean} True if React-controlled
     */
    function isReactControlledInput(input) {
        return input && input._valueTracker !== undefined;
    }

    /**
     * Set value on a select element (non-React pattern, for completeness)
     *
     * @param {HTMLSelectElement} select - Select element
     * @param {string} value - Value to select
     * @param {boolean} dispatchChange - Whether to dispatch change event (default: true)
     */
    function setSelectValue(select, value, dispatchChange = true) {
        if (!select) {
            console.warn('[React Input] No select element provided');
            return;
        }

        // Find and select the option
        for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value === value) {
                select.options[i].selected = true;
                break;
            }
        }

        // Dispatch change event
        if (dispatchChange) {
            select.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }

    /**
     * Set checked state on a checkbox/radio input (non-React pattern, for completeness)
     *
     * @param {HTMLInputElement} input - Checkbox or radio input
     * @param {boolean} checked - Checked state
     * @param {boolean} dispatchChange - Whether to dispatch change event (default: true)
     */
    function setCheckboxValue(input, checked, dispatchChange = true) {
        if (!input) {
            console.warn('[React Input] No input element provided');
            return;
        }

        input.checked = checked;

        // Dispatch change event
        if (dispatchChange) {
            input.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }

    var reactInput = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isReactControlledInput: isReactControlledInput,
        setCheckboxValue: setCheckboxValue,
        setReactInputValue: setReactInputValue,
        setSelectValue: setSelectValue
    });

    /**
     * Material Calculator Utility
     * Shared calculation logic for material requirements with artisan bonus
     */


    /**
     * Calculate materials reserved by queued actions
     * @param {string} actionHrid - Action HRID to check queue for (optional - if null, calculates for ALL queued actions)
     * @returns {Map<string, number>} Map of itemHrid -> queued quantity
     */
    function calculateQueuedMaterialsForAction(actionHrid = null) {
        const queuedMaterials = new Map();
        const gameData = dataManager$1.getInitClientData();

        if (!gameData) {
            return queuedMaterials;
        }

        // Get all queued actions
        const queuedActions = dataManager$1.getCurrentActions();

        if (!queuedActions || queuedActions.length === 0) {
            return queuedMaterials;
        }

        // Process each queued action
        for (const queuedAction of queuedActions) {
            // If actionHrid is specified, only process matching actions
            if (actionHrid && queuedAction.actionHrid !== actionHrid) {
                continue;
            }

            const actionDetails = dataManager$1.getActionDetails(queuedAction.actionHrid);
            if (!actionDetails) {
                continue;
            }

            // Calculate remaining actions for this queued action
            // Finite actions: maxCount is target, currentCount is progress
            // Infinite actions: Skip for now (would require material limit calculation which is complex)
            let actionCount = 0;
            if (queuedAction.hasMaxCount) {
                actionCount = queuedAction.maxCount - queuedAction.currentCount;
            } else {
                // Infinite action - skip for now (materials for infinite actions are complex)
                // User can use the "Ignore queue" setting if they queue many infinite actions
                continue;
            }

            if (actionCount <= 0) {
                continue;
            }

            // Calculate artisan bonus for this action type
            const artisanBonus = calculateArtisanBonus(actionDetails);

            // Process regular input items
            if (actionDetails.inputItems && actionDetails.inputItems.length > 0) {
                for (const input of actionDetails.inputItems) {
                    const basePerAction = input.count || input.amount || 1;

                    // Apply artisan reduction (same formula as profit-calculator)
                    const materialsPerAction = basePerAction * (1 - artisanBonus);

                    // Calculate total materials needed for this queued action
                    const totalForAction = Math.ceil(materialsPerAction * actionCount);

                    // Add to queued total
                    const currentQueued = queuedMaterials.get(input.itemHrid) || 0;
                    queuedMaterials.set(input.itemHrid, currentQueued + totalForAction);
                }
            }

            // Process upgrade item (if exists)
            if (actionDetails.upgradeItemHrid) {
                // Upgrade items always need exactly 1 per action, no artisan reduction
                const totalForAction = actionCount;

                const currentQueued = queuedMaterials.get(actionDetails.upgradeItemHrid) || 0;
                queuedMaterials.set(actionDetails.upgradeItemHrid, currentQueued + totalForAction);
            }
        }

        return queuedMaterials;
    }

    /**
     * Calculate material requirements for an action
     * @param {string} actionHrid - Action HRID (e.g., "/actions/crafting/celestial_enhancer")
     * @param {number} numActions - Number of actions to perform
     * @param {boolean} accountForQueue - Whether to subtract queued materials from available inventory (default: false)
     * @returns {Array<Object>} Array of material requirement objects (includes upgrade items)
     */
    function calculateMaterialRequirements(actionHrid, numActions, accountForQueue = false) {
        const actionDetails = dataManager$1.getActionDetails(actionHrid);
        const inventory = dataManager$1.getInventory();
        const gameData = dataManager$1.getInitClientData();

        if (!actionDetails) {
            return [];
        }

        // Calculate artisan bonus (material reduction from Artisan Tea)
        const artisanBonus = calculateArtisanBonus(actionDetails);

        // Get queued materials if accounting for queue
        // Pass null to get materials for ALL queued actions (not just matching actionHrid)
        const queuedMaterialsMap = accountForQueue ? calculateQueuedMaterialsForAction(null) : new Map();

        const materials = [];

        // Process regular input items first
        if (actionDetails.inputItems && actionDetails.inputItems.length > 0) {
            for (const input of actionDetails.inputItems) {
                const basePerAction = input.count || input.amount || 1;

                // Apply artisan reduction to materials
                // Materials are consumed PER ACTION
                // Efficiency gives bonus actions for FREE (no material cost)
                const materialsPerAction = basePerAction * (1 - artisanBonus);

                // Calculate total materials needed for requested actions
                const totalRequired = Math.ceil(materialsPerAction * numActions);

                const inventoryItem = inventory.find((i) => i.itemHrid === input.itemHrid);
                const have = inventoryItem?.count || 0;

                // Calculate queued and available amounts
                const queued = queuedMaterialsMap.get(input.itemHrid) || 0;
                const available = Math.max(0, have - queued);
                const missingAmount = Math.max(0, totalRequired - available);

                const itemDetails = gameData.itemDetailMap[input.itemHrid];
                if (!itemDetails) {
                    continue;
                }

                materials.push({
                    itemHrid: input.itemHrid,
                    itemName: itemDetails.name,
                    required: totalRequired,
                    have: have,
                    queued: queued,
                    available: available,
                    missing: missingAmount,
                    isTradeable: itemDetails.isTradable === true, // British spelling
                    isUpgradeItem: false,
                });
            }
        }

        // Process upgrade item at the end (if exists)
        if (actionDetails.upgradeItemHrid) {
            // Upgrade items always need exactly 1 per action, no artisan reduction
            const totalRequired = numActions;

            const inventoryItem = inventory.find((i) => i.itemHrid === actionDetails.upgradeItemHrid);
            const have = inventoryItem?.count || 0;

            // Calculate queued and available amounts
            const queued = queuedMaterialsMap.get(actionDetails.upgradeItemHrid) || 0;
            const available = Math.max(0, have - queued);
            const missingAmount = Math.max(0, totalRequired - available);

            const itemDetails = gameData.itemDetailMap[actionDetails.upgradeItemHrid];
            if (itemDetails) {
                materials.push({
                    itemHrid: actionDetails.upgradeItemHrid,
                    itemName: itemDetails.name,
                    required: totalRequired,
                    have: have,
                    queued: queued,
                    available: available,
                    missing: missingAmount,
                    isTradeable: itemDetails.isTradable === true, // British spelling
                    isUpgradeItem: true, // Flag to identify upgrade items
                });
            }
        }

        return materials;
    }

    /**
     * Calculate artisan bonus (material reduction) for an action
     * @param {Object} actionDetails - Action details from game data
     * @returns {number} Artisan bonus (0-1 decimal, e.g., 0.1129 for 11.29% reduction)
     */
    function calculateArtisanBonus(actionDetails) {
        try {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) {
                return 0;
            }

            // Get character data
            const equipment = dataManager$1.getEquipment();
            const itemDetailMap = gameData.itemDetailMap || {};

            // Calculate artisan bonus (material reduction from Artisan Tea)
            const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);
            const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);
            const artisanBonus = parseArtisanBonus(activeDrinks, itemDetailMap, drinkConcentration);

            return artisanBonus;
        } catch (error) {
            console.error('[Material Calculator] Error calculating artisan bonus:', error);
            return 0;
        }
    }

    var materialCalculator = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateMaterialRequirements: calculateMaterialRequirements,
        calculateQueuedMaterialsForAction: calculateQueuedMaterialsForAction
    });

    /**
     * Pricing Helper Utility
     * Shared logic for selecting market prices based on pricing mode settings
     */


    /**
     * Select appropriate price from market data based on pricing mode settings
     * @param {Object} priceData - Market price data with bid/ask properties
     * @param {string} modeSetting - Config setting key for pricing mode (default: 'profitCalc_pricingMode')
     * @param {string} respectSetting - Config setting key for respect pricing mode flag (default: 'expectedValue_respectPricingMode')
     * @returns {number} Selected price (bid or ask)
     */
    function selectPrice(
        priceData,
        modeSetting = 'profitCalc_pricingMode',
        respectSetting = 'expectedValue_respectPricingMode'
    ) {
        if (!priceData) return 0;

        const pricingMode = config$1.getSettingValue(modeSetting, 'conservative');
        const respectPricingMode = config$1.getSettingValue(respectSetting, true);

        // If not respecting mode or mode is conservative, always use bid
        if (!respectPricingMode || pricingMode === 'conservative') {
            return priceData.bid || 0;
        }

        // Hybrid/Optimistic: Use ask
        return priceData.ask || 0;
    }

    var pricingHelper = /*#__PURE__*/Object.freeze({
        __proto__: null,
        selectPrice: selectPrice
    });

    /**
     * Cleanup Registry Utility
     * Centralized registration for listeners, observers, timers, and custom cleanup.
     */

    /**
     * Create a cleanup registry for deterministic teardown.
     * @returns {{
     *   registerListener: (target: EventTarget, event: string, handler: Function, options?: Object) => void,
     *   registerObserver: (observer: MutationObserver|{ disconnect: Function }) => void,
     *   registerInterval: (intervalId: number) => void,
     *   registerTimeout: (timeoutId: number) => void,
     *   registerCleanup: (cleanupFn: Function) => void,
     *   cleanupAll: () => void
     * }} Cleanup registry API
     */
    function createCleanupRegistry() {
        const listeners = [];
        const observers = [];
        const intervals = [];
        const timeouts = [];
        const customCleanups = [];

        const registerListener = (target, event, handler, options) => {
            if (!target || !event || !handler) {
                console.warn('[CleanupRegistry] registerListener called with invalid arguments');
                return;
            }

            target.addEventListener(event, handler, options);
            listeners.push({ target, event, handler, options });
        };

        const registerObserver = (observer) => {
            if (!observer || typeof observer.disconnect !== 'function') {
                console.warn('[CleanupRegistry] registerObserver called with invalid observer');
                return;
            }

            observers.push(observer);
        };

        const registerInterval = (intervalId) => {
            if (!intervalId) {
                console.warn('[CleanupRegistry] registerInterval called with invalid interval id');
                return;
            }

            intervals.push(intervalId);
        };

        const registerTimeout = (timeoutId) => {
            if (!timeoutId) {
                console.warn('[CleanupRegistry] registerTimeout called with invalid timeout id');
                return;
            }

            timeouts.push(timeoutId);
        };

        const registerCleanup = (cleanupFn) => {
            if (typeof cleanupFn !== 'function') {
                console.warn('[CleanupRegistry] registerCleanup called with invalid function');
                return;
            }

            customCleanups.push(cleanupFn);
        };

        const cleanupAll = () => {
            listeners.forEach(({ target, event, handler, options }) => {
                try {
                    target.removeEventListener(event, handler, options);
                } catch (error) {
                    console.error('[CleanupRegistry] Failed to remove listener:', error);
                }
            });
            listeners.length = 0;

            observers.forEach((observer) => {
                try {
                    observer.disconnect();
                } catch (error) {
                    console.error('[CleanupRegistry] Failed to disconnect observer:', error);
                }
            });
            observers.length = 0;

            intervals.forEach((intervalId) => {
                try {
                    clearInterval(intervalId);
                } catch (error) {
                    console.error('[CleanupRegistry] Failed to clear interval:', error);
                }
            });
            intervals.length = 0;

            timeouts.forEach((timeoutId) => {
                try {
                    clearTimeout(timeoutId);
                } catch (error) {
                    console.error('[CleanupRegistry] Failed to clear timeout:', error);
                }
            });
            timeouts.length = 0;

            customCleanups.forEach((cleanupFn) => {
                try {
                    cleanupFn();
                } catch (error) {
                    console.error('[CleanupRegistry] Custom cleanup failed:', error);
                }
            });
            customCleanups.length = 0;
        };

        return {
            registerListener,
            registerObserver,
            registerInterval,
            registerTimeout,
            registerCleanup,
            cleanupAll,
        };
    }

    var cleanupRegistry = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createCleanupRegistry: createCleanupRegistry
    });

    /**
     * House Cost Calculator Utility
     * Calculates the total cost to build house rooms to specific levels
     * Used for combat score calculation
     */


    /**
     * Calculate the total cost to build a house room to a specific level
     * @param {string} houseRoomHrid - House room HRID (e.g., '/house_rooms/dojo')
     * @param {number} currentLevel - Target level (1-8)
     * @returns {number} Total build cost in coins
     */
    function calculateHouseBuildCost(houseRoomHrid, currentLevel) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return 0;

        const houseRoomDetailMap = gameData.houseRoomDetailMap;
        if (!houseRoomDetailMap) return 0;

        const houseDetail = houseRoomDetailMap[houseRoomHrid];
        if (!houseDetail) return 0;

        const upgradeCostsMap = houseDetail.upgradeCostsMap;
        if (!upgradeCostsMap) return 0;

        let totalCost = 0;

        // Sum costs for all levels from 1 to current
        for (let level = 1; level <= currentLevel; level++) {
            const levelUpgrades = upgradeCostsMap[level];
            if (!levelUpgrades) continue;

            // Add cost for each material required at this level
            for (const item of levelUpgrades) {
                // Special case: Coins have face value of 1 (no market price)
                if (item.itemHrid === '/items/coin') {
                    const itemCost = item.count * 1;
                    totalCost += itemCost;
                    continue;
                }

                const prices = marketAPI.getPrice(item.itemHrid, 0);
                if (!prices) continue;

                // Match MCS behavior: if one price is positive and other is negative, use positive for both
                let ask = prices.ask;
                let bid = prices.bid;

                if (ask > 0 && bid < 0) {
                    bid = ask;
                }
                if (bid > 0 && ask < 0) {
                    ask = bid;
                }

                // Use weighted average
                const weightedPrice = (ask + bid) / 2;

                const itemCost = item.count * weightedPrice;
                totalCost += itemCost;
            }
        }

        return totalCost;
    }

    /**
     * Calculate total cost for all battle houses
     * @param {Object} characterHouseRooms - Map of character house rooms from profile data
     * @returns {Object} {totalCost, breakdown: [{name, level, cost}]}
     */
    function calculateBattleHousesCost(characterHouseRooms) {
        const battleHouses = ['dining_room', 'library', 'dojo', 'gym', 'armory', 'archery_range', 'mystical_study'];

        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return { totalCost: 0, breakdown: [] };

        const houseRoomDetailMap = gameData.houseRoomDetailMap;
        if (!houseRoomDetailMap) return { totalCost: 0, breakdown: [] };

        let totalCost = 0;
        const breakdown = [];

        for (const [houseRoomHrid, houseData] of Object.entries(characterHouseRooms)) {
            // Check if this is a battle house
            const isBattleHouse = battleHouses.some((battleHouse) => houseRoomHrid.includes(battleHouse));

            if (!isBattleHouse) continue;

            const level = houseData.level || 0;
            if (level === 0) continue;

            const cost = calculateHouseBuildCost(houseRoomHrid, level);
            totalCost += cost;

            // Get human-readable name
            const houseDetail = houseRoomDetailMap[houseRoomHrid];
            const houseName = houseDetail?.name || houseRoomHrid.replace('/house_rooms/', '');

            breakdown.push({
                name: houseName,
                level: level,
                cost: cost,
            });
        }

        // Sort by cost descending
        breakdown.sort((a, b) => b.cost - a.cost);

        return { totalCost, breakdown };
    }

    var houseCostCalculator$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateBattleHousesCost: calculateBattleHousesCost,
        calculateHouseBuildCost: calculateHouseBuildCost
    });

    /**
     * Enhancement Calculator
     *
     * Uses Markov Chain matrix math to calculate exact expected values for enhancement attempts.
     * Based on the original MWI Tools Enhancelate() function.
     *
     * Math.js library is loaded via userscript @require header.
     */

    /**
     * Base success rates by enhancement level (before bonuses)
     */
    const BASE_SUCCESS_RATES$1 = [
        50, // +1
        45, // +2
        45, // +3
        40, // +4
        40, // +5
        40, // +6
        35, // +7
        35, // +8
        35, // +9
        35, // +10
        30, // +11
        30, // +12
        30, // +13
        30, // +14
        30, // +15
        30, // +16
        30, // +17
        30, // +18
        30, // +19
        30, // +20
    ];

    /**
     * Calculate total success rate bonus multiplier
     * @param {Object} params - Enhancement parameters
     * @param {number} params.enhancingLevel - Effective enhancing level (base + tea bonus)
     * @param {number} params.toolBonus - Tool success bonus % (already includes equipment + house bonus)
     * @param {number} params.itemLevel - Item level being enhanced
     * @returns {number} Success rate multiplier (e.g., 1.0519 = 105.19% of base rates)
     */
    function calculateSuccessMultiplier(params) {
        const { enhancingLevel, toolBonus, itemLevel } = params;

        // Total bonus calculation
        // toolBonus already includes equipment + house success bonus from config
        // We only need to add level advantage here

        let totalBonus;

        if (enhancingLevel >= itemLevel) {
            // Above or at item level: +0.05% per level above item level
            const levelAdvantage = 0.05 * (enhancingLevel - itemLevel);
            totalBonus = 1 + (toolBonus + levelAdvantage) / 100;
        } else {
            // Below item level: Penalty based on level deficit
            totalBonus = 1 - 0.5 * (1 - enhancingLevel / itemLevel) + toolBonus / 100;
        }

        return totalBonus;
    }

    /**
     * Calculate per-action time for enhancement
     * Simple calculation that doesn't require Markov chain analysis
     * @param {number} enhancingLevel - Effective enhancing level (includes tea bonus)
     * @param {number} itemLevel - Item level being enhanced
     * @param {number} speedBonus - Speed bonus % (for action time calculation)
     * @returns {number} Per-action time in seconds
     */
    function calculatePerActionTime(enhancingLevel, itemLevel, speedBonus = 0) {
        const baseActionTime = 12; // seconds
        let speedMultiplier;

        if (enhancingLevel > itemLevel) {
            // Above item level: Get speed bonus from level advantage + equipment + house
            // Note: speedBonus already includes house level bonus (1% per level)
            speedMultiplier = 1 + (enhancingLevel - itemLevel + speedBonus) / 100;
        } else {
            // Below item level: Only equipment + house speed bonus
            // Note: speedBonus already includes house level bonus (1% per level)
            speedMultiplier = 1 + speedBonus / 100;
        }

        return baseActionTime / speedMultiplier;
    }

    /**
     * Calculate enhancement statistics using Markov Chain matrix inversion
     * @param {Object} params - Enhancement parameters
     * @param {number} params.enhancingLevel - Effective enhancing level (includes tea bonus)
     * @param {number} params.houseLevel - Observatory house room level (used for speed calculation only)
     * @param {number} params.toolBonus - Tool success bonus % (already includes equipment + house success bonus from config)
     * @param {number} params.speedBonus - Speed bonus % (for action time calculation)
     * @param {number} params.itemLevel - Item level being enhanced
     * @param {number} params.targetLevel - Target enhancement level (1-20)
     * @param {number} params.protectFrom - Start using protection items at this level (0 = never)
     * @param {boolean} params.blessedTea - Whether Blessed Tea is active (1% double jump)
     * @param {number} params.guzzlingBonus - Drink concentration multiplier (1.0 = no bonus, scales blessed tea)
     * @returns {Object} Enhancement statistics
     */
    function calculateEnhancement(params) {
        const {
            enhancingLevel,
            _houseLevel,
            toolBonus,
            speedBonus = 0,
            itemLevel,
            targetLevel,
            protectFrom = 0,
            blessedTea = false,
            guzzlingBonus = 1.0,
        } = params;

        // Validate inputs
        if (targetLevel < 1 || targetLevel > 20) {
            throw new Error('Target level must be between 1 and 20');
        }
        if (protectFrom < 0 || protectFrom > targetLevel) {
            throw new Error('Protection level must be between 0 and target level');
        }

        // Calculate success rate multiplier
        const successMultiplier = calculateSuccessMultiplier({
            enhancingLevel,
            toolBonus,
            itemLevel,
        });

        // Build Markov Chain transition matrix (20×20)
        const markov = math.zeros(20, 20);

        for (let i = 0; i < targetLevel; i++) {
            const baseSuccessRate = BASE_SUCCESS_RATES$1[i] / 100.0;
            const successChance = baseSuccessRate * successMultiplier;

            // Where do we go on failure?
            // Protection only applies when protectFrom > 0 AND we're at or above that level
            const failureDestination = protectFrom > 0 && i >= protectFrom ? i - 1 : 0;

            if (blessedTea) {
                // Blessed Tea: 1% base chance to jump +2, scaled by guzzling bonus
                // Remaining success chance goes to +1 (after accounting for skip chance)
                const skipChance = successChance * 0.01 * guzzlingBonus;
                const remainingSuccess = successChance * (1 - 0.01 * guzzlingBonus);

                markov.set([i, i + 2], skipChance);
                markov.set([i, i + 1], remainingSuccess);
                markov.set([i, failureDestination], 1 - successChance);
            } else {
                // Normal: Success goes to +1, failure goes to destination
                markov.set([i, i + 1], successChance);
                markov.set([i, failureDestination], 1.0 - successChance);
            }
        }

        // Absorbing state at target level
        markov.set([targetLevel, targetLevel], 1.0);

        // Extract transient matrix Q (all states before target)
        const Q = markov.subset(math.index(math.range(0, targetLevel), math.range(0, targetLevel)));

        // Fundamental matrix: M = (I - Q)^-1
        const I = math.identity(targetLevel);
        const M = math.inv(math.subtract(I, Q));

        // Expected attempts from level 0 to target
        // Sum all elements in first row of M up to targetLevel
        let attempts = 0;
        for (let i = 0; i < targetLevel; i++) {
            attempts += M.get([0, i]);
        }

        // Expected protection item uses
        let protects = 0;
        if (protectFrom > 0 && protectFrom < targetLevel) {
            for (let i = protectFrom; i < targetLevel; i++) {
                const timesAtLevel = M.get([0, i]);
                const failureChance = markov.get([i, i - 1]);
                protects += timesAtLevel * failureChance;
            }
        }

        // Action time calculation
        const baseActionTime = 12; // seconds
        let speedMultiplier;

        if (enhancingLevel > itemLevel) {
            // Above item level: Get speed bonus from level advantage + equipment + house
            // Note: speedBonus already includes house level bonus (1% per level)
            speedMultiplier = 1 + (enhancingLevel - itemLevel + speedBonus) / 100;
        } else {
            // Below item level: Only equipment + house speed bonus
            // Note: speedBonus already includes house level bonus (1% per level)
            speedMultiplier = 1 + speedBonus / 100;
        }

        const perActionTime = baseActionTime / speedMultiplier;
        const totalTime = perActionTime * attempts;

        return {
            attempts: attempts, // Keep exact decimal value for calculations
            attemptsRounded: Math.round(attempts), // Rounded for display
            protectionCount: protects, // Keep decimal precision
            perActionTime: perActionTime,
            totalTime: totalTime,
            successMultiplier: successMultiplier,

            // Detailed success rates for each level
            successRates: BASE_SUCCESS_RATES$1.slice(0, targetLevel).map((base, i) => {
                return {
                    level: i + 1,
                    baseRate: base,
                    actualRate: Math.min(100, base * successMultiplier),
                };
            }),
        };
    }

    var enhancementCalculator = /*#__PURE__*/Object.freeze({
        __proto__: null,
        calculateEnhancement: calculateEnhancement,
        calculatePerActionTime: calculatePerActionTime
    });

    /**
     * Foundation Utils Library
     * All utility modules
     *
     * Exports to: window.Toolasha.Utils
     */


    // Export to global namespace
    const toolashaRoot$4 = window.Toolasha || {};
    window.Toolasha = toolashaRoot$4;

    if (typeof unsafeWindow !== 'undefined') {
        unsafeWindow.Toolasha = toolashaRoot$4;
    }

    toolashaRoot$4.Utils = {
        formatters,
        efficiency: efficiency$1,
        profitHelpers: profitHelpers$1,
        profitConstants: profitConstants$1,
        dom: dom$1,
        domObserverHelpers,
        timerRegistry: timerRegistry$3,
        bonusRevenueCalculator,
        enhancementMultipliers,
        experienceParser: experienceParser$1,
        marketListings,
        actionCalculator,
        actionPanelHelper,
        teaParser: teaParser$1,
        buffParser,
        selectors,
        houseEfficiency: houseEfficiency$1,
        experienceCalculator: experienceCalculator$1,
        marketData: marketData$1,
        abilityCalc,
        equipmentParser,
        uiComponents: uiComponents$1,
        enhancementConfig,
        enhancementGearDetector,
        reactInput,
        materialCalculator,
        tokenValuation,
        pricingHelper,
        cleanupRegistry,
        houseCostCalculator: houseCostCalculator$1,
        enhancementCalculator,
    };

    console.log('[Toolasha] Utils library loaded');

    /**
     * Profit Calculator Module
     * Calculates production costs and profit for crafted items
     */


    /**
     * ProfitCalculator class handles profit calculations for production actions
     */
    class ProfitCalculator {
        constructor() {
            // Cached static game data (never changes during session)
            this._itemDetailMap = null;
            this._actionDetailMap = null;
            this._communityBuffMap = null;
        }

        /**
         * Get item detail map (lazy-loaded and cached)
         * @returns {Object} Item details map from init_client_data
         */
        getItemDetailMap() {
            if (!this._itemDetailMap) {
                const initData = dataManager$1.getInitClientData();
                this._itemDetailMap = initData?.itemDetailMap || {};
            }
            return this._itemDetailMap;
        }

        /**
         * Get action detail map (lazy-loaded and cached)
         * @returns {Object} Action details map from init_client_data
         */
        getActionDetailMap() {
            if (!this._actionDetailMap) {
                const initData = dataManager$1.getInitClientData();
                this._actionDetailMap = initData?.actionDetailMap || {};
            }
            return this._actionDetailMap;
        }

        /**
         * Get community buff map (lazy-loaded and cached)
         * @returns {Object} Community buff details map from init_client_data
         */
        getCommunityBuffMap() {
            if (!this._communityBuffMap) {
                const initData = dataManager$1.getInitClientData();
                this._communityBuffMap = initData?.communityBuffTypeDetailMap || {};
            }
            return this._communityBuffMap;
        }

        /**
         * Calculate profit for a crafted item
         * @param {string} itemHrid - Item HRID
         * @returns {Promise<Object|null>} Profit data or null if not craftable
         */
        async calculateProfit(itemHrid) {
            // Get item details
            const itemDetails = dataManager$1.getItemDetails(itemHrid);
            if (!itemDetails) {
                return null;
            }

            // Find the action that produces this item
            const action = this.findProductionAction(itemHrid);
            if (!action) {
                return null; // Not a craftable item
            }

            // Get character skills for efficiency calculations
            const skills = dataManager$1.getSkills();
            if (!skills) {
                return null;
            }

            const actionDetails = dataManager$1.getActionDetails(action.actionHrid);
            if (!actionDetails) {
                return null;
            }

            // Initialize price cache for this calculation
            const priceCache = new Map();
            const getCachedPrice = (itemHridParam, options) => {
                const side = options?.side || '';
                const enhancementLevelParam = options?.enhancementLevel ?? '';
                const cacheKey = `${itemHridParam}|${side}|${enhancementLevelParam}`;

                if (priceCache.has(cacheKey)) {
                    return priceCache.get(cacheKey);
                }

                const price = getItemPrice(itemHridParam, options);
                priceCache.set(cacheKey, price);
                return price;
            };

            // Calculate base action time
            // Game uses NANOSECONDS (1e9 = 1 second)
            const baseTime = actionDetails.baseTimeCost / 1e9; // Convert nanoseconds to seconds

            // Get character level for the action's skill
            const skillLevel = this.getSkillLevel(skills, actionDetails.type);

            // Get equipped items for efficiency bonus calculation
            const characterEquipment = dataManager$1.getEquipment();
            const itemDetailMap = this.getItemDetailMap();

            // Get Drink Concentration from equipment
            const drinkConcentration = getDrinkConcentration(characterEquipment, itemDetailMap);

            // Get active drinks for this action type
            const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);

            // Calculate Action Level bonus from teas (e.g., Artisan Tea: +5 Action Level)
            // This lowers the effective requirement, not increases skill level
            const actionLevelBonus = parseActionLevelBonus(activeDrinks, itemDetailMap, drinkConcentration);

            // Calculate efficiency components
            // Action Level bonus increases the effective requirement
            const baseRequirement = actionDetails.levelRequirement?.level || 1;
            // Calculate tea skill level bonus (e.g., +8 Cheesesmithing from Ultra Cheesesmithing Tea)
            const teaSkillLevelBonus = parseTeaSkillLevelBonus(
                actionDetails.type,
                activeDrinks,
                itemDetailMap,
                drinkConcentration
            );

            // Calculate artisan material cost reduction
            const artisanBonus = parseArtisanBonus(activeDrinks, itemDetailMap, drinkConcentration);

            // Calculate gourmet bonus (Brewing/Cooking extra items)
            const gourmetBonus = parseGourmetBonus(activeDrinks, itemDetailMap, drinkConcentration);

            // Calculate processing bonus (Milking/Foraging/Woodcutting conversions)
            const processingBonus = parseProcessingBonus(activeDrinks, itemDetailMap, drinkConcentration);

            // Get community buff bonus (Production Efficiency)
            const communityBuffLevel = dataManager$1.getCommunityBuffLevel('/community_buff_types/production_efficiency');
            const communityEfficiency = this.calculateCommunityBuffBonus(communityBuffLevel, actionDetails.type);

            // Total efficiency bonus (all sources additive)
            const houseEfficiency = calculateHouseEfficiency(actionDetails.type);

            // Calculate equipment efficiency bonus
            const equipmentEfficiency = parseEquipmentEfficiencyBonuses(
                characterEquipment,
                actionDetails.type,
                itemDetailMap
            );

            // Calculate tea efficiency bonus
            const teaEfficiency = parseTeaEfficiency(actionDetails.type, activeDrinks, itemDetailMap, drinkConcentration);

            const achievementEfficiency =
                dataManager$1.getAchievementBuffFlatBoost(actionDetails.type, '/buff_types/efficiency') * 100;

            const efficiencyBreakdown = calculateEfficiencyBreakdown({
                requiredLevel: baseRequirement,
                skillLevel,
                teaSkillLevelBonus,
                actionLevelBonus,
                houseEfficiency,
                equipmentEfficiency,
                teaEfficiency,
                communityEfficiency,
                achievementEfficiency,
            });

            const totalEfficiency = efficiencyBreakdown.totalEfficiency;
            const levelEfficiency = efficiencyBreakdown.levelEfficiency;
            const effectiveRequirement = efficiencyBreakdown.effectiveRequirement;

            // Calculate equipment speed bonus
            const equipmentSpeedBonus = parseEquipmentSpeedBonuses(characterEquipment, actionDetails.type, itemDetailMap);

            // Calculate action time with ONLY speed bonuses
            // Efficiency does NOT reduce time - it gives bonus actions
            // Formula: baseTime / (1 + speedBonus)
            // Example: 60s / (1 + 0.15) = 52.17s
            const actionTime = baseTime / (1 + equipmentSpeedBonus);

            // Build time breakdown for display
            const timeBreakdown = this.calculateTimeBreakdown(baseTime, equipmentSpeedBonus);

            // Actions per hour (base rate without efficiency)
            const actionsPerHour = calculateActionsPerHour(actionTime);

            // Get output amount (how many items per action)
            // Use 'count' field from action output
            const outputAmount = action.count || action.baseAmount || 1;

            // Calculate efficiency multiplier
            // Formula matches original MWI Tools: 1 + efficiency%
            // Example: 150% efficiency → 1 + 1.5 = 2.5x multiplier
            const efficiencyMultiplier = calculateEfficiencyMultiplier(totalEfficiency);

            // Items produced per hour (with efficiency multiplier)
            const itemsPerHour = actionsPerHour * outputAmount * efficiencyMultiplier;

            // Extra items from Gourmet (Brewing/Cooking bonus)
            // Statistical average: itemsPerHour × gourmetChance
            const gourmetBonusItems = itemsPerHour * gourmetBonus;

            // Total items per hour (base + gourmet bonus)
            const totalItemsPerHour = itemsPerHour + gourmetBonusItems;

            // Calculate material costs (with artisan reduction if applicable)
            const materialCosts = this.calculateMaterialCosts(actionDetails, artisanBonus, getCachedPrice);

            // Total material cost per action
            const totalMaterialCost = materialCosts.reduce((sum, mat) => sum + mat.totalCost, 0);

            // Get market price for the item
            // Use fallback {ask: 0, bid: 0} if no market data exists (e.g., refined items)
            const itemPrice = marketAPI.getPrice(itemHrid, 0) || { ask: 0, bid: 0 };

            // Get output price based on pricing mode setting
            // Uses 'profit' context with 'sell' side to get correct sell price
            const rawOutputPrice = getCachedPrice(itemHrid, { context: 'profit', side: 'sell' });
            const outputPriceMissing = rawOutputPrice === null;
            const outputPrice = outputPriceMissing ? 0 : rawOutputPrice;

            // Apply market tax (2% tax on sales)
            const priceAfterTax = calculatePriceAfterTax(outputPrice);

            // Cost per item (without efficiency scaling)
            const costPerItem = totalMaterialCost / outputAmount;

            // Material costs per hour (accounting for efficiency multiplier)
            // Efficiency repeats the action, consuming materials each time
            const materialCostPerHour = actionsPerHour * totalMaterialCost * efficiencyMultiplier;

            // Revenue per hour (gross, before tax)
            const revenuePerHour = itemsPerHour * outputPrice + gourmetBonusItems * outputPrice;

            // Calculate tea consumption costs (drinks consumed per hour)
            const teaCostData = calculateTeaCostsPerHour({
                drinkSlots: activeDrinks,
                drinkConcentration,
                itemDetailMap,
                getItemPrice: getCachedPrice,
            });
            const teaCosts = teaCostData.costs;
            const totalTeaCostPerHour = teaCostData.totalCostPerHour;

            // Calculate bonus revenue from essence and rare find drops (before profit calculation)
            const bonusRevenue = calculateBonusRevenue(actionDetails, actionsPerHour, characterEquipment, itemDetailMap);

            const hasMissingPrices =
                outputPriceMissing ||
                materialCosts.some((material) => material.missingPrice) ||
                teaCostData.hasMissingPrices ||
                (bonusRevenue?.hasMissingPrices ?? false);

            // Apply efficiency multiplier to bonus revenue (efficiency repeats the action, including bonus rolls)
            const efficiencyBoostedBonusRevenue = (bonusRevenue?.totalBonusRevenue || 0) * efficiencyMultiplier;

            // Calculate market tax (2% of gross revenue including bonus revenue)
            const marketTax = (revenuePerHour + efficiencyBoostedBonusRevenue) * MARKET_TAX;

            // Total costs per hour (materials + teas + market tax)
            const totalCostPerHour = materialCostPerHour + totalTeaCostPerHour + marketTax;

            // Profit per hour (revenue + bonus revenue - total costs)
            const profitPerHour = revenuePerHour + efficiencyBoostedBonusRevenue - totalCostPerHour;

            // Profit per item (for display)
            const profitPerItem = profitPerHour / totalItemsPerHour;

            return {
                itemName: itemDetails.name,
                itemHrid,
                actionTime,
                actionsPerHour,
                itemsPerHour,
                totalItemsPerHour, // Items/hour including Gourmet bonus
                gourmetBonusItems, // Extra items from Gourmet
                outputAmount,
                materialCosts,
                totalMaterialCost,
                materialCostPerHour, // Material costs per hour (with efficiency)
                teaCosts, // Tea consumption costs breakdown
                totalTeaCostPerHour, // Total tea costs per hour
                costPerItem,
                itemPrice,
                outputPrice, // Output price before tax (bid or ask based on mode)
                outputPriceMissing,
                priceAfterTax, // Output price after 2% tax (bid or ask based on mode)
                revenuePerHour,
                profitPerItem,
                profitPerHour,
                profitPerAction: calculateProfitPerAction(profitPerHour, actionsPerHour), // Profit per action
                profitPerDay: calculateProfitPerDay(profitPerHour), // Profit per day
                bonusRevenue, // Bonus revenue from essences and rare finds
                hasMissingPrices,
                totalEfficiency, // Total efficiency percentage
                levelEfficiency, // Level advantage efficiency
                houseEfficiency, // House room efficiency
                equipmentEfficiency, // Equipment efficiency
                teaEfficiency, // Tea buff efficiency
                communityEfficiency, // Community buff efficiency
                achievementEfficiency, // Achievement buff efficiency
                actionLevelBonus, // Action Level bonus from teas (e.g., Artisan Tea)
                artisanBonus, // Artisan material cost reduction
                gourmetBonus, // Gourmet bonus item chance
                processingBonus, // Processing conversion chance
                drinkConcentration, // Drink Concentration stat
                efficiencyMultiplier,
                equipmentSpeedBonus,
                skillLevel,
                baseRequirement, // Base requirement level
                effectiveRequirement, // Requirement after Action Level bonus
                requiredLevel: effectiveRequirement, // For backwards compatibility
                timeBreakdown,
            };
        }

        /**
         * Find the action that produces a given item
         * @param {string} itemHrid - Item HRID
         * @returns {Object|null} Action output data or null
         */
        findProductionAction(itemHrid) {
            const actionDetailMap = this.getActionDetailMap();

            // Search through all actions for one that produces this item
            for (const [actionHrid, action] of Object.entries(actionDetailMap)) {
                if (action.outputItems) {
                    for (const output of action.outputItems) {
                        if (output.itemHrid === itemHrid) {
                            return {
                                actionHrid,
                                ...output,
                            };
                        }
                    }
                }
            }

            return null;
        }

        /**
         * Calculate material costs for an action
         * @param {Object} actionDetails - Action details from game data
         * @param {number} artisanBonus - Artisan material reduction (0 to 1, e.g., 0.112 for 11.2% reduction)
         * @param {Function} getCachedPrice - Price lookup function with caching
         * @returns {Array} Array of material cost objects
         */
        calculateMaterialCosts(actionDetails, artisanBonus = 0, getCachedPrice) {
            const costs = [];

            // Check for upgrade item (e.g., Crimson Bulwark → Rainbow Bulwark)
            if (actionDetails.upgradeItemHrid) {
                const itemDetails = dataManager$1.getItemDetails(actionDetails.upgradeItemHrid);

                if (itemDetails) {
                    // Get material price based on pricing mode (uses 'profit' context with 'buy' side)
                    const materialPrice = getCachedPrice(actionDetails.upgradeItemHrid, { context: 'profit', side: 'buy' });
                    const isPriceMissing = materialPrice === null;
                    const resolvedPrice = isPriceMissing ? 0 : materialPrice;

                    // Special case: Coins have no market price but have face value of 1
                    let finalPrice = resolvedPrice;
                    let isMissing = isPriceMissing;
                    if (actionDetails.upgradeItemHrid === '/items/coin' && finalPrice === 0) {
                        finalPrice = 1;
                        isMissing = false;
                    }

                    // Upgrade items are NOT affected by Artisan Tea (only regular inputItems are)
                    const reducedAmount = 1;

                    costs.push({
                        itemHrid: actionDetails.upgradeItemHrid,
                        itemName: itemDetails.name,
                        baseAmount: 1,
                        amount: reducedAmount,
                        askPrice: finalPrice,
                        totalCost: finalPrice * reducedAmount,
                        missingPrice: isMissing,
                    });
                }
            }

            // Process regular input items
            if (actionDetails.inputItems && actionDetails.inputItems.length > 0) {
                for (const input of actionDetails.inputItems) {
                    const itemDetails = dataManager$1.getItemDetails(input.itemHrid);

                    if (!itemDetails) {
                        continue;
                    }

                    // Use 'count' field (not 'amount')
                    const baseAmount = input.count || input.amount || 1;

                    // Apply artisan reduction
                    const reducedAmount = baseAmount * (1 - artisanBonus);

                    // Get material price based on pricing mode (uses 'profit' context with 'buy' side)
                    const materialPrice = getCachedPrice(input.itemHrid, { context: 'profit', side: 'buy' });
                    const isPriceMissing = materialPrice === null;
                    const resolvedPrice = isPriceMissing ? 0 : materialPrice;

                    // Special case: Coins have no market price but have face value of 1
                    let finalPrice = resolvedPrice;
                    let isMissing = isPriceMissing;
                    if (input.itemHrid === '/items/coin' && finalPrice === 0) {
                        finalPrice = 1; // 1 coin = 1 gold value
                        isMissing = false;
                    }

                    costs.push({
                        itemHrid: input.itemHrid,
                        itemName: itemDetails.name,
                        baseAmount: baseAmount,
                        amount: reducedAmount,
                        askPrice: finalPrice,
                        totalCost: finalPrice * reducedAmount,
                        missingPrice: isMissing,
                    });
                }
            }

            return costs;
        }

        /**
         * Get character skill level for a skill type
         * @param {Array} skills - Character skills array
         * @param {string} skillType - Skill type HRID (e.g., "/action_types/cheesesmithing")
         * @returns {number} Skill level
         */
        getSkillLevel(skills, skillType) {
            // Map action type to skill HRID
            // e.g., "/action_types/cheesesmithing" -> "/skills/cheesesmithing"
            const skillHrid = skillType.replace('/action_types/', '/skills/');

            const skill = skills.find((s) => s.skillHrid === skillHrid);
            return skill?.level || 1;
        }

        /**
         * Calculate efficiency bonus from multiple sources
         * @param {number} characterLevel - Character's skill level
         * @param {number} requiredLevel - Action's required level
         * @param {string} actionTypeHrid - Action type HRID for house room matching
         * @returns {number} Total efficiency bonus percentage
         */
        calculateEfficiencyBonus(characterLevel, requiredLevel, actionTypeHrid) {
            // Level efficiency: +1% per level above requirement
            const levelEfficiency = Math.max(0, characterLevel - requiredLevel);

            // House room efficiency: houseLevel × 1.5%
            const houseEfficiency = calculateHouseEfficiency(actionTypeHrid);

            // Total efficiency (sum of all sources)
            const totalEfficiency = levelEfficiency + houseEfficiency;

            return totalEfficiency;
        }

        /**
         * Calculate time breakdown showing how modifiers affect action time
         * @param {number} baseTime - Base action time in seconds
         * @param {number} equipmentSpeedBonus - Equipment speed bonus as decimal (e.g., 0.15 for 15%)
         * @returns {Object} Time breakdown with steps
         */
        calculateTimeBreakdown(baseTime, equipmentSpeedBonus) {
            const steps = [];

            // Equipment Speed step (if > 0)
            if (equipmentSpeedBonus > 0) {
                const finalTime = baseTime / (1 + equipmentSpeedBonus);
                const reduction = baseTime - finalTime;

                steps.push({
                    name: 'Equipment Speed',
                    bonus: equipmentSpeedBonus * 100, // convert to percentage
                    reduction: reduction, // seconds saved
                    timeAfter: finalTime, // final time
                });

                return {
                    baseTime: baseTime,
                    steps: steps,
                    finalTime: finalTime,
                    actionsPerHour: calculateActionsPerHour(finalTime),
                };
            }

            // No modifiers - final time is base time
            return {
                baseTime: baseTime,
                steps: [],
                finalTime: baseTime,
                actionsPerHour: calculateActionsPerHour(baseTime),
            };
        }

        /**
         * Calculate community buff bonus for production efficiency
         * @param {number} buffLevel - Community buff level (0-20)
         * @param {string} actionTypeHrid - Action type to check if buff applies
         * @returns {number} Efficiency bonus percentage
         */
        calculateCommunityBuffBonus(buffLevel, actionTypeHrid) {
            if (buffLevel === 0) {
                return 0;
            }

            // Check if buff applies to this action type
            const communityBuffMap = this.getCommunityBuffMap();
            const buffDef = communityBuffMap['/community_buff_types/production_efficiency'];

            if (!buffDef?.usableInActionTypeMap?.[actionTypeHrid]) {
                return 0; // Buff doesn't apply to this skill
            }

            // Formula: flatBoost + (level - 1) × flatBoostLevelBonus
            const baseBonus = buffDef.buff.flatBoost * 100; // 14%
            const levelBonus = (buffLevel - 1) * buffDef.buff.flatBoostLevelBonus * 100; // 0.3% per level

            return baseBonus + levelBonus;
        }
    }

    const profitCalculator = new ProfitCalculator();

    /**
     * Alchemy Profit Calculator Module
     * Calculates profit for alchemy actions (Coinify, Decompose, Transmute) from game JSON data
     *
     * Success Rates (Base, Unmodified):
     * - Coinify: 70% (0.7)
     * - Decompose: 60% (0.6)
     * - Transmute: Varies by item (from item.alchemyDetail.transmuteSuccessRate)
     *
     * Success Rate Modifiers:
     * - Tea: Catalytic Tea provides /buff_types/alchemy_success (5% ratio boost, scales with Drink Concentration)
     * - Formula: finalRate = baseRate × (1 + teaBonus)
     */


    // Base success rates for alchemy actions
    const BASE_SUCCESS_RATES = {
        COINIFY: 0.7, // 70%
        DECOMPOSE: 0.6, // 60%
        // TRANSMUTE: varies by item (from alchemyDetail.transmuteSuccessRate)
    };

    /**
     * Calculate alchemy-specific bonus drops (essences + rares) from item level.
     * Alchemy actions don't have essenceDropTable/rareDropTable in game data,
     * so we compute them from the item's level using reverse-engineered formulas.
     *
     * Essence: baseRate = (100 + itemLevel) / 1800
     * Rare (Small, level 1-34):  baseRate = (100 + itemLevel) / 144000
     * Rare (Medium, level 35-69): baseRate = (65 + itemLevel) / 216000
     * Rare (Large, level 70+):    baseRate = (30 + itemLevel) / 288000
     *
     * @param {number} itemLevel - The item's level (from itemDetails.itemLevel)
     * @param {number} actionsPerHour - Actions per hour (with efficiency)
     * @param {Map} equipment - Character equipment map
     * @param {Object} itemDetailMap - Item details map
     * @returns {Object} Bonus drop data with drops array and breakdowns
     */
    function calculateAlchemyBonusDrops(itemLevel, actionsPerHour, equipment, itemDetailMap) {
        const essenceFindBonus = parseEssenceFindBonus(equipment, itemDetailMap);

        const equipmentRareFindBonus = parseRareFindBonus(equipment, '/action_types/alchemy', itemDetailMap);
        const houseRareFindBonus = calculateHouseRareFind();
        const achievementRareFindBonus =
            dataManager$1.getAchievementBuffFlatBoost('/action_types/alchemy', '/buff_types/rare_find') * 100;
        const rareFindBonus = equipmentRareFindBonus + houseRareFindBonus + achievementRareFindBonus;

        const bonusDrops = [];
        let totalBonusRevenue = 0;

        // Essence drop: Alchemy Essence
        const baseEssenceRate = (100 + itemLevel) / 1800;
        const finalEssenceRate = baseEssenceRate * (1 + essenceFindBonus / 100);
        const essenceDropsPerHour = actionsPerHour * finalEssenceRate;

        let essencePrice = 0;
        const essenceItemDetails = itemDetailMap['/items/alchemy_essence'];
        if (essenceItemDetails?.isOpenable) {
            essencePrice = expectedValueCalculator.getCachedValue('/items/alchemy_essence') || 0;
        } else {
            const price = marketAPI.getPrice('/items/alchemy_essence', 0);
            essencePrice = price?.bid ?? 0;
        }

        const essenceRevenuePerHour = essenceDropsPerHour * essencePrice;
        bonusDrops.push({
            itemHrid: '/items/alchemy_essence',
            count: 1,
            dropRate: finalEssenceRate,
            effectiveDropRate: finalEssenceRate,
            price: essencePrice,
            isEssence: true,
            isRare: false,
            revenuePerAttempt: finalEssenceRate * essencePrice,
            revenuePerHour: essenceRevenuePerHour,
            dropsPerHour: essenceDropsPerHour,
        });
        totalBonusRevenue += essenceRevenuePerHour;

        // Rare drop: Artisan's Crate (size depends on item level)
        let baseRareRate;
        let crateHrid;
        if (itemLevel < 35) {
            baseRareRate = (100 + itemLevel) / 144000;
            crateHrid = '/items/small_artisans_crate';
        } else if (itemLevel < 70) {
            baseRareRate = (65 + itemLevel) / 216000;
            crateHrid = '/items/medium_artisans_crate';
        } else {
            baseRareRate = (30 + itemLevel) / 288000;
            crateHrid = '/items/large_artisans_crate';
        }

        const finalRareRate = baseRareRate * (1 + rareFindBonus / 100);
        const rareDropsPerHour = actionsPerHour * finalRareRate;

        let cratePrice = 0;
        const crateItemDetails = itemDetailMap[crateHrid];
        if (crateItemDetails?.isOpenable) {
            // Try cached EV first, then compute on-demand if cache is empty
            cratePrice =
                expectedValueCalculator.getCachedValue(crateHrid) ||
                expectedValueCalculator.calculateSingleContainer(crateHrid) ||
                0;
        } else {
            const price = marketAPI.getPrice(crateHrid, 0);
            cratePrice = price?.bid ?? 0;
        }

        const rareRevenuePerHour = rareDropsPerHour * cratePrice;
        bonusDrops.push({
            itemHrid: crateHrid,
            count: 1,
            dropRate: finalRareRate,
            effectiveDropRate: finalRareRate,
            price: cratePrice,
            isEssence: false,
            isRare: true,
            revenuePerAttempt: finalRareRate * cratePrice,
            revenuePerHour: rareRevenuePerHour,
            dropsPerHour: rareDropsPerHour,
        });
        totalBonusRevenue += rareRevenuePerHour;

        return {
            bonusDrops,
            totalBonusRevenue,
            essenceFindBonus,
            rareFindBonus,
            rareFindBreakdown: {
                equipment: equipmentRareFindBonus,
                house: houseRareFindBonus,
                achievement: achievementRareFindBonus,
                total: rareFindBonus,
            },
            essenceFindBreakdown: {
                equipment: essenceFindBonus,
                total: essenceFindBonus,
            },
        };
    }

    class AlchemyProfitCalculator {
        constructor() {
            // Cache for item detail map
            this._itemDetailMap = null;
        }

        /**
         * Get item detail map (lazy-loaded and cached)
         * @returns {Object} Item details map from init_client_data
         */
        getItemDetailMap() {
            if (!this._itemDetailMap) {
                const initData = dataManager$1.getInitClientData();
                this._itemDetailMap = initData?.itemDetailMap || {};
            }
            return this._itemDetailMap;
        }

        /**
         * Calculate success rate with detailed breakdown
         * @param {number} baseRate - Base success rate (0-1)
         * @returns {Object} Success rate breakdown { total, base, tea }
         */
        calculateSuccessRateBreakdown(baseRate) {
            try {
                // Get alchemy success bonus from active buffs
                const teaBonus = getAlchemySuccessBonus();

                // Calculate final success rate
                const total = Math.min(1.0, baseRate * (1 + teaBonus));

                return {
                    total,
                    base: baseRate,
                    tea: teaBonus,
                };
            } catch (error) {
                console.error('[AlchemyProfitCalculator] Failed to calculate success rate breakdown:', error);
                return {
                    total: baseRate,
                    base: baseRate,
                    tea: 0,
                };
            }
        }

        /**
         * Calculate coinify profit for an item with full detailed breakdown
         * This is the SINGLE source of truth used by both tooltip and action panel
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level (default 0)
         * @returns {Object|null} Detailed profit data or null if not coinifiable
         */
        calculateCoinifyProfit(itemHrid, enhancementLevel = 0) {
            try {
                const gameData = dataManager$1.getInitClientData();
                const itemDetails = dataManager$1.getItemDetails(itemHrid);

                if (!gameData || !itemDetails) {
                    return null;
                }

                // Check if item is coinifiable
                if (!itemDetails.alchemyDetail || itemDetails.alchemyDetail.isCoinifiable !== true) {
                    return null;
                }

                // Get alchemy action details
                const actionDetails = gameData.actionDetailMap['/actions/alchemy/coinify'];
                if (!actionDetails) {
                    return null;
                }

                // Get pricing mode
                const pricingMode = config$1.getSetting('profitCalc_pricingMode') || 'hybrid';
                let buyType, sellType;
                if (pricingMode === 'conservative') {
                    buyType = 'ask';
                    sellType = 'bid';
                } else if (pricingMode === 'hybrid') {
                    buyType = 'ask';
                    sellType = 'ask';
                } else {
                    buyType = 'bid';
                    sellType = 'ask';
                }

                // Calculate action stats (time + efficiency) using shared helper
                // Alchemy uses item level (not action requirement) for efficiency calculation
                const actionStats = calculateActionStats(actionDetails, {
                    skills: dataManager$1.getSkills(),
                    equipment: dataManager$1.getEquipment(),
                    itemDetailMap: gameData.itemDetailMap,
                    includeCommunityBuff: true,
                    includeBreakdown: true,
                    levelRequirementOverride: itemDetails.itemLevel || 1,
                });

                const { actionTime, totalEfficiency, efficiencyBreakdown } = actionStats;

                // Get equipment for drink concentration calculation
                const equipment = dataManager$1.getEquipment();

                // Get drink concentration separately (not in breakdown from calculateActionStats)
                const drinkConcentration = getDrinkConcentration(equipment, gameData.itemDetailMap);

                // Calculate success rate with breakdown
                const baseSuccessRate = BASE_SUCCESS_RATES.COINIFY;
                const successRateBreakdown = this.calculateSuccessRateBreakdown(baseSuccessRate);
                const successRate = successRateBreakdown.total;

                // Calculate input cost (material cost)
                const bulkMultiplier = itemDetails.alchemyDetail?.bulkMultiplier || 1;
                const pricePerItem = getItemPrice(itemHrid, { context: 'profit', side: buyType, enhancementLevel });
                if (pricePerItem === null) {
                    return null; // No market data
                }
                const materialCost = pricePerItem * bulkMultiplier;

                // Coinify has no catalyst (catalyst is 0 for coinify)
                const catalystPrice = 0;

                // Get coin cost per action attempt
                const coinCost = actionDetails.coinCost || 0;

                // Calculate cost per attempt (materials consumed on all attempts)
                const costPerAttempt = materialCost + coinCost;

                // Calculate output value (coins produced)
                // Formula: sellPrice × bulkMultiplier × 5
                const coinsProduced = (itemDetails.sellPrice || 0) * bulkMultiplier * 5;

                // Revenue per attempt (coins are always 1:1, only get coins on success)
                // Note: efficiency is applied to NET PROFIT, not revenue
                const revenuePerAttempt = coinsProduced * successRate;

                // Net profit per attempt (before efficiency)
                const netProfitPerAttempt = revenuePerAttempt - costPerAttempt;

                // Calculate tea costs
                const teaCostData = calculateTeaCostsPerHour({
                    drinkSlots: dataManager$1.getActionDrinkSlots('/action_types/alchemy'),
                    drinkConcentration,
                    itemDetailMap: gameData.itemDetailMap,
                    getItemPrice: (hrid) => getItemPrice(hrid, { context: 'profit', side: buyType }),
                });

                // Calculate per-hour values
                // Actions per hour (for display breakdown) - includes efficiency for display purposes
                // Convert efficiency from percentage to decimal (81.516% -> 0.81516)
                const efficiencyDecimal = totalEfficiency / 100;
                const actionsPerHourWithEfficiency = calculateActionsPerHour(actionTime) * (1 + efficiencyDecimal);

                // Calculate bonus revenue (essences + rares) from item level
                const itemLevel = itemDetails.itemLevel || 1;
                const alchemyBonus = calculateAlchemyBonusDrops(
                    itemLevel,
                    actionsPerHourWithEfficiency,
                    equipment,
                    gameData.itemDetailMap
                );

                // Material and revenue calculations (for breakdown display)
                const materialCostPerHour = (materialCost + coinCost) * actionsPerHourWithEfficiency;
                const catalystCostPerHour = 0; // No catalyst for coinify
                const revenuePerHour = revenuePerAttempt * actionsPerHourWithEfficiency + alchemyBonus.totalBonusRevenue;

                // Profit calculation (matches OLD system formula)
                // Formula: (netProfit × (1 + efficiency)) / actionTime × 3600 + bonusRevenue - teaCost
                const profitPerSecond = (netProfitPerAttempt * (1 + efficiencyDecimal)) / actionTime;
                const profitPerHour =
                    profitPerSecond * SECONDS_PER_HOUR + alchemyBonus.totalBonusRevenue - teaCostData.totalCostPerHour;
                const profitPerDay = calculateProfitPerDay(profitPerHour);

                // Build detailed breakdowns
                const requirementCosts = [
                    {
                        itemHrid,
                        count: bulkMultiplier,
                        price: pricePerItem,
                        costPerAction: materialCost,
                        costPerHour: materialCost * actionsPerHourWithEfficiency,
                        enhancementLevel: enhancementLevel || 0,
                    },
                ];

                // Add coin cost entry if applicable
                if (coinCost > 0) {
                    requirementCosts.push({
                        itemHrid: '/items/coin',
                        count: coinCost,
                        price: 1,
                        costPerAction: coinCost,
                        costPerHour: coinCost * actionsPerHourWithEfficiency,
                        enhancementLevel: 0,
                    });
                }

                const coinRevenuePerHour = revenuePerAttempt * actionsPerHourWithEfficiency;

                const dropRevenues = [
                    {
                        itemHrid: '/items/coin',
                        count: coinsProduced,
                        dropRate: 1.0, // Coins always drop
                        effectiveDropRate: 1.0,
                        price: 1, // Coins are 1:1
                        isEssence: false,
                        isRare: false,
                        revenuePerAttempt,
                        revenuePerHour: coinRevenuePerHour,
                        dropsPerHour: coinsProduced * successRate * actionsPerHourWithEfficiency,
                    },
                ];

                // Add alchemy essence and rare drops
                for (const drop of alchemyBonus.bonusDrops) {
                    dropRevenues.push(drop);
                }

                const catalystCost = {
                    itemHrid: null,
                    price: 0,
                    costPerSuccess: 0,
                    costPerAttempt: 0,
                    costPerHour: 0,
                };

                const consumableCosts = teaCostData.costs.map((cost) => ({
                    itemHrid: cost.itemHrid,
                    price: cost.pricePerDrink,
                    drinksPerHour: cost.drinksPerHour,
                    costPerHour: cost.totalCost,
                }));

                // Return comprehensive data matching what action panel needs
                return {
                    // Basic info
                    actionType: 'coinify',
                    itemHrid,
                    enhancementLevel,

                    // Summary totals
                    profitPerHour,
                    profitPerDay,
                    revenuePerHour,

                    // Actions and rates
                    actionsPerHour: actionsPerHourWithEfficiency,
                    actionTime,

                    // Per-attempt economics
                    materialCost,
                    catalystPrice,
                    costPerAttempt,
                    incomePerAttempt: revenuePerAttempt,
                    netProfitPerAttempt,

                    // Per-hour costs
                    materialCostPerHour,
                    catalystCostPerHour,
                    totalTeaCostPerHour: teaCostData.totalCostPerHour,

                    // Detailed breakdowns
                    requirementCosts,
                    dropRevenues,
                    catalystCost,
                    consumableCosts,

                    // Core stats
                    successRate,
                    efficiency: efficiencyDecimal, // Decimal form (0.81516 for 81.516%)

                    // Modifier breakdowns
                    successRateBreakdown,
                    efficiencyBreakdown,
                    rareFindBreakdown: alchemyBonus.rareFindBreakdown,
                    essenceFindBreakdown: alchemyBonus.essenceFindBreakdown,

                    // Pricing info
                    pricingMode,
                    buyType,
                    sellType,
                };
            } catch (error) {
                console.error('[AlchemyProfitCalculator] Failed to calculate coinify profit:', error);
                return null;
            }
        }

        /**
         * Calculate Decompose profit for an item with full detailed breakdown
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level (default 0)
         * @returns {Object|null} Profit data or null if not decomposable
         */
        calculateDecomposeProfit(itemHrid, enhancementLevel = 0) {
            try {
                const gameData = dataManager$1.getInitClientData();
                const itemDetails = dataManager$1.getItemDetails(itemHrid);

                if (!gameData || !itemDetails) {
                    return null;
                }

                // Check if item is decomposable
                if (!itemDetails.alchemyDetail || !itemDetails.alchemyDetail.decomposeItems) {
                    return null;
                }

                // Get alchemy action details
                const actionDetails = gameData.actionDetailMap['/actions/alchemy/decompose'];
                if (!actionDetails) {
                    return null;
                }

                // Get pricing mode
                const pricingMode = config$1.getSetting('profitCalc_pricingMode') || 'hybrid';
                let buyType, sellType;
                if (pricingMode === 'conservative') {
                    buyType = 'ask';
                    sellType = 'bid';
                } else if (pricingMode === 'hybrid') {
                    buyType = 'ask';
                    sellType = 'ask';
                } else {
                    buyType = 'bid';
                    sellType = 'ask';
                }

                // Calculate action stats (time + efficiency) using shared helper
                // Alchemy uses item level (not action requirement) for efficiency calculation
                const actionStats = calculateActionStats(actionDetails, {
                    skills: dataManager$1.getSkills(),
                    equipment: dataManager$1.getEquipment(),
                    itemDetailMap: gameData.itemDetailMap,
                    includeCommunityBuff: true,
                    includeBreakdown: true,
                    levelRequirementOverride: itemDetails.itemLevel || 1,
                });

                const { actionTime, totalEfficiency, efficiencyBreakdown } = actionStats;

                // Get equipment for drink concentration calculation
                const equipment = dataManager$1.getEquipment();
                const drinkConcentration = getDrinkConcentration(equipment, gameData.itemDetailMap);

                // Calculate success rate with breakdown
                const baseSuccessRate = BASE_SUCCESS_RATES.DECOMPOSE;
                const successRateBreakdown = this.calculateSuccessRateBreakdown(baseSuccessRate);
                const successRate = successRateBreakdown.total;

                // Get input cost (market price of the item being decomposed)
                const inputPrice = getItemPrice(itemHrid, { context: 'profit', side: buyType, enhancementLevel });
                if (inputPrice === null) {
                    return null; // No market data
                }

                // Calculate output value
                let outputValue = 0;
                const dropDetails = [];

                // 1. Base decompose items (always received on success)
                for (const output of itemDetails.alchemyDetail.decomposeItems) {
                    const outputPrice = getItemPrice(output.itemHrid, { context: 'profit', side: sellType });
                    if (outputPrice !== null) {
                        const afterTax = calculatePriceAfterTax(outputPrice);
                        const dropValue = afterTax * output.count;
                        outputValue += dropValue;

                        dropDetails.push({
                            itemHrid: output.itemHrid,
                            count: output.count,
                            price: outputPrice,
                            afterTax,
                            isEssence: false,
                            expectedValue: dropValue,
                        });
                    }
                }

                // 2. Enhancing Essence (if item is enhanced)
                let essenceAmount = 0;
                if (enhancementLevel > 0) {
                    const itemLevel = itemDetails.itemLevel || 1;
                    essenceAmount = Math.round(2 * (0.5 + 0.1 * Math.pow(1.05, itemLevel)) * Math.pow(2, enhancementLevel));

                    const essencePrice = getItemPrice('/items/enhancing_essence', { context: 'profit', side: sellType });
                    if (essencePrice !== null) {
                        const afterTax = calculatePriceAfterTax(essencePrice);
                        const dropValue = afterTax * essenceAmount;
                        outputValue += dropValue;

                        dropDetails.push({
                            itemHrid: '/items/enhancing_essence',
                            count: essenceAmount,
                            price: essencePrice,
                            afterTax,
                            isEssence: true,
                            expectedValue: dropValue,
                        });
                    }
                }

                // Revenue per attempt (only on success)
                const revenuePerAttempt = outputValue * successRate;

                // Get coin cost per action attempt
                const coinCost = actionDetails.coinCost || 0;

                // Cost per attempt (input consumed on every attempt)
                const costPerAttempt = inputPrice + coinCost;

                // Net profit per attempt (before efficiency)
                const netProfitPerAttempt = revenuePerAttempt - costPerAttempt;

                // Calculate tea costs
                const teaCostData = calculateTeaCostsPerHour({
                    drinkSlots: dataManager$1.getActionDrinkSlots('/action_types/alchemy'),
                    drinkConcentration,
                    itemDetailMap: gameData.itemDetailMap,
                    getItemPrice: (hrid) => getItemPrice(hrid, { context: 'profit', side: buyType }),
                });

                // Calculate per-hour values
                // Convert efficiency from percentage to decimal
                const efficiencyDecimal = totalEfficiency / 100;
                const actionsPerHourWithEfficiency = calculateActionsPerHour(actionTime) * (1 + efficiencyDecimal);

                // Calculate bonus revenue (essences + rares) from item level
                const itemLevel = itemDetails.itemLevel || 1;
                const alchemyBonus = calculateAlchemyBonusDrops(
                    itemLevel,
                    actionsPerHourWithEfficiency,
                    equipment,
                    gameData.itemDetailMap
                );

                // Material and revenue calculations (for breakdown display)
                const materialCostPerHour = (inputPrice + coinCost) * actionsPerHourWithEfficiency;
                const catalystCostPerHour = 0; // No catalyst for decompose
                const revenuePerHour = revenuePerAttempt * actionsPerHourWithEfficiency + alchemyBonus.totalBonusRevenue;

                // Profit calculation (matches OLD system formula)
                const profitPerSecond = (netProfitPerAttempt * (1 + efficiencyDecimal)) / actionTime;
                const profitPerHour =
                    profitPerSecond * SECONDS_PER_HOUR + alchemyBonus.totalBonusRevenue - teaCostData.totalCostPerHour;
                const profitPerDay = calculateProfitPerDay(profitPerHour);

                // Build detailed breakdowns
                const requirementCosts = [
                    {
                        itemHrid,
                        count: 1,
                        price: inputPrice,
                        costPerAction: inputPrice,
                        costPerHour: inputPrice * actionsPerHourWithEfficiency,
                        enhancementLevel: enhancementLevel || 0,
                    },
                ];

                // Add coin cost entry if applicable
                if (coinCost > 0) {
                    requirementCosts.push({
                        itemHrid: '/items/coin',
                        count: coinCost,
                        price: 1,
                        costPerAction: coinCost,
                        costPerHour: coinCost * actionsPerHourWithEfficiency,
                        enhancementLevel: 0,
                    });
                }

                const dropRevenues = dropDetails.map((drop) => ({
                    itemHrid: drop.itemHrid,
                    count: drop.count,
                    dropRate: 1.0, // Decompose drops are guaranteed on success
                    effectiveDropRate: 1.0,
                    price: drop.price,
                    isEssence: drop.isEssence,
                    isRare: false,
                    revenuePerAttempt: drop.expectedValue * successRate,
                    revenuePerHour: drop.expectedValue * successRate * actionsPerHourWithEfficiency,
                    dropsPerHour: drop.count * successRate * actionsPerHourWithEfficiency,
                }));

                // Add alchemy essence and rare drops
                for (const drop of alchemyBonus.bonusDrops) {
                    dropRevenues.push(drop);
                }

                const catalystCost = {
                    itemHrid: null,
                    price: 0,
                    costPerSuccess: 0,
                    costPerAttempt: 0,
                    costPerHour: 0,
                };

                const consumableCosts = teaCostData.costs.map((cost) => ({
                    itemHrid: cost.itemHrid,
                    price: cost.pricePerDrink,
                    drinksPerHour: cost.drinksPerHour,
                    costPerHour: cost.totalCost,
                }));

                // Return comprehensive data matching what action panel needs
                return {
                    // Basic info
                    actionType: 'decompose',
                    itemHrid,
                    enhancementLevel,

                    // Summary totals
                    profitPerHour,
                    profitPerDay,
                    revenuePerHour,

                    // Actions and rates
                    actionsPerHour: actionsPerHourWithEfficiency,
                    actionTime,

                    // Per-attempt economics
                    materialCost: inputPrice,
                    catalystPrice: 0,
                    costPerAttempt,
                    incomePerAttempt: revenuePerAttempt,
                    netProfitPerAttempt,

                    // Per-hour costs
                    materialCostPerHour,
                    catalystCostPerHour,
                    totalTeaCostPerHour: teaCostData.totalCostPerHour,

                    // Detailed breakdowns
                    requirementCosts,
                    dropRevenues,
                    catalystCost,
                    consumableCosts,

                    // Core stats
                    successRate,
                    efficiency: efficiencyDecimal,

                    // Modifier breakdowns
                    successRateBreakdown,
                    efficiencyBreakdown,
                    rareFindBreakdown: alchemyBonus.rareFindBreakdown,
                    essenceFindBreakdown: alchemyBonus.essenceFindBreakdown,

                    // Pricing info
                    pricingMode,
                    buyType,
                    sellType,
                };
            } catch (error) {
                console.error('[AlchemyProfitCalculator] Failed to calculate decompose profit:', error);
                return null;
            }
        }

        /**
         * Calculate Transmute profit for an item with full detailed breakdown
         * @param {string} itemHrid - Item HRID
         * @returns {Object|null} Profit data or null if not transmutable
         */
        calculateTransmuteProfit(itemHrid) {
            try {
                const gameData = dataManager$1.getInitClientData();
                const itemDetails = dataManager$1.getItemDetails(itemHrid);

                if (!gameData || !itemDetails) {
                    return null;
                }

                // Check if item is transmutable
                if (!itemDetails.alchemyDetail || !itemDetails.alchemyDetail.transmuteDropTable) {
                    return null;
                }

                // Get base success rate from item
                const baseSuccessRate = itemDetails.alchemyDetail.transmuteSuccessRate || 0;
                if (baseSuccessRate === 0) {
                    return null; // Cannot transmute
                }

                // Get alchemy action details
                const actionDetails = gameData.actionDetailMap['/actions/alchemy/transmute'];
                if (!actionDetails) {
                    return null;
                }

                // Get pricing mode
                const pricingMode = config$1.getSetting('profitCalc_pricingMode') || 'hybrid';
                let buyType, sellType;
                if (pricingMode === 'conservative') {
                    buyType = 'ask';
                    sellType = 'bid';
                } else if (pricingMode === 'hybrid') {
                    buyType = 'ask';
                    sellType = 'ask';
                } else {
                    buyType = 'bid';
                    sellType = 'ask';
                }

                // Calculate action stats (time + efficiency) using shared helper
                // Alchemy uses item level (not action requirement) for efficiency calculation
                const actionStats = calculateActionStats(actionDetails, {
                    skills: dataManager$1.getSkills(),
                    equipment: dataManager$1.getEquipment(),
                    itemDetailMap: gameData.itemDetailMap,
                    includeCommunityBuff: true,
                    includeBreakdown: true,
                    levelRequirementOverride: itemDetails.itemLevel || 1,
                });

                const { actionTime, totalEfficiency, efficiencyBreakdown } = actionStats;

                // Get equipment for drink concentration calculation
                const equipment = dataManager$1.getEquipment();
                const drinkConcentration = getDrinkConcentration(equipment, gameData.itemDetailMap);

                // Calculate success rate with breakdown
                const successRateBreakdown = this.calculateSuccessRateBreakdown(baseSuccessRate);
                const successRate = successRateBreakdown.total;

                // Get input cost (market price of the item being transmuted)
                const inputPrice = getItemPrice(itemHrid, { context: 'profit', side: buyType });
                if (inputPrice === null) {
                    return null; // No market data
                }

                // Calculate expected value of outputs
                let expectedOutputValue = 0;
                const dropDetails = [];

                for (const drop of itemDetails.alchemyDetail.transmuteDropTable) {
                    const outputPrice = getItemPrice(drop.itemHrid, { context: 'profit', side: sellType });
                    if (outputPrice !== null) {
                        const afterTax = calculatePriceAfterTax(outputPrice);
                        // Expected value: price × dropRate × averageCount
                        const averageCount = (drop.minCount + drop.maxCount) / 2;
                        const dropValue = afterTax * drop.dropRate * averageCount;
                        expectedOutputValue += dropValue;

                        dropDetails.push({
                            itemHrid: drop.itemHrid,
                            dropRate: drop.dropRate,
                            minCount: drop.minCount,
                            maxCount: drop.maxCount,
                            averageCount,
                            price: outputPrice,
                            expectedValue: dropValue,
                        });
                    }
                }

                // Revenue per attempt (expected value on success)
                const revenuePerAttempt = expectedOutputValue * successRate;

                // Get bulk multiplier (number of items consumed per action)
                const bulkMultiplier = itemDetails.alchemyDetail?.bulkMultiplier || 1;
                const materialCost = inputPrice * bulkMultiplier;

                // Get coin cost per action attempt
                const coinCost = actionDetails.coinCost || 0;

                // Cost per attempt (input consumed on every attempt)
                const costPerAttempt = materialCost + coinCost;

                // Net profit per attempt (before efficiency)
                const netProfitPerAttempt = revenuePerAttempt - costPerAttempt;

                // Calculate tea costs
                const teaCostData = calculateTeaCostsPerHour({
                    drinkSlots: dataManager$1.getActionDrinkSlots('/action_types/alchemy'),
                    drinkConcentration,
                    itemDetailMap: gameData.itemDetailMap,
                    getItemPrice: (hrid) => getItemPrice(hrid, { context: 'profit', side: buyType }),
                });

                // Calculate per-hour values
                // Convert efficiency from percentage to decimal
                const efficiencyDecimal = totalEfficiency / 100;
                const actionsPerHourWithEfficiency = calculateActionsPerHour(actionTime) * (1 + efficiencyDecimal);

                // Calculate bonus revenue (essences + rares) from item level
                const itemLevel = itemDetails.itemLevel || 1;
                const alchemyBonus = calculateAlchemyBonusDrops(
                    itemLevel,
                    actionsPerHourWithEfficiency,
                    equipment,
                    gameData.itemDetailMap
                );

                // Material and revenue calculations (for breakdown display)
                const materialCostPerHour = (materialCost + coinCost) * actionsPerHourWithEfficiency;
                const catalystCostPerHour = 0; // No catalyst for transmute
                const revenuePerHour = revenuePerAttempt * actionsPerHourWithEfficiency + alchemyBonus.totalBonusRevenue;

                // Profit calculation (matches OLD system formula)
                const profitPerSecond = (netProfitPerAttempt * (1 + efficiencyDecimal)) / actionTime;
                const profitPerHour =
                    profitPerSecond * SECONDS_PER_HOUR + alchemyBonus.totalBonusRevenue - teaCostData.totalCostPerHour;
                const profitPerDay = calculateProfitPerDay(profitPerHour);

                // Build detailed breakdowns
                const requirementCosts = [
                    {
                        itemHrid,
                        count: bulkMultiplier,
                        price: inputPrice,
                        costPerAction: materialCost,
                        costPerHour: materialCost * actionsPerHourWithEfficiency,
                        enhancementLevel: 0,
                    },
                ];

                // Add coin cost entry if applicable
                if (coinCost > 0) {
                    requirementCosts.push({
                        itemHrid: '/items/coin',
                        count: coinCost,
                        price: 1,
                        costPerAction: coinCost,
                        costPerHour: coinCost * actionsPerHourWithEfficiency,
                        enhancementLevel: 0,
                    });
                }

                const dropRevenues = dropDetails.map((drop) => ({
                    itemHrid: drop.itemHrid,
                    count: drop.averageCount,
                    dropRate: drop.dropRate,
                    effectiveDropRate: drop.dropRate,
                    price: drop.price,
                    isEssence: false,
                    isRare: false,
                    revenuePerAttempt: drop.expectedValue * successRate,
                    revenuePerHour: drop.expectedValue * successRate * actionsPerHourWithEfficiency,
                    dropsPerHour: drop.averageCount * drop.dropRate * successRate * actionsPerHourWithEfficiency,
                }));

                // Add alchemy essence and rare drops
                for (const drop of alchemyBonus.bonusDrops) {
                    dropRevenues.push(drop);
                }

                const catalystCost = {
                    itemHrid: null,
                    price: 0,
                    costPerSuccess: 0,
                    costPerAttempt: 0,
                    costPerHour: 0,
                };

                const consumableCosts = teaCostData.costs.map((cost) => ({
                    itemHrid: cost.itemHrid,
                    price: cost.pricePerDrink,
                    drinksPerHour: cost.drinksPerHour,
                    costPerHour: cost.totalCost,
                }));

                // Return comprehensive data matching what action panel needs
                return {
                    // Basic info
                    actionType: 'transmute',
                    itemHrid,
                    enhancementLevel: 0, // Transmute doesn't care about enhancement

                    // Summary totals
                    profitPerHour,
                    profitPerDay,
                    revenuePerHour,

                    // Actions and rates
                    actionsPerHour: actionsPerHourWithEfficiency,
                    actionTime,

                    // Per-attempt economics
                    materialCost,
                    catalystPrice: 0,
                    costPerAttempt,
                    incomePerAttempt: revenuePerAttempt,
                    netProfitPerAttempt,

                    // Per-hour costs
                    materialCostPerHour,
                    catalystCostPerHour,
                    totalTeaCostPerHour: teaCostData.totalCostPerHour,

                    // Detailed breakdowns
                    requirementCosts,
                    dropRevenues,
                    catalystCost,
                    consumableCosts,

                    // Core stats
                    successRate,
                    efficiency: efficiencyDecimal,

                    // Modifier breakdowns
                    successRateBreakdown,
                    efficiencyBreakdown,
                    rareFindBreakdown: alchemyBonus.rareFindBreakdown,
                    essenceFindBreakdown: alchemyBonus.essenceFindBreakdown,

                    // Pricing info
                    pricingMode,
                    buyType,
                    sellType,
                };
            } catch (error) {
                console.error('[AlchemyProfitCalculator] Failed to calculate transmute profit:', error);
                return null;
            }
        }

        /**
         * Calculate all applicable profits for an item
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level (default 0)
         * @returns {Object} Object with all applicable profit calculations
         */
        calculateAllProfits(itemHrid, enhancementLevel = 0) {
            const results = {};

            // Try coinify
            const coinifyProfit = this.calculateCoinifyProfit(itemHrid, enhancementLevel);
            if (coinifyProfit) {
                results.coinify = coinifyProfit;
            }

            // Try decompose
            const decomposeProfit = this.calculateDecomposeProfit(itemHrid, enhancementLevel);
            if (decomposeProfit) {
                results.decompose = decomposeProfit;
            }

            // Try transmute (only for base items)
            if (enhancementLevel === 0) {
                const transmuteProfit = this.calculateTransmuteProfit(itemHrid);
                if (transmuteProfit) {
                    results.transmute = transmuteProfit;
                }
            }

            return results;
        }
    }

    const alchemyProfitCalculator = new AlchemyProfitCalculator();

    /**
     * Enhancement Tooltip Module
     *
     * Provides enhancement analysis for item tooltips.
     * Calculates optimal enhancement path and total costs for reaching current enhancement level.
     *
     * This module is part of Phase 2 of Option D (Hybrid Approach):
     * - Enhancement panel: Shows 20-level enhancement table
     * - Item tooltips: Shows optimal path to reach current enhancement level
     */


    /**
     * Calculate optimal enhancement path for an item
     * Matches Enhancelator's algorithm exactly:
     * 1. Test all protection strategies for each level
     * 2. Pick minimum cost for each level (mixed strategies)
     * 3. Apply mirror optimization to mixed array
     *
     * @param {string} itemHrid - Item HRID (e.g., '/items/cheese_sword')
     * @param {number} currentEnhancementLevel - Current enhancement level (1-20)
     * @param {Object} config - Enhancement configuration from enhancement-config.js
     * @returns {Object|null} Enhancement analysis or null if not enhanceable
     */
    function calculateEnhancementPath(itemHrid, currentEnhancementLevel, config) {
        // Validate inputs
        if (!itemHrid || currentEnhancementLevel < 1 || currentEnhancementLevel > 20) {
            return null;
        }

        // Get item details
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return null;

        const itemDetails = gameData.itemDetailMap[itemHrid];
        if (!itemDetails) return null;

        // Check if item is enhanceable
        if (!itemDetails.enhancementCosts || itemDetails.enhancementCosts.length === 0) {
            return null;
        }

        const itemLevel = itemDetails.itemLevel || 1;

        // Step 1: Build 2D matrix like Enhancelator (all_results)
        // For each target level (1 to currentEnhancementLevel)
        // Test all protection strategies (0, 2, 3, ..., targetLevel)
        // Result: allResults[targetLevel][protectFrom] = cost data

        const allResults = [];

        for (let targetLevel = 1; targetLevel <= currentEnhancementLevel; targetLevel++) {
            const resultsForLevel = [];

            // Test "never protect" (0)
            const neverProtect = calculateCostForStrategy(itemHrid, targetLevel, 0, itemLevel, config);
            if (neverProtect) {
                resultsForLevel.push({ protectFrom: 0, ...neverProtect });
            }

            // Test all "protect from X" strategies (2 through targetLevel)
            for (let protectFrom = 2; protectFrom <= targetLevel; protectFrom++) {
                const result = calculateCostForStrategy(itemHrid, targetLevel, protectFrom, itemLevel, config);
                if (result) {
                    resultsForLevel.push({ protectFrom, ...result });
                }
            }

            allResults.push(resultsForLevel);
        }

        // Step 2: Build target_costs array (minimum cost for each level)
        // Like Enhancelator line 451-453
        const targetCosts = new Array(currentEnhancementLevel + 1);
        targetCosts[0] = getRealisticBaseItemPrice(itemHrid); // Level 0: base item

        for (let level = 1; level <= currentEnhancementLevel; level++) {
            const resultsForLevel = allResults[level - 1];
            const minCost = Math.min(...resultsForLevel.map((r) => r.totalCost));
            targetCosts[level] = minCost;
        }

        // Step 3: Apply Philosopher's Mirror optimization (single pass, in-place)
        // Like Enhancelator lines 456-465
        const mirrorPrice = getRealisticBaseItemPrice('/items/philosophers_mirror');
        let mirrorStartLevel = null;

        if (mirrorPrice > 0) {
            for (let level = 3; level <= currentEnhancementLevel; level++) {
                const traditionalCost = targetCosts[level];
                const mirrorCost = targetCosts[level - 2] + targetCosts[level - 1] + mirrorPrice;

                if (mirrorCost < traditionalCost) {
                    if (mirrorStartLevel === null) {
                        mirrorStartLevel = level;
                    }
                    targetCosts[level] = mirrorCost;
                }
            }
        }

        // Step 4: Build final result with breakdown
        targetCosts[currentEnhancementLevel];

        // Find which protection strategy was optimal for final level (before mirrors)
        const finalLevelResults = allResults[currentEnhancementLevel - 1];
        const optimalTraditional = finalLevelResults.reduce((best, curr) =>
            curr.totalCost < best.totalCost ? curr : best
        );

        let optimalStrategy;

        if (mirrorStartLevel !== null) {
            // Mirror was used - build mirror-optimized result
            optimalStrategy = buildMirrorOptimizedResult(
                itemHrid,
                currentEnhancementLevel,
                mirrorStartLevel,
                targetCosts,
                optimalTraditional,
                mirrorPrice);
        } else {
            // No mirror used - return traditional result
            optimalStrategy = {
                protectFrom: optimalTraditional.protectFrom,
                label: optimalTraditional.protectFrom === 0 ? 'Never' : `From +${optimalTraditional.protectFrom}`,
                expectedAttempts: optimalTraditional.expectedAttempts,
                totalTime: optimalTraditional.totalTime,
                baseCost: optimalTraditional.baseCost,
                materialCost: optimalTraditional.materialCost,
                protectionCost: optimalTraditional.protectionCost,
                protectionItemHrid: optimalTraditional.protectionItemHrid,
                protectionCount: optimalTraditional.protectionCount,
                totalCost: optimalTraditional.totalCost,
                usedMirror: false,
                mirrorStartLevel: null,
            };
        }

        return {
            targetLevel: currentEnhancementLevel,
            itemLevel,
            optimalStrategy,
            allStrategies: [optimalStrategy], // Only return optimal
        };
    }

    /**
     * Calculate cost for a single protection strategy to reach a target level
     * @private
     */
    function calculateCostForStrategy(itemHrid, targetLevel, protectFrom, itemLevel, config) {
        try {
            const params = {
                enhancingLevel: config.enhancingLevel,
                houseLevel: config.houseLevel,
                toolBonus: config.toolBonus || 0,
                speedBonus: config.speedBonus || 0,
                itemLevel,
                targetLevel,
                protectFrom,
                blessedTea: config.teas.blessed,
                guzzlingBonus: config.guzzlingBonus,
            };

            // Calculate enhancement statistics
            const result = calculateEnhancement(params);

            if (!result || typeof result.attempts !== 'number' || typeof result.totalTime !== 'number') {
                console.error('[Enhancement Tooltip] Invalid result from calculateEnhancement:', result);
                return null;
            }

            // Calculate costs
            const costs = calculateTotalCost(itemHrid, targetLevel, protectFrom, config);

            return {
                expectedAttempts: result.attempts,
                totalTime: result.totalTime,
                ...costs,
            };
        } catch (error) {
            console.error('[Enhancement Tooltip] Strategy calculation error:', error);
            return null;
        }
    }

    /**
     * Build mirror-optimized result with Fibonacci quantities
     * @private
     */
    function buildMirrorOptimizedResult(
        itemHrid,
        targetLevel,
        mirrorStartLevel,
        targetCosts,
        optimalTraditional,
        mirrorPrice,
        _config
    ) {
        const gameData = dataManager$1.getInitClientData();
        gameData.itemDetailMap[itemHrid];

        // Calculate Fibonacci quantities for consumed items
        const n = targetLevel - mirrorStartLevel;
        const numLowerTier = fib(n); // Quantity of (mirrorStartLevel - 2) items
        const numUpperTier = fib(n + 1); // Quantity of (mirrorStartLevel - 1) items
        const numMirrors = mirrorFib(n); // Quantity of Philosopher's Mirrors

        const lowerTierLevel = mirrorStartLevel - 2;
        const upperTierLevel = mirrorStartLevel - 1;

        // Get cost of one item at each level from targetCosts
        const costLowerTier = targetCosts[lowerTierLevel];
        const costUpperTier = targetCosts[upperTierLevel];

        // Calculate total costs for consumed items and mirrors
        const totalLowerTierCost = numLowerTier * costLowerTier;
        const totalUpperTierCost = numUpperTier * costUpperTier;
        const totalMirrorsCost = numMirrors * mirrorPrice;

        // Build consumed items array for display
        const consumedItems = [
            {
                level: lowerTierLevel,
                quantity: numLowerTier,
                costEach: costLowerTier,
                totalCost: totalLowerTierCost,
            },
            {
                level: upperTierLevel,
                quantity: numUpperTier,
                costEach: costUpperTier,
                totalCost: totalUpperTierCost,
            },
        ];

        // For mirror phase: ONLY consumed items + mirrors
        // The consumed item costs from targetCosts already include base/materials/protection
        // NO separate base/materials/protection for main item!

        return {
            protectFrom: optimalTraditional.protectFrom,
            label: optimalTraditional.protectFrom === 0 ? 'Never' : `From +${optimalTraditional.protectFrom}`,
            expectedAttempts: optimalTraditional.expectedAttempts,
            totalTime: optimalTraditional.totalTime,
            baseCost: 0, // Not applicable for mirror phase
            materialCost: 0, // Not applicable for mirror phase
            protectionCost: 0, // Not applicable for mirror phase
            protectionItemHrid: null,
            protectionCount: 0,
            consumedItemsCost: totalLowerTierCost + totalUpperTierCost,
            philosopherMirrorCost: totalMirrorsCost,
            totalCost: targetCosts[targetLevel], // Use recursive formula result for consistency
            mirrorStartLevel: mirrorStartLevel,
            usedMirror: true,
            traditionalCost: optimalTraditional.totalCost,
            consumedItems: consumedItems,
            mirrorCount: numMirrors,
        };
    }

    /**
     * Calculate total cost for enhancement path
     * Matches original MWI Tools v25.0 cost calculation
     * @private
     */
    function calculateTotalCost(itemHrid, targetLevel, protectFrom, config) {
        const gameData = dataManager$1.getInitClientData();
        const itemDetails = gameData.itemDetailMap[itemHrid];
        const itemLevel = itemDetails.itemLevel || 1;

        // Calculate total attempts for full path (0 to targetLevel)
        const pathResult = calculateEnhancement({
            enhancingLevel: config.enhancingLevel,
            houseLevel: config.houseLevel,
            toolBonus: config.toolBonus || 0,
            speedBonus: config.speedBonus || 0,
            itemLevel,
            targetLevel,
            protectFrom,
            blessedTea: config.teas.blessed,
            guzzlingBonus: config.guzzlingBonus,
        });

        // Calculate per-action material cost (same for all enhancement levels)
        // enhancementCosts is a flat array of materials needed per attempt
        let perActionCost = 0;
        if (itemDetails.enhancementCosts) {
            for (const material of itemDetails.enhancementCosts) {
                const materialDetail = gameData.itemDetailMap[material.itemHrid];
                let price;

                // Special case: Trainee charms have fixed 250k price (untradeable)
                if (material.itemHrid.startsWith('/items/trainee_')) {
                    price = 250000;
                } else if (material.itemHrid === '/items/coin') {
                    price = 1; // Coins have face value of 1
                } else {
                    const marketPrice = getItemPrices(material.itemHrid, 0);
                    if (marketPrice) {
                        let ask = marketPrice.ask;
                        let bid = marketPrice.bid;

                        // Match MCS behavior: if one price is positive and other is negative, use positive for both
                        if (ask > 0 && bid < 0) {
                            bid = ask;
                        }
                        if (bid > 0 && ask < 0) {
                            ask = bid;
                        }

                        // MCS uses just ask for material prices
                        price = ask;
                    } else {
                        // Fallback to sellPrice if no market data
                        price = materialDetail?.sellPrice || 0;
                    }
                }
                perActionCost += price * material.count;
            }
        }

        // Total material cost = per-action cost × total attempts
        const materialCost = perActionCost * pathResult.attempts;

        // Protection cost = cheapest protection option × protection count
        let protectionCost = 0;
        let protectionItemHrid = null;
        let protectionCount = 0;
        if (protectFrom > 0 && pathResult.protectionCount > 0) {
            const protectionInfo = getCheapestProtectionPrice(itemHrid);
            if (protectionInfo.price > 0) {
                protectionCost = protectionInfo.price * pathResult.protectionCount;
                protectionItemHrid = protectionInfo.itemHrid;
                protectionCount = pathResult.protectionCount;
            }
        }

        // Base item cost (initial investment) using realistic pricing
        const baseCost = getRealisticBaseItemPrice(itemHrid);

        return {
            baseCost,
            materialCost,
            protectionCost,
            protectionItemHrid,
            protectionCount,
            totalCost: baseCost + materialCost + protectionCost,
        };
    }

    /**
     * Get realistic base item price with production cost fallback
     * Matches original MWI Tools v25.0 getRealisticBaseItemPrice logic
     * @private
     */
    function getRealisticBaseItemPrice(itemHrid) {
        const marketPrice = getItemPrices(itemHrid, 0);
        const ask = marketPrice?.ask > 0 ? marketPrice.ask : 0;
        const bid = marketPrice?.bid > 0 ? marketPrice.bid : 0;

        // Calculate production cost as fallback
        const productionCost = getProductionCost(itemHrid);

        // If both ask and bid exist
        if (ask > 0 && bid > 0) {
            // If ask is significantly higher than bid (>30% markup), use max(bid, production)
            if (ask / bid > 1.3) {
                return Math.max(bid, productionCost);
            }
            // Otherwise use ask (normal market)
            return ask;
        }

        // If only ask exists
        if (ask > 0) {
            // If ask is inflated compared to production, use production
            if (productionCost > 0 && ask / productionCost > 1.3) {
                return productionCost;
            }
            // Otherwise use max of ask and production
            return Math.max(ask, productionCost);
        }

        // If only bid exists, use max(bid, production)
        if (bid > 0) {
            return Math.max(bid, productionCost);
        }

        // No market data - use production cost as fallback
        return productionCost;
    }

    /**
     * Calculate production cost from crafting recipe
     * Matches original MWI Tools v25.0 getBaseItemProductionCost logic
     * @private
     */
    function getProductionCost(itemHrid) {
        const gameData = dataManager$1.getInitClientData();
        const itemDetails = gameData.itemDetailMap[itemHrid];

        if (!itemDetails || !itemDetails.name) {
            return 0;
        }

        // Find the action that produces this item
        let actionHrid = null;
        for (const [hrid, action] of Object.entries(gameData.actionDetailMap)) {
            if (action.outputItems && action.outputItems.length > 0) {
                const output = action.outputItems[0];
                if (output.itemHrid === itemHrid) {
                    actionHrid = hrid;
                    break;
                }
            }
        }

        if (!actionHrid) {
            return 0;
        }

        const action = gameData.actionDetailMap[actionHrid];
        let totalPrice = 0;

        // Sum up input material costs
        if (action.inputItems) {
            for (const input of action.inputItems) {
                const inputPrice = getItemPrice(input.itemHrid, { mode: 'ask' }) || 0;
                totalPrice += inputPrice * input.count;
            }
        }

        // Apply Artisan Tea reduction (0.9x)
        totalPrice *= 0.9;

        // Add upgrade item cost if this is an upgrade recipe (for refined items)
        if (action.upgradeItemHrid) {
            const upgradePrice = getItemPrice(action.upgradeItemHrid, { mode: 'ask' }) || 0;
            totalPrice += upgradePrice;
        }

        return totalPrice;
    }

    /**
     * Get cheapest protection item price
     * Tests: item itself, mirror of protection, and specific protection items
     * @private
     */
    function getCheapestProtectionPrice(itemHrid) {
        const gameData = dataManager$1.getInitClientData();
        const itemDetails = gameData.itemDetailMap[itemHrid];

        // Build list of protection options: [item itself, mirror, ...specific items]
        const protectionOptions = [itemHrid, '/items/mirror_of_protection'];

        // Add specific protection items if they exist
        if (itemDetails.protectionItemHrids && itemDetails.protectionItemHrids.length > 0) {
            protectionOptions.push(...itemDetails.protectionItemHrids);
        }

        // Find cheapest option
        let cheapestPrice = Infinity;
        let cheapestItemHrid = null;
        for (const protectionHrid of protectionOptions) {
            const price = getRealisticBaseItemPrice(protectionHrid);
            if (price > 0 && price < cheapestPrice) {
                cheapestPrice = price;
                cheapestItemHrid = protectionHrid;
            }
        }

        return {
            price: cheapestPrice === Infinity ? 0 : cheapestPrice,
            itemHrid: cheapestItemHrid,
        };
    }

    /**
     * Fibonacci calculation for item quantities (from Enhancelator)
     * @private
     */
    function fib(n) {
        if (n === 0 || n === 1) {
            return 1;
        }
        return fib(n - 1) + fib(n - 2);
    }

    /**
     * Mirror Fibonacci calculation for mirror quantities (from Enhancelator)
     * @private
     */
    function mirrorFib(n) {
        if (n === 0) {
            return 1;
        }
        if (n === 1) {
            return 2;
        }
        return mirrorFib(n - 1) + mirrorFib(n - 2) + 1;
    }

    /**
     * Build HTML for enhancement tooltip section
     * @param {Object} enhancementData - Enhancement analysis from calculateEnhancementPath()
     * @returns {string} HTML string
     */
    function buildEnhancementTooltipHTML(enhancementData) {
        if (!enhancementData || !enhancementData.optimalStrategy) {
            return '';
        }

        const { targetLevel, optimalStrategy } = enhancementData;

        // Validate required fields
        if (
            typeof optimalStrategy.expectedAttempts !== 'number' ||
            typeof optimalStrategy.totalTime !== 'number' ||
            typeof optimalStrategy.materialCost !== 'number' ||
            typeof optimalStrategy.totalCost !== 'number'
        ) {
            console.error('[Enhancement Tooltip] Missing required fields in optimal strategy:', optimalStrategy);
            return '';
        }

        let html = '<div style="border-top: 1px solid rgba(255,255,255,0.2); margin-top: 8px; padding-top: 8px;">';
        html += '<div style="font-weight: bold; margin-bottom: 4px;">ENHANCEMENT PATH (+0 → +' + targetLevel + ')</div>';
        html += '<div style="font-size: 0.9em; margin-left: 8px;">';

        // Optimal strategy
        html += '<div>Strategy: ' + optimalStrategy.label + '</div>';

        // Show Philosopher's Mirror usage if applicable
        if (optimalStrategy.usedMirror && optimalStrategy.mirrorStartLevel) {
            html +=
                '<div style="color: #ffd700;">Uses Philosopher\'s Mirror from +' +
                optimalStrategy.mirrorStartLevel +
                '</div>';
        }

        html += '<div>Expected Attempts: ' + formatLargeNumber(optimalStrategy.expectedAttempts.toFixed(1)) + '</div>';

        // Costs
        html += '<div>';

        // Check if using mirror optimization
        if (optimalStrategy.usedMirror && optimalStrategy.consumedItems && optimalStrategy.consumedItems.length > 0) {
            // Mirror-optimized breakdown
            // For mirror phase, we ONLY show consumed items and mirrors (no base/materials/protection)
            // Consumed items section (Fibonacci-based quantities)
            html += "Consumed Items (Philosopher's Mirror):";
            html += '<div style="margin-left: 12px;">';

            // Show consumed items in descending order (higher level first), filter out zero quantities
            const sortedConsumed = [...optimalStrategy.consumedItems]
                .filter((item) => item.quantity > 0)
                .sort((a, b) => b.level - a.level);
            sortedConsumed.forEach((item, index) => {
                if (index > 0) html += '<br>'; // Add line break before items after the first
                html +=
                    '+' +
                    item.level +
                    ': ' +
                    item.quantity +
                    ' × ' +
                    formatLargeNumber(item.costEach) +
                    ' = ' +
                    formatLargeNumber(item.totalCost);
            });

            html += '</div>';
            // Philosopher's Mirror cost
            if (optimalStrategy.philosopherMirrorCost > 0) {
                const mirrorPrice = getRealisticBaseItemPrice('/items/philosophers_mirror');
                html += "Philosopher's Mirror: " + formatLargeNumber(optimalStrategy.philosopherMirrorCost);
                if (optimalStrategy.mirrorCount > 0 && mirrorPrice > 0) {
                    html += ' (' + optimalStrategy.mirrorCount + 'x @ ' + formatLargeNumber(mirrorPrice) + ' each)';
                }
            }

            html +=
                '<br><span style="font-weight: bold;">Total: ' + formatLargeNumber(optimalStrategy.totalCost) + '</span>';
        } else {
            // Traditional (non-mirror) breakdown
            html += 'Base Item: ' + formatLargeNumber(optimalStrategy.baseCost);
            html += '<br>Materials: ' + formatLargeNumber(optimalStrategy.materialCost);

            if (optimalStrategy.protectionCost > 0) {
                let protectionDisplay = formatLargeNumber(optimalStrategy.protectionCost);

                // Show protection count and item name if available
                if (optimalStrategy.protectionCount > 0) {
                    protectionDisplay += ' (' + optimalStrategy.protectionCount.toFixed(1) + '×';

                    if (optimalStrategy.protectionItemHrid) {
                        const gameData = dataManager$1.getInitClientData();
                        const itemDetails = gameData?.itemDetailMap[optimalStrategy.protectionItemHrid];
                        if (itemDetails?.name) {
                            protectionDisplay += ' ' + itemDetails.name;
                        }
                    }

                    protectionDisplay += ')';
                }

                html += '<br>Protection: ' + protectionDisplay;
            }

            html +=
                '<br><span style="font-weight: bold;">Total: ' + formatLargeNumber(optimalStrategy.totalCost) + '</span>';
        }

        html += '</div>';

        // Time estimate
        const totalSeconds = optimalStrategy.totalTime;

        if (totalSeconds < 60) {
            // Less than 1 minute: show seconds
            html += '<div>Time: ~' + Math.round(totalSeconds) + ' seconds</div>';
        } else if (totalSeconds < 3600) {
            // Less than 1 hour: show minutes
            const minutes = Math.round(totalSeconds / 60);
            html += '<div>Time: ~' + minutes + ' minutes</div>';
        } else if (totalSeconds < 86400) {
            // Less than 1 day: show hours
            const hours = (totalSeconds / 3600).toFixed(1);
            html += '<div>Time: ~' + hours + ' hours</div>';
        } else {
            // 1 day or more: show days
            const days = (totalSeconds / 86400).toFixed(1);
            html += '<div>Time: ~' + days + ' days</div>';
        }

        html += '</div>'; // Close margin-left div
        html += '</div>'; // Close main container

        return html;
    }

    /**
     * Gathering Profit Calculator
     *
     * Calculates comprehensive profit/hour for gathering actions (Foraging, Woodcutting, Milking) including:
     * - All drop table items at market prices
     * - Drink consumption costs
     * - Equipment speed bonuses
     * - Efficiency buffs (level, house, tea, equipment)
     * - Gourmet tea bonus items (production skills only)
     * - Market tax (2%)
     */


    /**
     * Cache for processing action conversions (inputItemHrid → conversion data)
     * Built once per game data load to avoid O(n) searches through action map
     */
    let processingConversionCache = null;

    /**
     * Build processing conversion cache from game data
     * @param {Object} gameData - Game data from dataManager
     * @returns {Map} Map of inputItemHrid → {actionHrid, outputItemHrid, conversionRatio}
     */
    function buildProcessingConversionCache(gameData) {
        const cache = new Map();
        const validProcessingTypes = [
            '/action_types/cheesesmithing', // Milk → Cheese conversions
            '/action_types/crafting', // Log → Lumber conversions
            '/action_types/tailoring', // Cotton/Flax/Bamboo/Cocoon/Radiant → Fabric conversions
        ];

        for (const [actionHrid, action] of Object.entries(gameData.actionDetailMap)) {
            if (!validProcessingTypes.includes(action.type)) {
                continue;
            }

            const inputItem = action.inputItems?.[0];
            const outputItem = action.outputItems?.[0];

            if (inputItem && outputItem) {
                cache.set(inputItem.itemHrid, {
                    actionHrid: actionHrid,
                    outputItemHrid: outputItem.itemHrid,
                    conversionRatio: inputItem.count,
                });
            }
        }

        return cache;
    }

    /**
     * Calculate comprehensive profit for a gathering action
     * @param {string} actionHrid - Action HRID (e.g., "/actions/foraging/asteroid_belt")
     * @returns {Object|null} Profit data or null if not applicable
     */
    async function calculateGatheringProfit(actionHrid) {
        const gameData = dataManager$1.getInitClientData();
        const actionDetail = gameData.actionDetailMap[actionHrid];

        if (!actionDetail) {
            return null;
        }

        // Only process gathering actions (Foraging, Woodcutting, Milking) with drop tables
        if (!GATHERING_TYPES$2.includes(actionDetail.type)) {
            return null;
        }

        if (!actionDetail.dropTable) {
            return null; // No drop table - nothing to calculate
        }

        // Build processing conversion cache once (lazy initialization)
        if (!processingConversionCache) {
            processingConversionCache = buildProcessingConversionCache(gameData);
        }

        const priceCache = new Map();
        const getCachedPrice = (itemHrid, options) => {
            const side = options?.side || '';
            const enhancementLevel = options?.enhancementLevel ?? '';
            const cacheKey = `${itemHrid}|${side}|${enhancementLevel}`;

            if (priceCache.has(cacheKey)) {
                return priceCache.get(cacheKey);
            }

            const price = getItemPrice(itemHrid, options);
            priceCache.set(cacheKey, price);
            return price;
        };

        // Note: Market API is pre-loaded by caller (max-produceable.js)
        // No need to check or fetch here

        // Get character data
        const equipment = dataManager$1.getEquipment();
        const skills = dataManager$1.getSkills();
        const houseRooms = Array.from(dataManager$1.getHouseRooms().values());

        // Calculate action time per action (with speed bonuses)
        const baseTimePerActionSec = actionDetail.baseTimeCost / 1000000000;
        const speedBonus = parseEquipmentSpeedBonuses(equipment, actionDetail.type, gameData.itemDetailMap);
        // speedBonus is already a decimal (e.g., 0.15 for 15%), don't divide by 100
        const actualTimePerActionSec = baseTimePerActionSec / (1 + speedBonus);

        // Calculate actions per hour
        const actionsPerHour = calculateActionsPerHour(actualTimePerActionSec);

        // Get character's actual equipped drink slots for this action type (from WebSocket data)
        const drinkSlots = dataManager$1.getActionDrinkSlots(actionDetail.type);

        // Get drink concentration from equipment
        const drinkConcentration = getDrinkConcentration(equipment, gameData.itemDetailMap);

        // Parse tea buffs
        const teaEfficiency = parseTeaEfficiency(actionDetail.type, drinkSlots, gameData.itemDetailMap, drinkConcentration);

        // Gourmet Tea only applies to production skills (Brewing, Cooking, Cheesesmithing, Crafting, Tailoring)
        // NOT gathering skills (Foraging, Woodcutting, Milking)
        const gourmetBonus = PRODUCTION_TYPES$4.includes(actionDetail.type)
            ? parseGourmetBonus(drinkSlots, gameData.itemDetailMap, drinkConcentration)
            : 0;

        // Processing Tea: 15% base chance to convert raw → processed (Cotton → Cotton Fabric, etc.)
        // Only applies to gathering skills (Foraging, Woodcutting, Milking)
        const processingBonus = GATHERING_TYPES$2.includes(actionDetail.type)
            ? parseProcessingBonus(drinkSlots, gameData.itemDetailMap, drinkConcentration)
            : 0;

        // Gathering Quantity: Increases item drop amounts (min/max)
        // Sources: Gathering Tea (15% base), Community Buff (20% base + 0.5%/level), Achievement Tiers
        // Only applies to gathering skills (Foraging, Woodcutting, Milking)
        let totalGathering = 0;
        let gatheringTea = 0;
        let communityGathering = 0;
        let achievementGathering = 0;
        if (GATHERING_TYPES$2.includes(actionDetail.type)) {
            // Parse Gathering Tea bonus
            gatheringTea = parseGatheringBonus(drinkSlots, gameData.itemDetailMap, drinkConcentration);

            // Get Community Buff level for gathering quantity
            const communityBuffLevel = dataManager$1.getCommunityBuffLevel('/community_buff_types/gathering_quantity');
            communityGathering = communityBuffLevel ? 0.2 + (communityBuffLevel - 1) * 0.005 : 0;

            // Get Achievement buffs for this action type (Beginner tier: +2% Gathering Quantity)
            achievementGathering = dataManager$1.getAchievementBuffFlatBoost(actionDetail.type, '/buff_types/gathering');

            // Stack all bonuses additively
            totalGathering = gatheringTea + communityGathering + achievementGathering;
        }

        const teaCostData = calculateTeaCostsPerHour({
            drinkSlots,
            drinkConcentration,
            itemDetailMap: gameData.itemDetailMap,
            getItemPrice: getCachedPrice,
        });
        const drinkCostPerHour = teaCostData.totalCostPerHour;
        const drinkCosts = teaCostData.costs.map((tea) => ({
            name: tea.itemName,
            priceEach: tea.pricePerDrink,
            drinksPerHour: tea.drinksPerHour,
            costPerHour: tea.totalCost,
            missingPrice: tea.missingPrice,
        }));

        // Calculate level efficiency bonus
        const requiredLevel = actionDetail.levelRequirement?.level || 1;
        const skillHrid = actionDetail.levelRequirement?.skillHrid;
        let currentLevel = requiredLevel;
        for (const skill of skills) {
            if (skill.skillHrid === skillHrid) {
                currentLevel = skill.level;
                break;
            }
        }

        // Calculate tea skill level bonus (e.g., +5 Foraging from Ultra Foraging Tea)
        const teaSkillLevelBonus = parseTeaSkillLevelBonus(
            actionDetail.type,
            drinkSlots,
            gameData.itemDetailMap,
            drinkConcentration
        );

        // Calculate house efficiency bonus
        let houseEfficiency = 0;
        for (const room of houseRooms) {
            const roomDetail = gameData.houseRoomDetailMap?.[room.houseRoomHrid];
            if (roomDetail?.usableInActionTypeMap?.[actionDetail.type]) {
                houseEfficiency += (room.level || 0) * 1.5;
            }
        }

        // Calculate equipment efficiency bonus (uses equipment-parser utility)
        const equipmentEfficiency = parseEquipmentEfficiencyBonuses(equipment, actionDetail.type, gameData.itemDetailMap);
        const achievementEfficiency =
            dataManager$1.getAchievementBuffFlatBoost(actionDetail.type, '/buff_types/efficiency') * 100;

        const efficiencyBreakdown = calculateEfficiencyBreakdown({
            requiredLevel,
            skillLevel: currentLevel,
            teaSkillLevelBonus,
            houseEfficiency,
            teaEfficiency,
            equipmentEfficiency,
            achievementEfficiency,
        });
        const totalEfficiency = efficiencyBreakdown.totalEfficiency;
        const levelEfficiency = efficiencyBreakdown.levelEfficiency;

        // Calculate efficiency multiplier (matches production profit calculator pattern)
        // Efficiency "repeats the action" - we apply it to item outputs, not action rate
        const efficiencyMultiplier = calculateEfficiencyMultiplier(totalEfficiency);

        // Calculate revenue from drop table
        // Processing happens PER ACTION (before efficiency multiplies the count)
        // So we calculate per-action outputs, then multiply by actionsPerHour and efficiency
        let baseRevenuePerHour = 0;
        let gourmetRevenueBonus = 0;
        let gourmetRevenueBonusPerAction = 0;
        let processingRevenueBonus = 0; // Track extra revenue from Processing Tea
        let processingRevenueBonusPerAction = 0; // Per-action processing revenue
        const processingConversions = []; // Track conversion details for display
        const baseOutputs = []; // Baseline outputs (before gourmet and processing)
        const gourmetBonuses = []; // Gourmet bonus outputs (display-only)
        const dropTable = actionDetail.dropTable;

        for (const drop of dropTable) {
            const rawPrice = getCachedPrice(drop.itemHrid, { context: 'profit', side: 'sell' });
            const rawPriceMissing = rawPrice === null;
            const resolvedRawPrice = rawPriceMissing ? 0 : rawPrice;
            // Apply gathering quantity bonus to drop amounts
            const baseAvgAmount = (drop.minCount + drop.maxCount) / 2;
            const avgAmountPerAction = baseAvgAmount * (1 + totalGathering);

            // Check if this item has a Processing Tea conversion (using cache for O(1) lookup)
            // Processing Tea only applies to: Milk→Cheese, Log→Lumber, Cotton/Flax/Bamboo/Cocoon/Radiant→Fabric
            const conversionData = processingConversionCache.get(drop.itemHrid);
            const processedItemHrid = conversionData?.outputItemHrid || null;
            conversionData?.actionHrid || null;

            // Per-action calculations (efficiency will be applied when converting to items per hour)
            let rawPerAction = 0;
            let processedPerAction = 0;

            const rawItemName = gameData.itemDetailMap[drop.itemHrid]?.name || 'Unknown';
            const baseItemsPerHour = actionsPerHour * drop.dropRate * avgAmountPerAction * efficiencyMultiplier;
            const baseItemsPerAction = drop.dropRate * avgAmountPerAction;
            const baseRevenuePerAction = baseItemsPerAction * resolvedRawPrice;
            const baseRevenueLine = baseItemsPerHour * resolvedRawPrice;
            baseRevenuePerHour += baseRevenueLine;
            baseOutputs.push({
                name: rawItemName,
                itemsPerHour: baseItemsPerHour,
                itemsPerAction: baseItemsPerAction,
                dropRate: drop.dropRate,
                priceEach: resolvedRawPrice,
                revenuePerHour: baseRevenueLine,
                revenuePerAction: baseRevenuePerAction,
                missingPrice: rawPriceMissing,
            });

            if (processedItemHrid && processingBonus > 0) {
                // Get conversion ratio from cache (e.g., 1 Milk → 1 Cheese)
                const conversionRatio = conversionData.conversionRatio;

                // Processing Tea check happens per action:
                // If procs (processingBonus% chance): Convert to processed + leftover
                const processedIfProcs = Math.floor(avgAmountPerAction / conversionRatio);
                const rawLeftoverIfProcs = avgAmountPerAction % conversionRatio;

                // If doesn't proc: All stays raw
                const rawIfNoProc = avgAmountPerAction;

                // Expected value per action
                processedPerAction = processingBonus * processedIfProcs;
                rawPerAction = processingBonus * rawLeftoverIfProcs + (1 - processingBonus) * rawIfNoProc;

                const processedPrice = getCachedPrice(processedItemHrid, { context: 'profit', side: 'sell' });
                const processedPriceMissing = processedPrice === null;
                const resolvedProcessedPrice = processedPriceMissing ? 0 : processedPrice;

                const processedItemsPerHour = actionsPerHour * drop.dropRate * processedPerAction * efficiencyMultiplier;
                const processedItemsPerAction = drop.dropRate * processedPerAction;

                // Track processing details
                const processedItemName = gameData.itemDetailMap[processedItemHrid]?.name || 'Unknown';

                // Value gain per conversion = cheese value - cost of milk used
                const costOfMilkUsed = conversionRatio * resolvedRawPrice;
                const valueGainPerConversion = resolvedProcessedPrice - costOfMilkUsed;
                const revenueFromConversion = processedItemsPerHour * valueGainPerConversion;
                const rawConsumedPerHour = processedItemsPerHour * conversionRatio;
                const rawConsumedPerAction = processedItemsPerAction * conversionRatio;

                processingRevenueBonus += revenueFromConversion;
                processingRevenueBonusPerAction += processedItemsPerAction * valueGainPerConversion;
                processingConversions.push({
                    rawItem: rawItemName,
                    processedItem: processedItemName,
                    valueGain: valueGainPerConversion,
                    conversionsPerHour: processedItemsPerHour,
                    conversionsPerAction: processedItemsPerAction,
                    rawConsumedPerHour,
                    rawConsumedPerAction,
                    rawPriceEach: resolvedRawPrice,
                    processedPriceEach: resolvedProcessedPrice,
                    revenuePerHour: revenueFromConversion,
                    revenuePerAction: processedItemsPerAction * valueGainPerConversion,
                    missingPrice: rawPriceMissing || processedPriceMissing,
                });
            } else {
                // No processing - simple calculation
                rawPerAction = avgAmountPerAction;
            }

            // Gourmet tea bonus (only for production skills, not gathering)
            if (gourmetBonus > 0) {
                const totalPerAction = rawPerAction + processedPerAction;
                const bonusPerAction = totalPerAction * (gourmetBonus / 100);
                const bonusItemsPerHour = actionsPerHour * drop.dropRate * bonusPerAction * efficiencyMultiplier;
                const bonusItemsPerAction = drop.dropRate * bonusPerAction;

                // Use weighted average price for gourmet bonus
                if (processedItemHrid && processingBonus > 0) {
                    const processedPrice = getCachedPrice(processedItemHrid, { context: 'profit', side: 'sell' });
                    const processedPriceMissing = processedPrice === null;
                    const resolvedProcessedPrice = processedPriceMissing ? 0 : processedPrice;
                    const weightedPrice =
                        (rawPerAction * resolvedRawPrice + processedPerAction * resolvedProcessedPrice) /
                        (rawPerAction + processedPerAction);
                    const bonusRevenue = bonusItemsPerHour * weightedPrice;
                    gourmetRevenueBonus += bonusRevenue;
                    gourmetRevenueBonusPerAction += bonusItemsPerAction * weightedPrice;
                    gourmetBonuses.push({
                        name: rawItemName,
                        itemsPerHour: bonusItemsPerHour,
                        itemsPerAction: bonusItemsPerAction,
                        dropRate: drop.dropRate,
                        priceEach: weightedPrice,
                        revenuePerHour: bonusRevenue,
                        revenuePerAction: bonusItemsPerAction * weightedPrice,
                        missingPrice: rawPriceMissing || processedPriceMissing,
                    });
                } else {
                    const bonusRevenue = bonusItemsPerHour * resolvedRawPrice;
                    gourmetRevenueBonus += bonusRevenue;
                    gourmetRevenueBonusPerAction += bonusItemsPerAction * resolvedRawPrice;
                    gourmetBonuses.push({
                        name: rawItemName,
                        itemsPerHour: bonusItemsPerHour,
                        itemsPerAction: bonusItemsPerAction,
                        dropRate: drop.dropRate,
                        priceEach: resolvedRawPrice,
                        revenuePerHour: bonusRevenue,
                        revenuePerAction: bonusItemsPerAction * resolvedRawPrice,
                        missingPrice: rawPriceMissing,
                    });
                }
            }
        }

        // Calculate bonus revenue from essence and rare find drops
        const bonusRevenue = calculateBonusRevenue(actionDetail, actionsPerHour, equipment, gameData.itemDetailMap);

        // Apply efficiency multiplier to bonus revenue (efficiency repeats the action, including bonus rolls)
        const efficiencyBoostedBonusRevenue = bonusRevenue.totalBonusRevenue * efficiencyMultiplier;

        const revenuePerHour =
            baseRevenuePerHour + gourmetRevenueBonus + processingRevenueBonus + efficiencyBoostedBonusRevenue;

        const hasMissingPrices =
            drinkCosts.some((drink) => drink.missingPrice) ||
            baseOutputs.some((output) => output.missingPrice) ||
            gourmetBonuses.some((output) => output.missingPrice) ||
            processingConversions.some((conversion) => conversion.missingPrice) ||
            (bonusRevenue?.hasMissingPrices ?? false);

        // Calculate market tax (2% of gross revenue)
        const marketTax = revenuePerHour * MARKET_TAX;

        // Calculate net profit (revenue - market tax - drink costs)
        const profitPerHour = revenuePerHour - marketTax - drinkCostPerHour;

        return {
            profitPerHour,
            profitPerAction: calculateProfitPerAction(profitPerHour, actionsPerHour), // Profit per action
            profitPerDay: calculateProfitPerDay(profitPerHour), // Profit per day
            revenuePerHour,
            drinkCostPerHour,
            drinkCosts, // Array of individual drink costs {name, priceEach, costPerHour}
            actionsPerHour, // Base actions per hour (without efficiency)
            baseOutputs, // Display-only base outputs {name, itemsPerHour, dropRate, priceEach, revenuePerHour}
            gourmetBonuses, // Display-only gourmet bonus outputs
            totalEfficiency, // Total efficiency percentage
            efficiencyMultiplier, // Efficiency as multiplier (1 + totalEfficiency / 100)
            speedBonus,
            bonusRevenue, // Essence and rare find details
            gourmetBonus, // Gourmet bonus percentage
            processingBonus, // Processing Tea chance (as decimal)
            processingRevenueBonus, // Extra revenue from Processing conversions
            processingConversions, // Array of conversion details {rawItem, processedItem, valueGain}
            processingRevenueBonusPerAction, // Processing bonus per action
            gourmetRevenueBonus, // Gourmet bonus revenue per hour
            gourmetRevenueBonusPerAction, // Gourmet bonus revenue per action
            gatheringQuantity: totalGathering, // Total gathering quantity bonus (as decimal) - renamed for display consistency
            hasMissingPrices,
            details: {
                levelEfficiency,
                houseEfficiency,
                teaEfficiency,
                equipmentEfficiency,
                achievementEfficiency,
                gourmetBonus,
                communityBuffQuantity: communityGathering, // Community Buff component (as decimal)
                gatheringTeaBonus: gatheringTea, // Gathering Tea component (as decimal)
                achievementGathering: achievementGathering, // Achievement Tier component (as decimal)
            },
        };
    }

    /**
     * Market Tooltip Prices Feature
     * Adds market prices to item tooltips
     */


    // Compiled regex patterns (created once, reused for performance)
    const REGEX_ENHANCEMENT_LEVEL = /\+(\d+)$/;
    const REGEX_ENHANCEMENT_STRIP = /\s*\+\d+$/;
    const REGEX_AMOUNT = /x([\d,]+)|Amount:\s*([\d,]+)/i;
    const REGEX_COMMA = /,/g;

    /**
     * Format price for tooltip display based on user setting
     * @param {number} num - The number to format
     * @returns {string} Formatted number
     */
    function formatTooltipPrice(num) {
        const useKMB = config$1.getSetting('formatting_useKMBFormat');
        return useKMB ? networthFormatter(num) : numberFormatter(num);
    }

    /**
     * TooltipPrices class handles injecting market prices into item tooltips
     */
    class TooltipPrices {
        constructor() {
            this.unregisterObserver = null;
            this.isActive = false;
            this.isInitialized = false;
            this.itemNameToHridCache = null; // Lazy-loaded reverse lookup cache
            this.itemNameToHridCacheSource = null; // Track source for invalidation
        }

        /**
         * Initialize the tooltip prices feature
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('itemTooltip_prices')) {
                return;
            }

            this.isInitialized = true;

            // Wait for market data to load
            if (!marketAPI.isLoaded()) {
                await marketAPI.fetch(true); // Force fresh fetch on init
            }

            // Add CSS to prevent tooltip cutoff
            this.addTooltipStyles();

            // Register with centralized DOM observer
            this.setupObserver();
        }

        /**
         * Add CSS styles to prevent tooltip cutoff
         *
         * CRITICAL: CSS alone is not enough! MUI uses JavaScript to position tooltips
         * with transform3d(), which can place them off-screen. We need both:
         * 1. CSS: Enables scrolling when tooltip is taller than viewport
         * 2. JavaScript: Repositions tooltip when it extends beyond viewport (see fixTooltipOverflow)
         */
        addTooltipStyles() {
            // Check if styles already exist (might be added by tooltip-consumables)
            if (document.getElementById('mwi-tooltip-fixes')) {
                return; // Already added
            }

            const css = `
            /* Ensure tooltip content is scrollable if too tall */
            .MuiTooltip-tooltip {
                max-height: calc(100vh - 20px) !important;
                overflow-y: auto !important;
            }

            /* Also target the popper container */
            .MuiTooltip-popper {
                max-height: 100vh !important;
            }

            /* Add subtle scrollbar styling */
            .MuiTooltip-tooltip::-webkit-scrollbar {
                width: 6px;
            }

            .MuiTooltip-tooltip::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.2);
            }

            .MuiTooltip-tooltip::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 3px;
            }

            .MuiTooltip-tooltip::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.5);
            }
        `;

            dom.addStyles(css, 'mwi-tooltip-fixes');
        }

        /**
         * Set up observer to watch for tooltip elements
         */
        setupObserver() {
            // Register with centralized DOM observer to watch for tooltip poppers
            this.unregisterObserver = domObserver$1.onClass('TooltipPrices', 'MuiTooltip-popper', (tooltipElement) => {
                this.handleTooltip(tooltipElement);
            });

            this.isActive = true;
        }

        /**
         * Handle a tooltip element
         * @param {Element} tooltipElement - The tooltip popper element
         */
        async handleTooltip(tooltipElement) {
            // Guard against duplicate processing
            if (tooltipElement.dataset.pricesProcessed) {
                return;
            }
            tooltipElement.dataset.pricesProcessed = 'true';

            // Check if it's a collection tooltip
            const collectionContent = tooltipElement.querySelector('div.Collection_tooltipContent__2IcSJ');
            const isCollectionTooltip = !!collectionContent;

            // Check if it's a regular item tooltip
            const nameElement = tooltipElement.querySelector('div.ItemTooltipText_name__2JAHA');
            const isItemTooltip = !!nameElement;

            if (!isCollectionTooltip && !isItemTooltip) {
                return; // Not a tooltip we can enhance
            }

            // Extract item name from appropriate element
            let itemName;
            if (isCollectionTooltip) {
                const collectionNameElement = tooltipElement.querySelector('div.Collection_name__10aep');
                if (!collectionNameElement) {
                    return; // No name element in collection tooltip
                }
                itemName = collectionNameElement.textContent.trim();
            } else {
                itemName = nameElement.textContent.trim();
            }

            // Get the item HRID from the name
            const itemHrid = this.extractItemHridFromName(itemName);

            if (!itemHrid) {
                return;
            }

            // Get item details
            const itemDetails = dataManager$1.getItemDetails(itemHrid);

            if (!itemDetails) {
                return;
            }

            // Check if this is an openable container first (they have no market price)
            if (itemDetails.isOpenable && config$1.getSetting('itemTooltip_expectedValue')) {
                const evData = expectedValueCalculator.calculateExpectedValue(itemHrid);
                if (evData) {
                    this.injectExpectedValueDisplay(tooltipElement, evData, isCollectionTooltip);
                }
                // Fix tooltip overflow before returning
                dom.fixTooltipOverflow(tooltipElement);
                return; // Skip price/profit display for containers
            }

            // Only check enhancement level for regular item tooltips (not collection tooltips)
            let enhancementLevel = 0;
            if (isItemTooltip && !isCollectionTooltip) {
                enhancementLevel = this.extractEnhancementLevel(tooltipElement);
            }

            // Get market price for the specific enhancement level (0 for base items, 1-20 for enhanced)
            const price = getItemPrices(itemHrid, enhancementLevel);

            // Inject price display only if we have market data
            if (price && (price.ask > 0 || price.bid > 0)) {
                // Get item amount from tooltip (for stacks)
                const amount = this.extractItemAmount(tooltipElement);
                this.injectPriceDisplay(tooltipElement, price, amount, isCollectionTooltip);
            }

            // Always show detailed craft profit if enabled
            if (config$1.getSetting('itemTooltip_profit') && enhancementLevel === 0) {
                // Original single-action craft profit display
                // Only run for base items (enhancementLevel = 0), not enhanced items
                // Enhanced items show their cost in the enhancement path section instead
                const profitData = await profitCalculator.calculateProfit(itemHrid);
                if (profitData) {
                    this.injectProfitDisplay(tooltipElement, profitData, isCollectionTooltip);
                }
            }

            // Optionally show alternative alchemy actions below craft profit
            if (config$1.getSetting('itemTooltip_multiActionProfit')) {
                // Multi-action profit display (alchemy actions only - craft shown above)
                await this.injectMultiActionProfitDisplay(tooltipElement, itemHrid, enhancementLevel, isCollectionTooltip);
            }

            // Check for gathering sources (Foraging, Woodcutting, Milking)
            if (config$1.getSetting('itemTooltip_gathering') && enhancementLevel === 0) {
                const gatheringData = await this.findGatheringSources(itemHrid);
                if (gatheringData && (gatheringData.soloActions.length > 0 || gatheringData.zoneActions.length > 0)) {
                    this.injectGatheringDisplay(tooltipElement, gatheringData, isCollectionTooltip);
                }
            }

            // Show enhancement path for enhanced items (1-20)
            if (enhancementLevel > 0) {
                // Get enhancement configuration
                const enhancementConfig = getEnhancingParams();
                if (enhancementConfig) {
                    // Calculate optimal enhancement path
                    const enhancementData = calculateEnhancementPath(itemHrid, enhancementLevel, enhancementConfig);

                    if (enhancementData) {
                        // Inject enhancement analysis into tooltip
                        this.injectEnhancementDisplay(tooltipElement, enhancementData);
                    }
                }
            }

            // Fix tooltip overflow (ensure it stays in viewport)
            dom.fixTooltipOverflow(tooltipElement);
        }

        /**
         * Extract enhancement level from tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @returns {number} Enhancement level (0 if not enhanced)
         */
        extractEnhancementLevel(tooltipElement) {
            const nameElement = tooltipElement.querySelector('div.ItemTooltipText_name__2JAHA');
            if (!nameElement) {
                return 0;
            }

            const itemName = nameElement.textContent.trim();

            // Match "+X" at end of name
            const match = itemName.match(REGEX_ENHANCEMENT_LEVEL);
            if (match) {
                return parseInt(match[1], 10);
            }

            return 0;
        }

        /**
         * Inject enhancement display into tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @param {Object} enhancementData - Enhancement analysis data
         */
        injectEnhancementDisplay(tooltipElement, enhancementData) {
            const tooltipText = tooltipElement.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

            if (!tooltipText) {
                return;
            }

            if (tooltipText.querySelector('.market-enhancement-injected')) {
                return;
            }

            // Create enhancement display container
            const enhancementDiv = dom.createStyledDiv(
                { color: config$1.COLOR_TOOLTIP_INFO },
                '',
                'market-enhancement-injected'
            );

            // Build HTML using the tooltip-enhancement module
            enhancementDiv.innerHTML = buildEnhancementTooltipHTML(enhancementData);

            tooltipText.appendChild(enhancementDiv);
        }

        /**
         * Extract item HRID from tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @returns {string|null} Item HRID or null
         */
        extractItemHrid(tooltipElement) {
            // Try to find the item HRID from the tooltip's data attributes or content
            // The game uses React, so we need to find the HRID from the displayed name

            const nameElement = tooltipElement.querySelector('div.ItemTooltipText_name__2JAHA');
            if (!nameElement) {
                return null;
            }

            let itemName = nameElement.textContent.trim();

            // Strip enhancement level (e.g., "+10" from "Griffin Bulwark +10")
            // This is critical - enhanced items need to lookup the base item
            itemName = itemName.replace(REGEX_ENHANCEMENT_STRIP, '');

            return this.extractItemHridFromName(itemName);
        }

        /**
         * Extract item HRID from item name
         * @param {string} itemName - Item name
         * @returns {string|null} Item HRID or null
         */
        extractItemHridFromName(itemName) {
            // Strip enhancement level (e.g., "+10" from "Griffin Bulwark +10")
            // This is critical - enhanced items need to lookup the base item
            itemName = itemName.replace(REGEX_ENHANCEMENT_STRIP, '');

            const initData = dataManager$1.getInitClientData();
            if (!initData || !initData.itemDetailMap) {
                return null;
            }

            // Return cached map if source data hasn't changed (handles character switch)
            if (this.itemNameToHridCache && this.itemNameToHridCacheSource === initData.itemDetailMap) {
                return this.itemNameToHridCache.get(itemName) || null;
            }

            // Build itemName -> HRID map
            const map = new Map();
            for (const [hrid, item] of Object.entries(initData.itemDetailMap)) {
                map.set(item.name, hrid);
            }

            // Only cache if we got actual entries (avoid poisoning with empty map)
            if (map.size > 0) {
                this.itemNameToHridCache = map;
                this.itemNameToHridCacheSource = initData.itemDetailMap;
            }

            // Return result from newly built map
            return map.get(itemName) || null;
        }

        /**
         * Extract item amount from tooltip (for stacks)
         * @param {Element} tooltipElement - Tooltip element
         * @returns {number} Item amount (default 1)
         */
        extractItemAmount(tooltipElement) {
            // Look for amount text in tooltip (e.g., "x5", "Amount: 5", "Amount: 4,900")
            const text = tooltipElement.textContent;
            const match = text.match(REGEX_AMOUNT);

            if (match) {
                // Strip commas before parsing
                const amountStr = (match[1] || match[2]).replace(REGEX_COMMA, '');
                return parseInt(amountStr, 10);
            }

            return 1; // Default to 1 if not found
        }

        /**
         * Inject price display into tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @param {Object} price - { ask, bid }
         * @param {number} amount - Item amount
         * @param {boolean} isCollectionTooltip - True if this is a collection tooltip
         */
        injectPriceDisplay(tooltipElement, price, amount, isCollectionTooltip = false) {
            const tooltipText = isCollectionTooltip
                ? tooltipElement.querySelector('.Collection_tooltipContent__2IcSJ')
                : tooltipElement.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

            if (!tooltipText) {
                console.warn('[TooltipPrices] Could not find tooltip text container');
                return;
            }

            if (tooltipText.querySelector('.market-price-injected')) {
                return;
            }

            // Create price display
            const priceDiv = dom.createStyledDiv({ color: config$1.COLOR_TOOLTIP_INFO }, '', 'market-price-injected');

            // Show message if no market data at all
            if (price.ask <= 0 && price.bid <= 0) {
                priceDiv.innerHTML = `Price: <span style="color: ${config$1.COLOR_TEXT_SECONDARY}; font-style: italic;">No market data</span>`;
                tooltipText.appendChild(priceDiv);
                return;
            }

            // Format prices, using "-" for missing values
            const askDisplay = price.ask > 0 ? formatTooltipPrice(price.ask) : '-';
            const bidDisplay = price.bid > 0 ? formatTooltipPrice(price.bid) : '-';

            // Calculate totals (only if both prices valid and amount > 1)
            let totalDisplay = '';
            if (amount > 1 && price.ask > 0 && price.bid > 0) {
                const totalAsk = price.ask * amount;
                const totalBid = price.bid * amount;
                totalDisplay = ` (${formatTooltipPrice(totalAsk)} / ${formatTooltipPrice(totalBid)})`;
            }

            // Format: "Price: 1,200 / 950" or "Price: 1,200 / -" or "Price: - / 950"
            priceDiv.innerHTML = `Price: ${askDisplay} / ${bidDisplay}${totalDisplay}`;

            tooltipText.appendChild(priceDiv);
        }

        /**
         * Inject profit display into tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @param {Object} profitData - Profit calculation data
         * @param {boolean} isCollectionTooltip - True if this is a collection tooltip
         */
        injectProfitDisplay(tooltipElement, profitData, isCollectionTooltip = false) {
            const tooltipText = isCollectionTooltip
                ? tooltipElement.querySelector('.Collection_tooltipContent__2IcSJ')
                : tooltipElement.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

            if (!tooltipText) {
                return;
            }

            if (tooltipText.querySelector('.market-profit-injected')) {
                return;
            }

            // Create profit display container
            const profitDiv = dom.createStyledDiv(
                { color: config$1.COLOR_TOOLTIP_INFO, marginTop: '8px' },
                '',
                'market-profit-injected'
            );

            // Check if detailed view is enabled
            const showDetailed = config$1.getSetting('itemTooltip_detailedProfit');

            // Build profit display
            let html = '<div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">';

            if (profitData.itemPrice.bid > 0 && profitData.itemPrice.ask > 0) {
                // Market data available - show profit
                html += '<div style="font-weight: bold; margin-bottom: 4px;">PROFIT</div>';
                html += '<div style="font-size: 0.9em; margin-left: 8px;">';

                const profitPerDay = profitData.profitPerDay;
                const profitColor = profitData.profitPerHour >= 0 ? config$1.COLOR_TOOLTIP_PROFIT : config$1.COLOR_TOOLTIP_LOSS;

                html += `<div style="color: ${profitColor}; font-weight: bold;">Net: ${numberFormatter(profitData.profitPerHour)}/hr (${formatKMB(profitPerDay)}/day)</div>`;

                // Show detailed breakdown if enabled
                if (showDetailed) {
                    html += this.buildDetailedProfitDisplay(profitData);
                }
            } else {
                // No market data - show cost
                html += '<div style="font-size: 0.9em; margin-left: 8px;">';

                const teaCostPerItem = profitData.totalTeaCostPerHour / profitData.itemsPerHour;
                const productionCost = profitData.totalMaterialCost + teaCostPerItem;

                html += `<div style="font-weight: bold; color: ${config$1.COLOR_TOOLTIP_INFO};">Cost: ${numberFormatter(productionCost)}/item</div>`;
                html += `<div style="color: ${config$1.COLOR_TEXT_SECONDARY}; font-style: italic; margin-top: 4px;">No market data available</div>`;
            }

            html += '</div>';
            html += '</div>';

            profitDiv.innerHTML = html;
            tooltipText.appendChild(profitDiv);
        }

        /**
         * Build detailed profit display with materials table
         * @param {Object} profitData - Profit calculation data
         * @returns {string} HTML string for detailed display
         */
        buildDetailedProfitDisplay(profitData) {
            let html = '';

            // Materials table
            if (profitData.materialCosts && profitData.materialCosts.length > 0) {
                html += '<div style="margin-top: 8px;">';
                html += `<table style="width: 100%; border-collapse: collapse; font-size: 0.85em; color: ${config$1.COLOR_TOOLTIP_INFO};">`;

                // Table header
                html += `<tr style="border-bottom: 1px solid ${config$1.COLOR_BORDER};">`;
                html += '<th style="padding: 2px 4px; text-align: left;">Material</th>';
                html += '<th style="padding: 2px 4px; text-align: center;">Count</th>';
                html += '<th style="padding: 2px 4px; text-align: right;">Ask</th>';
                html += '<th style="padding: 2px 4px; text-align: right;">Bid</th>';
                html += '</tr>';

                // Fetch market prices for all materials (profit calculator only stores one price based on mode)
                const materialsWithPrices = profitData.materialCosts.map((material) => {
                    const itemHrid = material.itemHrid;
                    const marketPrice = marketAPI.getPrice(itemHrid, 0);

                    return {
                        ...material,
                        askPrice: marketPrice?.ask && marketPrice.ask > 0 ? marketPrice.ask : 0,
                        bidPrice: marketPrice?.bid && marketPrice.bid > 0 ? marketPrice.bid : 0,
                    };
                });

                // Calculate totals using actual amounts (not count - materialCosts uses 'amount' field)
                const totalCount = materialsWithPrices.reduce((sum, m) => sum + m.amount, 0);
                const totalAsk = materialsWithPrices.reduce((sum, m) => sum + m.askPrice * m.amount, 0);
                const totalBid = materialsWithPrices.reduce((sum, m) => sum + m.bidPrice * m.amount, 0);

                // Total row
                html += `<tr style="border-bottom: 1px solid ${config$1.COLOR_BORDER};">`;
                html += '<td style="padding: 2px 4px; font-weight: bold;">Total</td>';
                html += `<td style="padding: 2px 4px; text-align: center;">${totalCount.toFixed(1)}</td>`;
                html += `<td style="padding: 2px 4px; text-align: right;">${formatKMB(totalAsk)}</td>`;
                html += `<td style="padding: 2px 4px; text-align: right;">${formatKMB(totalBid)}</td>`;
                html += '</tr>';

                // Material rows
                for (const material of materialsWithPrices) {
                    html += '<tr>';
                    html += `<td style="padding: 2px 4px;">${material.itemName}</td>`;
                    html += `<td style="padding: 2px 4px; text-align: center;">${material.amount.toFixed(1)}</td>`;
                    html += `<td style="padding: 2px 4px; text-align: right;">${formatKMB(material.askPrice)}</td>`;
                    html += `<td style="padding: 2px 4px; text-align: right;">${formatKMB(material.bidPrice)}</td>`;
                    html += '</tr>';
                }

                html += '</table>';
                html += '</div>';
            }

            // Detailed profit breakdown
            html += '<div style="margin-top: 8px; font-size: 0.85em;">';
            const profitPerAction = profitData.profitPerAction;
            const profitPerDay = profitData.profitPerDay;
            const profitColor = profitData.profitPerHour >= 0 ? config$1.COLOR_TOOLTIP_PROFIT : config$1.COLOR_TOOLTIP_LOSS;

            html += `<div style="color: ${profitColor};">Profit: ${numberFormatter(profitPerAction)}/action, ${numberFormatter(profitData.profitPerHour)}/hour, ${formatKMB(profitPerDay)}/day</div>`;
            html += '</div>';

            return html;
        }

        /**
         * Inject expected value display into tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @param {Object} evData - Expected value calculation data
         * @param {boolean} isCollectionTooltip - True if this is a collection tooltip
         */
        injectExpectedValueDisplay(tooltipElement, evData, isCollectionTooltip = false) {
            const tooltipText = isCollectionTooltip
                ? tooltipElement.querySelector('.Collection_tooltipContent__2IcSJ')
                : tooltipElement.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

            if (!tooltipText) {
                return;
            }

            if (tooltipText.querySelector('.market-ev-injected')) {
                return;
            }

            // Create EV display container
            const evDiv = dom.createStyledDiv(
                { color: config$1.COLOR_TOOLTIP_INFO, marginTop: '8px' },
                '',
                'market-ev-injected'
            );

            // Build EV display
            let html = '<div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">';

            // Header
            html += '<div style="font-weight: bold; margin-bottom: 4px;">EXPECTED VALUE</div>';
            html += '<div style="font-size: 0.9em; margin-left: 8px;">';

            // Expected value (simple display)
            html += `<div style="color: ${config$1.COLOR_TOOLTIP_PROFIT}; font-weight: bold;">Expected Return: ${formatTooltipPrice(evData.expectedValue)}</div>`;

            html += '</div>'; // Close summary section

            // Drop breakdown (if configured to show)
            const showDropsSetting = config$1.getSettingValue('expectedValue_showDrops', 'All');

            if (showDropsSetting !== 'None' && evData.drops.length > 0) {
                html += '<div style="border-top: 1px solid rgba(255,255,255,0.2); margin: 8px 0;"></div>';

                // Determine how many drops to show
                let dropsToShow = evData.drops;
                let headerLabel = 'All Drops';

                if (showDropsSetting === 'Top 5') {
                    dropsToShow = evData.drops.slice(0, 5);
                    headerLabel = 'Top 5 Drops';
                } else if (showDropsSetting === 'Top 10') {
                    dropsToShow = evData.drops.slice(0, 10);
                    headerLabel = 'Top 10 Drops';
                }

                html += `<div style="font-weight: bold; margin-bottom: 4px;">${headerLabel} (${evData.drops.length} total):</div>`;
                html += '<div style="font-size: 0.9em; margin-left: 8px;">';

                // List each drop
                for (const drop of dropsToShow) {
                    if (!drop.hasPriceData) {
                        // Show item without price data in gray
                        html += `<div style="color: ${config$1.COLOR_TEXT_SECONDARY};">• ${drop.itemName} (${formatPercentage(drop.dropRate, 2)}): ${drop.avgCount.toFixed(2)} avg → No price data</div>`;
                    } else {
                        // Format drop rate percentage
                        const dropRatePercent = formatPercentage(drop.dropRate, 2);

                        // Show full drop breakdown
                        html += `<div>• ${drop.itemName} (${dropRatePercent}%): ${drop.avgCount.toFixed(2)} avg → ${formatTooltipPrice(drop.expectedValue)}</div>`;
                    }
                }

                html += '</div>'; // Close drops list

                // Show total
                html += '<div style="border-top: 1px solid rgba(255,255,255,0.2); margin: 4px 0;"></div>';
                html += `<div style="font-size: 0.9em; margin-left: 8px; font-weight: bold;">Total from ${evData.drops.length} drops: ${formatTooltipPrice(evData.expectedValue)}</div>`;
            }

            html += '</div>'; // Close main container

            evDiv.innerHTML = html;

            tooltipText.appendChild(evDiv);
        }

        /**
         * Find gathering sources for an item
         * @param {string} itemHrid - Item HRID
         * @returns {Object|null} { soloActions: [...], zoneActions: [...] }
         */
        async findGatheringSources(itemHrid) {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData || !gameData.actionDetailMap) {
                return null;
            }

            const GATHERING_TYPES = ['/action_types/foraging', '/action_types/woodcutting', '/action_types/milking'];

            const soloActions = [];
            const zoneActions = [];

            // Search through all actions
            for (const [actionHrid, action] of Object.entries(gameData.actionDetailMap)) {
                // Skip non-gathering actions
                if (!GATHERING_TYPES.includes(action.type)) {
                    continue;
                }

                // Check if this action produces our item
                let foundInDrop = false;
                let dropRate = 0;
                let isSolo = false;

                // Check drop table (both solo and zone actions)
                if (action.dropTable) {
                    for (const drop of action.dropTable) {
                        if (drop.itemHrid === itemHrid) {
                            foundInDrop = true;
                            dropRate = drop.dropRate;
                            // Solo gathering has 100% drop rate (dropRate === 1)
                            // Zone gathering has < 100% drop rate
                            isSolo = dropRate === 1;
                            break;
                        }
                    }
                }

                // Check rare drop table (rare finds - always zone actions)
                if (!foundInDrop && action.rareDropTable) {
                    for (const drop of action.rareDropTable) {
                        if (drop.itemHrid === itemHrid) {
                            foundInDrop = true;
                            dropRate = drop.dropRate;
                            isSolo = false; // Rare drops are never solo
                            break;
                        }
                    }
                }

                if (foundInDrop || isSolo) {
                    const actionData = {
                        actionHrid,
                        actionName: action.name,
                        dropRate,
                    };

                    if (isSolo) {
                        soloActions.push(actionData);
                    } else {
                        zoneActions.push(actionData);
                    }
                }
            }

            // Only return if we found something
            if (soloActions.length === 0 && zoneActions.length === 0) {
                return null;
            }

            // Calculate profit for solo actions
            for (const action of soloActions) {
                const profitData = await calculateGatheringProfit(action.actionHrid);
                if (profitData) {
                    action.itemsPerHour = profitData.baseOutputs?.[0]?.itemsPerHour || 0;
                    action.profitPerHour = profitData.profitPerHour || 0;
                }
            }

            // Calculate items/hr for zone actions (no profit)
            for (const action of zoneActions) {
                const actionDetail = gameData.actionDetailMap[action.actionHrid];
                if (!actionDetail) {
                    continue;
                }

                // Calculate base actions per hour
                const baseTimeCost = actionDetail.baseTimeCost; // in nanoseconds
                const timeInSeconds = baseTimeCost / 1e9;
                const actionsPerHour = calculateActionsPerHour(timeInSeconds);

                // Calculate items per hour
                const itemsPerHour = actionsPerHour * action.dropRate;

                // For rare drops (< 1%), store items/day instead for better readability
                // For regular drops (>= 1%), store items/hr
                if (action.dropRate < 0.01) {
                    action.itemsPerDay = itemsPerHour * 24;
                    action.isRareDrop = true;
                } else {
                    action.itemsPerHour = itemsPerHour;
                    action.isRareDrop = false;
                }
            }

            return { soloActions, zoneActions };
        }

        /**
         * Inject gathering display into tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @param {Object} gatheringData - { soloActions: [...], zoneActions: [...] }
         * @param {boolean} isCollectionTooltip - True if collection tooltip
         */
        injectGatheringDisplay(tooltipElement, gatheringData, isCollectionTooltip = false) {
            const tooltipText = isCollectionTooltip
                ? tooltipElement.querySelector('.Collection_tooltipContent__2IcSJ')
                : tooltipElement.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

            if (!tooltipText) {
                return;
            }

            if (tooltipText.querySelector('.market-gathering-injected')) {
                return;
            }

            // Filter out rare drops if setting is disabled
            const showRareDrops = config$1.getSetting('itemTooltip_gatheringRareDrops');
            let zoneActions = gatheringData.zoneActions;
            if (!showRareDrops) {
                zoneActions = zoneActions.filter((action) => !action.isRareDrop);
            }

            // Skip if no actions to show
            if (gatheringData.soloActions.length === 0 && zoneActions.length === 0) {
                return;
            }

            // Create gathering display container
            const gatheringDiv = dom.createStyledDiv(
                { color: config$1.COLOR_TOOLTIP_INFO, marginTop: '8px' },
                '',
                'market-gathering-injected'
            );

            let html = '<div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">';
            html += '<div style="font-weight: bold; margin-bottom: 4px;">GATHERING</div>';

            // Solo actions section
            if (gatheringData.soloActions.length > 0) {
                html += '<div style="font-size: 0.9em; margin-left: 8px; margin-bottom: 6px;">';
                html += '<div style="font-weight: 500; margin-bottom: 2px;">Solo:</div>';

                for (const action of gatheringData.soloActions) {
                    const itemsPerHourStr = action.itemsPerHour ? Math.round(action.itemsPerHour) : '?';
                    const profitStr = action.profitPerHour ? formatKMB(Math.round(action.profitPerHour)) : '?';

                    html += `<div style="margin-left: 8px;">• ${action.actionName}: ${itemsPerHourStr} items/hr | ${profitStr} gold/hr</div>`;
                }

                html += '</div>';
            }

            // Zone actions section
            if (zoneActions.length > 0) {
                html += '<div style="font-size: 0.9em; margin-left: 8px;">';
                html += '<div style="font-weight: 500; margin-bottom: 2px;">Found in:</div>';

                for (const action of zoneActions) {
                    // Use more decimal places for very rare drops (< 0.1%)
                    const percentValue = action.dropRate * 100;
                    const dropRatePercent = percentValue < 0.1 ? percentValue.toFixed(4) : percentValue.toFixed(1);

                    // Show items/day for rare drops (< 1%), items/hr for regular drops
                    let itemsDisplay;
                    if (action.isRareDrop) {
                        const itemsPerDayStr = action.itemsPerDay ? action.itemsPerDay.toFixed(2) : '?';
                        itemsDisplay = `${itemsPerDayStr} items/day`;
                    } else {
                        const itemsPerHourStr = action.itemsPerHour ? Math.round(action.itemsPerHour) : '?';
                        itemsDisplay = `${itemsPerHourStr} items/hr`;
                    }

                    html += `<div style="margin-left: 8px;">• ${action.actionName}: ${itemsDisplay} (${dropRatePercent}% drop)</div>`;
                }

                html += '</div>';
            }

            html += '</div>'; // Close main container

            gatheringDiv.innerHTML = html;

            tooltipText.appendChild(gatheringDiv);
        }

        /**
         * Inject multi-action profit display into tooltip
         * Shows all profitable actions (craft, coinify, decompose, transmute) with best highlighted
         * @param {Element} tooltipElement - Tooltip element
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level
         * @param {boolean} isCollectionTooltip - True if this is a collection tooltip
         */
        async injectMultiActionProfitDisplay(tooltipElement, itemHrid, enhancementLevel, isCollectionTooltip = false) {
            const tooltipText = isCollectionTooltip
                ? tooltipElement.querySelector('.Collection_tooltipContent__2IcSJ')
                : tooltipElement.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

            if (!tooltipText) {
                return;
            }

            if (tooltipText.querySelector('.market-multi-action-injected')) {
                return;
            }

            // Collect alchemy profit data (craft profit is shown separately via injectProfitDisplay)
            const allProfits = [];

            // Try alchemy profits (coinify, decompose, transmute)
            const alchemyProfits = alchemyProfitCalculator.calculateAllProfits(itemHrid, enhancementLevel);

            if (alchemyProfits.coinify) {
                allProfits.push(alchemyProfits.coinify);
            }
            if (alchemyProfits.decompose) {
                allProfits.push(alchemyProfits.decompose);
            }
            if (alchemyProfits.transmute) {
                allProfits.push(alchemyProfits.transmute);
            }

            // If no profitable actions found, return
            if (allProfits.length === 0) {
                return;
            }

            // Sort by profitPerHour descending
            allProfits.sort((a, b) => b.profitPerHour - a.profitPerHour);

            // Check if item is craftable (has a production action)
            const isCraftable = profitCalculator.findProductionAction(itemHrid) !== null;

            // Create profit display container
            const profitDiv = dom.createStyledDiv(
                { color: config$1.COLOR_TOOLTIP_INFO, marginTop: '8px' },
                '',
                'market-multi-action-injected'
            );

            // Build display
            let html = '<div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">';

            // Show heading based on whether item is craftable
            const heading = isCraftable ? 'Alternative Actions:' : 'Profits:';
            html += `<div style="font-weight: bold; margin-bottom: 4px;">${heading}</div>`;
            html += '<div style="font-size: 0.9em; margin-left: 8px;">';

            for (let i = 0; i < allProfits.length; i++) {
                const profit = allProfits[i];
                const label = profit.actionType.charAt(0).toUpperCase() + profit.actionType.slice(1);
                const color = profit.profitPerHour >= 0 ? config$1.COLOR_TOOLTIP_INFO : config$1.COLOR_TOOLTIP_LOSS;
                html += `<div style="color: ${color};">• ${label}: ${numberFormatter(profit.profitPerHour)}/hr`;

                // Show success rate for alchemy actions
                if (profit.successRate !== undefined) {
                    html += ` <span style="opacity: 0.7;">(${(profit.successRate * 100).toFixed(0)}% success)</span>`;
                }

                html += '</div>';
            }

            html += '</div>';

            html += '</div>';

            profitDiv.innerHTML = html;
            tooltipText.appendChild(profitDiv);
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const tooltipPrices = new TooltipPrices();

    /**
     * Consumable Tooltips Feature
     * Adds HP/MP restoration stats to food/drink tooltips
     */


    /**
     * TooltipConsumables class handles injecting consumable stats into item tooltips
     */
    class TooltipConsumables {
        constructor() {
            this.unregisterObserver = null;
            this.isActive = false;
            this.isInitialized = false;
            this.itemNameToHridCache = null; // Lazy-loaded reverse lookup cache
            this.itemNameToHridCacheSource = null; // Track source for invalidation
        }

        /**
         * Initialize the consumable tooltips feature
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('showConsumTips')) {
                return;
            }

            this.isInitialized = true;

            // Wait for market data to load (needed for cost calculations)
            if (!marketAPI.isLoaded()) {
                await marketAPI.fetch(true);
            }

            // Add CSS to prevent tooltip cutoff (if not already added)
            this.addTooltipStyles();

            // Register with centralized DOM observer
            this.setupObserver();
        }

        /**
         * Add CSS styles to prevent tooltip cutoff
         *
         * CRITICAL: CSS alone is not enough! MUI uses JavaScript to position tooltips
         * with transform3d(), which can place them off-screen. We need both:
         * 1. CSS: Enables scrolling when tooltip is taller than viewport
         * 2. JavaScript: Repositions tooltip when it extends beyond viewport (see fixTooltipOverflow)
         */
        addTooltipStyles() {
            // Check if styles already exist (might be added by tooltip-prices)
            if (document.getElementById('mwi-tooltip-fixes')) {
                return; // Already added
            }

            const css = `
            /* Ensure tooltip content is scrollable if too tall */
            .MuiTooltip-tooltip {
                max-height: calc(100vh - 20px) !important;
                overflow-y: auto !important;
            }

            /* Also target the popper container */
            .MuiTooltip-popper {
                max-height: 100vh !important;
            }

            /* Add subtle scrollbar styling */
            .MuiTooltip-tooltip::-webkit-scrollbar {
                width: 6px;
            }

            .MuiTooltip-tooltip::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.2);
            }

            .MuiTooltip-tooltip::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 3px;
            }

            .MuiTooltip-tooltip::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.5);
            }
        `;

            dom.addStyles(css, 'mwi-tooltip-fixes');
        }

        /**
         * Set up observer to watch for tooltip elements
         */
        setupObserver() {
            // Register with centralized DOM observer to watch for tooltip poppers
            this.unregisterObserver = domObserver$1.onClass('TooltipConsumables', 'MuiTooltip-popper', (tooltipElement) => {
                this.handleTooltip(tooltipElement);
            });

            this.isActive = true;
        }

        /**
         * Handle a tooltip element
         * @param {Element} tooltipElement - The tooltip popper element
         */
        async handleTooltip(tooltipElement) {
            // Guard against duplicate processing
            if (tooltipElement.dataset.consumablesProcessed) {
                return;
            }
            tooltipElement.dataset.consumablesProcessed = 'true';

            // Check if it's an item tooltip
            const nameElement = tooltipElement.querySelector('div.ItemTooltipText_name__2JAHA');

            if (!nameElement) {
                return; // Not an item tooltip
            }

            // Get the item HRID from the tooltip
            const itemHrid = this.extractItemHrid(tooltipElement);

            if (!itemHrid) {
                return;
            }

            // Get item details
            const itemDetails = dataManager$1.getItemDetails(itemHrid);

            if (!itemDetails || !itemDetails.consumableDetail) {
                return; // Not a consumable
            }

            // Calculate consumable stats
            const consumableStats = this.calculateConsumableStats(itemHrid, itemDetails);

            if (!consumableStats) {
                return; // No stats to show
            }

            // Inject consumable display
            this.injectConsumableDisplay(tooltipElement, consumableStats);

            // Fix tooltip overflow (ensure it stays in viewport)
            dom.fixTooltipOverflow(tooltipElement);
        }

        /**
         * Extract item HRID from tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @returns {string|null} Item HRID or null
         */
        extractItemHrid(tooltipElement) {
            const nameElement = tooltipElement.querySelector('div.ItemTooltipText_name__2JAHA');
            if (!nameElement) {
                return null;
            }

            const itemName = nameElement.textContent.trim();

            const initData = dataManager$1.getInitClientData();
            if (!initData || !initData.itemDetailMap) {
                return null;
            }

            // Return cached map if source data hasn't changed (handles character switch)
            if (this.itemNameToHridCache && this.itemNameToHridCacheSource === initData.itemDetailMap) {
                return this.itemNameToHridCache.get(itemName) || null;
            }

            // Build itemName -> HRID map
            const map = new Map();
            for (const [hrid, item] of Object.entries(initData.itemDetailMap)) {
                map.set(item.name, hrid);
            }

            // Only cache if we got actual entries (avoid poisoning with empty map)
            if (map.size > 0) {
                this.itemNameToHridCache = map;
                this.itemNameToHridCacheSource = initData.itemDetailMap;
            }

            // Return result from newly built map
            return map.get(itemName) || null;
        }

        /**
         * Calculate consumable stats
         * @param {string} itemHrid - Item HRID
         * @param {Object} itemDetails - Item details from game data
         * @returns {Object|null} Consumable stats or null
         */
        calculateConsumableStats(itemHrid, itemDetails) {
            const consumable = itemDetails.consumableDetail;

            if (!consumable) {
                return null;
            }

            // Get the restoration type and amount
            let restoreType = null;
            let restoreAmount = 0;

            // Check for HP restoration
            if (consumable.hitpointRestore) {
                restoreType = 'HP';
                restoreAmount = consumable.hitpointRestore;
            }
            // Check for MP restoration
            else if (consumable.manapointRestore) {
                restoreType = 'MP';
                restoreAmount = consumable.manapointRestore;
            }

            if (!restoreType || restoreAmount === 0) {
                return null; // No restoration stats
            }

            // Track BOTH durations separately
            const recoveryDuration = consumable.recoveryDuration ? consumable.recoveryDuration / 1e9 : 0;
            const cooldownDuration = consumable.cooldownDuration ? consumable.cooldownDuration / 1e9 : 0;

            // Restore per second (for over-time items)
            const restorePerSecond = recoveryDuration > 0 ? restoreAmount / recoveryDuration : 0;

            // Get market price for cost calculations
            const price = marketAPI.getPrice(itemHrid, 0);
            const askPrice = price?.ask || 0;

            // Cost per HP or MP
            const costPerPoint = askPrice > 0 ? askPrice / restoreAmount : 0;

            // Daily max based on COOLDOWN, not recovery duration
            const usesPerDay = cooldownDuration > 0 ? (24 * 60 * 60) / cooldownDuration : 0;
            const dailyMax = restoreAmount * usesPerDay;

            return {
                restoreType,
                restoreAmount,
                restorePerSecond,
                recoveryDuration, // How long healing takes
                cooldownDuration, // How often you can use it
                askPrice,
                costPerPoint,
                dailyMax,
                usesPerDay,
            };
        }

        /**
         * Inject consumable display into tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @param {Object} stats - Consumable stats
         */
        injectConsumableDisplay(tooltipElement, stats) {
            const tooltipText = tooltipElement.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

            if (!tooltipText) {
                return;
            }

            if (tooltipText.querySelector('.consumable-stats-injected')) {
                return;
            }

            // Create consumable display container
            const consumableDiv = dom.createStyledDiv(
                { color: config$1.COLOR_TOOLTIP_INFO, marginTop: '8px' },
                '',
                'consumable-stats-injected'
            );

            // Build consumable display
            let html = '<div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">';

            // CONSUMABLE STATS section
            html += '<div style="font-weight: bold; margin-bottom: 4px;">CONSUMABLE STATS</div>';
            html += '<div style="font-size: 0.9em; margin-left: 8px;">';

            // Restores line
            if (stats.recoveryDuration > 0) {
                html += `<div>Restores: ${numberFormatter(stats.restorePerSecond, 1)} ${stats.restoreType}/s</div>`;
            } else {
                html += `<div>Restores: ${numberFormatter(stats.restoreAmount)} ${stats.restoreType} (instant)</div>`;
            }

            // Cost efficiency line
            if (stats.costPerPoint > 0) {
                html += `<div>Cost: ${numberFormatter(stats.costPerPoint, 1)} per ${stats.restoreType}</div>`;
            } else if (stats.askPrice === 0) {
                html += `<div style="color: gray; font-style: italic;">Cost: No market data</div>`;
            }

            // Daily maximum line - ALWAYS show (based on cooldown)
            if (stats.dailyMax > 0) {
                html += `<div>Daily Max: ${numberFormatter(stats.dailyMax)} ${stats.restoreType}</div>`;
            }

            // Recovery duration line - ONLY for over-time items
            if (stats.recoveryDuration > 0) {
                html += `<div>Recovery Time: ${stats.recoveryDuration}s</div>`;
            }

            // Cooldown line - ALWAYS show
            if (stats.cooldownDuration > 0) {
                html += `<div>Cooldown: ${stats.cooldownDuration}s (${numberFormatter(stats.usesPerDay)} uses/day)</div>`;
            }

            html += '</div>';
            html += '</div>';

            consumableDiv.innerHTML = html;

            tooltipText.appendChild(consumableDiv);
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const tooltipConsumables = new TooltipConsumables();

    /**
     * Market Filter
     * Adds filter dropdowns to marketplace to filter by level, class (skill requirement), and equipment slot
     */


    class MarketFilter {
        constructor() {
            this.isActive = false;
            this.unregisterHandlers = [];
            this.isInitialized = false;

            // Filter state
            this.minLevel = 1;
            this.maxLevel = 1000;
            this.skillRequirement = 'all';
            this.equipmentSlot = 'all';

            // Filter container reference
            this.filterContainer = null;
        }

        /**
         * Initialize market filter
         */
        initialize() {
            // Guard FIRST (before feature check)
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('marketFilter')) {
                return;
            }

            this.isInitialized = true;

            // Register DOM observer for marketplace panel
            this.registerDOMObservers();

            this.isActive = true;
        }

        /**
         * Register DOM observers for marketplace panel
         */
        registerDOMObservers() {
            // Watch for marketplace panel appearing
            const unregister = domObserver$1.onClass(
                'market-filter-container',
                'MarketplacePanel_itemFilterContainer',
                (filterContainer) => {
                    this.injectFilterUI(filterContainer);
                }
            );

            this.unregisterHandlers.push(unregister);

            // Watch for market items appearing/updating
            const unregisterItems = domObserver$1.onClass(
                'market-filter-items',
                'MarketplacePanel_marketItems',
                (_marketItemsContainer) => {
                    this.applyFilters();
                }
            );

            this.unregisterHandlers.push(unregisterItems);

            // Also check immediately in case marketplace is already open
            const existingFilterContainer = document.querySelector('div[class*="MarketplacePanel_itemFilterContainer"]');
            if (existingFilterContainer) {
                this.injectFilterUI(existingFilterContainer);
            }
        }

        /**
         * Inject filter UI into marketplace panel
         * @param {HTMLElement} _oriFilterContainer - Original filter container
         */
        injectFilterUI(_oriFilterContainer) {
            // Check if already injected
            if (document.querySelector('#toolasha-market-filters')) {
                return;
            }

            // Create filter container
            const filterDiv = document.createElement('div');
            filterDiv.id = 'toolasha-market-filters';
            filterDiv.style.cssText = 'display: flex; gap: 12px; margin-top: 8px; flex-wrap: wrap;';

            // Add level range filters
            filterDiv.appendChild(this.createLevelFilter('min'));
            filterDiv.appendChild(this.createLevelFilter('max'));

            // Add class (skill requirement) filter
            filterDiv.appendChild(this.createClassFilter());

            // Add slot (equipment type) filter
            filterDiv.appendChild(this.createSlotFilter());

            // Insert after the original filter container
            _oriFilterContainer.parentElement.insertBefore(filterDiv, _oriFilterContainer.nextSibling);

            this.filterContainer = filterDiv;

            // Apply initial filters
            this.applyFilters();
        }

        /**
         * Create level filter dropdown
         * @param {string} type - 'min' or 'max'
         * @returns {HTMLElement} Filter element
         */
        createLevelFilter(type) {
            const container = document.createElement('span');
            container.style.cssText = 'display: flex; align-items: center; gap: 4px;';

            const label = document.createElement('label');
            label.textContent = type === 'min' ? 'Level >= ' : 'Level < ';
            label.style.cssText = 'font-size: 12px; color: rgba(255, 255, 255, 0.7);';

            const select = document.createElement('select');
            select.id = `toolasha-level-${type}`;
            select.style.cssText =
                'padding: 4px 8px; border-radius: 4px; background: rgba(0, 0, 0, 0.3); color: #fff; border: 1px solid rgba(91, 141, 239, 0.3);';

            // Level options
            const levels =
                type === 'min'
                    ? [1, 10, 20, 30, 40, 50, 60, 65, 70, 75, 80, 85, 90, 95, 100]
                    : [10, 20, 30, 40, 50, 60, 65, 70, 75, 80, 85, 90, 95, 100, 1000];

            levels.forEach((level) => {
                const option = document.createElement('option');
                option.value = level;
                option.textContent = level === 1000 ? 'All' : level;
                if ((type === 'min' && level === 1) || (type === 'max' && level === 1000)) {
                    option.selected = true;
                }
                select.appendChild(option);
            });

            // Event listener
            select.addEventListener('change', () => {
                if (type === 'min') {
                    this.minLevel = parseInt(select.value);
                } else {
                    this.maxLevel = parseInt(select.value);
                }
                this.applyFilters();
            });

            container.appendChild(label);
            container.appendChild(select);
            return container;
        }

        /**
         * Create class (skill requirement) filter dropdown
         * @returns {HTMLElement} Filter element
         */
        createClassFilter() {
            const container = document.createElement('span');
            container.style.cssText = 'display: flex; align-items: center; gap: 4px;';

            const label = document.createElement('label');
            label.textContent = 'Class: ';
            label.style.cssText = 'font-size: 12px; color: rgba(255, 255, 255, 0.7);';

            const select = document.createElement('select');
            select.id = 'toolasha-class-filter';
            select.style.cssText =
                'padding: 4px 8px; border-radius: 4px; background: rgba(0, 0, 0, 0.3); color: #fff; border: 1px solid rgba(91, 141, 239, 0.3);';

            const classes = [
                { value: 'all', label: 'All' },
                { value: 'attack', label: 'Attack' },
                { value: 'melee', label: 'Melee' },
                { value: 'defense', label: 'Defense' },
                { value: 'ranged', label: 'Ranged' },
                { value: 'magic', label: 'Magic' },
                { value: 'others', label: 'Others' },
            ];

            classes.forEach((cls) => {
                const option = document.createElement('option');
                option.value = cls.value;
                option.textContent = cls.label;
                select.appendChild(option);
            });

            select.addEventListener('change', () => {
                this.skillRequirement = select.value;
                this.applyFilters();
            });

            container.appendChild(label);
            container.appendChild(select);
            return container;
        }

        /**
         * Create slot (equipment type) filter dropdown
         * @returns {HTMLElement} Filter element
         */
        createSlotFilter() {
            const container = document.createElement('span');
            container.style.cssText = 'display: flex; align-items: center; gap: 4px;';

            const label = document.createElement('label');
            label.textContent = 'Slot: ';
            label.style.cssText = 'font-size: 12px; color: rgba(255, 255, 255, 0.7);';

            const select = document.createElement('select');
            select.id = 'toolasha-slot-filter';
            select.style.cssText =
                'padding: 4px 8px; border-radius: 4px; background: rgba(0, 0, 0, 0.3); color: #fff; border: 1px solid rgba(91, 141, 239, 0.3);';

            const slots = [
                { value: 'all', label: 'All' },
                { value: 'main_hand', label: 'Main Hand' },
                { value: 'off_hand', label: 'Off Hand' },
                { value: 'two_hand', label: 'Two Hand' },
                { value: 'head', label: 'Head' },
                { value: 'body', label: 'Body' },
                { value: 'hands', label: 'Hands' },
                { value: 'legs', label: 'Legs' },
                { value: 'feet', label: 'Feet' },
                { value: 'neck', label: 'Neck' },
                { value: 'earrings', label: 'Earrings' },
                { value: 'ring', label: 'Ring' },
                { value: 'pouch', label: 'Pouch' },
                { value: 'back', label: 'Back' },
            ];

            slots.forEach((slot) => {
                const option = document.createElement('option');
                option.value = slot.value;
                option.textContent = slot.label;
                select.appendChild(option);
            });

            select.addEventListener('change', () => {
                this.equipmentSlot = select.value;
                this.applyFilters();
            });

            container.appendChild(label);
            container.appendChild(select);
            return container;
        }

        /**
         * Apply filters to all market items
         */
        applyFilters() {
            const marketItemsContainer = document.querySelector('div[class*="MarketplacePanel_marketItems"]');
            if (!marketItemsContainer) {
                return;
            }

            // Get game data
            const gameData = dataManager$1.getInitClientData();
            if (!gameData || !gameData.itemDetailMap) {
                return;
            }

            // Find all item divs
            const itemDivs = marketItemsContainer.querySelectorAll('div[class*="Item_itemContainer"]');

            itemDivs.forEach((itemDiv) => {
                // Get item HRID from SVG use element (same as MWI Tools)
                const useElement = itemDiv.querySelector('use');
                if (!useElement) {
                    return;
                }

                const href = useElement.getAttribute('href');
                if (!href) {
                    return;
                }

                // Extract HRID from href (e.g., #azure_sword -> /items/azure_sword)
                const hrefName = href.split('#')[1];
                if (!hrefName) {
                    return;
                }

                const itemHrid = `/items/${hrefName}`;
                const itemData = gameData.itemDetailMap[itemHrid];

                if (!itemData) {
                    itemDiv.style.display = '';
                    return;
                }

                if (!itemData.equipmentDetail) {
                    // Not equipment, hide if any non-"all" filter is active
                    if (
                        this.minLevel > 1 ||
                        this.maxLevel < 1000 ||
                        this.skillRequirement !== 'all' ||
                        this.equipmentSlot !== 'all'
                    ) {
                        itemDiv.style.display = 'none';
                    } else {
                        itemDiv.style.display = '';
                    }
                    return;
                }

                // Check if item passes all filters
                const passesFilters = this.checkItemFilters(itemData);
                itemDiv.style.display = passesFilters ? '' : 'none';
            });
        }

        /**
         * Check if item passes all current filters
         * @param {Object} itemData - Item data from game
         * @returns {boolean} True if item should be shown
         */
        checkItemFilters(itemData) {
            const itemLevel = itemData.itemLevel || 0;
            const equipmentDetail = itemData.equipmentDetail;

            // Level filter
            if (itemLevel < this.minLevel || itemLevel >= this.maxLevel) {
                return false;
            }

            // Slot filter
            if (this.equipmentSlot !== 'all') {
                const itemType = equipmentDetail.type || '';
                if (!itemType.includes(this.equipmentSlot)) {
                    return false;
                }
            }

            // Class (skill requirement) filter
            if (this.skillRequirement !== 'all') {
                const levelRequirements = equipmentDetail.levelRequirements || [];

                if (this.skillRequirement === 'others') {
                    // "Others" means non-combat skills
                    const combatSkills = ['attack', 'melee', 'defense', 'ranged', 'magic'];
                    const hasCombatReq = levelRequirements.some((req) =>
                        combatSkills.some((skill) => req.skillHrid.includes(skill))
                    );
                    if (hasCombatReq) {
                        return false;
                    }
                } else {
                    // Specific skill requirement
                    const hasRequirement = levelRequirements.some((req) => req.skillHrid.includes(this.skillRequirement));
                    if (!hasRequirement) {
                        return false;
                    }
                }
            }

            return true;
        }

        /**
         * Cleanup on disable
         */
        disable() {
            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];

            // Remove filter UI
            if (this.filterContainer) {
                this.filterContainer.remove();
                this.filterContainer = null;
            }

            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const marketFilter = new MarketFilter();

    /**
     * Auto-Fill Market Price
     * Automatically fills marketplace order forms with optimal competitive pricing
     */


    class AutoFillPrice {
        constructor() {
            this.isActive = false;
            this.unregisterHandlers = [];
            this.processedModals = new WeakSet(); // Track processed modals to prevent duplicates
            this.isInitialized = false;
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Initialize auto-fill price feature
         */
        initialize() {
            // Guard FIRST (before feature check)
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('fillMarketOrderPrice')) {
                return;
            }

            this.isInitialized = true;

            // Register DOM observer for marketplace order modals
            this.registerDOMObservers();

            this.isActive = true;
        }

        /**
         * Register DOM observers for order modals
         */
        registerDOMObservers() {
            // Watch for order modals appearing
            const unregister = domObserver$1.onClass('auto-fill-price', 'Modal_modalContainer', (modal) => {
                // Check if this is a marketplace order modal (not instant buy/sell)
                const header = modal.querySelector('div[class*="MarketplacePanel_header"]');
                if (!header) return;

                const headerText = header.textContent.trim();

                // Skip instant buy/sell modals (contain "Now" in title)
                if (headerText.includes(' Now')) {
                    return;
                }

                // Handle the order modal
                this.handleOrderModal(modal);
            });

            this.unregisterHandlers.push(unregister);
        }

        /**
         * Handle new order modal
         * @param {HTMLElement} modal - Modal container element
         */
        handleOrderModal(modal) {
            // Prevent duplicate processing (dom-observer can fire multiple times for same modal)
            if (this.processedModals.has(modal)) {
                return;
            }
            this.processedModals.add(modal);

            // Find the "Best Price" button/label
            const bestPriceLabel = modal.querySelector('span[class*="MarketplacePanel_bestPrice"]');
            if (!bestPriceLabel) {
                return;
            }

            // Determine if this is a buy or sell order
            const labelParent = bestPriceLabel.parentElement;
            const labelText = labelParent.textContent.toLowerCase();

            const isBuyOrder = labelText.includes('best buy');
            const isSellOrder = labelText.includes('best sell');

            if (!isBuyOrder && !isSellOrder) {
                return;
            }

            // Click the best price label to populate the suggested price
            bestPriceLabel.click();

            // Adjust price after clicking to be optimally competitive
            // For buy orders: increment by 1 to outbid
            // For sell orders: depends on user setting (match or undercut)
            const adjustTimeout = setTimeout(() => {
                this.adjustPrice(modal, isBuyOrder, isSellOrder);
            }, 50);
            this.timerRegistry.registerTimeout(adjustTimeout);
        }

        /**
         * Adjust the price to be optimally competitive
         * @param {HTMLElement} modal - Modal container element
         * @param {boolean} isBuyOrder - True if buy order
         * @param {boolean} isSellOrder - True if sell order
         */
        adjustPrice(modal, isBuyOrder, isSellOrder) {
            // Find the price input container
            const inputContainer = modal.querySelector(
                'div[class*="MarketplacePanel_inputContainer"] div[class*="MarketplacePanel_priceInputs"]'
            );
            if (!inputContainer) {
                return;
            }

            // Find the increment/decrement buttons
            const buttonContainers = inputContainer.querySelectorAll('div[class*="MarketplacePanel_buttonContainer"]');

            if (buttonContainers.length < 3) {
                return;
            }

            if (isBuyOrder) {
                // For buy orders: click the 3rd button container's button (increment)
                const targetContainer = buttonContainers[2];
                const button = targetContainer.querySelector('div button');
                if (button) {
                    button.click();
                }
            } else if (isSellOrder) {
                // For sell orders: check user setting
                const sellStrategy = config$1.getSettingValue('market_autoFillSellStrategy', 'match');

                if (sellStrategy === 'undercut') {
                    // Click the 2nd button container's button (decrement)
                    const targetContainer = buttonContainers[1];
                    const button = targetContainer.querySelector('div button');
                    if (button) {
                        button.click();
                    }
                }
                // If 'match', do nothing (use best sell price as-is)
            }
        }

        /**
         * Cleanup on disable
         */
        disable() {
            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];
            this.timerRegistry.clearAll();
            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const autoFillPrice = new AutoFillPrice();

    /**
     * Auto-Click Max Button
     * Automatically clicks the "Max" button in market listing dialogs
     */


    class AutoClickMax {
        constructor() {
            this.isActive = false;
            this.unregisterHandlers = [];
            this.processedModals = new WeakSet();
            this.isInitialized = false;
        }

        /**
         * Initialize the auto-click max feature
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.isFeatureEnabled('market_autoClickMax')) {
                return;
            }

            this.isActive = true;
            this.registerDOMObservers();
            this.isInitialized = true;
        }

        /**
         * Register DOM observers to watch for market listing modals
         */
        registerDOMObservers() {
            const unregister = domObserver$1.onClass('auto-click-max', 'Modal_modalContainer', (modal) => {
                this.handleOrderModal(modal);
            });
            this.unregisterHandlers.push(unregister);
        }

        /**
         * Handle market order modal appearance
         * @param {HTMLElement} modal - Modal container element
         */
        handleOrderModal(modal) {
            if (!this.isActive || !modal || this.processedModals.has(modal)) {
                return;
            }

            // Check if this is a Buy/Sell listing modal (not Instant Buy/Sell)
            const header = modal.querySelector('div[class*="MarketplacePanel_header"]');
            if (!header) {
                return;
            }

            const headerText = header.textContent;

            // Skip Instant Buy/Sell modals (they don't have Max button for quantity)
            if (headerText.includes('Now')) {
                return;
            }

            // Only process Buy Listing or Sell Listing modals
            if (!headerText.includes('Listing')) {
                return;
            }

            // Determine if this is a sell order by checking header text
            // Only auto-click Max for sell orders (not buy orders)
            const isSellOrder = headerText.includes('Sell Listing');

            if (!isSellOrder) {
                return; // Skip buy orders
            }

            // Mark as processed
            this.processedModals.add(modal);

            // Click the Max button
            this.findAndClickMaxButton(modal);
        }

        /**
         * Find and click the Max button in the modal
         * @param {HTMLElement} modal - Modal container element
         */
        findAndClickMaxButton(modal) {
            if (!modal) {
                return;
            }

            // Strategy 1: Find Max button by text content
            const allButtons = modal.querySelectorAll('button');
            const maxButton = Array.from(allButtons).find((btn) => {
                const text = btn.textContent.trim();
                return text === 'Max';
            });

            if (!maxButton) {
                return;
            }

            // Don't click if button is disabled
            if (maxButton.disabled) {
                return;
            }

            // Click the Max button
            try {
                maxButton.click();
            } catch (error) {
                console.error('[AutoClickMax] Failed to click Max button:', error);
            }
        }

        /**
         * Disable and cleanup
         */
        disable() {
            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];
            this.processedModals = new WeakSet();
            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const autoClickMax = new AutoClickMax();

    /**
     * Market Item Count Display Module
     *
     * Shows inventory count on market item tiles
     * Ported from Ranged Way Idle's visibleItemCountMarket feature
     */


    class ItemCountDisplay {
        constructor() {
            this.unregisterObserver = null;
            this.isInitialized = false;
        }

        /**
         * Initialize the item count display
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('market_visibleItemCount')) {
                return;
            }

            this.isInitialized = true;
            this.setupObserver();
        }

        /**
         * Setup DOM observer to watch for market panels
         */
        setupObserver() {
            // Watch for market items container
            this.unregisterObserver = domObserver$1.onClass(
                'ItemCountDisplay',
                'MarketplacePanel_marketItems',
                (marketContainer) => {
                    this.updateItemCounts(marketContainer);
                }
            );

            // Check for existing market container
            const existingContainer = document.querySelector('[class*="MarketplacePanel_marketItems"]');
            if (existingContainer) {
                this.updateItemCounts(existingContainer);
            }
        }

        /**
         * Update item counts for all items in market container
         * @param {HTMLElement} marketContainer - The market items container
         */
        updateItemCounts(marketContainer) {
            // Build item count map from inventory
            const itemCountMap = this.buildItemCountMap();

            // Find all clickable item tiles
            const itemTiles = marketContainer.querySelectorAll('[class*="Item_clickable"]');

            for (const itemTile of itemTiles) {
                this.updateSingleItem(itemTile, itemCountMap);
            }
        }

        /**
         * Build a map of itemHrid → count from inventory
         * @returns {Object} Map of item HRIDs to counts
         */
        buildItemCountMap() {
            const itemCountMap = {};
            const inventory = dataManager$1.getInventory();
            const includeEquipped = config$1.getSetting('market_visibleItemCountIncludeEquipped');

            if (!inventory) {
                return itemCountMap;
            }

            // Count inventory items (sum across all enhancement levels)
            for (const item of inventory) {
                if (!item.itemHrid) continue;
                itemCountMap[item.itemHrid] = (itemCountMap[item.itemHrid] || 0) + (item.count || 0);
            }

            // Optionally include equipped items
            if (includeEquipped) {
                const equipment = dataManager$1.getEquipment();
                if (equipment) {
                    for (const slot of Object.values(equipment)) {
                        if (slot && slot.itemHrid) {
                            itemCountMap[slot.itemHrid] = (itemCountMap[slot.itemHrid] || 0) + 1;
                        }
                    }
                }
            }

            return itemCountMap;
        }

        /**
         * Update a single item tile with count
         * @param {HTMLElement} itemTile - The item tile element
         * @param {Object} itemCountMap - Map of item HRIDs to counts
         */
        updateSingleItem(itemTile, itemCountMap) {
            // Extract item HRID from SVG use element
            const useElement = itemTile.querySelector('use');
            if (!useElement || !useElement.href || !useElement.href.baseVal) {
                return;
            }

            // Extract item ID from href (e.g., "#iron_bar" -> "iron_bar")
            const itemId = useElement.href.baseVal.split('#')[1];
            if (!itemId) {
                return;
            }

            const itemHrid = `/items/${itemId}`;
            const itemCount = itemCountMap[itemHrid] || 0;

            // Find or create count display element
            let countDiv = itemTile.querySelector('.mwi-item-count');
            if (!countDiv) {
                countDiv = document.createElement('div');
                countDiv.className = 'mwi-item-count';
                itemTile.appendChild(countDiv);

                // Set positioning (only on first creation)
                itemTile.style.position = 'relative';
                countDiv.style.position = 'absolute';
                countDiv.style.bottom = '-1px';
                countDiv.style.right = '2px';
                countDiv.style.textAlign = 'right';
                countDiv.style.fontSize = '0.85em';
                countDiv.style.fontWeight = 'bold';
                countDiv.style.pointerEvents = 'none';
            }

            // Get opacity setting (use getSettingValue for non-boolean settings)
            const opacity = config$1.getSettingValue('market_visibleItemCountOpacity', 0.25);

            // Update display based on count
            if (itemCount === 0) {
                // No items: dim the tile, hide the count text
                itemTile.style.opacity = opacity.toString();
                countDiv.textContent = '';
            } else {
                // Has items: full opacity, show count
                itemTile.style.opacity = '1.0';
                countDiv.textContent = itemCount.toString();
            }
        }

        /**
         * Disable the item count display
         */
        disable() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            // Remove all injected count displays and reset opacity
            document.querySelectorAll('.mwi-item-count').forEach((el) => el.remove());
            document.querySelectorAll('[class*="Item_clickable"]').forEach((tile) => {
                tile.style.opacity = '1.0';
            });

            this.isInitialized = false;
        }
    }

    const itemCountDisplay = new ItemCountDisplay();

    /**
     * Estimated Listing Age Module
     *
     * Estimates creation times for all market listings using listing ID interpolation
     * - Collects known listing IDs with timestamps (from your own listings)
     * - Uses linear interpolation/regression to estimate ages for unknown listings
     * - Displays estimated ages on the main Market Listings (order book) tab
     */


    class EstimatedListingAge {
        constructor() {
            this.knownListings = []; // Array of {id, timestamp, createdTimestamp, enhancementLevel, ...} sorted by id
            this.orderBooksCache = {}; // Cache of order book data from WebSocket
            this.currentItemHrid = null; // Track current item from WebSocket
            this.unregisterWebSocket = null;
            this.unregisterObserver = null;
            this.storageKey = 'marketListingTimestamps';
            this.orderBooksCacheKey = 'marketOrderBooksCache';
            this.isInitialized = false;
        }

        /**
         * Format timestamp based on user settings
         * @param {number} timestamp - Timestamp in milliseconds
         * @returns {string} Formatted time string
         */
        formatTimestamp(timestamp) {
            const ageFormat = config$1.getSettingValue('market_listingAgeFormat', 'datetime');

            if (ageFormat === 'elapsed') {
                // Show elapsed time (e.g., "3h 45m")
                const ageMs = Date.now() - timestamp;
                return formatRelativeTime(ageMs);
            } else {
                // Show date/time (e.g., "01-13 14:30:45" or "01-13 2:30:45 PM")
                const timeFormat = config$1.getSettingValue('market_listingTimeFormat', '24hour');
                const dateFormat = config$1.getSettingValue('market_listingDateFormat', 'MM-DD');
                const use12Hour = timeFormat === '12hour';

                const date = new Date(timestamp);
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const datePart = dateFormat === 'DD-MM' ? `${day}-${month}` : `${month}-${day}`;

                const timePart = date
                    .toLocaleString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: use12Hour,
                    })
                    .trim();

                return `${datePart} ${timePart}`;
            }
        }

        /**
         * Initialize the estimated listing age feature
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('market_showEstimatedListingAge')) {
                return;
            }

            this.isInitialized = true;

            // Load historical data from storage
            await this.loadHistoricalData();

            // Load cached order books from storage
            await this.loadOrderBooksCache();

            // Load initial listings from dataManager
            this.loadInitialListings();

            // Setup WebSocket listeners to collect your listing IDs
            this.setupWebSocketListeners();

            // Setup DOM observer for order book table
            this.setupObserver();
        }

        /**
         * Load initial listings from dataManager (already received via init_character_data)
         */
        loadInitialListings() {
            const listings = dataManager$1.getMarketListings();

            for (const listing of listings) {
                if (listing.id && listing.createdTimestamp) {
                    this.recordListing(listing);
                }
            }
        }

        /**
         * Load historical listing data from IndexedDB
         */
        async loadHistoricalData() {
            try {
                const stored = await storage$1.getJSON(this.storageKey, 'marketListings', []);

                // Load all historical data (no time-based filtering)
                this.knownListings = stored.sort((a, b) => a.id - b.id);

                // Add hardcoded seed listings for baseline estimation accuracy
                // These are anchor points from RWI script author's data
                const seedListings = [
                    { id: 106442952, timestamp: 1763409373481 },
                    { id: 106791533, timestamp: 1763541486867 },
                    { id: 107530218, timestamp: 1763842767083 },
                    { id: 107640371, timestamp: 1763890560819 },
                    { id: 107678558, timestamp: 1763904036320 },
                ];

                // Add seeds only if they don't already exist in stored data
                for (const seed of seedListings) {
                    if (!this.knownListings.find((l) => l.id === seed.id)) {
                        this.knownListings.push(seed);
                    }
                }

                // Re-sort after adding seeds
                this.knownListings.sort((a, b) => a.id - b.id);
            } catch (error) {
                console.error('[EstimatedListingAge] Failed to load historical data:', error);
                this.knownListings = [];
            }
        }

        /**
         * Load cached order books from IndexedDB
         */
        async loadOrderBooksCache() {
            try {
                const stored = await storage$1.getJSON(this.orderBooksCacheKey, 'marketListings', {});
                this.orderBooksCache = stored || {};
            } catch (error) {
                console.error('[EstimatedListingAge] Failed to load order books cache:', error);
                this.orderBooksCache = {};
            }
        }

        /**
         * Save listing data to IndexedDB
         */
        async saveHistoricalData() {
            try {
                await storage$1.setJSON(this.storageKey, this.knownListings, 'marketListings', true);
            } catch (error) {
                console.error('[EstimatedListingAge] Failed to save historical data:', error);
            }
        }

        /**
         * Save order books cache to IndexedDB
         */
        async saveOrderBooksCache() {
            try {
                await storage$1.setJSON(this.orderBooksCacheKey, this.orderBooksCache, 'marketListings', true);
            } catch (error) {
                console.error('[EstimatedListingAge] Failed to save order books cache:', error);
            }
        }

        /**
         * Setup WebSocket listeners to collect your listing IDs and order book data
         */
        setupWebSocketListeners() {
            // Handle initial character data
            const initHandler = (data) => {
                if (data.myMarketListings) {
                    for (const listing of data.myMarketListings) {
                        this.recordListing(listing);
                    }
                }
            };

            // Handle listing updates
            const updateHandler = (data) => {
                if (data.endMarketListings) {
                    for (const listing of data.endMarketListings) {
                        this.recordListing(listing);
                    }
                }
            };

            // Handle order book updates (contains listing IDs for ALL listings)
            const orderBookHandler = (data) => {
                if (data.marketItemOrderBooks) {
                    const itemHrid = data.marketItemOrderBooks.itemHrid;

                    // Store with timestamp for staleness tracking
                    this.orderBooksCache[itemHrid] = {
                        data: data.marketItemOrderBooks,
                        lastUpdated: Date.now(),
                    };

                    this.currentItemHrid = itemHrid; // Track current item

                    // Save to storage (debounced)
                    this.saveOrderBooksCache();

                    // Clear processed flags to re-render with new data
                    const containers = document.querySelectorAll('.mwi-estimated-age-set');
                    containers.forEach((container) => {
                        container.classList.remove('mwi-estimated-age-set');
                    });

                    // Also clear listing price display flags so Top Order Age updates
                    document.querySelectorAll('.mwi-listing-prices-set').forEach((table) => {
                        table.classList.remove('mwi-listing-prices-set');
                    });

                    // Manually re-process any existing containers (handles race condition where
                    // container appeared before WebSocket data arrived)
                    const existingContainers = document.querySelectorAll('[class*="MarketplacePanel_orderBooksContainer"]');
                    existingContainers.forEach((container) => {
                        this.processOrderBook(container);
                    });
                }
            };

            dataManager$1.on('character_initialized', initHandler);
            dataManager$1.on('market_listings_updated', updateHandler);
            dataManager$1.on('market_item_order_books_updated', orderBookHandler);

            // Store for cleanup
            this.unregisterWebSocket = () => {
                dataManager$1.off('character_initialized', initHandler);
                dataManager$1.off('market_listings_updated', updateHandler);
                dataManager$1.off('market_item_order_books_updated', orderBookHandler);
            };
        }

        /**
         * Record a listing with its full data
         * @param {Object} listing - Full listing object from WebSocket
         */
        recordListing(listing) {
            if (!listing.createdTimestamp) {
                return;
            }

            const timestamp = new Date(listing.createdTimestamp).getTime();

            // Check if we already have this listing
            const existingIndex = this.knownListings.findIndex((entry) => entry.id === listing.id);

            // Add new entry with full data
            const entry = {
                id: listing.id,
                timestamp: timestamp,
                createdTimestamp: listing.createdTimestamp, // ISO string for display
                itemHrid: listing.itemHrid,
                enhancementLevel: listing.enhancementLevel || 0, // For accurate row matching
                price: listing.price,
                orderQuantity: listing.orderQuantity,
                filledQuantity: listing.filledQuantity,
                isSell: listing.isSell,
            };

            if (existingIndex !== -1) {
                // Update existing entry (in case it had incomplete data)
                this.knownListings[existingIndex] = entry;
            } else {
                // Add new entry
                this.knownListings.push(entry);
            }

            // Re-sort by ID
            this.knownListings.sort((a, b) => a.id - b.id);

            // Save to storage (debounced)
            this.saveHistoricalData();
        }

        /**
         * Setup DOM observer to watch for order book table
         */
        setupObserver() {
            // Observe the main order book container
            this.unregisterObserver = domObserver$1.onClass(
                'EstimatedListingAge',
                'MarketplacePanel_orderBooksContainer',
                (container) => {
                    this.processOrderBook(container);
                }
            );
        }

        /**
         * Process the order book container and inject age estimates
         * @param {HTMLElement} container - Order book container
         */
        processOrderBook(container) {
            if (container.classList.contains('mwi-estimated-age-set')) {
                return;
            }

            // Find the buy and sell tables
            const tables = container.querySelectorAll('table');

            if (tables.length < 2) {
                return; // Need both buy and sell tables
            }

            // Mark as processed
            container.classList.add('mwi-estimated-age-set');

            // Process both tables
            tables.forEach((table) => {
                this.addAgeColumn(table);
            });
        }

        /**
         * Add estimated age column to order book table
         * @param {HTMLElement} table - Order book table
         */
        addAgeColumn(table) {
            const thead = table.querySelector('thead tr');
            const tbody = table.querySelector('tbody');

            if (!thead || !tbody) {
                return;
            }

            // Remove existing age column elements if they exist (RWI pattern)
            thead.querySelectorAll('.mwi-estimated-age-header').forEach((el) => el.remove());
            tbody.querySelectorAll('.mwi-estimated-age-cell').forEach((el) => el.remove());

            // Get current item and order book data
            const currentItemHrid = this.getCurrentItemHrid();

            if (!currentItemHrid || !this.orderBooksCache[currentItemHrid]) {
                return;
            }

            const cacheEntry = this.orderBooksCache[currentItemHrid];
            // Support both old format (direct data) and new format ({data, lastUpdated})
            const orderBookData = cacheEntry.data || cacheEntry;

            // Get current enhancement level being viewed
            const enhancementLevel = this.getCurrentEnhancementLevel();

            // Determine if this is buy or sell table (asks = sell, bids = buy)
            const isSellTable =
                table.closest('[class*="orderBookTableContainer"]') ===
                table.closest('[class*="orderBooksContainer"]')?.children[0];

            // Access orderBooks by enhancement level (orderBooks is an object, not array)
            // For non-equipment items, only level 0 exists
            // For equipment, there can be orderBooks[0], orderBooks[1], etc.
            const orderBookAtLevel = orderBookData.orderBooks?.[enhancementLevel];

            if (!orderBookAtLevel) {
                // No order book data for this enhancement level
                return;
            }

            const listings = isSellTable ? orderBookAtLevel.asks || [] : orderBookAtLevel.bids || [];

            // Add header
            const header = document.createElement('th');
            header.classList.add('mwi-estimated-age-header');
            header.textContent = '~Age';
            header.title = 'Estimated listing age (based on listing ID)';
            thead.appendChild(header);

            // Track which of user's listings have been matched to prevent duplicates
            const usedListingIds = new Set();

            // Add age cells to each row
            const rows = tbody.querySelectorAll('tr');
            let index = 0;

            rows.forEach((row) => {
                const cell = document.createElement('td');
                cell.classList.add('mwi-estimated-age-cell');

                if (index < listings.length) {
                    // Top 20 listings from order book (use positional indexing like RWI)
                    const listing = listings[index];
                    const listingId = listing.listingId;

                    // Check if this is YOUR listing (and not already matched)
                    const yourListing = this.knownListings.find(
                        (known) => known.id === listingId && !usedListingIds.has(known.id)
                    );

                    if (yourListing) {
                        // Mark this listing as used
                        usedListingIds.add(yourListing.id);

                        // Exact timestamp for your listing
                        const formatted = this.formatTimestamp(yourListing.timestamp);
                        cell.textContent = formatted; // No tilde for exact timestamps
                        cell.style.color = '#00FF00'; // Green for YOUR listing
                        cell.style.fontSize = '0.9em';
                    } else {
                        // Estimated timestamp for other listings
                        const estimatedTimestamp = this.estimateTimestamp(listingId);
                        const formatted = this.formatTimestamp(estimatedTimestamp);
                        cell.textContent = `~${formatted}`;
                        cell.style.color = '#999999'; // Gray to indicate estimate
                        cell.style.fontSize = '0.9em';
                    }
                } else if (index === listings.length) {
                    // Ellipsis row
                    cell.textContent = '· · ·';
                    cell.style.color = '#666666';
                    cell.style.fontSize = '0.9em';
                } else {
                    // Beyond top 20 - YOUR listings only
                    const hasCancel = row.textContent.includes('Cancel');
                    if (hasCancel) {
                        // Extract price and quantity for matching
                        const priceText = row.querySelector('[class*="price"]')?.textContent || '';
                        const quantityText = row.children[0]?.textContent || '';
                        const price = this.parsePrice(priceText);
                        const quantity = this.parseQuantity(quantityText);

                        // Match from knownListings (filtering out already-used and top-20 listings)
                        const allOrderBookIds = new Set(listings.map((l) => l.listingId));
                        const matchedListing = this.knownListings.find((listing) => {
                            if (usedListingIds.has(listing.id)) return false;
                            if (allOrderBookIds.has(listing.id)) return false; // Skip top 20

                            const itemMatch = listing.itemHrid === currentItemHrid;
                            const priceMatch = Math.abs(listing.price - price) < 0.01;
                            const qtyMatch = listing.orderQuantity - listing.filledQuantity === quantity;
                            return itemMatch && priceMatch && qtyMatch;
                        });

                        if (matchedListing) {
                            usedListingIds.add(matchedListing.id);
                            const formatted = this.formatTimestamp(matchedListing.timestamp);
                            cell.textContent = formatted;
                            cell.style.color = '#00FF00'; // Green for YOUR listing
                            cell.style.fontSize = '0.9em';
                        } else {
                            cell.textContent = '~Unknown';
                            cell.style.color = '#666666';
                            cell.style.fontSize = '0.9em';
                        }
                    } else {
                        cell.textContent = '· · ·';
                        cell.style.color = '#666666';
                        cell.style.fontSize = '0.9em';
                    }
                }

                row.appendChild(cell);
                index++;
            });
        }

        /**
         * Get current item HRID being viewed in order book
         * @returns {string|null} Item HRID or null
         */
        getCurrentItemHrid() {
            // PRIMARY: Check for current item element (same as RWI approach)
            const currentItemElement = document.querySelector('.MarketplacePanel_currentItem__3ercC');
            if (currentItemElement) {
                const useElement = currentItemElement.querySelector('use');
                if (useElement && useElement.href && useElement.href.baseVal) {
                    const itemHrid = '/items/' + useElement.href.baseVal.split('#')[1];
                    return itemHrid;
                }
            }

            // SECONDARY: Use WebSocket tracked item
            if (this.currentItemHrid) {
                return this.currentItemHrid;
            }

            // TERTIARY: Try to find from YOUR listings in the order book
            const orderBookContainer = document.querySelector('[class*="MarketplacePanel_orderBooksContainer"]');
            if (!orderBookContainer) {
                return null;
            }

            const tables = orderBookContainer.querySelectorAll('table');
            for (const table of tables) {
                const rows = table.querySelectorAll('tbody tr');
                for (const row of rows) {
                    const hasCancel = row.textContent.includes('Cancel');
                    if (hasCancel) {
                        const priceText = row.querySelector('[class*="price"]')?.textContent || '';
                        const quantityText = row.children[0]?.textContent || '';

                        const price = this.parsePrice(priceText);
                        const quantity = this.parseQuantity(quantityText);

                        // Find matching listing from YOUR listings
                        const matchedListing = this.knownListings.find((listing) => {
                            const priceMatch = Math.abs(listing.price - price) < 0.01;
                            const qtyMatch = listing.orderQuantity - listing.filledQuantity === quantity;
                            return priceMatch && qtyMatch;
                        });

                        if (matchedListing) {
                            return matchedListing.itemHrid;
                        }
                    }
                }
            }

            return null;
        }

        /**
         * Get current enhancement level being viewed in order book
         * @returns {number} Enhancement level (0 for non-equipment)
         */
        getCurrentEnhancementLevel() {
            // Check for enhancement level indicator in the current item display
            const currentItemElement = document.querySelector('.MarketplacePanel_currentItem__3ercC');
            if (currentItemElement) {
                const enhancementElement = currentItemElement.querySelector('[class*="Item_enhancementLevel"]');
                if (enhancementElement) {
                    const match = enhancementElement.textContent.match(/\+(\d+)/);
                    if (match) {
                        return parseInt(match[1], 10);
                    }
                }
            }

            // Default to enhancement level 0 (non-equipment or base equipment)
            return 0;
        }

        /**
         * Parse price from text (handles K/M suffixes)
         * @param {string} text - Price text
         * @returns {number} Price value
         */
        parsePrice(text) {
            let multiplier = 1;
            if (text.toUpperCase().includes('K')) {
                multiplier = 1000;
                text = text.replace(/K/gi, '');
            } else if (text.toUpperCase().includes('M')) {
                multiplier = 1000000;
                text = text.replace(/M/gi, '');
            }
            const numStr = text.replace(/[^0-9.]/g, '');
            return numStr ? Number(numStr) * multiplier : 0;
        }

        /**
         * Parse quantity from text (handles K/M suffixes)
         * @param {string} text - Quantity text
         * @returns {number} Quantity value
         */
        parseQuantity(text) {
            let multiplier = 1;
            if (text.toUpperCase().includes('K')) {
                multiplier = 1000;
                text = text.replace(/K/gi, '');
            } else if (text.toUpperCase().includes('M')) {
                multiplier = 1000000;
                text = text.replace(/M/gi, '');
            }
            const numStr = text.replace(/[^0-9.]/g, '');
            return numStr ? Number(numStr) * multiplier : 0;
        }

        /**
         * Get color based on data staleness
         * @param {number} lastUpdated - Timestamp when data was last updated
         * @returns {string} Color code for display
         */
        getStalenessColor(lastUpdated) {
            if (!lastUpdated) {
                return '#999999'; // Gray for unknown age
            }

            const age = Date.now() - lastUpdated;
            const minutes = age / (60 * 1000);
            const hours = age / (60 * 60 * 1000);

            if (minutes < 15) return '#00AA00'; // < 15 min: dark green (fresh)
            if (hours < 1) return '#00FF00'; // < 1 hour: light green (recent)
            if (hours < 4) return '#FFAA00'; // < 4 hours: yellow (moderate)
            if (hours < 12) return '#FF6600'; // < 12 hours: orange (stale)
            return '#FF0000'; // 12+ hours: red (very stale)
        }

        /**
         * Get tooltip text for staleness
         * @param {number} lastUpdated - Timestamp when data was last updated
         * @returns {string} Tooltip text
         */
        getStalenessTooltip(lastUpdated) {
            if (!lastUpdated) {
                return 'Order book data - Visit market page to refresh';
            }

            const age = Date.now() - lastUpdated;
            const relativeTime = formatRelativeTime(age);
            return `Order book data from ${relativeTime} ago - Visit market page to refresh`;
        }

        /**
         * Estimate timestamp for a listing ID
         * @param {number} listingId - Listing ID to estimate
         * @returns {number} Estimated timestamp in milliseconds
         */
        estimateTimestamp(listingId) {
            if (this.knownListings.length === 0) {
                // No data, assume recent (1 hour ago)
                return Date.now() - 60 * 60 * 1000;
            }

            if (this.knownListings.length === 1) {
                // Only one data point, use it
                return this.knownListings[0].timestamp;
            }

            const minId = this.knownListings[0].id;
            const maxId = this.knownListings[this.knownListings.length - 1].id;

            let estimate;
            // Check if ID is within known range
            if (listingId >= minId && listingId <= maxId) {
                estimate = this.linearInterpolation(listingId);
            } else {
                estimate = this.linearRegression(listingId);
            }

            // CRITICAL: Clamp to reasonable bounds
            const now = Date.now();

            // Never allow future timestamps (listings cannot be created in the future)
            if (estimate > now) {
                estimate = now;
            }

            return estimate;
        }

        /**
         * Linear interpolation for IDs within known range
         * @param {number} listingId - Listing ID
         * @returns {number} Estimated timestamp
         */
        linearInterpolation(listingId) {
            // Check for exact match
            const exact = this.knownListings.find((entry) => entry.id === listingId);
            if (exact) {
                return exact.timestamp;
            }

            // Find surrounding points
            let leftIndex = 0;
            let rightIndex = this.knownListings.length - 1;

            for (let i = 0; i < this.knownListings.length - 1; i++) {
                if (listingId >= this.knownListings[i].id && listingId <= this.knownListings[i + 1].id) {
                    leftIndex = i;
                    rightIndex = i + 1;
                    break;
                }
            }

            const left = this.knownListings[leftIndex];
            const right = this.knownListings[rightIndex];

            // Linear interpolation formula
            const idRange = right.id - left.id;
            const idOffset = listingId - left.id;
            const ratio = idOffset / idRange;

            return left.timestamp + ratio * (right.timestamp - left.timestamp);
        }

        /**
         * Linear regression for IDs outside known range
         * @param {number} listingId - Listing ID
         * @returns {number} Estimated timestamp
         */
        linearRegression(listingId) {
            // Calculate linear regression slope
            let sumX = 0,
                sumY = 0;
            for (const entry of this.knownListings) {
                sumX += entry.id;
                sumY += entry.timestamp;
            }

            const n = this.knownListings.length;
            const meanX = sumX / n;
            const meanY = sumY / n;

            let numerator = 0;
            let denominator = 0;
            for (const entry of this.knownListings) {
                numerator += (entry.id - meanX) * (entry.timestamp - meanY);
                denominator += (entry.id - meanX) * (entry.id - meanX);
            }

            const slope = numerator / denominator;

            // Get boundary points
            const minId = this.knownListings[0].id;
            const maxId = this.knownListings[this.knownListings.length - 1].id;
            const minTimestamp = this.knownListings[0].timestamp;
            const maxTimestamp = this.knownListings[this.knownListings.length - 1].timestamp;

            // Extrapolate from closest boundary (RWI approach)
            // This prevents drift from large intercept values
            if (listingId > maxId) {
                return slope * (listingId - maxId) + maxTimestamp;
            } else {
                return slope * (listingId - minId) + minTimestamp;
            }
        }

        /**
         * Clear all injected displays
         */
        clearDisplays() {
            document.querySelectorAll('.mwi-estimated-age-set').forEach((container) => {
                container.classList.remove('mwi-estimated-age-set');
            });
            document.querySelectorAll('.mwi-estimated-age-header').forEach((el) => el.remove());
            document.querySelectorAll('.mwi-estimated-age-cell').forEach((el) => el.remove());
        }

        /**
         * Disable the estimated listing age feature
         */
        disable() {
            if (this.unregisterWebSocket) {
                this.unregisterWebSocket();
                this.unregisterWebSocket = null;
            }

            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            this.clearDisplays();
            this.isInitialized = false;
        }
    }

    const estimatedListingAge = new EstimatedListingAge();

    /**
     * Market Listing Price Display Module
     *
     * Shows pricing information on individual market listings
     * - Top Order Price: Current best market price with competitive color coding
     * - Total Price: Total remaining value of the listing
     * Ported from Ranged Way Idle's showListingInfo feature
     */


    class ListingPriceDisplay {
        constructor() {
            this.allListings = {}; // Maintained listing state
            this.unregisterWebSocket = null;
            this.unregisterObserver = null;
            this.isInitialized = false;
            this.cleanupRegistry = createCleanupRegistry();
            this.activeRefreshes = new WeakSet(); // Track tables being refreshed (debouncing)
            this.tbodyObservers = new WeakMap(); // Track MutationObservers per tbody
        }

        /**
         * Initialize the listing price display
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('market_showListingPrices')) {
                return;
            }

            this.isInitialized = true;

            // Load initial listings from dataManager
            this.loadInitialListings();

            this.setupWebSocketListeners();
            this.setupObserver();
        }

        /**
         * Load initial listings from dataManager (already received via init_character_data)
         */
        loadInitialListings() {
            const listings = dataManager$1.getMarketListings();

            for (const listing of listings) {
                this.handleListing(listing);
            }
        }

        /**
         * Setup WebSocket listeners for listing updates
         */
        setupWebSocketListeners() {
            // Handle initial character data
            const initHandler = (data) => {
                if (data.myMarketListings) {
                    for (const listing of data.myMarketListings) {
                        this.handleListing(listing);
                    }
                }
            };

            // Handle listing updates
            const updateHandler = (data) => {
                if (data.endMarketListings) {
                    for (const listing of data.endMarketListings) {
                        this.handleListing(listing);
                    }
                    // Clear existing displays to force refresh
                    this.clearDisplays();

                    // Wait for React to update DOM before re-processing
                    // (DOM observer won't fire because table element didn't appear/disappear)
                    const visibleTable = document.querySelector('[class*="MarketplacePanel_myListingsTable"]');
                    if (visibleTable) {
                        this.scheduleTableRefresh(visibleTable);
                    }
                }
            };

            dataManager$1.on('character_initialized', initHandler);
            dataManager$1.on('market_listings_updated', updateHandler);

            // Handle order book updates to re-render with populated cache (if Top Order Age enabled)
            let orderBookHandler = null;
            if (config$1.getSetting('market_showTopOrderAge')) {
                orderBookHandler = (data) => {
                    if (data.marketItemOrderBooks) {
                        // Delay re-render to let estimatedListingAge populate cache first (race condition)
                        setTimeout(() => {
                            document.querySelectorAll('[class*="MarketplacePanel_myListingsTable"]').forEach((table) => {
                                table.classList.remove('mwi-listing-prices-set');
                                this.updateTable(table);
                            });
                        }, 10);
                    }
                };
                dataManager$1.on('market_item_order_books_updated', orderBookHandler);
            }

            // Store for cleanup
            this.unregisterWebSocket = () => {
                dataManager$1.off('character_initialized', initHandler);
                dataManager$1.off('market_listings_updated', updateHandler);
                if (orderBookHandler) {
                    dataManager$1.off('market_item_order_books_updated', orderBookHandler);
                }
            };

            this.cleanupRegistry.registerCleanup(() => {
                if (this.unregisterWebSocket) {
                    this.unregisterWebSocket();
                    this.unregisterWebSocket = null;
                }
            });
        }

        /**
         * Setup DOM observer to watch for My Listings table
         */
        setupObserver() {
            this.unregisterObserver = domObserver$1.onClass(
                'ListingPriceDisplay',
                'MarketplacePanel_myListingsTable',
                (tableNode) => {
                    this.scheduleTableRefresh(tableNode);
                }
            );

            this.cleanupRegistry.registerCleanup(() => {
                if (this.unregisterObserver) {
                    this.unregisterObserver();
                    this.unregisterObserver = null;
                }
            });

            // Check for existing table
            const existingTable = document.querySelector('[class*="MarketplacePanel_myListingsTable"]');
            if (existingTable) {
                this.scheduleTableRefresh(existingTable);
            }
        }

        /**
         * Schedule a refresh to wait for React to populate table rows
         * Uses MutationObserver to detect when rows are added instead of polling
         * @param {HTMLElement} tableNode - The listings table element
         */
        scheduleTableRefresh(tableNode) {
            // Debouncing: prevent multiple concurrent refreshes on same table
            if (this.activeRefreshes.has(tableNode)) {
                return;
            }

            const tbody = tableNode.querySelector('tbody');
            if (!tbody) {
                return;
            }

            this.activeRefreshes.add(tableNode);

            // Check if we should process immediately (rows already match)
            const rowCount = tbody.querySelectorAll('tr').length;
            const listingCount = Object.keys(this.allListings).length;

            if (rowCount === listingCount && rowCount > 0) {
                this.updateTable(tableNode);
                this.activeRefreshes.delete(tableNode);
                return;
            }

            // Otherwise, watch for row additions using MutationObserver
            let observer = this.tbodyObservers.get(tbody);

            if (!observer) {
                observer = new MutationObserver(() => {
                    const currentRowCount = tbody.querySelectorAll('tr').length;
                    const currentListingCount = Object.keys(this.allListings).length;

                    if (currentRowCount === currentListingCount && currentRowCount > 0) {
                        // Rows match - process the table
                        this.updateTable(tableNode);
                        this.activeRefreshes.delete(tableNode);

                        // Disconnect observer until next refresh
                        observer.disconnect();
                    }
                });

                this.tbodyObservers.set(tbody, observer);

                this.cleanupRegistry.registerCleanup(() => {
                    observer.disconnect();
                    this.tbodyObservers.delete(tbody);
                });
            }

            // Start observing for row additions
            observer.observe(tbody, {
                childList: true,
                subtree: false,
            });

            // Safety timeout: if rows never match after 3 seconds, give up and process anyway
            const safetyTimeoutId = setTimeout(() => {
                observer.disconnect();
                this.activeRefreshes.delete(tableNode);

                // Process with whatever rows are available
                if (tbody.querySelectorAll('tr').length > 0) {
                    this.updateTable(tableNode);
                }
            }, 3000);

            this.cleanupRegistry.registerTimeout(safetyTimeoutId);
        }

        /**
         * Handle listing data from WebSocket
         * @param {Object} listing - Listing data
         */
        handleListing(listing) {
            // Filter out cancelled and fully claimed listings
            if (
                listing.status === '/market_listing_status/cancelled' ||
                (listing.status === '/market_listing_status/filled' &&
                    listing.unclaimedItemCount === 0 &&
                    listing.unclaimedCoinCount === 0)
            ) {
                delete this.allListings[listing.id];
                return;
            }

            // Store/update listing data
            this.allListings[listing.id] = {
                id: listing.id,
                isSell: listing.isSell,
                itemHrid: listing.itemHrid,
                enhancementLevel: listing.enhancementLevel,
                orderQuantity: listing.orderQuantity,
                filledQuantity: listing.filledQuantity,
                price: listing.price,
                createdTimestamp: listing.createdTimestamp,
                unclaimedCoinCount: listing.unclaimedCoinCount || 0,
                unclaimedItemCount: listing.unclaimedItemCount || 0,
            };
        }

        /**
         * Update the My Listings table with pricing columns
         * @param {HTMLElement} tableNode - The listings table element
         */
        updateTable(tableNode) {
            if (tableNode.classList.contains('mwi-listing-prices-set')) {
                return;
            }

            // Clear any existing price displays from this table before re-rendering
            tableNode.querySelectorAll('.mwi-listing-price-header').forEach((el) => el.remove());
            tableNode.querySelectorAll('.mwi-listing-price-cell').forEach((el) => el.remove());

            // Wait until row count matches listing count
            const tbody = tableNode.querySelector('tbody');
            if (!tbody) {
                return;
            }

            const rowCount = tbody.querySelectorAll('tr').length;
            const listingCount = Object.keys(this.allListings).length;

            if (rowCount !== listingCount) {
                return; // Table not fully populated yet
            }

            // OPTIMIZATION: Pre-fetch all market prices in one batch
            const itemsToPrice = Object.values(this.allListings).map((listing) => ({
                itemHrid: listing.itemHrid,
                enhancementLevel: listing.enhancementLevel,
            }));
            const priceCache = marketAPI.getPricesBatch(itemsToPrice);

            // Add table headers
            this.addTableHeaders(tableNode);

            // Add data to rows
            this.addDataToRows(tbody);

            // Add price displays to each row
            this.addPriceDisplays(tbody, priceCache);

            // Check if we should mark as fully processed
            let fullyProcessed = true;

            if (config$1.getSetting('market_showTopOrderAge')) {
                // Only mark as processed if cache has data for all listings
                for (const listing of Object.values(this.allListings)) {
                    const orderBookData = estimatedListingAge.orderBooksCache[listing.itemHrid];
                    if (!orderBookData || !orderBookData.orderBooks || orderBookData.orderBooks.length === 0) {
                        fullyProcessed = false;
                        break;
                    }
                }
            }

            // Only mark as processed if fully complete
            if (fullyProcessed) {
                tableNode.classList.add('mwi-listing-prices-set');
            }
        }

        /**
         * Add column headers to table head
         * @param {HTMLElement} tableNode - The listings table
         */
        addTableHeaders(tableNode) {
            const thead = tableNode.querySelector('thead tr');
            if (!thead) return;

            // Skip if headers already added
            if (thead.querySelector('.mwi-listing-price-header')) {
                return;
            }

            // Create "Top Order Price" header
            const topOrderHeader = document.createElement('th');
            topOrderHeader.classList.add('mwi-listing-price-header');
            topOrderHeader.textContent = 'Top Order Price';

            // Create "Top Order Age" header (if setting enabled)
            let topOrderAgeHeader = null;
            if (config$1.getSetting('market_showTopOrderAge')) {
                topOrderAgeHeader = document.createElement('th');
                topOrderAgeHeader.classList.add('mwi-listing-price-header');
                topOrderAgeHeader.textContent = 'Top Order Age';
                topOrderAgeHeader.title = 'Estimated age of the top competing order';
            }

            // Create "Total Price" header
            const totalPriceHeader = document.createElement('th');
            totalPriceHeader.classList.add('mwi-listing-price-header');
            totalPriceHeader.textContent = 'Total Price';

            // Create "Listed" header (if setting enabled)
            let listedHeader = null;
            if (config$1.getSetting('market_showListingAge')) {
                listedHeader = document.createElement('th');
                listedHeader.classList.add('mwi-listing-price-header');
                listedHeader.textContent = 'Listed';
            }

            // Insert headers (order: Top Order Price, Top Order Age, Total Price, Listed)
            let insertIndex = 4;
            thead.insertBefore(topOrderHeader, thead.children[insertIndex++]);
            if (topOrderAgeHeader) {
                thead.insertBefore(topOrderAgeHeader, thead.children[insertIndex++]);
            }
            thead.insertBefore(totalPriceHeader, thead.children[insertIndex++]);
            if (listedHeader) {
                thead.insertBefore(listedHeader, thead.children[insertIndex++]);
            }
        }

        /**
         * Add listing data to row datasets for matching
         * @param {HTMLElement} tbody - Table body element
         */
        addDataToRows(tbody) {
            const listings = Object.values(this.allListings);
            const used = new Set();

            for (const row of tbody.querySelectorAll('tr')) {
                const rowInfo = this.extractRowInfo(row);

                // Find matching listing with improved criteria
                const matchedListing = listings.find((listing) => {
                    if (used.has(listing.id)) return false;

                    // Basic matching criteria
                    const itemMatch = listing.itemHrid === rowInfo.itemHrid;
                    const enhancementMatch = listing.enhancementLevel === rowInfo.enhancementLevel;
                    const typeMatch = listing.isSell === rowInfo.isSell;
                    const priceMatch = !rowInfo.price || Math.abs(listing.price - rowInfo.price) < 0.01;

                    if (!itemMatch || !enhancementMatch || !typeMatch || !priceMatch) {
                        return false;
                    }

                    // If quantity info is available from row, use it for precise matching
                    if (rowInfo.filledQuantity !== null && rowInfo.orderQuantity !== null) {
                        const quantityMatch =
                            listing.filledQuantity === rowInfo.filledQuantity &&
                            listing.orderQuantity === rowInfo.orderQuantity;
                        return quantityMatch;
                    }

                    // Fallback to basic match if no quantity info
                    return true;
                });

                if (matchedListing) {
                    used.add(matchedListing.id);
                    // Store listing data in row dataset
                    row.dataset.listingId = matchedListing.id;
                    row.dataset.itemHrid = matchedListing.itemHrid;
                    row.dataset.enhancementLevel = matchedListing.enhancementLevel;
                    row.dataset.isSell = matchedListing.isSell;
                    row.dataset.price = matchedListing.price;
                    row.dataset.orderQuantity = matchedListing.orderQuantity;
                    row.dataset.filledQuantity = matchedListing.filledQuantity;
                    row.dataset.createdTimestamp = matchedListing.createdTimestamp;
                    row.dataset.unclaimedCoinCount = matchedListing.unclaimedCoinCount;
                    row.dataset.unclaimedItemCount = matchedListing.unclaimedItemCount;
                }
            }
        }

        /**
         * Extract listing info from table row for matching
         * @param {HTMLElement} row - Table row element
         * @returns {Object} Extracted row info
         */
        extractRowInfo(row) {
            // Extract itemHrid from SVG use element
            let itemHrid = null;
            const useElements = row.querySelectorAll('use');
            for (const use of useElements) {
                const href = use.href && use.href.baseVal ? use.href.baseVal : '';
                if (href.includes('#')) {
                    const idPart = href.split('#')[1];
                    if (idPart && !idPart.toLowerCase().includes('coin')) {
                        itemHrid = `/items/${idPart}`;
                        break;
                    }
                }
            }

            // Extract enhancement level
            let enhancementLevel = 0;
            const enhNode = row.querySelector('[class*="enhancementLevel"]');
            if (enhNode && enhNode.textContent) {
                const match = enhNode.textContent.match(/\+\s*(\d+)/);
                if (match) {
                    enhancementLevel = Number(match[1]);
                }
            }

            // Detect isSell from type cell (2nd cell)
            let isSell = null;
            const typeCell = row.children[1];
            if (typeCell) {
                const text = (typeCell.textContent || '').toLowerCase();
                if (text.includes('sell')) {
                    isSell = true;
                } else if (text.includes('buy')) {
                    isSell = false;
                }
            }

            // Extract quantity (3rd cell) - format: "filled / total"
            let filledQuantity = null;
            let orderQuantity = null;
            const quantityCell = row.children[2];
            if (quantityCell) {
                const text = quantityCell.textContent.trim();
                const match = text.match(/(\d+)\s*\/\s*(\d+)/);
                if (match) {
                    filledQuantity = Number(match[1]);
                    orderQuantity = Number(match[2]);
                }
            }

            // Extract price (4th cell before our inserts)
            let price = NaN;
            const priceNode = row.querySelector('[class*="price"]') || row.children[3];
            if (priceNode) {
                let text =
                    priceNode.firstChild && priceNode.firstChild.textContent
                        ? priceNode.firstChild.textContent
                        : priceNode.textContent;
                text = String(text).trim();

                // Handle K/M suffixes (e.g., "340K" = 340000, "1.5M" = 1500000)
                let multiplier = 1;
                if (text.toUpperCase().includes('K')) {
                    multiplier = 1000;
                    text = text.replace(/K/gi, '');
                } else if (text.toUpperCase().includes('M')) {
                    multiplier = 1000000;
                    text = text.replace(/M/gi, '');
                }

                // Parse number handling both locale formats:
                // US: "3,172" or "3,172.50" (comma = thousands, dot = decimal)
                // EU: "3.172" or "3.172,50" (dot = thousands, comma = decimal)
                // Strategy: Find last dot/comma (decimal separator), remove all others (thousand separators)
                const lastDotIndex = text.lastIndexOf('.');
                const lastCommaIndex = text.lastIndexOf(',');
                const lastSeparatorIndex = Math.max(lastDotIndex, lastCommaIndex);

                let numStr;
                if (lastSeparatorIndex === -1) {
                    // No separators, just extract digits
                    numStr = text.replace(/[^0-9]/g, '');
                } else {
                    // Has separator - determine if it's decimal or thousand separator
                    const beforeSeparator = text.substring(0, lastSeparatorIndex);
                    const afterSeparator = text.substring(lastSeparatorIndex + 1);

                    // If there are 1-2 digits after separator, it's likely a decimal point
                    // If there are exactly 3 digits after separator, it could be either (ambiguous)
                    // If there are more than 3 digits, it's definitely a decimal point
                    const digitsAfter = afterSeparator.replace(/[^0-9]/g, '').length;

                    if (digitsAfter <= 2 && digitsAfter > 0) {
                        // Decimal separator (e.g., "3,172.50" or "3.172,50")
                        numStr = beforeSeparator.replace(/[^0-9]/g, '') + '.' + afterSeparator.replace(/[^0-9]/g, '');
                    } else {
                        // Thousand separator or no decimal (e.g., "3,172" or "3.172")
                        numStr = text.replace(/[^0-9]/g, '');
                    }
                }

                price = numStr ? Number(numStr) * multiplier : NaN;
            }

            return { itemHrid, enhancementLevel, isSell, price, filledQuantity, orderQuantity };
        }

        /**
         * Add price display cells to each row
         * @param {HTMLElement} tbody - Table body element
         * @param {Map} priceCache - Pre-fetched price cache
         */
        addPriceDisplays(tbody, priceCache) {
            for (const row of tbody.querySelectorAll('tr')) {
                // Skip if displays already added
                if (row.querySelector('.mwi-listing-price-cell')) {
                    continue;
                }

                const dataset = row.dataset;
                const hasMatchedListing = !!dataset.listingId;

                // Insert at index 4 (same as headers) to maintain alignment
                const insertIndex = 4;
                const insertBeforeCell = row.children[insertIndex] || null;

                if (hasMatchedListing) {
                    // Matched row - create cells with actual data
                    const itemHrid = dataset.itemHrid;
                    const enhancementLevel = Number(dataset.enhancementLevel);
                    const isSell = dataset.isSell === 'true';
                    const price = Number(dataset.price);
                    const orderQuantity = Number(dataset.orderQuantity);
                    const filledQuantity = Number(dataset.filledQuantity);
                    const unclaimedCoinCount = Number(dataset.unclaimedCoinCount) || 0;
                    const unclaimedItemCount = Number(dataset.unclaimedItemCount) || 0;

                    // Create Top Order Price cell
                    const topOrderCell = this.createTopOrderPriceCell(
                        itemHrid,
                        enhancementLevel,
                        isSell,
                        price,
                        priceCache
                    );
                    row.insertBefore(topOrderCell, insertBeforeCell);

                    // Create Top Order Age cell (if setting enabled)
                    if (config$1.getSetting('market_showTopOrderAge')) {
                        const topOrderAgeCell = this.createTopOrderAgeCell(itemHrid, enhancementLevel, isSell);
                        row.insertBefore(topOrderAgeCell, row.children[insertIndex + 1]);
                    }

                    // Create Total Price cell
                    const currentInsertIndex = insertIndex + (config$1.getSetting('market_showTopOrderAge') ? 2 : 1);
                    const totalPriceCell = this.createTotalPriceCell(
                        itemHrid,
                        isSell,
                        price,
                        orderQuantity,
                        filledQuantity,
                        unclaimedCoinCount,
                        unclaimedItemCount
                    );
                    row.insertBefore(totalPriceCell, row.children[currentInsertIndex]);

                    // Create Listed Age cell (if setting enabled)
                    if (config$1.getSetting('market_showListingAge') && dataset.createdTimestamp) {
                        const listedInsertIndex = currentInsertIndex + 1;
                        const listedAgeCell = this.createListedAgeCell(dataset.createdTimestamp);
                        row.insertBefore(listedAgeCell, row.children[listedInsertIndex]);
                    }
                } else {
                    // Unmatched row - create placeholder cells to prevent column misalignment
                    const topOrderCell = this.createPlaceholderCell();
                    row.insertBefore(topOrderCell, insertBeforeCell);

                    if (config$1.getSetting('market_showTopOrderAge')) {
                        const topOrderAgeCell = this.createPlaceholderCell();
                        row.insertBefore(topOrderAgeCell, row.children[insertIndex + 1]);
                    }

                    const currentInsertIndex = insertIndex + (config$1.getSetting('market_showTopOrderAge') ? 2 : 1);
                    const totalPriceCell = this.createPlaceholderCell();
                    row.insertBefore(totalPriceCell, row.children[currentInsertIndex]);

                    if (config$1.getSetting('market_showListingAge')) {
                        const listedInsertIndex = currentInsertIndex + 1;
                        const listedAgeCell = this.createPlaceholderCell();
                        row.insertBefore(listedAgeCell, row.children[listedInsertIndex]);
                    }
                }
            }
        }

        /**
         * Create Top Order Price cell
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level
         * @param {boolean} isSell - Is sell order
         * @param {number} price - Listing price
         * @param {Map} priceCache - Pre-fetched price cache
         * @returns {HTMLElement} Table cell element
         */
        createTopOrderPriceCell(itemHrid, enhancementLevel, isSell, price, priceCache) {
            const cell = document.createElement('td');
            cell.classList.add('mwi-listing-price-cell');

            const span = document.createElement('span');
            span.classList.add('mwi-listing-price-value');

            // Get current market price from cache
            const key = `${itemHrid}:${enhancementLevel}`;
            const marketPrice = priceCache.get(key);
            const topOrderPrice = marketPrice ? (isSell ? marketPrice.ask : marketPrice.bid) : null;

            if (topOrderPrice === null || topOrderPrice === -1) {
                span.textContent = coinFormatter(null);
                span.style.color = '#004FFF'; // Blue for no data
            } else {
                span.textContent = coinFormatter(topOrderPrice);

                // Color coding based on competitiveness
                if (isSell) {
                    // Sell order: green if our price is lower (better), red if higher (undercut)
                    span.style.color = topOrderPrice < price ? '#FF0000' : '#00FF00';
                } else {
                    // Buy order: green if our price is higher (better), red if lower (undercut)
                    span.style.color = topOrderPrice > price ? '#FF0000' : '#00FF00';
                }
            }

            cell.appendChild(span);
            return cell;
        }

        /**
         * Create Top Order Age cell
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level
         * @param {boolean} isSell - Is sell order
         * @returns {HTMLElement} Table cell element
         */
        createTopOrderAgeCell(itemHrid, enhancementLevel, isSell) {
            const cell = document.createElement('td');
            cell.classList.add('mwi-listing-price-cell');

            const span = document.createElement('span');
            span.classList.add('mwi-listing-price-value');

            // Get order book data from estimatedListingAge module (shared cache)
            const cacheEntry = estimatedListingAge.orderBooksCache[itemHrid];

            if (!cacheEntry) {
                // No order book data available
                span.textContent = 'N/A';
                span.style.color = '#666666';
                span.style.fontSize = '0.9em';
                cell.appendChild(span);
                return cell;
            }

            // Support both old format (direct data) and new format ({data, lastUpdated})
            const orderBookData = cacheEntry.data || cacheEntry;
            const lastUpdated = cacheEntry.lastUpdated;

            if (!orderBookData || !orderBookData.orderBooks || orderBookData.orderBooks.length === 0) {
                // No order book data available
                span.textContent = 'N/A';
                span.style.color = '#666666';
                span.style.fontSize = '0.9em';
                cell.appendChild(span);
                return cell;
            }

            // Find matching order book for this enhancement level
            let orderBook = orderBookData.orderBooks.find((ob) => ob.enhancementLevel === enhancementLevel);

            // For non-enhanceable items (enh level 0), orderBook won't have enhancementLevel field
            // Just use the first (and only) orderBook entry
            if (!orderBook && enhancementLevel === 0 && orderBookData.orderBooks.length > 0) {
                orderBook = orderBookData.orderBooks[0];
            }

            if (!orderBook) {
                span.textContent = 'N/A';
                span.style.color = '#666666';
                span.style.fontSize = '0.9em';
                cell.appendChild(span);
                return cell;
            }

            // Get top order (first in array)
            const topOrders = isSell ? orderBook.asks : orderBook.bids;

            if (!topOrders || topOrders.length === 0) {
                // No competing orders
                span.textContent = 'None';
                span.style.color = '#00FF00'; // Green = you're the only one
                span.style.fontSize = '0.9em';
                cell.appendChild(span);
                return cell;
            }

            const topOrder = topOrders[0];
            const topListingId = topOrder.listingId;

            // Estimate timestamp using existing logic
            const estimatedTimestamp = estimatedListingAge.estimateTimestamp(topListingId);

            // Format as elapsed time
            const ageMs = Date.now() - estimatedTimestamp;
            const formatted = formatRelativeTime(ageMs);

            span.textContent = `~${formatted}`;

            // Apply staleness color based on when order book data was fetched
            span.style.color = estimatedListingAge.getStalenessColor(lastUpdated);
            span.style.fontSize = '0.9em';

            // Add tooltip with staleness info
            if (lastUpdated) {
                span.title = estimatedListingAge.getStalenessTooltip(lastUpdated);
            }

            cell.appendChild(span);
            return cell;
        }

        /**
         * Create Total Price cell
         * @param {string} itemHrid - Item HRID
         * @param {boolean} isSell - Is sell order
         * @param {number} price - Unit price
         * @param {number} orderQuantity - Total quantity ordered
         * @param {number} filledQuantity - Quantity already filled
         * @param {number} unclaimedCoinCount - Unclaimed coins (for filled sell orders)
         * @param {number} unclaimedItemCount - Unclaimed items (for filled buy orders)
         * @returns {HTMLElement} Table cell element
         */
        createTotalPriceCell(
            itemHrid,
            isSell,
            price,
            orderQuantity,
            filledQuantity,
            unclaimedCoinCount,
            unclaimedItemCount
        ) {
            const cell = document.createElement('td');
            cell.classList.add('mwi-listing-price-cell');

            const span = document.createElement('span');
            span.classList.add('mwi-listing-price-value');

            let totalPrice;

            // For filled listings, show unclaimed amount
            if (filledQuantity === orderQuantity) {
                if (isSell) {
                    // Sell order: show unclaimed coins
                    totalPrice = unclaimedCoinCount;
                } else {
                    // Buy order: show value of unclaimed items
                    totalPrice = unclaimedItemCount * price;
                }
            } else {
                // For active listings, calculate remaining value
                // Calculate tax rate (0.18 for cowbells, 0.02 for others, 0.0 for buy orders)
                const taxRate = isSell ? (itemHrid === '/items/bag_of_10_cowbells' ? 0.18 : 0.02) : 0;
                totalPrice = (orderQuantity - filledQuantity) * Math.floor(calculatePriceAfterTax(price, taxRate));
            }

            // Format and color code
            span.textContent = coinFormatter(totalPrice);

            // Color based on amount
            span.style.color = this.getAmountColor(totalPrice);

            cell.appendChild(span);
            return cell;
        }

        /**
         * Create Listed Age cell
         * @param {string} createdTimestamp - ISO timestamp when listing was created
         * @returns {HTMLElement} Table cell element
         */
        createListedAgeCell(createdTimestamp) {
            const cell = document.createElement('td');
            cell.classList.add('mwi-listing-price-cell');

            const span = document.createElement('span');
            span.classList.add('mwi-listing-price-value');

            // Calculate age in milliseconds
            const createdDate = new Date(createdTimestamp);
            const ageMs = Date.now() - createdDate.getTime();

            // Format relative time
            span.textContent = formatRelativeTime(ageMs);
            span.style.color = '#AAAAAA'; // Gray for time display

            cell.appendChild(span);
            return cell;
        }

        /**
         * Create placeholder cell for unmatched rows
         * @returns {HTMLElement} Empty table cell element
         */
        createPlaceholderCell() {
            const cell = document.createElement('td');
            cell.classList.add('mwi-listing-price-cell');

            const span = document.createElement('span');
            span.classList.add('mwi-listing-price-value');
            span.textContent = 'N/A';
            span.style.color = '#666666'; // Gray for placeholder
            span.style.fontSize = '0.9em';

            cell.appendChild(span);
            return cell;
        }

        /**
         * Get color for amount based on magnitude
         * @param {number} amount - Amount value
         * @returns {string} Color code
         */
        getAmountColor(amount) {
            if (amount >= 1000000) return '#FFD700'; // Gold for 1M+
            if (amount >= 100000) return '#00FF00'; // Green for 100K+
            if (amount >= 10000) return '#FFFFFF'; // White for 10K+
            return '#AAAAAA'; // Gray for small amounts
        }

        /**
         * Clear all injected displays
         */
        clearDisplays() {
            document.querySelectorAll('.mwi-listing-prices-set').forEach((table) => {
                table.classList.remove('mwi-listing-prices-set');
            });
            document.querySelectorAll('.mwi-listing-price-header').forEach((el) => el.remove());
            document.querySelectorAll('.mwi-listing-price-cell').forEach((el) => el.remove());
        }

        /**
         * Disable the listing price display
         */
        disable() {
            console.log('[ListingPriceDisplay] 🧹 Cleaning up handlers');

            // Cleanup all MutationObservers
            for (const observer of this.tbodyObservers.values()) {
                observer.disconnect();
            }
            this.tbodyObservers.clear();

            this.cleanupRegistry.cleanupAll();
            this.clearDisplays();
            this.allListings = {};
            this.activeRefreshes = new WeakSet();
            this.isInitialized = false;
        }
    }

    const listingPriceDisplay = new ListingPriceDisplay();

    /**
     * Market Order Totals Module
     *
     * Displays market listing totals in the header area:
     * - Buy Orders (BO): Coins locked in buy orders
     * - Sell Orders (SO): Expected proceeds from sell orders
     * - Unclaimed (💰): Coins waiting to be collected
     */


    class MarketOrderTotals {
        constructor() {
            this.unregisterWebSocket = null;
            this.unregisterObserver = null;
            this.isInitialized = false;
            this.displayElement = null;
            this.marketplaceClickHandler = (event) => {
                event.preventDefault();
                this.openMarketplace();
            };
        }

        /**
         * Initialize the market order totals feature
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('market_showOrderTotals')) {
                return;
            }

            this.isInitialized = true;

            // Setup data listeners for listing updates
            this.setupDataListeners();

            // Setup DOM observer for header
            this.setupObserver();
        }

        /**
         * Setup WebSocket listeners to detect listing changes
         */
        setupDataListeners() {
            const updateHandler = () => {
                this.updateDisplay();
            };

            dataManager$1.on('market_listings_updated', updateHandler);
            dataManager$1.on('character_initialized', updateHandler);

            this.unregisterWebSocket = () => {
                dataManager$1.off('market_listings_updated', updateHandler);
                dataManager$1.off('character_initialized', updateHandler);
            };
        }

        /**
         * Setup DOM observer for header area
         */
        setupObserver() {
            // 1. Check if element already exists (handles late initialization)
            const existingElem = document.querySelector('[class*="Header_totalLevel"]');
            if (existingElem) {
                this.injectDisplay(existingElem);
            }

            // 2. Watch for future additions (handles SPA navigation, page reloads)
            this.unregisterObserver = domObserver$1.onClass('MarketOrderTotals', 'Header_totalLevel', (totalLevelElem) => {
                this.injectDisplay(totalLevelElem);
            });
        }

        /**
         * Calculate market order totals from all listings
         * @returns {Object} Totals object with buyOrders, sellOrders, unclaimed
         */
        calculateTotals() {
            const listings = dataManager$1.getMarketListings();

            let buyOrders = 0;
            let sellOrders = 0;
            let unclaimed = 0;

            for (const listing of listings) {
                if (!listing) {
                    continue;
                }

                // Unclaimed coins
                unclaimed += listing.unclaimedCoinCount || 0;

                // Skip cancelled or fully claimed listings
                if (
                    listing.status === '/market_listing_status/cancelled' ||
                    (listing.status === '/market_listing_status/filled' &&
                        (listing.unclaimedItemCount || 0) === 0 &&
                        (listing.unclaimedCoinCount || 0) === 0)
                ) {
                    continue;
                }

                if (listing.isSell) {
                    // Sell orders: Calculate expected proceeds after tax
                    if (listing.status === '/market_listing_status/filled') {
                        continue;
                    }

                    const tax = listing.itemHrid === '/items/bag_of_10_cowbells' ? 0.82 : 0.98;
                    const remainingQuantity = Math.max(0, listing.orderQuantity - listing.filledQuantity);

                    if (remainingQuantity > 0) {
                        sellOrders += remainingQuantity * Math.floor(listing.price * tax);
                    }
                } else {
                    // Buy orders: Prepaid coins locked in the order
                    buyOrders += listing.coinsAvailable || 0;
                }
            }

            return {
                buyOrders,
                sellOrders,
                unclaimed,
            };
        }

        /**
         * Inject display element into header
         * @param {HTMLElement} totalLevelElem - Total level element
         */
        injectDisplay(totalLevelElem) {
            // Skip if already injected
            if (this.displayElement && document.body.contains(this.displayElement)) {
                return;
            }

            // Create display container
            this.displayElement = document.createElement('div');
            this.displayElement.classList.add('mwi-market-order-totals');
            this.displayElement.style.cssText = `
            display: flex;
            gap: 12px;
            font-size: 0.85em;
            color: #aaa;
            margin-top: 4px;
            padding: 2px 0;
        `;

            // Find the networth header (if it exists) and insert after it
            // Otherwise insert after total level
            const networthHeader = document.querySelector('.mwi-networth-header');
            if (networthHeader) {
                networthHeader.insertAdjacentElement('afterend', this.displayElement);
            } else {
                totalLevelElem.insertAdjacentElement('afterend', this.displayElement);
            }

            // Initial update
            this.updateDisplay();
        }

        /**
         * Update the display with current totals
         */
        updateDisplay() {
            if (!this.displayElement || !document.body.contains(this.displayElement)) {
                const headerElement = document.querySelector('[class*="Header_totalLevel"]');
                if (headerElement) {
                    this.injectDisplay(headerElement);
                }

                if (!this.displayElement || !document.body.contains(this.displayElement)) {
                    return;
                }
            }

            const totals = this.calculateTotals();

            // Check if we have no data yet (all zeros)
            const hasNoData = totals.buyOrders === 0 && totals.sellOrders === 0 && totals.unclaimed === 0;

            this.displayElement.style.justifyContent = hasNoData ? 'flex-end' : 'flex-start';
            this.displayElement.style.width = hasNoData ? '100%' : '';

            if (hasNoData) {
                const marketplaceIcon = this.getMarketplaceIcon();
                this.displayElement.innerHTML = `
                <button
                    type="button"
                    class="mwi-market-order-totals-link"
                    title="Open Marketplace"
                    aria-label="Open Marketplace"
                    style="background: none; border: none; padding: 0; cursor: pointer; display: flex; align-items: center;"
                >
                    ${marketplaceIcon}
                </button>
            `;

                const linkButton = this.displayElement.querySelector('.mwi-market-order-totals-link');
                if (linkButton) {
                    linkButton.addEventListener('click', this.marketplaceClickHandler);
                }

                return;
            }

            // Format values for display
            const boDisplay = `<span style="color: #ffd700;">${formatKMB(totals.buyOrders)}</span>`;
            const soDisplay = `<span style="color: #ffd700;">${formatKMB(totals.sellOrders)}</span>`;
            const unclaimedDisplay = `<span style="color: #ffd700;">${formatKMB(totals.unclaimed)}</span>`;

            // Update display
            this.displayElement.innerHTML = `
            <div style="display: flex; align-items: center; gap: 4px;" title="Buy Orders (coins locked in buy orders)">
                <span style="color: #888; font-weight: 500;">BO:</span>
                ${boDisplay}
            </div>
            <div style="display: flex; align-items: center; gap: 4px;" title="Sell Orders (expected proceeds after tax)">
                <span style="color: #888; font-weight: 500;">SO:</span>
                ${soDisplay}
            </div>
            <div style="display: flex; align-items: center; gap: 4px;" title="Unclaimed coins (waiting to be collected)">
                <span style="font-weight: 500;">💰:</span>
                ${unclaimedDisplay}
            </div>
        `;
        }

        /**
         * Open the marketplace view
         */
        openMarketplace() {
            try {
                const navButtons = document.querySelectorAll('.NavigationBar_nav__3uuUl');
                const marketplaceButton = Array.from(navButtons).find((nav) => {
                    const svg = nav.querySelector('svg[aria-label="navigationBar.marketplace"]');
                    return svg !== null;
                });

                if (!marketplaceButton) {
                    console.error('[MarketOrderTotals] Marketplace navbar button not found');
                    return;
                }

                marketplaceButton.click();
            } catch (error) {
                console.error('[MarketOrderTotals] Failed to open marketplace:', error);
            }
        }

        /**
         * Build marketplace icon markup using navbar icon (fallback to emoji).
         * @returns {string} HTML string for icon
         */
        getMarketplaceIcon() {
            const navIcon = document.querySelector('svg[aria-label="navigationBar.marketplace"]');
            if (navIcon) {
                const clonedIcon = navIcon.cloneNode(true);
                clonedIcon.setAttribute('width', '16');
                clonedIcon.setAttribute('height', '16');
                clonedIcon.setAttribute('aria-hidden', 'true');
                return clonedIcon.outerHTML;
            }

            return '<span aria-hidden="true">🏪</span>';
        }

        /**
         * Clear all displays
         */
        clearDisplay() {
            if (this.displayElement) {
                this.displayElement.remove();
                this.displayElement = null;
            }
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.unregisterWebSocket) {
                this.unregisterWebSocket();
                this.unregisterWebSocket = null;
            }

            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            this.clearDisplay();
            this.isInitialized = false;
        }
    }

    const marketOrderTotals = new MarketOrderTotals();

    /**
     * Market History Viewer Module
     *
     * Displays a comprehensive table of all market listings with:
     * - Sortable columns
     * - Search/filter functionality
     * - Pagination with user-configurable rows per page
     * - CSV export
     * - Summary statistics
     */


    class MarketHistoryViewer {
        constructor() {
            this.isInitialized = false;
            this.modal = null;
            this.listings = [];
            this.filteredListings = [];
            this.currentPage = 1;
            this.rowsPerPage = 50;
            this.showAll = false;
            this.sortColumn = 'createdTimestamp';
            this.sortDirection = 'desc'; // Most recent first
            this.searchTerm = '';
            this.typeFilter = 'all'; // 'all', 'buy', 'sell'
            this.useKMBFormat = false; // K/M/B formatting toggle
            this.storageKey = 'marketListingTimestamps';
            this.timerRegistry = createTimerRegistry();

            // Column filters
            this.filters = {
                dateFrom: null, // Date object or null
                dateTo: null, // Date object or null
                selectedItems: [], // Array of itemHrids
                selectedEnhLevels: [], // Array of enhancement levels (numbers)
                selectedTypes: [], // Array of 'buy' and/or 'sell'
            };
            this.activeFilterPopup = null; // Track currently open filter popup
            this.popupCloseHandler = null; // Track the close handler to clean it up properly

            // Marketplace tab tracking
            this.marketplaceTab = null;
            this.tabCleanupObserver = null;
        }

        /**
         * Get the current items sprite URL from the DOM
         * @returns {string|null} Items sprite URL or null if not found
         */
        getItemsSpriteUrl() {
            const itemIcon = document.querySelector('use[href*="items_sprite"]');
            if (!itemIcon) {
                return null;
            }
            const href = itemIcon.getAttribute('href');
            return href ? href.split('#')[0] : null;
        }

        /**
         * Initialize the feature
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('market_showHistoryViewer')) {
                return;
            }

            this.isInitialized = true;

            // Load K/M/B format preference
            this.useKMBFormat = await storage$1.get('marketHistoryKMBFormat', 'settings', false);

            // Load saved filters
            await this.loadFilters();

            // Add marketplace tab
            this.addMarketplaceTab();
        }

        /**
         * Load saved filters from storage
         */
        async loadFilters() {
            try {
                const savedFilters = await storage$1.getJSON('marketHistoryFilters', 'settings', null);
                if (savedFilters) {
                    // Convert date strings back to Date objects
                    this.filters.dateFrom = savedFilters.dateFrom ? new Date(savedFilters.dateFrom) : null;
                    this.filters.dateTo = savedFilters.dateTo ? new Date(savedFilters.dateTo) : null;
                    this.filters.selectedItems = savedFilters.selectedItems || [];
                    this.filters.selectedEnhLevels = savedFilters.selectedEnhLevels || [];
                    this.filters.selectedTypes = savedFilters.selectedTypes || [];
                }
            } catch (error) {
                console.error('[MarketHistoryViewer] Failed to load filters:', error);
            }
        }

        /**
         * Save filters to storage
         */
        async saveFilters() {
            try {
                // Convert Date objects to strings for storage
                const filtersToSave = {
                    dateFrom: this.filters.dateFrom ? this.filters.dateFrom.toISOString() : null,
                    dateTo: this.filters.dateTo ? this.filters.dateTo.toISOString() : null,
                    selectedItems: this.filters.selectedItems,
                    selectedEnhLevels: this.filters.selectedEnhLevels,
                    selectedTypes: this.filters.selectedTypes,
                };
                await storage$1.setJSON('marketHistoryFilters', filtersToSave, 'settings', true);
            } catch (error) {
                console.error('[MarketHistoryViewer] Failed to save filters:', error);
            }
        }

        /**
         * Add "Market History" tab to marketplace tabs
         */
        addMarketplaceTab() {
            const ensureTabExists = () => {
                // Get tabs container
                const tabsContainer = document.querySelector('.MuiTabs-flexContainer[role="tablist"]');
                if (!tabsContainer) return;

                // Verify this is the marketplace tabs (check for Market Listings tab)
                const hasMarketListingsTab = Array.from(tabsContainer.children).some((btn) =>
                    btn.textContent.includes('Market Listings')
                );
                if (!hasMarketListingsTab) return;

                // Check if tab already exists
                if (tabsContainer.querySelector('[data-mwi-market-history-tab="true"]')) {
                    return;
                }

                // Get reference tab (My Listings) to clone structure
                const referenceTab = Array.from(tabsContainer.children).find((btn) =>
                    btn.textContent.includes('My Listings')
                );
                if (!referenceTab) return;

                // Clone reference tab
                const tab = referenceTab.cloneNode(true);

                // Mark as market history tab
                tab.setAttribute('data-mwi-market-history-tab', 'true');

                // Update badge content
                const badgeSpan = tab.querySelector('.TabsComponent_badge__1Du26');
                if (badgeSpan) {
                    badgeSpan.innerHTML = `
                    <div style="text-align: center;">
                        <div>Market History</div>
                    </div>
                `;
                }

                // Remove selected state
                tab.classList.remove('Mui-selected');
                tab.setAttribute('aria-selected', 'false');
                tab.setAttribute('tabindex', '-1');

                // Add click handler
                tab.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.openModal();
                });

                // Insert before any missing materials custom tabs (data-mwi-custom-tab="true")
                const firstCustomTab = Array.from(tabsContainer.children).find(
                    (btn) => btn.getAttribute('data-mwi-custom-tab') === 'true'
                );

                if (firstCustomTab) {
                    firstCustomTab.before(tab);
                } else {
                    // No custom tabs, append to end
                    tabsContainer.appendChild(tab);
                }

                this.marketplaceTab = tab;
            };

            // Watch for marketplace tabs container to appear
            if (!this.tabCleanupObserver) {
                this.tabCleanupObserver = createMutationWatcher(
                    document.body,
                    () => {
                        // Check if marketplace is still active
                        const tabsContainer = document.querySelector('.MuiTabs-flexContainer[role="tablist"]');
                        if (!tabsContainer) {
                            // Marketplace closed, clean up tab
                            if (this.marketplaceTab && !document.body.contains(this.marketplaceTab)) {
                                this.marketplaceTab = null;
                            }
                            return;
                        }

                        // Check if this is still the marketplace (Market Listings tab exists)
                        const hasMarketListingsTab = Array.from(tabsContainer.children).some((btn) =>
                            btn.textContent.includes('Market Listings')
                        );

                        if (!hasMarketListingsTab) {
                            // No longer on marketplace, clean up
                            if (this.marketplaceTab && document.body.contains(this.marketplaceTab)) {
                                this.marketplaceTab.remove();
                                this.marketplaceTab = null;
                            }
                            return;
                        }

                        // Try to ensure tab exists
                        ensureTabExists();
                    },
                    { childList: true, subtree: true }
                );
            }

            // Initial attempt
            ensureTabExists();
        }

        /**
         * Load listings from storage
         */
        async loadListings() {
            try {
                const stored = await storage$1.getJSON(this.storageKey, 'marketListings', []);
                // Filter out listings without itemHrid (e.g., seed listings from estimated-listing-age)
                this.listings = stored.filter((listing) => listing && listing.itemHrid);
                this.cachedDateRange = null; // Clear cache when loading new data
                this.applyFilters();
            } catch (error) {
                console.error('[MarketHistoryViewer] Failed to load listings:', error);
                this.listings = [];
                this.filteredListings = [];
            }
        }

        /**
         * Apply filters and search to listings
         */
        applyFilters() {
            let filtered = [...this.listings];

            // Clear cached date range when filters change
            this.cachedDateRange = null;

            // Apply type filter (legacy - kept for backwards compatibility)
            if (this.typeFilter === 'buy') {
                filtered = filtered.filter((listing) => !listing.isSell);
            } else if (this.typeFilter === 'sell') {
                filtered = filtered.filter((listing) => listing.isSell);
            }

            // Apply search term (search in item name)
            if (this.searchTerm) {
                const term = this.searchTerm.toLowerCase();
                filtered = filtered.filter((listing) => {
                    const itemName = this.getItemName(listing.itemHrid).toLowerCase();
                    return itemName.includes(term);
                });
            }

            // Apply date range filter
            if (this.filters.dateFrom || this.filters.dateTo) {
                filtered = filtered.filter((listing) => {
                    const listingDate = new Date(listing.createdTimestamp || listing.timestamp);

                    if (this.filters.dateFrom && listingDate < this.filters.dateFrom) {
                        return false;
                    }

                    if (this.filters.dateTo) {
                        // Set dateTo to end of day (23:59:59.999)
                        const endOfDay = new Date(this.filters.dateTo);
                        endOfDay.setHours(23, 59, 59, 999);
                        if (listingDate > endOfDay) {
                            return false;
                        }
                    }

                    return true;
                });
            }

            // Apply item filter
            if (this.filters.selectedItems.length > 0) {
                filtered = filtered.filter((listing) => this.filters.selectedItems.includes(listing.itemHrid));
            }

            // Apply enhancement level filter
            if (this.filters.selectedEnhLevels.length > 0) {
                filtered = filtered.filter((listing) => this.filters.selectedEnhLevels.includes(listing.enhancementLevel));
            }

            // Apply type filter (column filter)
            if (this.filters.selectedTypes.length > 0 && this.filters.selectedTypes.length < 2) {
                // Only filter if not both selected (both selected = show all)
                const showBuy = this.filters.selectedTypes.includes('buy');
                const showSell = this.filters.selectedTypes.includes('sell');

                filtered = filtered.filter((listing) => {
                    if (showBuy && !listing.isSell) return true;
                    if (showSell && listing.isSell) return true;
                    return false;
                });
            }

            // Apply sorting
            filtered.sort((a, b) => {
                let aVal = a[this.sortColumn];
                let bVal = b[this.sortColumn];

                // Handle timestamp sorting
                if (this.sortColumn === 'createdTimestamp') {
                    aVal = a.timestamp; // Use numeric timestamp for sorting
                    bVal = b.timestamp;
                }

                // Handle item name sorting
                if (this.sortColumn === 'itemHrid') {
                    aVal = this.getItemName(a.itemHrid);
                    bVal = this.getItemName(b.itemHrid);
                }

                // Handle total (price × filled) sorting
                if (this.sortColumn === 'total') {
                    aVal = a.price * a.filledQuantity;
                    bVal = b.price * b.filledQuantity;
                }

                if (typeof aVal === 'string') {
                    return this.sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                } else {
                    return this.sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
                }
            });

            this.filteredListings = filtered;
            this.currentPage = 1; // Reset to first page when filters change

            // Auto-cleanup invalid filter selections (only on first pass to prevent infinite recursion)
            if (!this._cleanupInProgress) {
                this._cleanupInProgress = true;
                const cleaned = this.cleanupInvalidSelections();

                if (cleaned) {
                    // Selections were cleaned - re-apply filters with the cleaned selections
                    this.applyFilters();
                }

                this._cleanupInProgress = false;

                // Re-render table if modal is open and cleanup happened (only on outermost call)
                if (cleaned && this.modal && this.modal.style.display !== 'none') {
                    this.renderTable();
                }
            }
        }

        /**
         * Remove filter selections that yield no results with current filters
         * @returns {boolean} True if any selections were cleaned up
         */
        cleanupInvalidSelections() {
            let changed = false;

            // Check item selections
            if (this.filters.selectedItems.length > 0) {
                const validItems = new Set(this.filteredListings.map((l) => l.itemHrid));
                const originalLength = this.filters.selectedItems.length;
                this.filters.selectedItems = this.filters.selectedItems.filter((hrid) => validItems.has(hrid));

                if (this.filters.selectedItems.length !== originalLength) {
                    changed = true;
                }
            }

            // Check enhancement level selections
            if (this.filters.selectedEnhLevels.length > 0) {
                const validLevels = new Set(this.filteredListings.map((l) => l.enhancementLevel));
                const originalLength = this.filters.selectedEnhLevels.length;
                this.filters.selectedEnhLevels = this.filters.selectedEnhLevels.filter((level) => validLevels.has(level));

                if (this.filters.selectedEnhLevels.length !== originalLength) {
                    changed = true;
                }
            }

            // Check type selections
            if (this.filters.selectedTypes.length > 0) {
                const hasBuy = this.filteredListings.some((l) => !l.isSell);
                const hasSell = this.filteredListings.some((l) => l.isSell);
                const originalLength = this.filters.selectedTypes.length;

                this.filters.selectedTypes = this.filters.selectedTypes.filter((type) => {
                    if (type === 'buy') return hasBuy;
                    if (type === 'sell') return hasSell;
                    return false;
                });

                if (this.filters.selectedTypes.length !== originalLength) {
                    changed = true;
                }
            }

            // Save changes to storage
            if (changed) {
                this.saveFilters();
            }

            return changed;
        }

        /**
         * Get item name from HRID
         */
        getItemName(itemHrid) {
            const itemDetails = dataManager$1.getItemDetails(itemHrid);
            return itemDetails?.name || itemHrid.split('/').pop().replace(/_/g, ' ');
        }

        /**
         * Format number based on K/M/B toggle
         * @param {number} num - Number to format
         * @returns {string} Formatted number
         */
        formatNumber(num) {
            return this.useKMBFormat ? formatKMB(num, 1) : formatWithSeparator(num);
        }

        /**
         * Get paginated listings for current page
         */
        getPaginatedListings() {
            if (this.showAll) {
                return this.filteredListings;
            }

            const start = (this.currentPage - 1) * this.rowsPerPage;
            const end = start + this.rowsPerPage;
            return this.filteredListings.slice(start, end);
        }

        /**
         * Get total pages
         */
        getTotalPages() {
            if (this.showAll) {
                return 1;
            }
            return Math.ceil(this.filteredListings.length / this.rowsPerPage);
        }

        /**
         * Open the market history modal
         */
        async openModal() {
            // Load listings
            await this.loadListings();

            // Create modal if it doesn't exist
            if (!this.modal) {
                this.createModal();
            }

            // Show modal
            this.modal.style.display = 'flex';

            // Render table
            this.renderTable();
        }

        /**
         * Close the modal
         */
        closeModal() {
            if (this.modal) {
                this.modal.style.display = 'none';
            }
        }

        /**
         * Create modal structure
         */
        createModal() {
            // Modal overlay
            this.modal = document.createElement('div');
            this.modal.className = 'mwi-market-history-modal';
            this.modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        `;

            // Modal content
            const content = document.createElement('div');
            content.className = 'mwi-market-history-content';
            content.style.cssText = `
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            max-width: 95%;
            max-height: 90%;
            overflow: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        `;

            // Header
            const header = document.createElement('div');
            header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        `;

            const title = document.createElement('h2');
            title.textContent = 'Market History';
            title.style.cssText = `
            margin: 0;
            color: #fff;
        `;

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '✕';
            closeBtn.style.cssText = `
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
        `;
            closeBtn.addEventListener('click', () => this.closeModal());

            header.appendChild(title);
            header.appendChild(closeBtn);

            // Controls container
            const controls = document.createElement('div');
            controls.className = 'mwi-market-history-controls';
            controls.style.cssText = `
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
        `;

            content.appendChild(header);
            content.appendChild(controls);

            // Table container
            const tableContainer = document.createElement('div');
            tableContainer.className = 'mwi-market-history-table-container';
            content.appendChild(tableContainer);

            // Pagination container
            const pagination = document.createElement('div');
            pagination.className = 'mwi-market-history-pagination';
            pagination.style.cssText = `
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        `;
            content.appendChild(pagination);

            this.modal.appendChild(content);
            document.body.appendChild(this.modal);

            // Close on background click
            this.modal.addEventListener('click', (e) => {
                if (e.target === this.modal) {
                    this.closeModal();
                }
            });
        }

        /**
         * Render controls (search, filters, export)
         */
        renderControls() {
            const controls = this.modal.querySelector('.mwi-market-history-controls');

            // Only render if controls are empty (prevents re-rendering on every keystroke)
            if (controls.children.length > 0) {
                // Just update the stats text
                this.updateStats();
                return;
            }

            // Left group: Search and filters
            const leftGroup = document.createElement('div');
            leftGroup.style.cssText = `
            display: flex;
            gap: 10px;
            align-items: center;
        `;

            // Search box
            const searchBox = document.createElement('input');
            searchBox.type = 'text';
            searchBox.placeholder = 'Search items...';
            searchBox.value = this.searchTerm;
            searchBox.className = 'mwi-search-box';
            searchBox.style.cssText = `
            padding: 6px 12px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #1a1a1a;
            color: #fff;
            min-width: 200px;
        `;
            searchBox.addEventListener('input', (e) => {
                this.searchTerm = e.target.value;
                this.applyFilters();
                this.renderTable();
            });

            // Type filter
            const typeFilter = document.createElement('select');
            typeFilter.style.cssText = `
            padding: 6px 12px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #1a1a1a;
            color: #fff;
        `;
            const typeOptions = [
                { value: 'all', label: 'All Types' },
                { value: 'buy', label: 'Buy Orders' },
                { value: 'sell', label: 'Sell Orders' },
            ];
            typeOptions.forEach((opt) => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.label;
                if (opt.value === this.typeFilter) {
                    option.selected = true;
                }
                typeFilter.appendChild(option);
            });
            typeFilter.addEventListener('change', (e) => {
                this.typeFilter = e.target.value;
                this.applyFilters();
                this.renderTable();
            });

            leftGroup.appendChild(searchBox);
            leftGroup.appendChild(typeFilter);

            // Middle group: Active filter badges
            const middleGroup = document.createElement('div');
            middleGroup.className = 'mwi-active-filters';
            middleGroup.style.cssText = `
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            flex: 1;
            min-height: 32px;
        `;

            // Action buttons group
            const actionGroup = document.createElement('div');
            actionGroup.style.cssText = `
            display: flex;
            gap: 8px;
            align-items: center;
        `;

            // Export button
            const exportBtn = document.createElement('button');
            exportBtn.textContent = 'Export CSV';
            exportBtn.style.cssText = `
            padding: 6px 12px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        `;
            exportBtn.addEventListener('click', () => this.exportCSV());

            // Import button
            const importBtn = document.createElement('button');
            importBtn.textContent = 'Import Market Data';
            importBtn.style.cssText = `
            padding: 6px 12px;
            background: #9b59b6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        `;
            importBtn.addEventListener('click', () => this.showImportDialog());

            // Clear History button (destructive action - red)
            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear History';
            clearBtn.style.cssText = `
            padding: 6px 12px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        `;
            clearBtn.addEventListener('mouseenter', () => {
                clearBtn.style.background = '#b91c1c';
            });
            clearBtn.addEventListener('mouseleave', () => {
                clearBtn.style.background = '#dc2626';
            });
            clearBtn.addEventListener('click', () => this.clearHistory());

            actionGroup.appendChild(exportBtn);
            actionGroup.appendChild(importBtn);
            actionGroup.appendChild(clearBtn);

            // Right group: Options and stats
            const rightGroup = document.createElement('div');
            rightGroup.style.cssText = `
            display: flex;
            gap: 12px;
            align-items: center;
            margin-left: auto;
        `;

            // K/M/B Format checkbox
            const kmbCheckbox = document.createElement('input');
            kmbCheckbox.type = 'checkbox';
            kmbCheckbox.checked = this.useKMBFormat;
            kmbCheckbox.id = 'mwi-kmb-format';
            kmbCheckbox.style.cssText = `
            cursor: pointer;
        `;
            kmbCheckbox.addEventListener('change', (e) => {
                this.useKMBFormat = e.target.checked;
                // Save preference to storage
                storage$1.set('marketHistoryKMBFormat', this.useKMBFormat, 'settings');
                this.renderTable(); // Re-render to apply formatting
            });

            const kmbLabel = document.createElement('label');
            kmbLabel.htmlFor = 'mwi-kmb-format';
            kmbLabel.textContent = 'K/M/B Format';
            kmbLabel.style.cssText = `
            cursor: pointer;
            color: #aaa;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        `;
            kmbLabel.prepend(kmbCheckbox);

            // Summary stats
            const stats = document.createElement('div');
            stats.className = 'mwi-market-history-stats';
            stats.style.cssText = `
            color: #aaa;
            font-size: 14px;
            white-space: nowrap;
        `;
            stats.textContent = `Total: ${this.filteredListings.length} listings`;

            rightGroup.appendChild(kmbLabel);
            rightGroup.appendChild(stats);

            controls.appendChild(leftGroup);
            controls.appendChild(middleGroup);
            controls.appendChild(actionGroup);
            controls.appendChild(rightGroup);

            // Add Clear All Filters button if needed (handled dynamically)
            this.updateClearFiltersButton();

            // Render active filter badges
            this.renderActiveFilters();
        }

        /**
         * Update just the stats text (without re-rendering controls)
         */
        updateStats() {
            const stats = this.modal.querySelector('.mwi-market-history-stats');
            if (stats) {
                stats.textContent = `Total: ${this.filteredListings.length} listings`;
            }

            // Update Clear All Filters button visibility
            this.updateClearFiltersButton();

            // Update active filter badges
            this.renderActiveFilters();
        }

        /**
         * Render active filter badges in the middle section
         */
        renderActiveFilters() {
            const container = this.modal.querySelector('.mwi-active-filters');
            if (!container) return;

            // Explicitly remove all children to ensure SVG elements are garbage collected
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            const badges = [];

            // Date filter
            if (this.filters.dateFrom || this.filters.dateTo) {
                const dateText = [];
                if (this.filters.dateFrom) {
                    dateText.push(this.filters.dateFrom.toLocaleDateString());
                }
                if (this.filters.dateTo) {
                    dateText.push(this.filters.dateTo.toLocaleDateString());
                }
                badges.push({
                    label: `Date: ${dateText.join(' - ')}`,
                    onRemove: () => {
                        this.filters.dateFrom = null;
                        this.filters.dateTo = null;
                        this.saveFilters();
                        this.applyFilters();
                        this.renderTable();
                    },
                });
            }

            // Item filters
            if (this.filters.selectedItems.length > 0) {
                if (this.filters.selectedItems.length === 1) {
                    badges.push({
                        label: this.getItemName(this.filters.selectedItems[0]),
                        icon: this.filters.selectedItems[0],
                        onRemove: () => {
                            this.filters.selectedItems = [];
                            this.saveFilters();
                            this.applyFilters();
                            this.renderTable();
                        },
                    });
                } else {
                    badges.push({
                        label: `${this.filters.selectedItems.length} items selected`,
                        icon: this.filters.selectedItems[0], // Show first item's icon
                        onRemove: () => {
                            this.filters.selectedItems = [];
                            this.saveFilters();
                            this.applyFilters();
                            this.renderTable();
                        },
                    });
                }
            }

            // Enhancement level filters
            if (this.filters.selectedEnhLevels.length > 0) {
                const levels = this.filters.selectedEnhLevels.sort((a, b) => a - b);
                if (levels.length === 1) {
                    const levelText = levels[0] > 0 ? `+${levels[0]}` : 'No Enhancement';
                    badges.push({
                        label: `Enh Lvl: ${levelText}`,
                        onRemove: () => {
                            this.filters.selectedEnhLevels = [];
                            this.saveFilters();
                            this.applyFilters();
                            this.renderTable();
                        },
                    });
                } else {
                    badges.push({
                        label: `Enh Lvl: ${levels.length} selected`,
                        onRemove: () => {
                            this.filters.selectedEnhLevels = [];
                            this.saveFilters();
                            this.applyFilters();
                            this.renderTable();
                        },
                    });
                }
            }

            // Type filters
            if (this.filters.selectedTypes.length > 0 && this.filters.selectedTypes.length < 2) {
                badges.push({
                    label: `Type: ${this.filters.selectedTypes.includes('buy') ? 'Buy' : 'Sell'}`,
                    onRemove: () => {
                        this.filters.selectedTypes = [];
                        this.saveFilters();
                        this.applyFilters();
                        this.renderTable();
                    },
                });
            }

            // Render badges
            badges.forEach((badge) => {
                const badgeEl = document.createElement('div');
                badgeEl.style.cssText = `
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 4px 8px;
                background: #3a3a3a;
                border: 1px solid #555;
                border-radius: 4px;
                color: #aaa;
                font-size: 13px;
            `;

                // Add icon if provided
                if (badge.icon) {
                    const itemsSpriteUrl = this.getItemsSpriteUrl();
                    if (itemsSpriteUrl) {
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('width', '16');
                        svg.setAttribute('height', '16');
                        svg.style.flexShrink = '0';

                        // Extract icon name and create use element with external sprite reference
                        const iconName = badge.icon.split('/').pop();
                        const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                        use.setAttribute('href', `${itemsSpriteUrl}#${iconName}`);
                        svg.appendChild(use);
                        badgeEl.appendChild(svg);
                    }
                }

                const label = document.createElement('span');
                label.textContent = badge.label;

                const removeBtn = document.createElement('button');
                removeBtn.textContent = '✕';
                removeBtn.style.cssText = `
                background: none;
                border: none;
                color: #aaa;
                cursor: pointer;
                padding: 0;
                font-size: 14px;
                line-height: 1;
            `;
                removeBtn.addEventListener('mouseenter', () => {
                    removeBtn.style.color = '#fff';
                });
                removeBtn.addEventListener('mouseleave', () => {
                    removeBtn.style.color = '#aaa';
                });
                removeBtn.addEventListener('click', badge.onRemove);

                badgeEl.appendChild(label);
                badgeEl.appendChild(removeBtn);
                container.appendChild(badgeEl);
            });
        }

        /**
         * Update Clear All Filters button visibility based on filter state
         */
        updateClearFiltersButton() {
            const controls = this.modal.querySelector('.mwi-market-history-controls');
            if (!controls) return;

            const hasActiveFilters =
                this.filters.dateFrom !== null ||
                this.filters.dateTo !== null ||
                this.filters.selectedItems.length > 0 ||
                this.filters.selectedEnhLevels.length > 0 ||
                (this.filters.selectedTypes.length > 0 && this.filters.selectedTypes.length < 2);

            const existingBtn = controls.querySelector('.mwi-clear-filters-button');

            if (hasActiveFilters && !existingBtn) {
                // Create button
                const clearFiltersBtn = document.createElement('button');
                clearFiltersBtn.className = 'mwi-clear-filters-button';
                clearFiltersBtn.textContent = 'Clear All Filters';
                clearFiltersBtn.style.cssText = `
                padding: 6px 12px;
                background: #e67e22;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                white-space: nowrap;
            `;
                clearFiltersBtn.addEventListener('mouseenter', () => {
                    clearFiltersBtn.style.background = '#d35400';
                });
                clearFiltersBtn.addEventListener('mouseleave', () => {
                    clearFiltersBtn.style.background = '#e67e22';
                });
                clearFiltersBtn.addEventListener('click', () => this.clearAllFilters());

                // Insert into right group (before K/M/B checkbox)
                const rightGroup = controls.children[3]; // Fourth child is rightGroup
                if (rightGroup) {
                    rightGroup.insertBefore(clearFiltersBtn, rightGroup.firstChild);
                }
            } else if (!hasActiveFilters && existingBtn) {
                // Remove button
                existingBtn.remove();
            }
        }

        /**
         * Render table with listings
         */
        renderTable() {
            this.renderControls();

            const tableContainer = this.modal.querySelector('.mwi-market-history-table-container');

            // Explicitly remove all children to ensure SVG elements are garbage collected
            while (tableContainer.firstChild) {
                tableContainer.removeChild(tableContainer.firstChild);
            }

            const table = document.createElement('table');
            table.style.cssText = `
            width: 100%;
            border-collapse: collapse;
            color: #fff;
        `;

            // Header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            headerRow.style.cssText = `
            background: #1a1a1a;
        `;

            const columns = [
                { key: 'createdTimestamp', label: 'Date' },
                { key: 'itemHrid', label: 'Item' },
                { key: 'enhancementLevel', label: 'Enh Lvl' },
                { key: 'isSell', label: 'Type' },
                { key: 'price', label: 'Price' },
                { key: 'orderQuantity', label: 'Quantity' },
                { key: 'filledQuantity', label: 'Filled' },
                { key: 'total', label: 'Total' },
            ];

            columns.forEach((col) => {
                const th = document.createElement('th');
                th.style.cssText = `
                padding: 10px;
                text-align: left;
                border-bottom: 2px solid #555;
                user-select: none;
                position: relative;
            `;

                // Create header content container
                const headerContent = document.createElement('div');
                headerContent.style.cssText = `
                display: flex;
                align-items: center;
                gap: 8px;
            `;

                // Label and sort indicator
                const labelSpan = document.createElement('span');
                labelSpan.textContent = col.label;
                labelSpan.style.cursor = 'pointer';

                // Sort indicator
                if (this.sortColumn === col.key) {
                    labelSpan.textContent += this.sortDirection === 'asc' ? ' ▲' : ' ▼';
                }

                // Sort click handler
                labelSpan.addEventListener('click', () => {
                    if (this.sortColumn === col.key) {
                        this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        this.sortColumn = col.key;
                        this.sortDirection = 'desc';
                    }
                    this.applyFilters();
                    this.renderTable();
                });

                headerContent.appendChild(labelSpan);

                // Add filter button for filterable columns
                const filterableColumns = ['createdTimestamp', 'itemHrid', 'enhancementLevel', 'isSell'];
                if (filterableColumns.includes(col.key)) {
                    const filterBtn = document.createElement('button');
                    filterBtn.textContent = '⋮';
                    filterBtn.style.cssText = `
                    background: none;
                    border: none;
                    color: #aaa;
                    cursor: pointer;
                    font-size: 16px;
                    padding: 2px 4px;
                    font-weight: bold;
                `;

                    // Check if filter is active
                    const hasActiveFilter = this.hasActiveFilter(col.key);
                    if (hasActiveFilter) {
                        filterBtn.style.color = '#4a90e2';
                        filterBtn.textContent = '⋮';
                    }

                    filterBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.showFilterPopup(col.key, filterBtn);
                    });

                    headerContent.appendChild(filterBtn);
                }

                th.appendChild(headerContent);
                headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Body
            const tbody = document.createElement('tbody');
            const paginatedListings = this.getPaginatedListings();

            if (paginatedListings.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = columns.length;
                cell.textContent = 'No listings found';
                cell.style.cssText = `
                padding: 20px;
                text-align: center;
                color: #888;
            `;
                row.appendChild(cell);
                tbody.appendChild(row);
            } else {
                paginatedListings.forEach((listing, index) => {
                    const row = document.createElement('tr');
                    row.style.cssText = `
                    border-bottom: 1px solid #333;
                    background: ${index % 2 === 0 ? '#2a2a2a' : '#252525'};
                `;

                    // Date
                    const dateCell = document.createElement('td');
                    // Use createdTimestamp if available, otherwise fall back to numeric timestamp
                    const dateValue = listing.createdTimestamp || listing.timestamp;
                    dateCell.textContent = new Date(dateValue).toLocaleString();
                    dateCell.style.padding = '4px 10px';
                    row.appendChild(dateCell);

                    // Item (with icon)
                    const itemCell = document.createElement('td');
                    itemCell.style.cssText = `
                    padding: 4px 10px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                `;

                    // Create SVG icon
                    const itemsSpriteUrl = this.getItemsSpriteUrl();
                    if (itemsSpriteUrl) {
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('width', '20');
                        svg.setAttribute('height', '20');

                        // Extract icon name and create use element with external sprite reference
                        const iconName = listing.itemHrid.split('/').pop();
                        const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                        use.setAttribute('href', `${itemsSpriteUrl}#${iconName}`);
                        svg.appendChild(use);

                        // Add icon
                        itemCell.appendChild(svg);
                    }

                    // Add text
                    const textSpan = document.createElement('span');
                    textSpan.textContent = this.getItemName(listing.itemHrid);
                    itemCell.appendChild(textSpan);

                    row.appendChild(itemCell);

                    // Enhancement
                    const enhCell = document.createElement('td');
                    enhCell.textContent = listing.enhancementLevel > 0 ? `+${listing.enhancementLevel}` : '-';
                    enhCell.style.padding = '4px 10px';
                    row.appendChild(enhCell);

                    // Type
                    const typeCell = document.createElement('td');
                    typeCell.textContent = listing.isSell ? 'Sell' : 'Buy';
                    typeCell.style.cssText = `
                    padding: 4px 10px;
                    color: ${listing.isSell ? '#4ade80' : '#60a5fa'};
                `;
                    row.appendChild(typeCell);

                    // Price
                    const priceCell = document.createElement('td');
                    priceCell.textContent = this.formatNumber(listing.price);
                    priceCell.style.padding = '4px 10px';
                    row.appendChild(priceCell);

                    // Quantity
                    const qtyCell = document.createElement('td');
                    qtyCell.textContent = this.formatNumber(listing.orderQuantity);
                    qtyCell.style.padding = '4px 10px';
                    row.appendChild(qtyCell);

                    // Filled
                    const filledCell = document.createElement('td');
                    filledCell.textContent = this.formatNumber(listing.filledQuantity);
                    filledCell.style.padding = '4px 10px';
                    row.appendChild(filledCell);

                    // Total (Price × Filled)
                    const totalCell = document.createElement('td');
                    const totalValue = listing.price * listing.filledQuantity;
                    totalCell.textContent = this.formatNumber(totalValue);
                    totalCell.style.padding = '4px 10px';
                    row.appendChild(totalCell);

                    tbody.appendChild(row);
                });
            }

            table.appendChild(tbody);
            tableContainer.appendChild(table);

            // Render pagination
            this.renderPagination();
        }

        /**
         * Render pagination controls
         */
        renderPagination() {
            const pagination = this.modal.querySelector('.mwi-market-history-pagination');

            // Explicitly remove all children to ensure proper cleanup
            while (pagination.firstChild) {
                pagination.removeChild(pagination.firstChild);
            }

            // Left side: Rows per page
            const leftSide = document.createElement('div');
            leftSide.style.cssText = `
            display: flex;
            gap: 8px;
            align-items: center;
            color: #aaa;
        `;

            const label = document.createElement('span');
            label.textContent = 'Rows per page:';

            const rowsInput = document.createElement('input');
            rowsInput.type = 'number';
            rowsInput.value = this.rowsPerPage;
            rowsInput.min = '1';
            rowsInput.disabled = this.showAll;
            rowsInput.style.cssText = `
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background: ${this.showAll ? '#333' : '#1a1a1a'};
            color: ${this.showAll ? '#666' : '#fff'};
        `;
            rowsInput.addEventListener('change', (e) => {
                this.rowsPerPage = Math.max(1, parseInt(e.target.value) || 50);
                this.currentPage = 1;
                this.renderTable();
            });

            const showAllCheckbox = document.createElement('input');
            showAllCheckbox.type = 'checkbox';
            showAllCheckbox.checked = this.showAll;
            showAllCheckbox.style.cssText = `
            cursor: pointer;
        `;
            showAllCheckbox.addEventListener('change', (e) => {
                this.showAll = e.target.checked;
                rowsInput.disabled = this.showAll;
                rowsInput.style.background = this.showAll ? '#333' : '#1a1a1a';
                rowsInput.style.color = this.showAll ? '#666' : '#fff';
                this.currentPage = 1;
                this.renderTable();
            });

            const showAllLabel = document.createElement('label');
            showAllLabel.textContent = 'Show All';
            showAllLabel.style.cssText = `
            cursor: pointer;
            color: #aaa;
        `;
            showAllLabel.prepend(showAllCheckbox);

            leftSide.appendChild(label);
            leftSide.appendChild(rowsInput);
            leftSide.appendChild(showAllLabel);

            // Right side: Page navigation
            const rightSide = document.createElement('div');
            rightSide.style.cssText = `
            display: flex;
            gap: 8px;
            align-items: center;
            color: #aaa;
        `;

            if (!this.showAll) {
                const totalPages = this.getTotalPages();

                const prevBtn = document.createElement('button');
                prevBtn.textContent = '◀';
                prevBtn.disabled = this.currentPage === 1;
                prevBtn.style.cssText = `
                padding: 4px 12px;
                background: ${this.currentPage === 1 ? '#333' : '#4a90e2'};
                color: ${this.currentPage === 1 ? '#666' : 'white'};
                border: none;
                border-radius: 4px;
                cursor: ${this.currentPage === 1 ? 'default' : 'pointer'};
            `;
                prevBtn.addEventListener('click', () => {
                    if (this.currentPage > 1) {
                        this.currentPage--;
                        this.renderTable();
                    }
                });

                const pageInfo = document.createElement('span');
                pageInfo.textContent = `Page ${this.currentPage} of ${totalPages}`;

                const nextBtn = document.createElement('button');
                nextBtn.textContent = '▶';
                nextBtn.disabled = this.currentPage === totalPages;
                nextBtn.style.cssText = `
                padding: 4px 12px;
                background: ${this.currentPage === totalPages ? '#333' : '#4a90e2'};
                color: ${this.currentPage === totalPages ? '#666' : 'white'};
                border: none;
                border-radius: 4px;
                cursor: ${this.currentPage === totalPages ? 'default' : 'pointer'};
            `;
                nextBtn.addEventListener('click', () => {
                    if (this.currentPage < totalPages) {
                        this.currentPage++;
                        this.renderTable();
                    }
                });

                rightSide.appendChild(prevBtn);
                rightSide.appendChild(pageInfo);
                rightSide.appendChild(nextBtn);
            } else {
                const showingInfo = document.createElement('span');
                showingInfo.textContent = `Showing all ${this.filteredListings.length} listings`;
                rightSide.appendChild(showingInfo);
            }

            pagination.appendChild(leftSide);
            pagination.appendChild(rightSide);
        }

        /**
         * Export listings to CSV
         */
        exportCSV() {
            const headers = ['Date', 'Item', 'Enhancement', 'Type', 'Price', 'Quantity', 'Filled', 'Total', 'ID'];
            const rows = this.filteredListings.map((listing) => [
                new Date(listing.createdTimestamp || listing.timestamp).toISOString(),
                this.getItemName(listing.itemHrid),
                listing.enhancementLevel || 0,
                listing.isSell ? 'Sell' : 'Buy',
                listing.price,
                listing.orderQuantity,
                listing.filledQuantity,
                listing.price * listing.filledQuantity, // Total
                listing.id,
            ]);

            const csv = [headers, ...rows].map((row) => row.map((cell) => `"${cell}"`).join(',')).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `market-history-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        /**
         * Import listings from CSV
         */
        async importCSV(csvText) {
            try {
                // Parse CSV
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    throw new Error('CSV file is empty or invalid');
                }

                // Parse header
                const _headerLine = lines[0];
                const _expectedHeaders = [
                    'Date',
                    'Item',
                    'Enhancement',
                    'Type',
                    'Price',
                    'Quantity',
                    'Filled',
                    'Total',
                    'ID',
                ];

                // Show progress message
                const progressMsg = document.createElement('div');
                progressMsg.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #2a2a2a;
                padding: 20px;
                border-radius: 8px;
                color: #fff;
                z-index: 10001;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            `;
                progressMsg.textContent = `Importing ${lines.length - 1} listings from CSV...`;
                document.body.appendChild(progressMsg);

                // Load existing listings
                const existingListings = await storage$1.getJSON(this.storageKey, 'marketListings', []);
                const existingIds = new Set(existingListings.map((l) => l.id));

                let imported = 0;
                let skipped = 0;

                // Build item name to HRID map
                const itemNameToHrid = {};
                const gameData = dataManager$1.getInitClientData();
                if (gameData?.itemDetailMap) {
                    for (const [hrid, details] of Object.entries(gameData.itemDetailMap)) {
                        if (details.name) {
                            itemNameToHrid[details.name] = hrid;
                        }
                    }
                }

                // Process each line
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    // Parse CSV row (handle quoted fields)
                    const fields = [];
                    let currentField = '';
                    let inQuotes = false;

                    for (let j = 0; j < line.length; j++) {
                        const char = line[j];
                        if (char === '"') {
                            inQuotes = !inQuotes;
                        } else if (char === ',' && !inQuotes) {
                            fields.push(currentField);
                            currentField = '';
                        } else {
                            currentField += char;
                        }
                    }
                    fields.push(currentField); // Add last field

                    if (fields.length < 9) {
                        console.warn(`[MarketHistoryViewer] Skipping invalid CSV row ${i}: ${line}`);
                        continue;
                    }

                    const [dateStr, itemName, enhStr, typeStr, priceStr, qtyStr, filledStr, _totalStr, idStr] = fields;

                    // Parse ID
                    const id = parseInt(idStr);
                    if (isNaN(id)) {
                        console.warn(`[MarketHistoryViewer] Skipping row with invalid ID: ${idStr}`);
                        continue;
                    }

                    // Skip duplicates
                    if (existingIds.has(id)) {
                        skipped++;
                        continue;
                    }

                    // Find item HRID from name
                    const itemHrid = itemNameToHrid[itemName];
                    if (!itemHrid) {
                        console.warn(`[MarketHistoryViewer] Could not find HRID for item: ${itemName}`);
                        skipped++;
                        continue;
                    }

                    // Create listing object
                    const listing = {
                        id: id,
                        timestamp: new Date(dateStr).getTime(),
                        createdTimestamp: dateStr,
                        itemHrid: itemHrid,
                        enhancementLevel: parseInt(enhStr) || 0,
                        price: parseFloat(priceStr),
                        orderQuantity: parseFloat(qtyStr),
                        filledQuantity: parseFloat(filledStr),
                        isSell: typeStr.toLowerCase() === 'sell',
                    };

                    existingListings.push(listing);
                    imported++;
                }

                // Save to storage
                await storage$1.setJSON(this.storageKey, existingListings, 'marketListings', true);

                // Remove progress message
                document.body.removeChild(progressMsg);

                // Show success message
                alert(
                    `Import complete!\n\nImported: ${imported} new listings\nSkipped: ${skipped} duplicates or invalid rows\nTotal: ${existingListings.length} listings`
                );

                // Reload and render table
                await this.loadListings();
                this.renderTable();
            } catch (error) {
                console.error('[MarketHistoryViewer] CSV import error:', error);
                throw error;
            }
        }

        /**
         * Show import dialog
         */
        showImportDialog() {
            // Create file input
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.txt,.json,.csv';
            fileInput.style.display = 'none';

            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();

                    // Detect file type and use appropriate import method
                    if (file.name.endsWith('.csv')) {
                        await this.importCSV(text);
                    } else {
                        await this.importEdibleToolsData(text);
                    }
                } catch (error) {
                    console.error('[MarketHistoryViewer] Import failed:', error);
                    alert(`Import failed: ${error.message}`);
                }
            });

            document.body.appendChild(fileInput);
            fileInput.click();
            document.body.removeChild(fileInput);
        }

        /**
         * Import market listing data (supports Edible Tools format)
         */
        async importEdibleToolsData(jsonText) {
            try {
                // Check for truncated file
                if (!jsonText.trim().endsWith('}')) {
                    throw new Error(
                        'File appears to be truncated or incomplete. The JSON does not end properly. ' +
                            'Try exporting from Edible Tools again, or export to CSV from the Market History Viewer and import that instead.'
                    );
                }

                // Parse the storage file
                const data = JSON.parse(jsonText);

                if (!data.market_list) {
                    throw new Error('No market_list found in file. Expected format: {"market_list": "[...]"}');
                }

                // Parse the market_list JSON string
                const marketList = JSON.parse(data.market_list);

                if (!Array.isArray(marketList) || marketList.length === 0) {
                    throw new Error('market_list is empty or invalid');
                }

                // Show progress message
                const progressMsg = document.createElement('div');
                progressMsg.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #2a2a2a;
                padding: 20px;
                border-radius: 8px;
                color: #fff;
                z-index: 10001;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            `;
                progressMsg.textContent = `Importing ${marketList.length} listings...`;
                document.body.appendChild(progressMsg);

                // Convert imported format to Toolasha format
                const existingListings = await storage$1.getJSON(this.storageKey, 'marketListings', []);
                const existingIds = new Set(existingListings.map((l) => l.id));

                let imported = 0;
                let skipped = 0;

                for (const etListing of marketList) {
                    // Skip if we already have this listing
                    if (existingIds.has(etListing.id)) {
                        skipped++;
                        continue;
                    }

                    // Convert to Toolasha format
                    const toolashaListing = {
                        id: etListing.id,
                        timestamp: new Date(etListing.createdTimestamp).getTime(),
                        createdTimestamp: etListing.createdTimestamp,
                        itemHrid: etListing.itemHrid,
                        enhancementLevel: etListing.enhancementLevel || 0,
                        price: etListing.price,
                        orderQuantity: etListing.orderQuantity,
                        filledQuantity: etListing.filledQuantity,
                        isSell: etListing.isSell,
                    };

                    existingListings.push(toolashaListing);
                    imported++;
                }

                // Save to storage
                await storage$1.setJSON(this.storageKey, existingListings, 'marketListings', true);

                // Remove progress message
                document.body.removeChild(progressMsg);

                // Show success message
                alert(
                    `Import complete!\n\nImported: ${imported} new listings\nSkipped: ${skipped} duplicates\nTotal: ${existingListings.length} listings`
                );

                // Reload and render table
                await this.loadListings();
                this.renderTable();
            } catch (error) {
                console.error('[MarketHistoryViewer] Import error:', error);
                throw error;
            }
        }

        /**
         * Clear all market history data
         */
        async clearHistory() {
            // Strong confirmation dialog
            const confirmed = confirm(
                `⚠️ WARNING: This will permanently delete ALL market history data!\n` +
                    `You are about to delete ${this.listings.length} listings.\n` +
                    `RECOMMENDATION: Export to CSV first using the "Export CSV" button.\n` +
                    `This action CANNOT be undone!\n` +
                    `Are you absolutely sure you want to continue?`
            );

            if (!confirmed) {
                return;
            }

            try {
                // Clear from storage
                await storage$1.setJSON(this.storageKey, [], 'marketListings', true);

                // Clear local data
                this.listings = [];
                this.filteredListings = [];

                // Show success message
                alert('Market history cleared successfully.');

                // Reload and render table (will show empty state)
                await this.loadListings();
                this.renderTable();
            } catch (error) {
                console.error('[MarketHistoryViewer] Failed to clear history:', error);
                alert(`Failed to clear history: ${error.message}`);
            }
        }

        /**
         * Get filtered listings excluding a specific filter type
         * Used for dynamic filter options - shows what's available given OTHER active filters
         * @param {string} excludeFilterType - Filter to exclude: 'date', 'item', 'enhancementLevel', 'type'
         * @returns {Array} Filtered listings
         */
        getFilteredListingsExcluding(excludeFilterType) {
            let filtered = [...this.listings];

            // Apply legacy type filter if set
            if (this.typeFilter === 'buy') {
                filtered = filtered.filter((listing) => !listing.isSell);
            } else if (this.typeFilter === 'sell') {
                filtered = filtered.filter((listing) => listing.isSell);
            }

            // Apply search term
            if (this.searchTerm) {
                const term = this.searchTerm.toLowerCase();
                filtered = filtered.filter((listing) => {
                    const itemName = this.getItemName(listing.itemHrid).toLowerCase();
                    return itemName.includes(term);
                });
            }

            // Apply date range filter (unless excluded)
            if (excludeFilterType !== 'date' && (this.filters.dateFrom || this.filters.dateTo)) {
                filtered = filtered.filter((listing) => {
                    const listingDate = new Date(listing.createdTimestamp || listing.timestamp);

                    if (this.filters.dateFrom && listingDate < this.filters.dateFrom) {
                        return false;
                    }

                    if (this.filters.dateTo) {
                        const endOfDay = new Date(this.filters.dateTo);
                        endOfDay.setHours(23, 59, 59, 999);
                        if (listingDate > endOfDay) {
                            return false;
                        }
                    }

                    return true;
                });
            }

            // Apply item filter (unless excluded)
            if (excludeFilterType !== 'item' && this.filters.selectedItems.length > 0) {
                filtered = filtered.filter((listing) => this.filters.selectedItems.includes(listing.itemHrid));
            }

            // Apply enhancement level filter (unless excluded)
            if (excludeFilterType !== 'enhancementLevel' && this.filters.selectedEnhLevels.length > 0) {
                filtered = filtered.filter((listing) => this.filters.selectedEnhLevels.includes(listing.enhancementLevel));
            }

            // Apply type filter (unless excluded)
            if (
                excludeFilterType !== 'type' &&
                this.filters.selectedTypes.length > 0 &&
                this.filters.selectedTypes.length < 2
            ) {
                const showBuy = this.filters.selectedTypes.includes('buy');
                const showSell = this.filters.selectedTypes.includes('sell');

                filtered = filtered.filter((listing) => {
                    if (showBuy && !listing.isSell) return true;
                    if (showSell && listing.isSell) return true;
                    return false;
                });
            }

            return filtered;
        }

        /**
         * Check if a column has an active filter
         * @param {string} columnKey - Column key to check
         * @returns {boolean} True if filter is active
         */
        hasActiveFilter(columnKey) {
            switch (columnKey) {
                case 'createdTimestamp':
                    return this.filters.dateFrom !== null || this.filters.dateTo !== null;
                case 'itemHrid':
                    return this.filters.selectedItems.length > 0;
                case 'enhancementLevel':
                    return this.filters.selectedEnhLevels.length > 0;
                case 'isSell':
                    return this.filters.selectedTypes.length > 0 && this.filters.selectedTypes.length < 2;
                default:
                    return false;
            }
        }

        /**
         * Show filter popup for a column
         * @param {string} columnKey - Column key
         * @param {HTMLElement} buttonElement - Button that triggered popup
         */
        showFilterPopup(columnKey, buttonElement) {
            // If clicking the same button that opened the current popup, close it (toggle behavior)
            if (this.activeFilterPopup && this.activeFilterButton === buttonElement) {
                this.activeFilterPopup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
                if (this.popupCloseHandler) {
                    document.removeEventListener('click', this.popupCloseHandler);
                    this.popupCloseHandler = null;
                }
                return;
            }

            // Close any existing popup and remove its event listener
            if (this.activeFilterPopup) {
                this.activeFilterPopup.remove();
                this.activeFilterPopup = null;
            }
            if (this.popupCloseHandler) {
                document.removeEventListener('click', this.popupCloseHandler);
                this.popupCloseHandler = null;
            }

            // Create popup based on column type
            let popup;
            switch (columnKey) {
                case 'createdTimestamp':
                    popup = this.createDateFilterPopup();
                    break;
                case 'itemHrid':
                    popup = this.createItemFilterPopup();
                    break;
                case 'enhancementLevel':
                    popup = this.createEnhancementFilterPopup();
                    break;
                case 'isSell':
                    popup = this.createTypeFilterPopup();
                    break;
                default:
                    return;
            }

            // Position popup below button
            const buttonRect = buttonElement.getBoundingClientRect();
            popup.style.position = 'fixed';
            popup.style.top = `${buttonRect.bottom + 5}px`;
            popup.style.left = `${buttonRect.left}px`;
            popup.style.zIndex = '10002';

            document.body.appendChild(popup);
            this.activeFilterPopup = popup;
            this.activeFilterButton = buttonElement; // Track which button opened this popup

            // Close popup when clicking outside
            this.popupCloseHandler = (e) => {
                // Don't close if clicking on date inputs or their calendar pickers
                if (e.target.type === 'date' || e.target.closest('input[type="date"]')) {
                    return;
                }

                if (!popup.contains(e.target) && e.target !== buttonElement) {
                    popup.remove();
                    this.activeFilterPopup = null;
                    this.activeFilterButton = null;
                    document.removeEventListener('click', this.popupCloseHandler);
                    this.popupCloseHandler = null;
                }
            };
            const popupTimeout = setTimeout(() => document.addEventListener('click', this.popupCloseHandler), 10);
            this.timerRegistry.registerTimeout(popupTimeout);
        }

        /**
         * Create date filter popup
         * @returns {HTMLElement} Popup element
         */
        createDateFilterPopup() {
            const popup = document.createElement('div');
            popup.style.cssText = `
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 12px;
            min-width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        `;

            // Title
            const title = document.createElement('div');
            title.textContent = 'Filter by Date';
            title.style.cssText = `
            color: #fff;
            font-weight: bold;
            margin-bottom: 10px;
        `;
            popup.appendChild(title);

            // Get date range from filtered listings (excluding date filter itself)
            // Cache the result to avoid recalculating on every popup open
            if (!this.cachedDateRange) {
                const filteredListings = this.getFilteredListingsExcluding('date');

                if (filteredListings.length > 0) {
                    // Use timestamps directly to avoid creating Date objects unnecessarily
                    const timestamps = filteredListings.map((l) => l.timestamp || new Date(l.createdTimestamp).getTime());
                    this.cachedDateRange = {
                        minDate: new Date(Math.min(...timestamps)),
                        maxDate: new Date(Math.max(...timestamps)),
                    };
                } else {
                    this.cachedDateRange = { minDate: null, maxDate: null };
                }
            }

            const { minDate, maxDate } = this.cachedDateRange;

            if (minDate && maxDate) {
                // Show available date range
                const rangeInfo = document.createElement('div');
                rangeInfo.style.cssText = `
                color: #aaa;
                font-size: 11px;
                margin-bottom: 10px;
                padding: 6px;
                background: #1a1a1a;
                border-radius: 3px;
            `;
                rangeInfo.textContent = `Available: ${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}`;
                popup.appendChild(rangeInfo);
            }

            // From date
            const fromLabel = document.createElement('label');
            fromLabel.textContent = 'From:';
            fromLabel.style.cssText = `
            display: block;
            color: #aaa;
            margin-bottom: 4px;
            font-size: 12px;
        `;

            const fromInput = document.createElement('input');
            fromInput.type = 'date';
            fromInput.value = this.filters.dateFrom ? this.filters.dateFrom.toISOString().split('T')[0] : '';
            if (minDate) fromInput.min = minDate.toISOString().split('T')[0];
            if (maxDate) fromInput.max = maxDate.toISOString().split('T')[0];
            fromInput.style.cssText = `
            width: 100%;
            padding: 6px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #fff;
            margin-bottom: 10px;
        `;

            // To date
            const toLabel = document.createElement('label');
            toLabel.textContent = 'To:';
            toLabel.style.cssText = `
            display: block;
            color: #aaa;
            margin-bottom: 4px;
            font-size: 12px;
        `;

            const toInput = document.createElement('input');
            toInput.type = 'date';
            toInput.value = this.filters.dateTo ? this.filters.dateTo.toISOString().split('T')[0] : '';
            if (minDate) toInput.min = minDate.toISOString().split('T')[0];
            if (maxDate) toInput.max = maxDate.toISOString().split('T')[0];
            toInput.style.cssText = `
            width: 100%;
            padding: 6px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #fff;
            margin-bottom: 10px;
        `;

            // Buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
            display: flex;
            gap: 8px;
            margin-top: 10px;
        `;

            const applyBtn = document.createElement('button');
            applyBtn.textContent = 'Apply';
            applyBtn.style.cssText = `
            flex: 1;
            padding: 6px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        `;
            applyBtn.addEventListener('click', () => {
                this.filters.dateFrom = fromInput.value ? new Date(fromInput.value) : null;
                this.filters.dateTo = toInput.value ? new Date(toInput.value) : null;
                this.saveFilters();
                this.applyFilters();
                this.renderTable();
                popup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
            });

            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = `
            flex: 1;
            padding: 6px;
            background: #666;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        `;
            clearBtn.addEventListener('click', () => {
                this.filters.dateFrom = null;
                this.filters.dateTo = null;
                this.saveFilters();
                this.applyFilters();
                this.renderTable();
                popup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
            });

            buttonContainer.appendChild(applyBtn);
            buttonContainer.appendChild(clearBtn);

            popup.appendChild(fromLabel);
            popup.appendChild(fromInput);
            popup.appendChild(toLabel);
            popup.appendChild(toInput);
            popup.appendChild(buttonContainer);

            return popup;
        }

        /**
         * Create item filter popup
         * @returns {HTMLElement} Popup element
         */
        createItemFilterPopup() {
            const popup = document.createElement('div');
            popup.style.cssText = `
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 12px;
            min-width: 300px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        `;

            // Title
            const title = document.createElement('div');
            title.textContent = 'Filter by Item';
            title.style.cssText = `
            color: #fff;
            font-weight: bold;
            margin-bottom: 10px;
        `;
            popup.appendChild(title);

            // Search box
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'Search items...';
            searchInput.style.cssText = `
            width: 100%;
            padding: 6px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #fff;
            margin-bottom: 8px;
        `;

            popup.appendChild(searchInput);

            // Get unique items from filtered listings (excluding item filter itself)
            const filteredListings = this.getFilteredListingsExcluding('item');
            const itemHrids = [...new Set(filteredListings.map((l) => l.itemHrid))];
            const itemsWithNames = itemHrids.map((hrid) => ({
                hrid,
                name: this.getItemName(hrid),
            }));
            itemsWithNames.sort((a, b) => a.name.localeCompare(b.name));

            // Checkboxes container
            const checkboxContainer = document.createElement('div');
            checkboxContainer.style.cssText = `
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            max-height: 250px;
        `;

            const renderCheckboxes = (filterText = '') => {
                // Explicitly remove all children to ensure proper cleanup
                while (checkboxContainer.firstChild) {
                    checkboxContainer.removeChild(checkboxContainer.firstChild);
                }

                const filtered = filterText
                    ? itemsWithNames.filter((item) => item.name.toLowerCase().includes(filterText.toLowerCase()))
                    : itemsWithNames;

                filtered.forEach((item) => {
                    const label = document.createElement('label');
                    label.style.cssText = `
                    display: block;
                    color: #fff;
                    padding: 4px;
                    cursor: pointer;
                `;

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = this.filters.selectedItems.includes(item.hrid);
                    checkbox.style.marginRight = '6px';

                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(item.name));
                    checkboxContainer.appendChild(label);

                    checkbox.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            if (!this.filters.selectedItems.includes(item.hrid)) {
                                this.filters.selectedItems.push(item.hrid);
                            }
                        } else {
                            const index = this.filters.selectedItems.indexOf(item.hrid);
                            if (index > -1) {
                                this.filters.selectedItems.splice(index, 1);
                            }
                        }
                    });
                });
            };

            renderCheckboxes();
            searchInput.addEventListener('input', (e) => renderCheckboxes(e.target.value));

            popup.appendChild(checkboxContainer);

            // Buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
            display: flex;
            gap: 8px;
        `;

            const applyBtn = document.createElement('button');
            applyBtn.textContent = 'Apply';
            applyBtn.style.cssText = `
            flex: 1;
            padding: 6px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        `;
            applyBtn.addEventListener('click', () => {
                this.saveFilters();
                this.applyFilters();
                this.renderTable();
                popup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
            });

            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = `
            flex: 1;
            padding: 6px;
            background: #666;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        `;
            clearBtn.addEventListener('click', () => {
                this.filters.selectedItems = [];
                this.saveFilters();
                this.applyFilters();
                this.renderTable();
                popup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
            });

            buttonContainer.appendChild(applyBtn);
            buttonContainer.appendChild(clearBtn);
            popup.appendChild(buttonContainer);

            return popup;
        }

        /**
         * Create enhancement level filter popup
         * @returns {HTMLElement} Popup element
         */
        createEnhancementFilterPopup() {
            const popup = document.createElement('div');
            popup.style.cssText = `
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 12px;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        `;

            // Title
            const title = document.createElement('div');
            title.textContent = 'Filter by Enhancement Level';
            title.style.cssText = `
            color: #fff;
            font-weight: bold;
            margin-bottom: 10px;
        `;
            popup.appendChild(title);

            // Get unique enhancement levels from filtered listings (excluding enhancement filter itself)
            const filteredListings = this.getFilteredListingsExcluding('enhancementLevel');
            const enhLevels = [...new Set(filteredListings.map((l) => l.enhancementLevel))];
            enhLevels.sort((a, b) => a - b);

            // Checkboxes
            const checkboxContainer = document.createElement('div');
            checkboxContainer.style.cssText = `
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 10px;
        `;

            enhLevels.forEach((level) => {
                const label = document.createElement('label');
                label.style.cssText = `
                display: block;
                color: #fff;
                padding: 4px;
                cursor: pointer;
            `;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = this.filters.selectedEnhLevels.includes(level);
                checkbox.style.marginRight = '6px';

                const levelText = level > 0 ? `+${level}` : 'No Enhancement';

                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(levelText));
                checkboxContainer.appendChild(label);

                checkbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        if (!this.filters.selectedEnhLevels.includes(level)) {
                            this.filters.selectedEnhLevels.push(level);
                        }
                    } else {
                        const index = this.filters.selectedEnhLevels.indexOf(level);
                        if (index > -1) {
                            this.filters.selectedEnhLevels.splice(index, 1);
                        }
                    }
                });
            });

            popup.appendChild(checkboxContainer);

            // Buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
            display: flex;
            gap: 8px;
        `;

            const applyBtn = document.createElement('button');
            applyBtn.textContent = 'Apply';
            applyBtn.style.cssText = `
            flex: 1;
            padding: 6px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        `;
            applyBtn.addEventListener('click', () => {
                this.saveFilters();
                this.applyFilters();
                this.renderTable();
                popup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
            });

            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = `
            flex: 1;
            padding: 6px;
            background: #666;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        `;
            clearBtn.addEventListener('click', () => {
                this.filters.selectedEnhLevels = [];
                this.saveFilters();
                this.applyFilters();
                this.renderTable();
                popup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
            });

            buttonContainer.appendChild(applyBtn);
            buttonContainer.appendChild(clearBtn);
            popup.appendChild(buttonContainer);

            return popup;
        }

        /**
         * Create type filter popup (Buy/Sell)
         * @returns {HTMLElement} Popup element
         */
        createTypeFilterPopup() {
            const popup = document.createElement('div');
            popup.style.cssText = `
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 12px;
            min-width: 150px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        `;

            // Title
            const title = document.createElement('div');
            title.textContent = 'Filter by Type';
            title.style.cssText = `
            color: #fff;
            font-weight: bold;
            margin-bottom: 10px;
        `;
            popup.appendChild(title);

            // Check which types exist in filtered listings (excluding type filter itself)
            const filteredListings = this.getFilteredListingsExcluding('type');
            const hasBuyOrders = filteredListings.some((l) => !l.isSell);
            const hasSellOrders = filteredListings.some((l) => l.isSell);

            // Buy checkbox
            if (hasBuyOrders) {
                const buyLabel = document.createElement('label');
                buyLabel.style.cssText = `
                display: block;
                color: #fff;
                padding: 4px;
                cursor: pointer;
                margin-bottom: 6px;
            `;

                const buyCheckbox = document.createElement('input');
                buyCheckbox.type = 'checkbox';
                buyCheckbox.checked = this.filters.selectedTypes.includes('buy');
                buyCheckbox.style.marginRight = '6px';

                buyLabel.appendChild(buyCheckbox);
                buyLabel.appendChild(document.createTextNode('Buy Orders'));
                popup.appendChild(buyLabel);

                buyCheckbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        if (!this.filters.selectedTypes.includes('buy')) {
                            this.filters.selectedTypes.push('buy');
                        }
                    } else {
                        const index = this.filters.selectedTypes.indexOf('buy');
                        if (index > -1) {
                            this.filters.selectedTypes.splice(index, 1);
                        }
                    }
                });
            }

            // Sell checkbox
            if (hasSellOrders) {
                const sellLabel = document.createElement('label');
                sellLabel.style.cssText = `
                display: block;
                color: #fff;
                padding: 4px;
                cursor: pointer;
            `;

                const sellCheckbox = document.createElement('input');
                sellCheckbox.type = 'checkbox';
                sellCheckbox.checked = this.filters.selectedTypes.includes('sell');
                sellCheckbox.style.marginRight = '6px';

                sellLabel.appendChild(sellCheckbox);
                sellLabel.appendChild(document.createTextNode('Sell Orders'));
                popup.appendChild(sellLabel);

                sellCheckbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        if (!this.filters.selectedTypes.includes('sell')) {
                            this.filters.selectedTypes.push('sell');
                        }
                    } else {
                        const index = this.filters.selectedTypes.indexOf('sell');
                        if (index > -1) {
                            this.filters.selectedTypes.splice(index, 1);
                        }
                    }
                });
            }

            // Buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
            display: flex;
            gap: 8px;
            margin-top: 10px;
        `;

            const applyBtn = document.createElement('button');
            applyBtn.textContent = 'Apply';
            applyBtn.style.cssText = `
            flex: 1;
            padding: 6px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        `;
            applyBtn.addEventListener('click', () => {
                this.saveFilters();
                this.applyFilters();
                this.renderTable();
                popup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
            });

            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.style.cssText = `
            flex: 1;
            padding: 6px;
            background: #666;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        `;
            clearBtn.addEventListener('click', () => {
                this.filters.selectedTypes = [];
                this.saveFilters();
                this.applyFilters();
                this.renderTable();
                popup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
            });

            buttonContainer.appendChild(applyBtn);
            buttonContainer.appendChild(clearBtn);
            popup.appendChild(buttonContainer);

            return popup;
        }

        /**
         * Clear all active filters
         */
        async clearAllFilters() {
            this.filters.dateFrom = null;
            this.filters.dateTo = null;
            this.filters.selectedItems = [];
            this.filters.selectedEnhLevels = [];
            this.filters.selectedTypes = [];

            await this.saveFilters();
            this.applyFilters();
            this.renderTable();
        }

        /**
         * Disable the feature
         */
        disable() {
            // Note: We don't need to disconnect observer since we're using the shared settings UI observer

            // Clean up any active filter popup and its event listener
            if (this.activeFilterPopup) {
                this.activeFilterPopup.remove();
                this.activeFilterPopup = null;
                this.activeFilterButton = null;
            }
            if (this.popupCloseHandler) {
                document.removeEventListener('click', this.popupCloseHandler);
                this.popupCloseHandler = null;
            }

            this.timerRegistry.clearAll();

            // Remove modal and all its event listeners
            if (this.modal) {
                this.modal.remove();
                this.modal = null;
            }

            // Remove settings button
            const button = document.querySelector('.mwi-market-history-button');
            if (button) {
                button.remove();
            }

            // Clear data references
            this.listings = [];
            this.filteredListings = [];
            this.cachedDateRange = null;

            this.isInitialized = false;
        }
    }

    const marketHistoryViewer = new MarketHistoryViewer();

    /**
     * Philosopher's Stone Transmutation Calculator
     *
     * Calculates expected value and ROI for transmuting items into Philosopher's Stones.
     * Shows a sortable table of all items that can transmute into philos with live market data.
     */


    const PHILO_HRID = '/items/philosophers_stone';
    const PRIME_CATALYST_HRID = '/items/prime_catalyst';
    const PRIME_CATALYST_ADDITIVE_BONUS = 0.25; // 25% additive boost
    const TRANSMUTE_ACTION_TIME_SECONDS = 20;
    const CATALYTIC_TEA_BUFF_TYPE = '/buff_types/alchemy_success';

    class PhiloCalculator {
        constructor() {
            this.isInitialized = false;
            this.modal = null;
            this.sortColumn = 'cost';
            this.sortDirection = 'desc';

            // User-editable inputs
            this.philoPrice = 0;
            this.catalystPrice = 0;
            this.useCatalyst = true;
            this.useCatalyticTea = false;
            this.catalyticTeaRatioBoost = 0;
            this.drinkConcentrationLevel = 0; // 0-20
            this.hideNegativeProfitItems = true;
            this.filterText = '';

            // Cached row data
            this.rows = [];
        }

        /**
         * Initialize the feature
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('market_showPhiloCalculator')) {
                return;
            }

            this.isInitialized = true;
            this.addSettingsButton();
        }

        /**
         * Disable / cleanup the feature
         */
        disable() {
            if (this.modal) {
                this.modal.remove();
                this.modal = null;
            }
            this.isInitialized = false;
        }

        /**
         * Add "Philo Gamba" button to settings panel
         */
        addSettingsButton() {
            const ensureButtonExists = () => {
                const settingsPanel = document.querySelector('[class*="SettingsPanel"]');
                if (!settingsPanel) return;

                if (settingsPanel.querySelector('.mwi-philo-calc-button')) {
                    return;
                }

                const button = document.createElement('button');
                button.className = 'mwi-philo-calc-button';
                button.textContent = 'Philo Gamba';
                button.style.cssText = `
                margin: 10px;
                padding: 8px 16px;
                background: #4a90e2;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;

                button.addEventListener('mouseenter', () => {
                    button.style.background = '#357abd';
                });

                button.addEventListener('mouseleave', () => {
                    button.style.background = '#4a90e2';
                });

                button.addEventListener('click', () => {
                    this.openModal();
                });

                // Insert after the market history button if it exists, otherwise at top
                const historyButton = settingsPanel.querySelector('.mwi-market-history-button');
                if (historyButton) {
                    historyButton.after(button);
                } else {
                    settingsPanel.insertBefore(button, settingsPanel.firstChild);
                }
            };

            const settingsUI = window.Toolasha?.UI?.settingsUI;
            if (settingsUI && typeof settingsUI.onSettingsPanelAppear === 'function') {
                settingsUI.onSettingsPanelAppear(ensureButtonExists);
            }

            ensureButtonExists();
        }

        /**
         * Get item name from game data
         * @param {string} itemHrid - Item HRID
         * @returns {string} Item name
         */
        getItemName(itemHrid) {
            const initData = dataManager$1.getInitClientData();
            const itemData = initData?.itemDetailMap?.[itemHrid];
            return itemData?.name || itemHrid.replace('/items/', '').replaceAll('_', ' ');
        }

        /**
         * Load default prices from market data
         */
        loadDefaultPrices() {
            const philoPriceData = marketAPI.getPrice(PHILO_HRID, 0);
            this.philoPrice = philoPriceData?.bid || 0;

            const catalystPriceData = marketAPI.getPrice(PRIME_CATALYST_HRID, 0);
            this.catalystPrice = catalystPriceData?.ask || 0;
        }

        /**
         * Calculate catalytic tea base bonus from game data (item definition)
         * @returns {number} Base ratioBoost from item definition
         */
        calculateCatalyticTeaRatioBoost() {
            try {
                const gameData = dataManager$1.getInitClientData();
                if (!gameData?.itemDetailMap) return 0;

                const teaItem = gameData.itemDetailMap['/items/catalytic_tea'];
                if (!teaItem?.consumableDetail?.buffs) return 0;

                // Find alchemy success buff
                for (const buff of teaItem.consumableDetail.buffs) {
                    if (buff.typeHrid === CATALYTIC_TEA_BUFF_TYPE) {
                        return buff.ratioBoost || 0;
                    }
                }

                return 0;
            } catch (error) {
                console.error('[PhiloCalculator] Failed to calculate catalytic tea ratio boost:', error);
                return 0;
            }
        }

        /**
         * Load settings from storage
         */
        async loadSettings() {
            try {
                const saved = await storage$1.getJSON('philoCalculatorSettings', 'settings', null);
                if (saved) {
                    this.useCatalyst = saved.useCatalyst !== false;
                    this.useCatalyticTea = saved.useCatalyticTea || false;
                    this.drinkConcentrationLevel = saved.drinkConcentrationLevel || 0;
                    this.hideNegativeProfitItems = saved.hideNegativeProfitItems !== false;
                    this.filterText = saved.filterText || '';
                }
            } catch (error) {
                console.error('[PhiloCalculator] Failed to load settings:', error);
            }
        }

        /**
         * Save settings to storage
         */
        async saveSettings() {
            try {
                await storage$1.setJSON(
                    'philoCalculatorSettings',
                    {
                        useCatalyst: this.useCatalyst,
                        useCatalyticTea: this.useCatalyticTea,
                        drinkConcentrationLevel: this.drinkConcentrationLevel,
                        hideNegativeProfitItems: this.hideNegativeProfitItems,
                        filterText: this.filterText,
                    },
                    'settings',
                    true
                );
            } catch (error) {
                console.error('[PhiloCalculator] Failed to save settings:', error);
            }
        }

        /**
         * Get drink concentration for a given enhancement level
         * @param {number} enhancementLevel - Enhancement level (0-20)
         * @returns {number} Drink concentration as decimal (e.g., 0.1032 for 10.32%)
         */
        getDrinkConcentrationForLevel(enhancementLevel) {
            try {
                const gameData = dataManager$1.getInitClientData();
                const equipment = dataManager$1.getEquipment();
                if (!equipment || !gameData?.itemDetailMap) return 0;

                let totalConcentration = 0;
                const baseConcentrationByLevel = new Map();

                // Scan equipment for drink concentration items and their base values
                for (const [_slotHrid, equippedItem] of equipment) {
                    const itemDetails = gameData.itemDetailMap[equippedItem.itemHrid];
                    if (!itemDetails?.equipmentDetail?.noncombatStats?.drinkConcentration) continue;

                    const baseConcentration = itemDetails.equipmentDetail.noncombatStats.drinkConcentration;
                    baseConcentrationByLevel.set(equippedItem.itemHrid, baseConcentration);
                }

                // If we have drink concentration items, apply the requested enhancement level
                for (const [itemHrid, baseConcentration] of baseConcentrationByLevel) {
                    const itemDetails = gameData.itemDetailMap[itemHrid];
                    const multiplier = getEnhancementMultiplier(itemDetails, enhancementLevel);
                    totalConcentration += baseConcentration * multiplier;
                }

                return totalConcentration;
            } catch (error) {
                console.error('[PhiloCalculator] Failed to get drink concentration:', error);
                return 0;
            }
        }

        /**
         * Scan itemDetailMap for all items that can transmute into Philosopher's Stone
         * @returns {Array} Array of { itemHrid, itemDetails } objects
         */
        findPhiloTransmuteItems() {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData?.itemDetailMap) return [];

            const results = [];

            for (const [itemHrid, itemDetails] of Object.entries(gameData.itemDetailMap)) {
                const alchemy = itemDetails?.alchemyDetail;
                if (!alchemy?.transmuteDropTable || !alchemy.transmuteSuccessRate) continue;

                const hasPhilo = alchemy.transmuteDropTable.some((drop) => drop.itemHrid === PHILO_HRID);
                if (hasPhilo) {
                    results.push({ itemHrid, itemDetails });
                }
            }

            return results;
        }

        /**
         * Calculate all columns for a single item
         * @param {string} itemHrid - Item HRID
         * @param {Object} itemDetails - Item detail object
         * @returns {Object|null} Row data or null if price unavailable
         */
        calculateRow(itemHrid, itemDetails) {
            const alchemy = itemDetails.alchemyDetail;
            const baseTransmuteRate = alchemy.transmuteSuccessRate;

            // Calculate additive bonuses
            let totalBonus = 0;

            // Catalytic tea bonus
            if (this.useCatalyticTea && this.catalyticTeaRatioBoost > 0) {
                const drinkConcentration = this.getDrinkConcentrationForLevel(this.drinkConcentrationLevel);
                totalBonus += this.catalyticTeaRatioBoost * (1 + drinkConcentration);
            }

            // Prime catalyst bonus (additive, not multiplicative)
            if (this.useCatalyst) {
                totalBonus += PRIME_CATALYST_ADDITIVE_BONUS;
            }

            const successRate = Math.min(1.0, baseTransmuteRate * (1 + totalBonus));
            const bulkMultiplier = alchemy.bulkMultiplier || 1;

            // Find philo drop rate
            const philoDrop = alchemy.transmuteDropTable.find((d) => d.itemHrid === PHILO_HRID);
            if (!philoDrop) return null;

            const philoDropRate = philoDrop.dropRate;
            const philoChance = successRate * philoDropRate;

            // Get item cost (market ask price)
            const priceData = marketAPI.getPrice(itemHrid, 0);
            const itemCost = priceData?.ask;
            if (itemCost === null || itemCost === undefined) return null;

            // Catalyst cost per action (consumed only on success)
            const catalystCostPerAction = this.useCatalyst ? successRate * this.catalystPrice : 0;

            // Transmute coin cost from game data
            const gameData = dataManager$1.getInitClientData();
            const transmuteAction = gameData?.actionDetailMap?.['/actions/alchemy/transmute'];
            const coinCost = transmuteAction?.coinCost || 0;

            // Total cost per transmute action
            const totalCostPerAction = itemCost * bulkMultiplier + catalystCostPerAction + coinCost;

            // Calculate EV of all drops (including philo)
            let evPerAction = 0;
            for (const drop of alchemy.transmuteDropTable) {
                let dropValue;
                if (drop.itemHrid === PHILO_HRID) {
                    dropValue = this.philoPrice;
                } else {
                    const dropPrice = marketAPI.getPrice(drop.itemHrid, 0);
                    dropValue = dropPrice?.bid;
                    if (dropValue === null || dropValue === undefined) continue;
                }

                const avgCount = (drop.minCount + drop.maxCount) / 2;
                evPerAction += successRate * drop.dropRate * avgCount * dropValue;
            }

            // Profit per action (EV now includes philo value)
            const profitPerAction = evPerAction - totalCostPerAction;

            // Actions and items needed per philo
            const actionsPerPhilo = 1 / philoChance;

            // Net items consumed per action (input minus expected self-returns)
            const selfDrop = alchemy.transmuteDropTable.find((d) => d.itemHrid === itemHrid);
            const selfDropRate = selfDrop ? selfDrop.dropRate : 0;
            const avgSelfCount = selfDrop ? (selfDrop.minCount + selfDrop.maxCount) / 2 : 0;
            const returnChance = successRate * selfDropRate;
            const itemsPerAction = bulkMultiplier - returnChance * avgSelfCount;

            // Items needed per philo (net items consumed × actions needed)
            const itemsPerPhilo = actionsPerPhilo * itemsPerAction;

            // Profit per philo obtained
            const profitPerPhilo = profitPerAction * actionsPerPhilo;

            // Profit margin
            const profitMargin = profitPerAction / totalCostPerAction;

            // Time per philo
            const timePerPhiloSeconds = actionsPerPhilo * TRANSMUTE_ACTION_TIME_SECONDS;

            // Profit per hour
            const actionsPerHour = 3600 / TRANSMUTE_ACTION_TIME_SECONDS;
            const profitPerHour = profitPerAction * actionsPerHour;

            // Revenue and cost per hour
            const revenuePerHour = evPerAction * actionsPerHour;
            const costPerHour = totalCostPerAction * actionsPerHour;

            return {
                itemHrid,
                name: this.getItemName(itemHrid),
                cost: itemCost,
                philoChance,
                returnChance,
                transmuteChance: baseTransmuteRate,
                effectiveTransmuteChance: successRate,
                transmuteCost: totalCostPerAction,
                ev: evPerAction,
                itemsPerAction,
                actionsPerPhilo,
                itemsPerPhilo,
                profitPerPhilo,
                profitMargin,
                timePerPhiloSeconds,
                profitPerHour,
                revenuePerHour,
                costPerHour,
            };
        }

        /**
         * Calculate all rows
         */
        calculateAllRows() {
            const items = this.findPhiloTransmuteItems();
            this.rows = [];

            for (const { itemHrid, itemDetails } of items) {
                const row = this.calculateRow(itemHrid, itemDetails);
                if (row) {
                    this.rows.push(row);
                }
            }

            this.sortRows();
        }

        /**
         * Sort rows by current sort column and direction
         */
        sortRows() {
            const col = this.sortColumn;
            const dir = this.sortDirection === 'asc' ? 1 : -1;

            this.rows.sort((a, b) => {
                const aVal = a[col];
                const bVal = b[col];

                if (typeof aVal === 'string') {
                    return dir * aVal.localeCompare(bVal);
                }
                return dir * (aVal - bVal);
            });
        }

        /**
         * Handle column header click for sorting
         * @param {string} column - Column key to sort by
         */
        toggleSort(column) {
            if (this.sortColumn === column) {
                this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                this.sortColumn = column;
                this.sortDirection = 'desc';
            }
            this.sortRows();
            this.renderTable();
        }

        /**
         * Open the calculator modal
         */
        async openModal() {
            if (this.modal) {
                this.modal.remove();
            }

            // Load saved settings first
            await this.loadSettings();

            this.loadDefaultPrices();
            this.catalyticTeaRatioBoost = this.calculateCatalyticTeaRatioBoost();

            // Set default drink concentration level (only if not previously saved)
            if (this.drinkConcentrationLevel === 0) {
                let currentDrinkEnhancementLevel = 0;
                const gameData = dataManager$1.getInitClientData();
                const equipment = dataManager$1.getEquipment();
                if (equipment && gameData?.itemDetailMap) {
                    for (const [_slotHrid, equippedItem] of equipment) {
                        const itemDetails = gameData.itemDetailMap[equippedItem.itemHrid];
                        if (itemDetails?.equipmentDetail?.noncombatStats?.drinkConcentration) {
                            currentDrinkEnhancementLevel = equippedItem.enhancementLevel || 0;
                            break;
                        }
                    }
                }
                this.drinkConcentrationLevel = currentDrinkEnhancementLevel;
            }

            this.calculateAllRows();

            this.modal = document.createElement('div');
            this.modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
            background: #2a2a2a;
            color: #ffffff;
            border-radius: 8px;
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        `;

            // Header
            const header = document.createElement('div');
            header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #444;
        `;
            header.innerHTML = `
            <span style="font-size: 18px; font-weight: bold;">Philosopher's Stone Calculator</span>
        `;

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '\u00D7';
            closeBtn.style.cssText = `
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            padding: 0 4px;
        `;
            closeBtn.addEventListener('click', () => {
                this.modal.remove();
                this.modal = null;
            });
            header.appendChild(closeBtn);

            // Controls
            const controls = this.createControls();

            // Table container
            const tableContainer = document.createElement('div');
            tableContainer.className = 'philo-calc-table-container';
            tableContainer.style.cssText = `
            overflow: auto;
            flex: 1;
            padding: 0 20px 20px;
        `;

            dialog.appendChild(header);
            dialog.appendChild(controls);
            dialog.appendChild(tableContainer);
            this.modal.appendChild(dialog);

            // Close on backdrop click
            this.modal.addEventListener('click', (e) => {
                if (e.target === this.modal) {
                    this.modal.remove();
                    this.modal = null;
                }
            });

            // Close on Escape key
            const escHandler = (e) => {
                if (e.key === 'Escape' && this.modal) {
                    this.modal.remove();
                    this.modal = null;
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);

            document.body.appendChild(this.modal);
            this.renderTable();
        }

        /**
         * Create the input controls section (philo price, catalyst price, checkbox)
         * @returns {HTMLElement} Controls container
         */
        createControls() {
            const container = document.createElement('div');
            container.style.cssText = `
            padding: 12px 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid #444;
        `;

            // Philo price input
            const philoLabel = document.createElement('label');
            philoLabel.style.cssText = 'display: flex; align-items: center; gap: 6px; font-size: 13px;';
            philoLabel.textContent = 'Philo Price: ';
            const philoInput = document.createElement('input');
            philoInput.type = 'text';
            philoInput.value = this.philoPrice.toLocaleString();
            philoInput.style.cssText = `
            width: 130px;
            padding: 4px 8px;
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 13px;
        `;
            philoInput.addEventListener('change', () => {
                const parsed = parseInt(philoInput.value.replaceAll(',', '').replaceAll('.', ''), 10);
                if (!isNaN(parsed)) {
                    this.philoPrice = parsed;
                    this.recalculate();
                }
            });
            philoLabel.appendChild(philoInput);

            // Catalyst price input
            const catLabel = document.createElement('label');
            catLabel.style.cssText = 'display: flex; align-items: center; gap: 6px; font-size: 13px;';
            catLabel.textContent = 'Catalyst Price: ';
            const catInput = document.createElement('input');
            catInput.type = 'text';
            catInput.value = this.catalystPrice.toLocaleString();
            catInput.style.cssText = `
            width: 130px;
            padding: 4px 8px;
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 13px;
        `;
            catInput.addEventListener('change', () => {
                const parsed = parseInt(catInput.value.replaceAll(',', '').replaceAll('.', ''), 10);
                if (!isNaN(parsed)) {
                    this.catalystPrice = parsed;
                    this.recalculate();
                }
            });
            catLabel.appendChild(catInput);

            // Use catalyst checkbox
            const checkLabel = document.createElement('label');
            checkLabel.style.cssText = 'display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = this.useCatalyst;
            checkbox.style.cursor = 'pointer';
            checkbox.addEventListener('change', () => {
                this.useCatalyst = checkbox.checked;
                this.recalculate();
                this.saveSettings();
            });
            checkLabel.appendChild(checkbox);
            checkLabel.appendChild(document.createTextNode('Use Prime Catalyst'));

            container.appendChild(philoLabel);
            container.appendChild(catLabel);
            container.appendChild(checkLabel);

            // Catalytic Tea checkbox
            const teaCheckLabel = document.createElement('label');
            teaCheckLabel.style.cssText = 'display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;';
            const teaCheckbox = document.createElement('input');
            teaCheckbox.type = 'checkbox';
            teaCheckbox.checked = this.useCatalyticTea;
            teaCheckbox.style.cursor = 'pointer';
            teaCheckbox.addEventListener('change', () => {
                this.useCatalyticTea = teaCheckbox.checked;
                this.recalculate();
                this.saveSettings();
            });
            teaCheckLabel.appendChild(teaCheckbox);

            // Display base ratioBoost if available
            const boostText =
                this.catalyticTeaRatioBoost > 0
                    ? ` (${formatPercentage(this.catalyticTeaRatioBoost, 1)})`
                    : ' (unavailable)';
            teaCheckLabel.appendChild(document.createTextNode(`Catalytic Tea${boostText}`));
            container.appendChild(teaCheckLabel);

            // Drink Concentration Dropdown
            const drinkLabel = document.createElement('label');
            drinkLabel.style.cssText = 'display: flex; align-items: center; gap: 6px; font-size: 13px;';
            drinkLabel.textContent = 'Drink Concentration: ';
            const drinkSelect = document.createElement('select');
            drinkSelect.style.cssText = `
            padding: 4px 8px;
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 13px;
        `;

            // Populate dropdown with enhancement levels +0 through +20
            for (let level = 0; level <= 20; level++) {
                const concentration = this.getDrinkConcentrationForLevel(level);
                const option = document.createElement('option');
                option.value = level;
                option.textContent = `+${level} (${formatPercentage(concentration, 2)})`;
                if (level === this.drinkConcentrationLevel) {
                    option.selected = true;
                }
                drinkSelect.appendChild(option);
            }

            drinkSelect.addEventListener('change', () => {
                this.drinkConcentrationLevel = parseInt(drinkSelect.value, 10);
                this.recalculate();
                this.saveSettings();
            });
            drinkLabel.appendChild(drinkSelect);
            container.appendChild(drinkLabel);

            // Hide negative profit checkbox
            const hideNegCheckLabel = document.createElement('label');
            hideNegCheckLabel.style.cssText =
                'display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;';
            const hideNegCheckbox = document.createElement('input');
            hideNegCheckbox.type = 'checkbox';
            hideNegCheckbox.checked = this.hideNegativeProfitItems;
            hideNegCheckbox.style.cursor = 'pointer';
            hideNegCheckbox.addEventListener('change', () => {
                this.hideNegativeProfitItems = hideNegCheckbox.checked;
                this.renderTable();
                this.saveSettings();
            });
            hideNegCheckLabel.appendChild(hideNegCheckbox);
            hideNegCheckLabel.appendChild(document.createTextNode('Hide Negative Profit'));
            container.appendChild(hideNegCheckLabel);

            // Filter label
            const filterLabel = document.createElement('label');
            filterLabel.style.cssText = 'display: flex; align-items: center; gap: 6px; font-size: 13px;';
            filterLabel.textContent = 'Filter: ';
            const filterInput = document.createElement('input');
            filterInput.type = 'text';
            filterInput.placeholder = 'Item name...';
            filterInput.value = this.filterText;
            filterInput.style.cssText = `
            width: 140px;
            padding: 4px 8px;
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 13px;
        `;
            filterInput.addEventListener('input', () => {
                this.filterText = filterInput.value;
                this.renderTable();
                this.saveSettings();
            });
            filterLabel.appendChild(filterInput);
            container.appendChild(filterLabel);

            // Refresh prices button
            const refreshBtn = document.createElement('button');
            refreshBtn.textContent = 'Refresh Prices';
            refreshBtn.style.cssText = `
            padding: 4px 12px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        `;
            refreshBtn.addEventListener('mouseenter', () => {
                refreshBtn.style.background = '#357abd';
            });
            refreshBtn.addEventListener('mouseleave', () => {
                refreshBtn.style.background = '#4a90e2';
            });
            refreshBtn.addEventListener('click', async () => {
                refreshBtn.disabled = true;
                refreshBtn.textContent = 'Refreshing...';
                refreshBtn.style.opacity = '0.6';
                try {
                    await marketAPI.fetch(true);
                    this.loadDefaultPrices();
                    // Update the price inputs to reflect new data
                    const inputs = container.querySelectorAll('input[type="text"]');
                    if (inputs[0]) inputs[0].value = this.philoPrice.toLocaleString();
                    if (inputs[1]) inputs[1].value = this.catalystPrice.toLocaleString();
                    this.recalculate();
                } catch (error) {
                    console.error('[PhiloCalculator] Failed to refresh prices:', error);
                }
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'Refresh Prices';
                refreshBtn.style.opacity = '1';
            });
            container.appendChild(refreshBtn);

            return container;
        }

        /**
         * Recalculate all rows and re-render
         */
        recalculate() {
            this.calculateAllRows();
            this.renderTable();
        }

        /**
         * Render the results table
         */
        renderTable() {
            const container = this.modal?.querySelector('.philo-calc-table-container');
            if (!container) return;

            const columns = [
                { key: 'name', label: 'Item', align: 'left' },
                { key: 'cost', label: 'Cost' },
                { key: 'philoChance', label: 'Philo %' },
                { key: 'returnChance', label: 'Return %' },
                { key: 'transmuteChance', label: 'Base Xmute %' },
                { key: 'effectiveTransmuteChance', label: 'Eff. Xmute %' },
                { key: 'transmuteCost', label: 'Xmute Cost' },
                { key: 'ev', label: 'EV' },
                { key: 'itemsPerAction', label: 'Items/Act' },
                { key: 'actionsPerPhilo', label: 'Acts/Philo' },
                { key: 'itemsPerPhilo', label: 'Items/Philo' },
                { key: 'profitPerPhilo', label: 'Profit/Philo' },
                { key: 'profitMargin', label: 'Margin' },
                { key: 'timePerPhiloSeconds', label: 'Time/Philo' },
                { key: 'profitPerHour', label: 'Profit/Hr' },
                { key: 'revenuePerHour', label: 'Revenue/Hr' },
                { key: 'costPerHour', label: 'Cost/Hr' },
            ];

            const table = document.createElement('table');
            table.style.cssText = `
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        `;

            // Header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');

            for (const col of columns) {
                const th = document.createElement('th');
                th.style.cssText = `
                padding: 8px 6px;
                text-align: ${col.align || 'right'};
                border-bottom: 2px solid #555;
                cursor: pointer;
                user-select: none;
                white-space: nowrap;
                position: sticky;
                top: 0;
                background: #2a2a2a;
                z-index: 1;
            `;

                const arrow = this.sortColumn === col.key ? (this.sortDirection === 'asc' ? ' \u25B2' : ' \u25BC') : '';
                th.textContent = col.label + arrow;

                th.addEventListener('click', () => this.toggleSort(col.key));
                headerRow.appendChild(th);
            }

            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Body
            const tbody = document.createElement('tbody');

            // Apply item name filter
            const filterLower = this.filterText.toLowerCase();
            let filteredRows = filterLower
                ? this.rows.filter((row) => row.name.toLowerCase().includes(filterLower))
                : this.rows;

            // Apply negative profit filter
            if (this.hideNegativeProfitItems) {
                filteredRows = filteredRows.filter((row) => row.profitPerPhilo >= 0);
            }

            for (let i = 0; i < filteredRows.length; i++) {
                const row = filteredRows[i];
                const tr = document.createElement('tr');
                const bgColor = i % 2 === 0 ? '#2a2a2a' : '#252525';
                tr.style.cssText = `background: ${bgColor};`;

                for (const col of columns) {
                    const td = document.createElement('td');
                    td.style.cssText = `
                    padding: 6px;
                    text-align: ${col.align || 'right'};
                    white-space: nowrap;
                `;

                    const value = row[col.key];

                    // Format based on column type
                    switch (col.key) {
                        case 'name':
                            td.textContent = value;
                            break;
                        case 'philoChance':
                        case 'returnChance':
                        case 'transmuteChance':
                        case 'effectiveTransmuteChance':
                            td.textContent = formatPercentage(value, 2);
                            break;
                        case 'profitMargin':
                            td.textContent = formatPercentage(value, 1);
                            td.style.color = value >= 0 ? config$1.COLOR_PROFIT : config$1.COLOR_LOSS;
                            break;
                        case 'timePerPhiloSeconds':
                            td.textContent = timeReadable(value);
                            break;
                        case 'profitPerPhilo':
                        case 'profitPerHour':
                            td.textContent = formatLargeNumber(Math.round(value));
                            td.style.color = value >= 0 ? config$1.COLOR_PROFIT : config$1.COLOR_LOSS;
                            break;
                        case 'revenuePerHour':
                        case 'costPerHour':
                            td.textContent = formatLargeNumber(Math.round(value));
                            break;
                        case 'actionsPerPhilo':
                        case 'itemsPerPhilo':
                            td.textContent = formatLargeNumber(Math.round(value));
                            break;
                        case 'itemsPerAction':
                            td.textContent = value.toFixed(2);
                            break;
                        default:
                            td.textContent = formatLargeNumber(Math.round(value));
                            break;
                    }

                    tr.appendChild(td);
                }

                tbody.appendChild(tr);
            }

            table.appendChild(tbody);

            container.innerHTML = '';
            container.appendChild(table);
        }
    }

    const philoCalculator = new PhiloCalculator();

    /**
     * Personal Trade History Module
     * Tracks your buy/sell prices for marketplace items
     */


    /**
     * TradeHistory class manages personal buy/sell price tracking
     */
    class TradeHistory {
        constructor() {
            this.history = {}; // itemHrid:enhancementLevel -> { buy, sell }
            this.isInitialized = false;
            this.isLoaded = false;
            this.characterId = null;
            this.marketUpdateHandler = null; // Store handler reference for cleanup
        }

        /**
         * Get character-specific storage key
         * @returns {string} Storage key with character ID suffix
         */
        getStorageKey() {
            if (this.characterId) {
                return `tradeHistory_${this.characterId}`;
            }
            return 'tradeHistory'; // Fallback for no character ID
        }

        /**
         * Setup setting listener for feature toggle
         */
        setupSettingListener() {
            config$1.onSettingChange('market_tradeHistory', (value) => {
                if (value) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });
        }

        /**
         * Initialize trade history tracking
         */
        async initialize() {
            // Guard FIRST (before feature check)
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('market_tradeHistory')) {
                return;
            }

            // Get current character ID
            this.characterId = dataManager$1.getCurrentCharacterId();

            // Load existing history from storage
            await this.loadHistory();

            this.marketUpdateHandler = (data) => {
                this.handleMarketUpdate(data);
            };

            // Hook into data manager for market listing updates
            dataManager$1.on('market_listings_updated', this.marketUpdateHandler);

            this.isInitialized = true;
        }

        /**
         * Load trade history from storage
         */
        async loadHistory() {
            try {
                const storageKey = this.getStorageKey();
                const saved = await storage$1.getJSON(storageKey, 'settings', {});
                this.history = saved || {};
                this.isLoaded = true;
            } catch (error) {
                console.error('[TradeHistory] Failed to load history:', error);
                this.history = {};
                this.isLoaded = true;
            }
        }

        /**
         * Save trade history to storage
         */
        async saveHistory() {
            try {
                const storageKey = this.getStorageKey();
                await storage$1.setJSON(storageKey, this.history, 'settings', true);
            } catch (error) {
                console.error('[TradeHistory] Failed to save history:', error);
            }
        }

        /**
         * Handle market_listings_updated WebSocket message
         * @param {Object} data - Market update data
         */
        handleMarketUpdate(data) {
            if (!data.endMarketListings) return;

            let hasChanges = false;

            // Process each completed order
            data.endMarketListings.forEach((order) => {
                // Only track orders that actually filled
                if (order.filledQuantity === 0) return;

                const key = `${order.itemHrid}:${order.enhancementLevel}`;

                // Get existing history for this item or create new
                const itemHistory = this.history[key] || {};

                // Update buy or sell price
                if (order.isSell) {
                    itemHistory.sell = order.price;
                } else {
                    itemHistory.buy = order.price;
                }

                this.history[key] = itemHistory;
                hasChanges = true;
            });

            // Save to storage if any changes
            if (hasChanges) {
                this.saveHistory();
            }
        }

        /**
         * Get trade history for a specific item
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level (default 0)
         * @returns {Object|null} { buy, sell } or null if no history
         */
        getHistory(itemHrid, enhancementLevel = 0) {
            const key = `${itemHrid}:${enhancementLevel}`;
            return this.history[key] || null;
        }

        /**
         * Check if history data is loaded
         * @returns {boolean}
         */
        isReady() {
            return this.isLoaded;
        }

        /**
         * Clear all trade history
         */
        async clearHistory() {
            this.history = {};
            await this.saveHistory();
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.marketUpdateHandler) {
                dataManager$1.off('market_listings_updated', this.marketUpdateHandler);
                this.marketUpdateHandler = null;
            }

            // Don't clear history data, just stop tracking
            this.isInitialized = false;
        }

        /**
         * Handle character switch - clear old data and reinitialize
         */
        async handleCharacterSwitch() {
            // Disable first to clean up old handlers
            this.disable();

            // Clear old character's data from memory
            this.history = {};
            this.isLoaded = false;

            // Reinitialize with new character
            await this.initialize();
        }
    }

    const tradeHistory = new TradeHistory();
    tradeHistory.setupSettingListener();

    // Setup character switch handler
    dataManager$1.on('character_switched', () => {
        if (config$1.getSetting('market_tradeHistory')) {
            tradeHistory.handleCharacterSwitch();
        }
    });

    /**
     * Trade History Display Module
     * Shows your last buy/sell prices in the marketplace panel
     */


    class TradeHistoryDisplay {
        constructor() {
            this.isActive = false;
            this.unregisterObserver = null;
            this.unregisterWebSocket = null;
            this.currentItemHrid = null;
            this.currentEnhancementLevel = 0;
            this.currentOrderBookData = null;
            this.isInitialized = false;
            this.needsPriceDataRetry = false; // Track if we need to retry due to missing price data
        }

        /**
         * Initialize the display system
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('market_tradeHistory')) {
                return;
            }

            this.isInitialized = true;
            this.setupWebSocketListener();
            this.setupSettingListener();
            this.isActive = true;
        }

        /**
         * Setup setting change listener to refresh display when comparison mode changes
         */
        setupSettingListener() {
            config$1.onSettingChange('market_tradeHistoryComparisonMode', () => {
                // Refresh display if currently viewing an item
                if (this.currentItemHrid) {
                    const history = tradeHistory.getHistory(this.currentItemHrid, this.currentEnhancementLevel);
                    this.updateDisplay(null, history);
                }
            });
        }

        /**
         * Setup WebSocket listener for order book updates
         */
        setupWebSocketListener() {
            const orderBookHandler = (data) => {
                if (data.marketItemOrderBooks) {
                    // Store order book data for current item
                    this.currentOrderBookData = data.marketItemOrderBooks;

                    // Extract item info from WebSocket data
                    const itemHrid = data.marketItemOrderBooks.itemHrid;

                    // Get enhancement level from DOM
                    const enhancementLevel = this.getCurrentEnhancementLevel();

                    // Check if this is a different item
                    if (itemHrid === this.currentItemHrid && enhancementLevel === this.currentEnhancementLevel) {
                        // Only update if we previously failed due to missing price data
                        if (!this.needsPriceDataRetry) {
                            return;
                        }
                    }

                    // Update tracking
                    this.currentItemHrid = itemHrid;
                    this.currentEnhancementLevel = enhancementLevel;

                    // Get trade history for this item
                    const history = tradeHistory.getHistory(itemHrid, enhancementLevel);

                    // Update display (pass null for panel since we don't use it)
                    this.updateDisplay(null, history);
                }
            };

            dataManager$1.on('market_item_order_books_updated', orderBookHandler);

            // Store unregister function for cleanup
            this.unregisterWebSocket = () => {
                dataManager$1.off('market_item_order_books_updated', orderBookHandler);
            };
        }

        /**
         * Get current enhancement level being viewed in order book
         * @returns {number} Enhancement level (0 for non-equipment)
         */
        getCurrentEnhancementLevel() {
            // Check for enhancement level indicator in the current item display
            const currentItemElement = document.querySelector('[class*="MarketplacePanel_currentItem"]');
            if (currentItemElement) {
                const enhancementElement = currentItemElement.querySelector('[class*="Item_enhancementLevel"]');
                if (enhancementElement) {
                    const match = enhancementElement.textContent.match(/\+(\d+)/);
                    if (match) {
                        return parseInt(match[1], 10);
                    }
                }
            }

            // Default to enhancement level 0 (non-equipment or base equipment)
            return 0;
        }

        /**
         * Update trade history display
         * @param {HTMLElement} panel - Current item panel (unused, kept for signature compatibility)
         * @param {Object|null} history - Trade history { buy, sell } or null
         */
        updateDisplay(panel, history) {
            // Remove existing display
            const existing = document.querySelectorAll('.mwi-trade-history');
            existing.forEach((el) => el.remove());

            // Don't show anything if no history
            if (!history || (!history.buy && !history.sell)) {
                return;
            }

            // Get current top order prices from the DOM
            const currentPrices = this.extractCurrentPrices(panel);

            // Don't show display if we don't have current prices yet
            if (!currentPrices) {
                this.needsPriceDataRetry = true;
                return;
            }

            // Get comparison mode setting
            const comparisonMode = config$1.getSettingValue('market_tradeHistoryComparisonMode', 'instant');

            // Find the button container - it's outside the currentItem panel
            // Search in the entire document since button container is at a higher level
            const buttonContainer = document.querySelector('[class*="MarketplacePanel_marketNavButtonContainer"]');
            if (!buttonContainer) {
                return;
            }

            // Create history display
            const historyDiv = document.createElement('div');
            historyDiv.className = 'mwi-trade-history';

            historyDiv.style.cssText = `
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-left: 12px;
            font-size: 0.85rem;
            color: #888;
            padding: 6px 12px;
            background: rgba(0,0,0,0.8);
            border-radius: 4px;
            white-space: nowrap;
        `;

            // Build content
            const parts = [];
            parts.push(`<span style="color: #aaa; font-weight: 500;">Last:</span>`);

            if (history.buy) {
                const buyColor = this.getBuyColor(history.buy, currentPrices, comparisonMode);
                parts.push(
                    `<span style="color: ${buyColor}; font-weight: 600;" title="Your last buy price">Buy ${formatKMB3Digits(history.buy)}</span>`
                );
            }

            if (history.buy && history.sell) {
                parts.push(`<span style="color: #555;">|</span>`);
            }

            if (history.sell) {
                const sellColor = this.getSellColor(history.sell, currentPrices, comparisonMode);
                parts.push(
                    `<span style="color: ${sellColor}; font-weight: 600;" title="Your last sell price">Sell ${formatKMB3Digits(history.sell)}</span>`
                );
            }

            historyDiv.innerHTML = parts.join('');

            // Append to button container
            buttonContainer.appendChild(historyDiv);

            // Clear retry flag since we successfully displayed
            this.needsPriceDataRetry = false;
        }

        /**
         * Extract current top order prices from WebSocket order book data
         * @param {HTMLElement} panel - Current item panel (unused, kept for signature compatibility)
         * @returns {Object|null} { ask, bid } or null
         */
        extractCurrentPrices(_panel) {
            // Use WebSocket order book data instead of DOM scraping
            if (!this.currentOrderBookData || !this.currentOrderBookData.orderBooks) {
                return null;
            }

            // Get current enhancement level to find correct order book
            const enhancementLevel = this.getCurrentEnhancementLevel();

            // orderBooks is an array indexed by enhancement level
            const orderBook = this.currentOrderBookData.orderBooks[enhancementLevel];
            if (!orderBook) {
                return null;
            }

            // Extract top ask (lowest sell price) and top bid (highest buy price)
            const topAsk = orderBook.asks?.[0]?.price;
            const topBid = orderBook.bids?.[0]?.price;

            // Validate prices exist and are positive
            if (!topAsk || topAsk <= 0 || !topBid || topBid <= 0) {
                return null;
            }

            return {
                ask: topAsk,
                bid: topBid,
            };
        }

        /**
         * Get color for buy price based on comparison mode
         * @param {number} lastBuy - Your last buy price
         * @param {Object|null} currentPrices - Current market prices { ask, bid }
         * @param {string} comparisonMode - 'instant' or 'listing'
         * @returns {string} Color code
         */
        getBuyColor(lastBuy, currentPrices, comparisonMode) {
            if (!currentPrices) {
                return '#888'; // Grey if no market data
            }

            // Choose comparison price based on mode
            const comparePrice = comparisonMode === 'instant' ? currentPrices.ask : currentPrices.bid;

            if (!comparePrice || comparePrice === -1) {
                return '#888'; // Grey if no market data
            }

            if (comparisonMode === 'instant') {
                // Instant mode: Compare to ask (what you'd pay to instant-buy now)
                if (comparePrice > lastBuy) {
                    return config$1.COLOR_LOSS; // Red - would pay more now
                } else if (comparePrice < lastBuy) {
                    return config$1.COLOR_PROFIT; // Green - would pay less now
                }
            } else if (comparePrice > lastBuy) {
                // Listing mode: Compare to bid (what buyers are offering = what you could sell for)
                return config$1.COLOR_PROFIT; // Green - can sell for more than you bought (profit)
            } else if (comparePrice < lastBuy) {
                return config$1.COLOR_LOSS; // Red - can only sell for less than you bought (loss)
            }

            return '#888'; // Grey - same price
        }

        /**
         * Get color for sell price based on comparison mode
         * @param {number} lastSell - Your last sell price
         * @param {Object|null} currentPrices - Current market prices { ask, bid }
         * @param {string} comparisonMode - 'instant' or 'listing'
         * @returns {string} Color code
         */
        getSellColor(lastSell, currentPrices, comparisonMode) {
            if (!currentPrices) {
                return '#888'; // Grey if no market data
            }

            // Choose comparison price based on mode
            const comparePrice = comparisonMode === 'instant' ? currentPrices.bid : currentPrices.ask;

            if (!comparePrice || comparePrice === -1) {
                return '#888'; // Grey if no market data
            }

            if (comparisonMode === 'instant') {
                // Instant mode: Compare to bid (what you'd get to instant-sell now)
                if (comparePrice > lastSell) {
                    return config$1.COLOR_PROFIT; // Green - would get more now
                } else if (comparePrice < lastSell) {
                    return config$1.COLOR_LOSS; // Red - would get less now
                }
            } else if (comparePrice > lastSell) {
                // Listing mode: Compare to ask (what sellers are asking)
                return config$1.COLOR_LOSS; // Red - others selling for more (you sold too cheap)
            } else if (comparePrice < lastSell) {
                return config$1.COLOR_PROFIT; // Green - others selling for less (you sold well)
            }

            return '#888'; // Grey - same price
        }

        /**
         * Disable the display
         */
        disable() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            if (this.unregisterWebSocket) {
                this.unregisterWebSocket();
                this.unregisterWebSocket = null;
            }

            // Remove all displays
            document.querySelectorAll('.mwi-trade-history').forEach((el) => el.remove());

            this.isActive = false;
            this.currentItemHrid = null;
            this.currentEnhancementLevel = 0;
            this.currentOrderBookData = null;
            this.isInitialized = false;
        }
    }

    const tradeHistoryDisplay = new TradeHistoryDisplay();

    /**
     * Production Profit Calculator
     *
     * Calculates comprehensive profit/hour for production actions (Brewing, Cooking, Crafting, Tailoring, Cheesesmithing)
     * Reuses existing profit calculator from tooltip system.
     */


    /**
     * Action types for production skills (5 skills)
     */
    const PRODUCTION_TYPES$3 = [
        '/action_types/brewing',
        '/action_types/cooking',
        '/action_types/cheesesmithing',
        '/action_types/crafting',
        '/action_types/tailoring',
    ];

    /**
     * Calculate comprehensive profit for a production action
     * @param {string} actionHrid - Action HRID (e.g., "/actions/brewing/efficiency_tea")
     * @returns {Object|null} Profit data or null if not applicable
     */
    async function calculateProductionProfit(actionHrid) {
        const gameData = dataManager$1.getInitClientData();
        const actionDetail = gameData.actionDetailMap[actionHrid];

        if (!actionDetail) {
            return null;
        }

        // Only process production actions with outputs
        if (!PRODUCTION_TYPES$3.includes(actionDetail.type)) {
            return null;
        }

        if (!actionDetail.outputItems || actionDetail.outputItems.length === 0) {
            return null; // No output - nothing to calculate
        }

        // Note: Market API is pre-loaded by caller (max-produceable.js)
        // No need to check or fetch here

        // Get output item HRID
        const outputItemHrid = actionDetail.outputItems[0].itemHrid;

        // Reuse existing profit calculator (does all the heavy lifting)
        const profitData = await profitCalculator.calculateProfit(outputItemHrid);

        if (!profitData) {
            return null;
        }

        return profitData;
    }

    /**
     * Task Profit Calculator
     * Calculates total profit for gathering and production tasks
     * Includes task rewards (coins, task tokens, Purple's Gift) + action profit
     */


    /**
     * Calculate Task Token value from Task Shop items
     * Uses same approach as Ranged Way Idle - find best Task Shop item
     * @returns {Object} Token value breakdown or error state
     */
    function calculateTaskTokenValue() {
        // Return error state if expected value calculator isn't ready
        if (!expectedValueCalculator.isInitialized) {
            return {
                tokenValue: null,
                giftPerTask: null,
                totalPerToken: null,
                error: 'Market data not loaded',
            };
        }

        const taskShopItems = [
            '/items/large_meteorite_cache',
            '/items/large_artisans_crate',
            '/items/large_treasure_chest',
        ];

        // Get expected value of each Task Shop item (all cost 30 tokens)
        const expectedValues = taskShopItems.map((itemHrid) => {
            const result = expectedValueCalculator.calculateExpectedValue(itemHrid);
            return result?.expectedValue || 0;
        });

        // Use best (highest value) item
        const bestValue = Math.max(...expectedValues);

        // Task Token value = best chest value / 30 (cost in tokens)
        const taskTokenValue = bestValue / 30;

        // Calculate Purple's Gift prorated value (divide by 50 tasks)
        const giftResult = expectedValueCalculator.calculateExpectedValue('/items/purples_gift');
        const giftValue = giftResult?.expectedValue || 0;
        const giftPerTask = giftValue / 50;

        return {
            tokenValue: taskTokenValue,
            giftPerTask: giftPerTask,
            totalPerToken: taskTokenValue + giftPerTask,
            error: null,
        };
    }

    /**
     * Calculate task reward value (coins + tokens + Purple's Gift)
     * @param {number} coinReward - Coin reward amount
     * @param {number} taskTokenReward - Task token reward amount
     * @returns {Object} Reward value breakdown
     */
    function calculateTaskRewardValue(coinReward, taskTokenReward) {
        const tokenData = calculateTaskTokenValue();

        // Handle error state (market data not loaded)
        if (tokenData.error) {
            return {
                coins: coinReward,
                taskTokens: 0,
                purpleGift: 0,
                total: coinReward,
                breakdown: {
                    tokenValue: 0,
                    tokensReceived: taskTokenReward,
                    giftPerTask: 0,
                },
                error: tokenData.error,
            };
        }

        const taskTokenValue = taskTokenReward * tokenData.tokenValue;
        const purpleGiftValue = taskTokenReward * tokenData.giftPerTask;

        return {
            coins: coinReward,
            taskTokens: taskTokenValue,
            purpleGift: purpleGiftValue,
            total: coinReward + taskTokenValue + purpleGiftValue,
            breakdown: {
                tokenValue: tokenData.tokenValue,
                tokensReceived: taskTokenReward,
                giftPerTask: tokenData.giftPerTask,
            },
            error: null,
        };
    }

    /**
     * Detect task type from description
     * @param {string} taskDescription - Task description text (e.g., "Cheesesmithing - Holy Cheese")
     * @returns {string} Task type: 'gathering', 'production', 'combat', or 'unknown'
     */
    function detectTaskType(taskDescription) {
        // Extract skill from "Skill - Action" format
        const skillMatch = taskDescription.match(/^([^-]+)\s*-/);
        if (!skillMatch) return 'unknown';

        const skill = skillMatch[1].trim().toLowerCase();

        // Gathering skills
        if (['foraging', 'woodcutting', 'milking'].includes(skill)) {
            return 'gathering';
        }

        // Production skills
        if (['cheesesmithing', 'brewing', 'cooking', 'crafting', 'tailoring'].includes(skill)) {
            return 'production';
        }

        // Combat
        if (skill === 'defeat') {
            return 'combat';
        }

        return 'unknown';
    }

    /**
     * Parse task description to extract action HRID
     * Format: "Skill - Action Name" (e.g., "Cheesesmithing - Holy Cheese", "Milking - Cow")
     * @param {string} taskDescription - Task description text
     * @param {string} taskType - Task type (gathering/production)
     * @param {number} quantity - Task quantity
     * @param {number} currentProgress - Current progress (actions completed)
     * @returns {Object|null} {actionHrid, quantity, currentProgress, description} or null if parsing fails
     */
    function parseTaskDescription(taskDescription, taskType, quantity, currentProgress) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) {
            return null;
        }

        const actionDetailMap = gameData.actionDetailMap;
        if (!actionDetailMap) {
            return null;
        }

        // Extract action name from "Skill - Action" format
        const match = taskDescription.match(/^[^-]+\s*-\s*(.+)$/);
        if (!match) {
            return null;
        }

        const actionName = match[1].trim();

        // Find matching action HRID by searching for action name in action details
        for (const [actionHrid, actionDetail] of Object.entries(actionDetailMap)) {
            if (actionDetail.name && actionDetail.name.toLowerCase() === actionName.toLowerCase()) {
                return { actionHrid, quantity, currentProgress, description: taskDescription };
            }
        }

        return null;
    }

    /**
     * Calculate gathering task profit
     * @param {string} actionHrid - Action HRID
     * @param {number} quantity - Number of times to perform action
     * @returns {Promise<Object>} Profit breakdown
     */
    async function calculateGatheringTaskProfit(actionHrid, quantity) {
        let profitData;
        try {
            profitData = await calculateGatheringProfit(actionHrid);
        } catch {
            profitData = null;
        }

        if (!profitData) {
            return {
                totalValue: 0,
                breakdown: {
                    actionHrid,
                    quantity,
                    perAction: 0,
                },
            };
        }

        const hasMissingPrices = profitData.hasMissingPrices;

        const totals = calculateGatheringActionTotalsFromBase({
            actionsCount: quantity,
            actionsPerHour: profitData.actionsPerHour,
            baseOutputs: profitData.baseOutputs,
            bonusDrops: profitData.bonusRevenue?.bonusDrops || [],
            processingRevenueBonusPerAction: profitData.processingRevenueBonusPerAction,
            gourmetRevenueBonusPerAction: profitData.gourmetRevenueBonusPerAction,
            drinkCostPerHour: profitData.drinkCostPerHour,
            efficiencyMultiplier: profitData.efficiencyMultiplier || 1,
        });

        return {
            totalValue: hasMissingPrices ? null : totals.totalProfit,
            hasMissingPrices,
            breakdown: {
                actionHrid,
                quantity,
                perAction: quantity > 0 ? totals.totalProfit / quantity : 0,
            },
            // Include detailed data for expandable display
            details: {
                profitPerHour: profitData.profitPerHour,
                actionsPerHour: profitData.actionsPerHour,
                baseOutputs: profitData.baseOutputs,
                gourmetBonuses: profitData.gourmetBonuses,
                bonusRevenue: profitData.bonusRevenue,
                processingConversions: profitData.processingConversions,
                processingRevenueBonusPerAction: profitData.processingRevenueBonusPerAction,
                processingBonus: profitData.processingBonus,
                gourmetRevenueBonusPerAction: profitData.gourmetRevenueBonusPerAction,
                gourmetBonus: profitData.gourmetBonus,
                efficiencyMultiplier: profitData.efficiencyMultiplier,
            },
        };
    }

    /**
     * Calculate production task profit
     * @param {string} actionHrid - Action HRID
     * @param {number} quantity - Number of times to perform action
     * @returns {Promise<Object>} Profit breakdown
     */
    async function calculateProductionTaskProfit(actionHrid, quantity) {
        let profitData;
        try {
            profitData = await calculateProductionProfit(actionHrid);
        } catch {
            profitData = null;
        }

        if (!profitData) {
            return {
                totalProfit: 0,
                breakdown: {
                    actionHrid,
                    quantity,
                    outputValue: 0,
                    materialCost: 0,
                    perAction: 0,
                },
            };
        }

        const hasMissingPrices = profitData.hasMissingPrices;

        const bonusDrops = profitData.bonusRevenue?.bonusDrops || [];
        const totals = calculateProductionActionTotalsFromBase({
            actionsCount: quantity,
            actionsPerHour: profitData.actionsPerHour,
            outputAmount: profitData.outputAmount || 1,
            outputPrice: profitData.outputPrice,
            gourmetBonus: profitData.gourmetBonus || 0,
            bonusDrops,
            materialCosts: profitData.materialCosts,
            totalTeaCostPerHour: profitData.totalTeaCostPerHour,
            efficiencyMultiplier: profitData.efficiencyMultiplier || 1,
        });

        return {
            totalProfit: hasMissingPrices ? null : totals.totalProfit,
            hasMissingPrices,
            breakdown: {
                actionHrid,
                quantity,
                outputValue: totals.totalBaseRevenue + totals.totalGourmetRevenue,
                materialCost: totals.totalMaterialCost + totals.totalTeaCost,
                perAction: quantity > 0 ? totals.totalProfit / quantity : 0,
            },
            // Include detailed data for expandable display
            details: {
                profitPerHour: profitData.profitPerHour,
                materialCosts: profitData.materialCosts,
                teaCosts: profitData.teaCosts,
                outputAmount: profitData.outputAmount,
                itemName: profitData.itemName,
                itemHrid: profitData.itemHrid,
                gourmetBonus: profitData.gourmetBonus,
                priceEach: profitData.outputPrice,
                outputPriceMissing: profitData.outputPriceMissing,
                actionsPerHour: profitData.actionsPerHour,
                bonusRevenue: profitData.bonusRevenue, // Pass through bonus revenue data
            },
        };
    }

    /**
     * Calculate complete task profit
     * @param {Object} taskData - Task data {description, coinReward, taskTokenReward}
     * @returns {Promise<Object|null>} Complete profit breakdown or null for combat/unknown tasks
     */
    async function calculateTaskProfit(taskData) {
        const taskType = detectTaskType(taskData.description);

        // Skip combat tasks entirely
        if (taskType === 'combat') {
            return null;
        }

        // Parse task details
        const taskInfo = parseTaskDescription(taskData.description, taskType, taskData.quantity, taskData.currentProgress);
        if (!taskInfo) {
            // Return error state for UI to display "Unable to calculate"
            return {
                type: taskType,
                error: 'Unable to parse task description',
                totalProfit: 0,
            };
        }

        // Calculate task rewards
        const rewardValue = calculateTaskRewardValue(taskData.coinReward, taskData.taskTokenReward);

        // Calculate action profit based on task type
        let actionProfit = null;
        if (taskType === 'gathering') {
            actionProfit = await calculateGatheringTaskProfit(taskInfo.actionHrid, taskInfo.quantity);
        } else if (taskType === 'production') {
            actionProfit = await calculateProductionTaskProfit(taskInfo.actionHrid, taskInfo.quantity);
        }

        if (!actionProfit) {
            return {
                type: taskType,
                error: 'Unable to calculate action profit',
                totalProfit: 0,
            };
        }

        // Calculate total profit
        const actionValue = taskType === 'production' ? actionProfit.totalProfit : actionProfit.totalValue;
        const hasMissingPrices = actionProfit.hasMissingPrices;
        const totalProfit = hasMissingPrices ? null : rewardValue.total + actionValue;

        return {
            type: taskType,
            totalProfit,
            hasMissingPrices,
            rewards: rewardValue,
            action: actionProfit,
            taskInfo: taskInfo,
        };
    }

    /**
     * Networth Cache
     * LRU cache for expensive enhancement cost calculations
     * Prevents recalculating the same enhancement paths repeatedly
     */

    class NetworthCache {
        constructor(maxSize = 100) {
            this.maxSize = maxSize;
            this.cache = new Map();
            this.marketDataHash = null;
        }

        /**
         * Generate cache key for enhancement calculation
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level
         * @returns {string} Cache key
         */
        generateKey(itemHrid, enhancementLevel) {
            return `${itemHrid}_${enhancementLevel}`;
        }

        /**
         * Generate hash of market data for cache invalidation
         * Uses first 10 items' prices as a simple hash
         * @param {Object} marketData - Market data object
         * @returns {string} Hash string
         */
        generateMarketHash(marketData) {
            if (!marketData || !marketData.marketData) return 'empty';

            // Sample first 10 items for hash (performance vs accuracy tradeoff)
            const items = Object.entries(marketData.marketData).slice(0, 10);
            const hashParts = items.map(([hrid, data]) => {
                const ask = data[0]?.a || 0;
                const bid = data[0]?.b || 0;
                return `${hrid}:${ask}:${bid}`;
            });

            return hashParts.join('|');
        }

        /**
         * Check if market data has changed and invalidate cache if needed
         * @param {Object} marketData - Current market data
         */
        checkAndInvalidate(marketData) {
            const newHash = this.generateMarketHash(marketData);

            if (this.marketDataHash !== null && this.marketDataHash !== newHash) {
                // Market data changed, invalidate entire cache
                this.clear();
            }

            this.marketDataHash = newHash;
        }

        /**
         * Get cached enhancement cost
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level
         * @returns {number|null} Cached cost or null if not found
         */
        get(itemHrid, enhancementLevel) {
            const key = this.generateKey(itemHrid, enhancementLevel);

            if (!this.cache.has(key)) {
                return null;
            }

            // Move to end (most recently used)
            const value = this.cache.get(key);
            this.cache.delete(key);
            this.cache.set(key, value);

            return value;
        }

        /**
         * Set cached enhancement cost
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level
         * @param {number} cost - Enhancement cost
         */
        set(itemHrid, enhancementLevel, cost) {
            const key = this.generateKey(itemHrid, enhancementLevel);

            // Delete if exists (to update position)
            if (this.cache.has(key)) {
                this.cache.delete(key);
            }

            // Add to end
            this.cache.set(key, cost);

            // Evict oldest if over size limit
            if (this.cache.size > this.maxSize) {
                const firstKey = this.cache.keys().next().value;
                this.cache.delete(firstKey);
            }
        }

        /**
         * Clear entire cache
         */
        clear() {
            this.cache.clear();
            this.marketDataHash = null;
        }

        /**
         * Get cache statistics
         * @returns {Object} {size, maxSize, hitRate}
         */
        getStats() {
            return {
                size: this.cache.size,
                maxSize: this.maxSize,
                marketDataHash: this.marketDataHash,
            };
        }
    }

    const networthCache = new NetworthCache();

    /**
     * Networth Calculator
     * Calculates total character networth including:
     * - Equipped items
     * - Inventory items
     * - Market listings
     * - Houses (all 17)
     * - Abilities (equipped + others)
     */


    /**
     * Calculate the value of a single item
     * @param {Object} item - Item data {itemHrid, enhancementLevel, count}
     * @param {Map} priceCache - Optional price cache from getPricesBatch()
     * @returns {number} Total value in coins
     */
    async function calculateItemValue(item, priceCache = null) {
        const { itemHrid, enhancementLevel = 0, count = 1 } = item;

        let itemValue = 0;

        // Check if high enhancement cost mode is enabled
        const useHighEnhancementCost = config$1.getSetting('networth_highEnhancementUseCost');
        const minLevel = config$1.getSetting('networth_highEnhancementMinLevel') || 13;

        // For enhanced items (1+)
        if (enhancementLevel >= 1) {
            // For high enhancement levels, use cost instead of market price (if enabled)
            if (useHighEnhancementCost && enhancementLevel >= minLevel) {
                // Check cache first
                const cachedCost = networthCache.get(itemHrid, enhancementLevel);
                if (cachedCost !== null) {
                    itemValue = cachedCost;
                } else {
                    // Calculate enhancement cost (ignore market price)
                    const enhancementParams = getEnhancingParams();
                    const enhancementPath = calculateEnhancementPath(itemHrid, enhancementLevel, enhancementParams);

                    if (enhancementPath && enhancementPath.optimalStrategy) {
                        itemValue = enhancementPath.optimalStrategy.totalCost;
                        // Cache the result
                        networthCache.set(itemHrid, enhancementLevel, itemValue);
                    } else {
                        // Enhancement calculation failed, fallback to base item price
                        console.warn('[Networth] Enhancement calculation failed for:', itemHrid, '+' + enhancementLevel);
                        itemValue = getMarketPrice(itemHrid, 0, priceCache);
                    }
                }
            } else {
                // Normal logic for lower enhancement levels: try market price first, then calculate
                const marketPrice = getMarketPrice(itemHrid, enhancementLevel, priceCache);

                if (marketPrice > 0) {
                    itemValue = marketPrice;
                } else {
                    // No market data, calculate enhancement cost
                    const cachedCost = networthCache.get(itemHrid, enhancementLevel);
                    if (cachedCost !== null) {
                        itemValue = cachedCost;
                    } else {
                        const enhancementParams = getEnhancingParams();
                        const enhancementPath = calculateEnhancementPath(itemHrid, enhancementLevel, enhancementParams);

                        if (enhancementPath && enhancementPath.optimalStrategy) {
                            itemValue = enhancementPath.optimalStrategy.totalCost;
                            networthCache.set(itemHrid, enhancementLevel, itemValue);
                        } else {
                            console.warn(
                                '[Networth] Enhancement calculation failed for:',
                                itemHrid,
                                '+' + enhancementLevel
                            );
                            itemValue = getMarketPrice(itemHrid, 0, priceCache);
                        }
                    }
                }
            }
        } else {
            // Unenhanced items: use market price or crafting cost
            itemValue = getMarketPrice(itemHrid, enhancementLevel, priceCache);
        }

        return itemValue * count;
    }

    /**
     * Get market price for an item
     * @param {string} itemHrid - Item HRID
     * @param {number} enhancementLevel - Enhancement level
     * @param {Map} priceCache - Optional price cache from getPricesBatch()
     * @returns {number} Price per item (always uses ask price)
     */
    function getMarketPrice(itemHrid, enhancementLevel, priceCache = null) {
        // Special handling for currencies
        const currencyValue = calculateCurrencyValue(itemHrid);
        if (currencyValue !== null) {
            return currencyValue;
        }

        let prices;

        // Use cache if provided, otherwise fetch directly
        if (priceCache) {
            const key = `${itemHrid}:${enhancementLevel}`;
            prices = priceCache.get(key);
        } else {
            prices = getItemPrices(itemHrid, enhancementLevel);
        }

        // Try ask price first
        const ask = prices?.ask;
        if (ask && ask > 0) {
            return ask;
        }

        // No valid ask price - try fallbacks (only for base items)
        // Enhanced items should calculate via enhancement path, not crafting cost
        if (enhancementLevel === 0) {
            // Check if it's an openable container (crates, caches, chests)
            const itemDetails = dataManager$1.getItemDetails(itemHrid);
            if (itemDetails?.isOpenable && expectedValueCalculator.isInitialized) {
                const evData = expectedValueCalculator.calculateExpectedValue(itemHrid);
                if (evData && evData.expectedValue > 0) {
                    return evData.expectedValue;
                }
            }

            // Try crafting cost as fallback
            const craftingCost = calculateCraftingCost(itemHrid);
            if (craftingCost > 0) {
                return craftingCost;
            }

            // Try shop cost as final fallback (for shop-only items)
            const shopCost = getShopCost$1(itemHrid);
            if (shopCost > 0) {
                return shopCost;
            }
        }

        return 0;
    }

    /**
     * Get shop cost for an item (if purchaseable with coins)
     * @param {string} itemHrid - Item HRID
     * @returns {number} Coin cost, or 0 if not in shop or not purchaseable with coins
     */
    function getShopCost$1(itemHrid) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return 0;

        // Find shop item for this itemHrid
        for (const shopItem of Object.values(gameData.shopItemDetailMap || {})) {
            if (shopItem.itemHrid === itemHrid) {
                // Check if purchaseable with coins
                if (shopItem.costs && shopItem.costs.length > 0) {
                    const coinCost = shopItem.costs.find((cost) => cost.itemHrid === '/items/coin');
                    if (coinCost) {
                        return coinCost.count;
                    }
                }
            }
        }

        return 0;
    }

    /**
     * Calculate value for currency items
     * @param {string} itemHrid - Item HRID
     * @returns {number|null} Currency value per unit, or null if not a currency
     */
    function calculateCurrencyValue(itemHrid) {
        // Coins: Face value (1 coin = 1 value)
        if (itemHrid === '/items/coin') {
            return 1;
        }

        // Cowbells: Market value of Bag of 10 Cowbells / 10 (if enabled)
        if (itemHrid === '/items/cowbell') {
            // Check if cowbells should be included in net worth
            const includeCowbells = config$1.getSetting('networth_includeCowbells');
            if (!includeCowbells) {
                return null; // Don't include cowbells in net worth
            }

            const bagPrice = getItemPrice('/items/bag_of_10_cowbells', { mode: 'ask' }) || 0;
            if (bagPrice > 0) {
                return bagPrice / 10;
            }
            // Fallback: vendor value
            return 100000;
        }

        // Task Tokens: Expected value from Task Shop chests
        if (itemHrid === '/items/task_token') {
            const includeTaskTokens = config$1.getSetting('networth_includeTaskTokens');
            if (includeTaskTokens === false) {
                return null; // Don't include task tokens in net worth
            }

            const tokenData = calculateTaskTokenValue();
            if (tokenData && tokenData.tokenValue > 0) {
                return tokenData.tokenValue;
            }
            // Fallback if market data not loaded: 30K (approximate)
            return 30000;
        }

        // Dungeon tokens: Best market value per token approach
        // Calculate based on best shop item value (similar to task tokens)
        // Uses profitCalc_pricingMode which defaults to 'hybrid' (ask price)
        if (itemHrid === '/items/chimerical_token') {
            return calculateDungeonTokenValue(itemHrid, 'profitCalc_pricingMode', null) || 0;
        }
        if (itemHrid === '/items/sinister_token') {
            return calculateDungeonTokenValue(itemHrid, 'profitCalc_pricingMode', null) || 0;
        }
        if (itemHrid === '/items/enchanted_token') {
            return calculateDungeonTokenValue(itemHrid, 'profitCalc_pricingMode', null) || 0;
        }
        if (itemHrid === '/items/pirate_token') {
            return calculateDungeonTokenValue(itemHrid, 'profitCalc_pricingMode', null) || 0;
        }

        return null; // Not a currency
    }

    /**
     * Calculate crafting cost for an item (simple version without efficiency bonuses)
     * Applies Artisan Tea reduction (0.9x) to input materials
     * @param {string} itemHrid - Item HRID
     * @returns {number} Total material cost or 0 if not craftable
     */
    function calculateCraftingCost(itemHrid) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return 0;

        // Find the action that produces this item
        for (const action of Object.values(gameData.actionDetailMap || {})) {
            if (action.outputItems) {
                for (const output of action.outputItems) {
                    if (output.itemHrid === itemHrid) {
                        // Found the crafting action, calculate material costs
                        let inputCost = 0;

                        // Add input items
                        if (action.inputItems && action.inputItems.length > 0) {
                            for (const input of action.inputItems) {
                                const inputPrice = getMarketPrice(input.itemHrid, 0, null);
                                inputCost += inputPrice * input.count;
                            }
                        }

                        // Apply Artisan Tea reduction (0.9x) to input materials
                        inputCost *= 0.9;

                        // Add upgrade item cost (not affected by Artisan Tea)
                        let upgradeCost = 0;
                        if (action.upgradeItemHrid) {
                            const upgradePrice = getMarketPrice(action.upgradeItemHrid, 0, null);
                            upgradeCost = upgradePrice;
                        }

                        const totalCost = inputCost + upgradeCost;

                        // Divide by output count to get per-item cost
                        return totalCost / (output.count || 1);
                    }
                }
            }
        }

        return 0;
    }

    /**
     * Calculate total value of all houses (all 17)
     * @param {Object} characterHouseRooms - Map of character house rooms
     * @returns {Object} {totalCost, breakdown: [{name, level, cost}]}
     */
    function calculateAllHousesCost(characterHouseRooms) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return { totalCost: 0, breakdown: [] };

        const houseRoomDetailMap = gameData.houseRoomDetailMap;
        if (!houseRoomDetailMap) return { totalCost: 0, breakdown: [] };

        let totalCost = 0;
        const breakdown = [];

        for (const [houseRoomHrid, houseData] of Object.entries(characterHouseRooms)) {
            const level = houseData.level || 0;
            if (level === 0) continue;

            const cost = calculateHouseBuildCost(houseRoomHrid, level);
            totalCost += cost;

            // Get human-readable name
            const houseDetail = houseRoomDetailMap[houseRoomHrid];
            const houseName = houseDetail?.name || houseRoomHrid.replace('/house_rooms/', '');

            breakdown.push({
                name: houseName,
                level: level,
                cost: cost,
            });
        }

        // Sort by cost descending
        breakdown.sort((a, b) => b.cost - a.cost);

        return { totalCost, breakdown };
    }

    /**
     * Calculate total value of all abilities
     * @param {Array} characterAbilities - Array of character abilities
     * @param {Object} abilityCombatTriggersMap - Map of equipped abilities
     * @returns {Object} {totalCost, equippedCost, breakdown, equippedBreakdown, otherBreakdown}
     */
    function calculateAllAbilitiesCost(characterAbilities, abilityCombatTriggersMap) {
        if (!characterAbilities || characterAbilities.length === 0) {
            return {
                totalCost: 0,
                equippedCost: 0,
                breakdown: [],
                equippedBreakdown: [],
                otherBreakdown: [],
            };
        }

        let totalCost = 0;
        let equippedCost = 0;
        const breakdown = [];
        const equippedBreakdown = [];
        const otherBreakdown = [];

        // Create set of equipped ability HRIDs from abilityCombatTriggersMap keys
        const equippedHrids = new Set(Object.keys(abilityCombatTriggersMap || {}));

        for (const ability of characterAbilities) {
            if (!ability.abilityHrid || ability.level === 0) continue;

            const cost = calculateAbilityCost(ability.abilityHrid, ability.level);
            totalCost += cost;

            // Format ability name for display
            const abilityName = ability.abilityHrid
                .replace('/abilities/', '')
                .split('_')
                .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');

            const abilityData = {
                name: `${abilityName} ${ability.level}`,
                cost: cost,
            };

            breakdown.push(abilityData);

            // Categorize as equipped or other
            if (equippedHrids.has(ability.abilityHrid)) {
                equippedCost += cost;
                equippedBreakdown.push(abilityData);
            } else {
                otherBreakdown.push(abilityData);
            }
        }

        // Sort all breakdowns by cost descending
        breakdown.sort((a, b) => b.cost - a.cost);
        equippedBreakdown.sort((a, b) => b.cost - a.cost);
        otherBreakdown.sort((a, b) => b.cost - a.cost);

        return {
            totalCost,
            equippedCost,
            breakdown,
            equippedBreakdown,
            otherBreakdown,
        };
    }

    /**
     * Calculate total networth
     * @returns {Promise<Object>} Networth data with breakdowns
     */
    async function calculateNetworth() {
        const gameData = dataManager$1.getCombinedData();
        if (!gameData) {
            console.error('[Networth] No game data available');
            return createEmptyNetworthData();
        }

        // Ensure market data is loaded (check in-memory first to avoid storage reads)
        if (!marketAPI.isLoaded()) {
            const marketData = await marketAPI.fetch();
            if (!marketData) {
                console.error('[Networth] Failed to fetch market data');
                return createEmptyNetworthData();
            }
        }

        // Invalidate cache if market data changed (wrap for cache compatibility)
        networthCache.checkAndInvalidate({ marketData: marketAPI.marketData });

        const characterItems = gameData.characterItems || [];
        const marketListings = gameData.myMarketListings || [];
        const characterHouseRooms = gameData.characterHouseRoomMap || {};
        const characterAbilities = gameData.characterAbilities || [];
        const abilityCombatTriggersMap = gameData.abilityCombatTriggersMap || {};

        // OPTIMIZATION: Pre-fetch all market prices in one batch
        const itemsToPrice = [];

        // Collect all items that need pricing
        for (const item of characterItems) {
            itemsToPrice.push({ itemHrid: item.itemHrid, enhancementLevel: item.enhancementLevel || 0 });
        }

        // Collect market listings items
        for (const listing of marketListings) {
            itemsToPrice.push({ itemHrid: listing.itemHrid, enhancementLevel: listing.enhancementLevel || 0 });
        }

        // Batch fetch all prices at once (eliminates ~400 redundant lookups)
        const priceCache = marketAPI.getPricesBatch(itemsToPrice);

        // Calculate equipped items value
        let equippedValue = 0;
        const equippedBreakdown = [];

        for (const item of characterItems) {
            if (item.itemLocationHrid === '/item_locations/inventory') continue;

            const value = await calculateItemValue(item, priceCache);
            equippedValue += value;

            // Add to breakdown
            const itemDetails = gameData.itemDetailMap[item.itemHrid];
            const itemName = itemDetails?.name || item.itemHrid.replace('/items/', '');
            const displayName = item.enhancementLevel > 0 ? `${itemName} +${item.enhancementLevel}` : itemName;

            equippedBreakdown.push({
                name: displayName,
                value,
            });
        }

        // Calculate inventory items value
        let inventoryValue = 0;
        const inventoryBreakdown = [];
        const inventoryByCategory = {};

        // Separate ability books for Fixed Assets section
        let abilityBooksValue = 0;
        const abilityBooksBreakdown = [];

        // Track gold coins separately for header display
        let coinCount = 0;

        for (const item of characterItems) {
            if (item.itemLocationHrid !== '/item_locations/inventory') continue;

            // Extract coin count for header display
            if (item.itemHrid === '/items/coin') {
                coinCount = item.count || 0;
            }

            const value = await calculateItemValue(item, priceCache);

            // Add to breakdown
            const itemDetails = gameData.itemDetailMap[item.itemHrid];
            const itemName = itemDetails?.name || item.itemHrid.replace('/items/', '');
            const displayName = item.enhancementLevel > 0 ? `${itemName} +${item.enhancementLevel}` : itemName;

            const itemData = {
                name: displayName,
                value,
                count: item.count,
            };

            // Check if this is an ability book
            const categoryHrid = itemDetails?.categoryHrid || '/item_categories/other';
            const isAbilityBook = categoryHrid === '/item_categories/ability_book';
            const booksAsInventory = config$1.getSetting('networth_abilityBooksAsInventory') === true;

            if (isAbilityBook && !booksAsInventory) {
                // Add to ability books (Fixed Assets)
                abilityBooksValue += value;
                abilityBooksBreakdown.push(itemData);
            } else {
                // Add to regular inventory (Current Assets)
                inventoryValue += value;
                inventoryBreakdown.push(itemData);

                // Categorize item
                const categoryName = gameData.itemCategoryDetailMap?.[categoryHrid]?.name || 'Other';

                if (!inventoryByCategory[categoryName]) {
                    inventoryByCategory[categoryName] = {
                        items: [],
                        totalValue: 0,
                    };
                }

                inventoryByCategory[categoryName].items.push(itemData);
                inventoryByCategory[categoryName].totalValue += value;
            }
        }

        // Sort items within each category by value descending
        for (const category of Object.values(inventoryByCategory)) {
            category.items.sort((a, b) => b.value - a.value);
        }

        // Sort ability books by value descending
        abilityBooksBreakdown.sort((a, b) => b.value - a.value);

        // Calculate market listings value
        let listingsValue = 0;
        const listingsBreakdown = [];

        for (const listing of marketListings) {
            const quantity = listing.orderQuantity - listing.filledQuantity;
            const enhancementLevel = listing.enhancementLevel || 0;

            if (listing.isSell) {
                // Selling: value is locked in listing + unclaimed coins
                // Apply marketplace fee (2% for normal items, 18% for cowbells)
                const fee = listing.itemHrid === '/items/bag_of_10_cowbells' ? 0.18 : 0.02;

                const value = await calculateItemValue(
                    { itemHrid: listing.itemHrid, enhancementLevel, count: quantity },
                    priceCache
                );

                listingsValue += value * (1 - fee) + listing.unclaimedCoinCount;
            } else {
                // Buying: value is locked coins + unclaimed items
                const unclaimedValue = await calculateItemValue(
                    { itemHrid: listing.itemHrid, enhancementLevel, count: listing.unclaimedItemCount },
                    priceCache
                );

                listingsValue += quantity * listing.price + unclaimedValue;
            }
        }

        // Calculate houses value
        const housesData = calculateAllHousesCost(characterHouseRooms);

        // Calculate abilities value
        const abilitiesData = calculateAllAbilitiesCost(characterAbilities, abilityCombatTriggersMap);

        // Calculate totals
        const currentAssetsTotal = equippedValue + inventoryValue + listingsValue;
        const fixedAssetsTotal = housesData.totalCost + abilitiesData.totalCost + abilityBooksValue;
        const totalNetworth = currentAssetsTotal + fixedAssetsTotal;

        // Sort breakdowns by value descending
        equippedBreakdown.sort((a, b) => b.value - a.value);
        inventoryBreakdown.sort((a, b) => b.value - a.value);

        return {
            totalNetworth,
            coins: coinCount,
            currentAssets: {
                total: currentAssetsTotal,
                equipped: { value: equippedValue, breakdown: equippedBreakdown },
                inventory: {
                    value: inventoryValue,
                    breakdown: inventoryBreakdown,
                    byCategory: inventoryByCategory,
                },
                listings: { value: listingsValue, breakdown: listingsBreakdown },
            },
            fixedAssets: {
                total: fixedAssetsTotal,
                houses: housesData,
                abilities: abilitiesData,
                abilityBooks: {
                    totalCost: abilityBooksValue,
                    breakdown: abilityBooksBreakdown,
                },
            },
        };
    }

    /**
     * Create empty networth data structure
     * @returns {Object} Empty networth data
     */
    function createEmptyNetworthData() {
        return {
            totalNetworth: 0,
            coins: 0,
            currentAssets: {
                total: 0,
                equipped: { value: 0, breakdown: [] },
                inventory: { value: 0, breakdown: [], byCategory: {} },
                listings: { value: 0, breakdown: [] },
            },
            fixedAssets: {
                total: 0,
                houses: { totalCost: 0, breakdown: [] },
                abilities: {
                    totalCost: 0,
                    equippedCost: 0,
                    breakdown: [],
                    equippedBreakdown: [],
                    otherBreakdown: [],
                },
                abilityBooks: {
                    totalCost: 0,
                    breakdown: [],
                },
            },
        };
    }

    /**
     * Networth Display Components
     * Handles UI rendering for networth in two locations:
     * 1. Header (top right) - Gold: [amount]
     * 2. Inventory Panel - Detailed breakdown with collapsible sections
     */


    /**
     * Header Display Component
     * Shows "Gold: [amount]" next to total level
     */
    class NetworthHeaderDisplay {
        constructor() {
            this.container = null;
            this.unregisterHandlers = [];
            this.isInitialized = false;
            this.networthFeature = null; // Reference to parent feature for recalculation
        }

        /**
         * Set reference to parent networth feature
         * @param {Object} feature - NetworthFeature instance
         */
        setNetworthFeature(feature) {
            this.networthFeature = feature;
        }

        /**
         * Get the current items sprite URL from the DOM
         * @returns {string|null} Items sprite URL or null if not found
         */
        getItemsSpriteUrl() {
            const itemIcon = document.querySelector('use[href*="items_sprite"]');
            if (!itemIcon) {
                return null;
            }
            const href = itemIcon.getAttribute('href');
            return href ? href.split('#')[0] : null;
        }

        /**
         * Clone SVG symbol from DOM into defs
         * @param {string} symbolId - Symbol ID to clone
         * @param {SVGDefsElement} defsElement - Defs element to append to
         * @returns {boolean} True if symbol was found and cloned
         */
        cloneSymbolToDefs(symbolId, defsElement) {
            // Check if already cloned
            if (defsElement.querySelector(`symbol[id="${symbolId}"]`)) {
                return true;
            }

            // Find the symbol in the game's loaded sprites
            const symbol = document.querySelector(`symbol[id="${symbolId}"]`);
            if (!symbol) {
                console.warn('[NetworthHeaderDisplay] Symbol not found:', symbolId);
                return false;
            }

            // Clone and add to our defs
            const clonedSymbol = symbol.cloneNode(true);
            defsElement.appendChild(clonedSymbol);
            return true;
        }

        /**
         * Initialize header display
         */
        initialize() {
            // 1. Check if element already exists (handles late initialization)
            const existingElem = document.querySelector('[class*="Header_totalLevel"]');
            if (existingElem) {
                this.renderHeader(existingElem);
            }

            // 2. Watch for future additions (handles SPA navigation, page reloads)
            const unregister = domObserver$1.onClass('NetworthHeader', 'Header_totalLevel', (elem) => {
                this.renderHeader(elem);
            });
            this.unregisterHandlers.push(unregister);

            this.isInitialized = true;
        }

        /**
         * Render header display
         * @param {Element} totalLevelElem - Total level element
         */
        renderHeader(totalLevelElem) {
            // Check if already rendered
            if (this.container && document.body.contains(this.container)) {
                return;
            }

            // Remove any existing container
            if (this.container) {
                this.container.remove();
            }

            // Create container
            this.container = document.createElement('div');
            this.container.className = 'mwi-networth-header';
            this.container.style.cssText = `
            font-size: 0.875rem;
            font-weight: 500;
            color: ${config$1.COLOR_ACCENT};
            text-wrap: nowrap;
        `;

            // Insert after total level
            totalLevelElem.insertAdjacentElement('afterend', this.container);

            // Initial render with loading state
            this.renderGoldDisplay('Loading...');

            // Trigger recalculation immediately to update from "Loading..." to actual value
            if (this.networthFeature && typeof this.networthFeature.recalculate === 'function') {
                this.networthFeature.recalculate().catch((error) => {
                    console.error('[NetworthHeaderDisplay] Immediate recalculation failed:', error);
                });
            }
        }

        /**
         * Render gold display with icon and value
         * @param {string} value - Formatted value text
         */
        renderGoldDisplay(value) {
            this.container.innerHTML = '';

            // Create wrapper for icon + text
            const wrapper = document.createElement('span');
            wrapper.style.cssText = `
            display: inline-flex;
            align-items: center;
            gap: 4px;
        `;

            // Get current items sprite URL from DOM
            const itemsSpriteUrl = this.getItemsSpriteUrl();

            // Create SVG icon using game's sprite
            if (itemsSpriteUrl) {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '16');
                svg.setAttribute('height', '16');
                svg.style.cssText = `
                vertical-align: middle;
                fill: currentColor;
            `;

                // Create use element with external sprite reference
                const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                use.setAttribute('href', `${itemsSpriteUrl}#coin`);
                svg.appendChild(use);

                wrapper.appendChild(svg);
            }

            // Create text span
            const textSpan = document.createElement('span');
            textSpan.textContent = `Gold: ${value}`;

            // Assemble
            wrapper.appendChild(textSpan);
            this.container.appendChild(wrapper);
        }

        /**
         * Update header with networth data
         * @param {Object} networthData - Networth data from calculator
         */
        update(networthData) {
            if (!this.container || !document.body.contains(this.container)) {
                return;
            }

            const valueFormatted = networthFormatter(Math.round(networthData.coins));

            this.renderGoldDisplay(valueFormatted);
        }

        /**
         * Refresh colors on existing header element
         */
        refresh() {
            if (this.container && document.body.contains(this.container)) {
                this.container.style.color = config$1.COLOR_ACCENT;
            }
        }

        /**
         * Disable and cleanup
         */
        disable() {
            if (this.container) {
                this.container.remove();
                this.container = null;
            }

            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];
            this.isInitialized = false;
        }
    }

    /**
     * Inventory Panel Display Component
     * Shows detailed networth breakdown below inventory search bar
     */
    class NetworthInventoryDisplay {
        constructor() {
            this.container = null;
            this.unregisterHandlers = [];
            this.currentData = null;
            this.isInitialized = false;
        }

        /**
         * Initialize inventory panel display
         */
        initialize() {
            // 1. Check if element already exists (handles late initialization)
            const existingElem = document.querySelector('[class*="Inventory_items"]');
            if (existingElem) {
                this.renderPanel(existingElem);
            }

            // 2. Watch for future additions (handles SPA navigation, inventory panel reloads)
            const unregister = domObserver$1.onClass('NetworthInv', 'Inventory_items', (elem) => {
                this.renderPanel(elem);
            });
            this.unregisterHandlers.push(unregister);

            this.isInitialized = true;
        }

        /**
         * Render inventory panel
         * @param {Element} inventoryElem - Inventory items element
         */
        renderPanel(inventoryElem) {
            // Check if already rendered
            if (this.container && document.body.contains(this.container)) {
                return;
            }

            // Remove any existing container
            if (this.container) {
                this.container.remove();
            }

            // Create container
            this.container = document.createElement('div');
            this.container.className = 'mwi-networth-panel';
            this.container.style.cssText = `
            text-align: left;
            color: ${config$1.COLOR_ACCENT};
            font-size: 0.875rem;
            margin-bottom: 12px;
        `;

            // Insert before inventory items
            inventoryElem.insertAdjacentElement('beforebegin', this.container);

            // Initial render with loading state or current data
            if (this.currentData) {
                this.update(this.currentData);
            } else {
                this.container.innerHTML = `
                <div style="font-weight: bold; cursor: pointer;">
                    + Total Networth: Loading...
                </div>
            `;
            }
        }

        /**
         * Update panel with networth data
         * @param {Object} networthData - Networth data from calculator
         */
        update(networthData) {
            this.currentData = networthData;

            if (!this.container || !document.body.contains(this.container)) {
                return;
            }

            // Preserve expand/collapse states before updating
            const expandedStates = {};
            const sectionsToPreserve = [
                'mwi-networth-details',
                'mwi-current-assets-details',
                'mwi-equipment-breakdown',
                'mwi-inventory-breakdown',
                'mwi-fixed-assets-details',
                'mwi-houses-breakdown',
                'mwi-abilities-details',
                'mwi-equipped-abilities-breakdown',
                'mwi-other-abilities-breakdown',
                'mwi-ability-books-breakdown',
            ];

            // Also preserve inventory category states
            const inventoryCategories = Object.keys(networthData.currentAssets.inventory.byCategory || {});
            inventoryCategories.forEach((categoryName) => {
                const categoryId = `mwi-inventory-${categoryName.toLowerCase().replace(/\s+/g, '-')}`;
                sectionsToPreserve.push(categoryId);
            });

            sectionsToPreserve.forEach((id) => {
                const elem = this.container.querySelector(`#${id}`);
                if (elem) {
                    expandedStates[id] = elem.style.display !== 'none';
                }
            });

            const totalNetworth = networthFormatter(Math.round(networthData.totalNetworth));

            this.container.innerHTML = `
            <div style="cursor: pointer; font-weight: bold;" id="mwi-networth-toggle">
                + Total Networth: ${totalNetworth}
            </div>
            <div id="mwi-networth-details" style="display: none; margin-left: 20px;">
                <!-- Current Assets -->
                <div style="cursor: pointer; margin-top: 8px;" id="mwi-current-assets-toggle">
                    + Current Assets: ${networthFormatter(Math.round(networthData.currentAssets.total))}
                </div>
                <div id="mwi-current-assets-details" style="display: none; margin-left: 20px;">
                    <!-- Equipment Value -->
                    <div style="cursor: pointer; margin-top: 4px;" id="mwi-equipment-toggle">
                        + Equipment value: ${networthFormatter(Math.round(networthData.currentAssets.equipped.value))}
                    </div>
                    <div id="mwi-equipment-breakdown" style="display: none; margin-left: 20px; font-size: 0.8rem; color: #bbb; white-space: pre-line;">${this.renderEquipmentBreakdown(networthData.currentAssets.equipped.breakdown)}</div>

                    <!-- Inventory Value -->
                    <div style="cursor: pointer; margin-top: 4px;" id="mwi-inventory-toggle">
                        + Inventory value: ${networthFormatter(Math.round(networthData.currentAssets.inventory.value))}
                    </div>
                    <div id="mwi-inventory-breakdown" style="display: none; margin-left: 20px;">
                        ${this.renderInventoryBreakdown(networthData.currentAssets.inventory.byCategory)}
                    </div>

                    <div style="margin-top: 4px;">Market listings: ${networthFormatter(Math.round(networthData.currentAssets.listings.value))}</div>
                </div>

                <!-- Fixed Assets -->
                <div style="cursor: pointer; margin-top: 8px;" id="mwi-fixed-assets-toggle">
                    + Fixed Assets: ${networthFormatter(Math.round(networthData.fixedAssets.total))}
                </div>
                <div id="mwi-fixed-assets-details" style="display: none; margin-left: 20px;">
                    <!-- Houses -->
                    <div style="cursor: pointer; margin-top: 4px;" id="mwi-houses-toggle">
                        + Houses: ${networthFormatter(Math.round(networthData.fixedAssets.houses.totalCost))}
                    </div>
                    <div id="mwi-houses-breakdown" style="display: none; margin-left: 20px; font-size: 0.8rem; color: #bbb; white-space: pre-line;">${this.renderHousesBreakdown(networthData.fixedAssets.houses.breakdown)}</div>

                    <!-- Abilities -->
                    <div style="cursor: pointer; margin-top: 4px;" id="mwi-abilities-toggle">
                        + Abilities: ${networthFormatter(Math.round(networthData.fixedAssets.abilities.totalCost))}
                    </div>
                    <div id="mwi-abilities-details" style="display: none; margin-left: 20px;">
                        <!-- Equipped Abilities -->
                        <div style="cursor: pointer; margin-top: 4px;" id="mwi-equipped-abilities-toggle">
                            + Equipped (${networthData.fixedAssets.abilities.equippedBreakdown.length}): ${networthFormatter(Math.round(networthData.fixedAssets.abilities.equippedCost))}
                        </div>
                        <div id="mwi-equipped-abilities-breakdown" style="display: none; margin-left: 20px; font-size: 0.8rem; color: #bbb; white-space: pre-line;">${this.renderAbilitiesBreakdown(networthData.fixedAssets.abilities.equippedBreakdown)}</div>

                        <!-- Other Abilities -->
                        ${
                            networthData.fixedAssets.abilities.otherBreakdown.length > 0
                                ? `
                            <div style="cursor: pointer; margin-top: 4px;" id="mwi-other-abilities-toggle">
                                + Other (${networthData.fixedAssets.abilities.otherBreakdown.length}): ${networthFormatter(Math.round(networthData.fixedAssets.abilities.totalCost - networthData.fixedAssets.abilities.equippedCost))}
                            </div>
                            <div id="mwi-other-abilities-breakdown" style="display: none; margin-left: 20px; font-size: 0.8rem; color: #bbb; white-space: pre-line;">${this.renderAbilitiesBreakdown(networthData.fixedAssets.abilities.otherBreakdown)}</div>
                        `
                                : ''
                        }
                    </div>

                    <!-- Ability Books -->
                    ${
                        networthData.fixedAssets.abilityBooks.breakdown.length > 0
                            ? `
                        <div style="cursor: pointer; margin-top: 4px;" id="mwi-ability-books-toggle">
                            + Ability Books (${networthData.fixedAssets.abilityBooks.breakdown.length}): ${networthFormatter(Math.round(networthData.fixedAssets.abilityBooks.totalCost))}
                        </div>
                        <div id="mwi-ability-books-breakdown" style="display: none; margin-left: 20px; font-size: 0.8rem; color: #bbb; white-space: pre-line;">${this.renderAbilityBooksBreakdown(networthData.fixedAssets.abilityBooks.breakdown)}</div>
                    `
                            : ''
                    }
                </div>
            </div>
        `;

            // Restore expand/collapse states after updating
            sectionsToPreserve.forEach((id) => {
                const elem = this.container.querySelector(`#${id}`);
                if (elem && expandedStates[id]) {
                    elem.style.display = 'block';

                    // Update the corresponding toggle button text (+ to -)
                    const toggleId = id.replace('-details', '-toggle').replace('-breakdown', '-toggle');
                    const toggleBtn = this.container.querySelector(`#${toggleId}`);
                    if (toggleBtn) {
                        const currentText = toggleBtn.textContent;
                        toggleBtn.textContent = currentText.replace('+ ', '- ');
                    }
                }
            });

            // Set up event listeners for all toggles
            this.setupToggleListeners(networthData);
        }

        /**
         * Render houses breakdown HTML
         * @param {Array} breakdown - Array of {name, level, cost}
         * @returns {string} HTML string
         */
        renderHousesBreakdown(breakdown) {
            if (breakdown.length === 0) {
                return '<div>No houses built</div>';
            }

            return breakdown
                .map((house) => {
                    return `${house.name} ${house.level}: ${networthFormatter(Math.round(house.cost))}`;
                })
                .join('\n');
        }

        /**
         * Render abilities breakdown HTML
         * @param {Array} breakdown - Array of {name, cost}
         * @returns {string} HTML string
         */
        renderAbilitiesBreakdown(breakdown) {
            if (breakdown.length === 0) {
                return '<div>No abilities</div>';
            }

            return breakdown
                .map((ability) => {
                    return `${ability.name}: ${networthFormatter(Math.round(ability.cost))}`;
                })
                .join('\n');
        }

        /**
         * Render ability books breakdown HTML
         * @param {Array} breakdown - Array of {name, value, count}
         * @returns {string} HTML string
         */
        renderAbilityBooksBreakdown(breakdown) {
            if (breakdown.length === 0) {
                return '<div>No ability books</div>';
            }

            return breakdown
                .map((book) => {
                    return `${book.name} (${formatKMB(book.count)}): ${networthFormatter(Math.round(book.value))}`;
                })
                .join('\n');
        }

        /**
         * Render equipment breakdown HTML
         * @param {Array} breakdown - Array of {name, value}
         * @returns {string} HTML string
         */
        renderEquipmentBreakdown(breakdown) {
            if (breakdown.length === 0) {
                return '<div>No equipment</div>';
            }

            return breakdown
                .map((item) => {
                    return `${item.name}: ${networthFormatter(Math.round(item.value))}`;
                })
                .join('\n');
        }

        /**
         * Render inventory breakdown HTML (grouped by category)
         * @param {Object} byCategory - Object with category names as keys
         * @returns {string} HTML string
         */
        renderInventoryBreakdown(byCategory) {
            if (!byCategory || Object.keys(byCategory).length === 0) {
                return '<div>No inventory</div>';
            }

            // Sort categories by total value descending
            const sortedCategories = Object.entries(byCategory).sort((a, b) => b[1].totalValue - a[1].totalValue);

            return sortedCategories
                .map(([categoryName, categoryData]) => {
                    const categoryId = `mwi-inventory-${categoryName.toLowerCase().replace(/\s+/g, '-')}`;
                    const categoryToggleId = `${categoryId}-toggle`;

                    // Build items HTML with newlines
                    const itemsHTML = categoryData.items
                        .map((item) => {
                            return `${item.name} x${formatKMB(item.count)}: ${networthFormatter(Math.round(item.value))}`;
                        })
                        .join('\n');

                    return `
                <div style="cursor: pointer; margin-top: 4px; font-size: 0.85rem;" id="${categoryToggleId}">
                    + ${categoryName}: ${networthFormatter(Math.round(categoryData.totalValue))}
                </div>
                <div id="${categoryId}" style="display: none; margin-left: 20px; font-size: 0.75rem; color: #999; white-space: pre-line;">
                    ${itemsHTML}
                </div>
            `;
                })
                .join('');
        }

        /**
         * Set up toggle event listeners
         * @param {Object} networthData - Networth data
         */
        setupToggleListeners(networthData) {
            // Main networth toggle
            this.setupToggle(
                'mwi-networth-toggle',
                'mwi-networth-details',
                `Total Networth: ${networthFormatter(Math.round(networthData.totalNetworth))}`
            );

            // Current assets toggle
            this.setupToggle(
                'mwi-current-assets-toggle',
                'mwi-current-assets-details',
                `Current Assets: ${networthFormatter(Math.round(networthData.currentAssets.total))}`
            );

            // Equipment toggle
            this.setupToggle(
                'mwi-equipment-toggle',
                'mwi-equipment-breakdown',
                `Equipment value: ${networthFormatter(Math.round(networthData.currentAssets.equipped.value))}`
            );

            // Inventory toggle
            this.setupToggle(
                'mwi-inventory-toggle',
                'mwi-inventory-breakdown',
                `Inventory value: ${networthFormatter(Math.round(networthData.currentAssets.inventory.value))}`
            );

            // Inventory category toggles
            const byCategory = networthData.currentAssets.inventory.byCategory || {};
            Object.entries(byCategory).forEach(([categoryName, categoryData]) => {
                const categoryId = `mwi-inventory-${categoryName.toLowerCase().replace(/\s+/g, '-')}`;
                const categoryToggleId = `${categoryId}-toggle`;
                this.setupToggle(
                    categoryToggleId,
                    categoryId,
                    `${categoryName}: ${networthFormatter(Math.round(categoryData.totalValue))}`
                );
            });

            // Fixed assets toggle
            this.setupToggle(
                'mwi-fixed-assets-toggle',
                'mwi-fixed-assets-details',
                `Fixed Assets: ${networthFormatter(Math.round(networthData.fixedAssets.total))}`
            );

            // Houses toggle
            this.setupToggle(
                'mwi-houses-toggle',
                'mwi-houses-breakdown',
                `Houses: ${networthFormatter(Math.round(networthData.fixedAssets.houses.totalCost))}`
            );

            // Abilities toggle
            this.setupToggle(
                'mwi-abilities-toggle',
                'mwi-abilities-details',
                `Abilities: ${networthFormatter(Math.round(networthData.fixedAssets.abilities.totalCost))}`
            );

            // Equipped abilities toggle
            this.setupToggle(
                'mwi-equipped-abilities-toggle',
                'mwi-equipped-abilities-breakdown',
                `Equipped (${networthData.fixedAssets.abilities.equippedBreakdown.length}): ${networthFormatter(Math.round(networthData.fixedAssets.abilities.equippedCost))}`
            );

            // Other abilities toggle (if exists)
            if (networthData.fixedAssets.abilities.otherBreakdown.length > 0) {
                this.setupToggle(
                    'mwi-other-abilities-toggle',
                    'mwi-other-abilities-breakdown',
                    `Other Abilities: ${networthFormatter(Math.round(networthData.fixedAssets.abilities.totalCost - networthData.fixedAssets.abilities.equippedCost))}`
                );
            }

            // Ability books toggle (if exists)
            if (networthData.fixedAssets.abilityBooks.breakdown.length > 0) {
                this.setupToggle(
                    'mwi-ability-books-toggle',
                    'mwi-ability-books-breakdown',
                    `Ability Books: ${networthFormatter(Math.round(networthData.fixedAssets.abilityBooks.totalCost))}`
                );
            }
        }

        /**
         * Set up a single toggle button
         * @param {string} toggleId - Toggle button element ID
         * @param {string} detailsId - Details element ID
         * @param {string} label - Label text (without +/- prefix)
         */
        setupToggle(toggleId, detailsId, label) {
            const toggleBtn = this.container.querySelector(`#${toggleId}`);
            const details = this.container.querySelector(`#${detailsId}`);

            if (!toggleBtn || !details) return;

            toggleBtn.addEventListener('click', () => {
                const isCollapsed = details.style.display === 'none';
                details.style.display = isCollapsed ? 'block' : 'none';
                toggleBtn.textContent = (isCollapsed ? '- ' : '+ ') + label;
            });
        }

        /**
         * Refresh colors on existing panel
         */
        refresh() {
            if (!this.container || !document.body.contains(this.container)) {
                return;
            }

            // Update main container color
            this.container.style.color = config$1.COLOR_ACCENT;
        }

        /**
         * Disable and cleanup
         */
        disable() {
            if (this.container) {
                this.container.remove();
                this.container = null;
            }

            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];
            this.currentData = null;
            this.isInitialized = false;
        }
    }

    // Export both display components
    const networthHeaderDisplay = new NetworthHeaderDisplay();
    const networthInventoryDisplay = new NetworthInventoryDisplay();

    /**
     * Create a pause registry for deterministic pause/resume handling.
     * @param {{ connectionState?: { on: Function, off: Function } }} [options] - Optional dependency overrides.
     * @returns {{
     *   register: (id: string, pauseFn: Function, resumeFn: Function) => void,
     *   unregister: (id: string) => void,
     *   pauseAll: () => void,
     *   resumeAll: () => void,
     *   cleanup: () => void
     * }} Pause registry API
     */
    function createPauseRegistry(options = {}) {
        const registry = new Map();
        const connectionStateRef = options.connectionState || connectionState;
        let isPaused = false;

        const normalizeId = (id) => (typeof id === 'string' ? id.trim() : id);
        const isValidId = (id) => typeof id === 'string' && id.trim().length > 0;

        /**
         * Register pausable work by unique id.
         * @param {string} id - Unique identifier for the pausable work.
         * @param {Function} pauseFn - Callback invoked on pause.
         * @param {Function} resumeFn - Callback invoked on resume.
         */
        const register = (id, pauseFn, resumeFn) => {
            if (!isValidId(id) || typeof pauseFn !== 'function' || typeof resumeFn !== 'function') {
                console.warn('[PauseRegistry] register called with invalid arguments');
                return;
            }

            const normalizedId = normalizeId(id);
            if (registry.has(normalizedId)) {
                console.warn(`[PauseRegistry] register called with duplicate id: ${normalizedId}`);
            }

            registry.set(normalizedId, { pauseFn, resumeFn });

            if (isPaused) {
                try {
                    pauseFn();
                } catch (error) {
                    console.error(`[PauseRegistry] Failed to pause '${normalizedId}' during register:`, error);
                }
            }
        };

        /**
         * Unregister pausable work by id.
         * Note: Unregister does not auto-resume if currently paused.
         * @param {string} id - Identifier to remove.
         */
        const unregister = (id) => {
            if (!isValidId(id)) {
                console.warn('[PauseRegistry] unregister called with invalid id');
                return;
            }

            registry.delete(normalizeId(id));
        };

        const callAll = (actionLabel, handlerKey) => {
            for (const [entryId, entry] of registry.entries()) {
                const handler = entry[handlerKey];
                if (typeof handler !== 'function') {
                    continue;
                }

                try {
                    handler();
                } catch (error) {
                    console.error(`[PauseRegistry] Failed to ${actionLabel} '${entryId}':`, error);
                }
            }
        };

        /**
         * Pause all registered work.
         */
        const pauseAll = () => {
            if (isPaused) {
                return;
            }

            isPaused = true;
            callAll('pause', 'pauseFn');
        };

        /**
         * Resume all registered work.
         */
        const resumeAll = () => {
            if (!isPaused) {
                return;
            }

            isPaused = false;
            callAll('resume', 'resumeFn');
        };

        const handleDisconnected = () => {
            pauseAll();
        };

        const handleReconnected = () => {
            resumeAll();
        };

        if (connectionStateRef && typeof connectionStateRef.on === 'function') {
            connectionStateRef.on('disconnected', handleDisconnected);
            connectionStateRef.on('reconnected', handleReconnected);
        } else {
            console.warn('[PauseRegistry] connectionState unavailable; pause/resume events not wired');
        }

        /**
         * Cleanup registry subscriptions.
         */
        const cleanup = () => {
            if (!connectionStateRef || typeof connectionStateRef.off !== 'function') {
                return;
            }

            connectionStateRef.off('disconnected', handleDisconnected);
            connectionStateRef.off('reconnected', handleReconnected);
        };

        return {
            register,
            unregister,
            pauseAll,
            resumeAll,
            cleanup,
        };
    }

    /**
     * Networth Feature - Main Coordinator
     * Manages networth calculation and display updates
     */


    class NetworthFeature {
        constructor() {
            this.isActive = false;
            this.updateInterval = null;
            this.currentData = null;
            this.timerRegistry = createTimerRegistry();
            this.pauseRegistry = null;
        }

        /**
         * Initialize the networth feature
         */
        async initialize() {
            if (this.isActive) return;

            // Set reference in display components so they can trigger recalculation
            networthHeaderDisplay.setNetworthFeature(this);

            // Initialize header display (always enabled with networth feature)
            if (config$1.isFeatureEnabled('networth')) {
                networthHeaderDisplay.initialize();
            }

            // Initialize inventory panel display (separate toggle)
            if (config$1.isFeatureEnabled('inventorySummary')) {
                networthInventoryDisplay.initialize();
            }

            if (!this.pauseRegistry) {
                this.pauseRegistry = createPauseRegistry();
                this.pauseRegistry.register(
                    'networth-update-interval',
                    () => this.stopAutoRefresh(),
                    () => this.resumeAutoRefresh()
                );
            }

            // Start update interval (every 30 seconds)
            if (connectionState.isConnected()) {
                this.startAutoRefresh();
            }

            // Initial calculation
            if (connectionState.isConnected()) {
                await this.recalculate();
            }

            this.isActive = true;
        }

        /**
         * Recalculate networth and update displays
         */
        async recalculate() {
            if (!connectionState.isConnected()) {
                return;
            }

            try {
                // Calculate networth
                const networthData = await calculateNetworth();
                this.currentData = networthData;

                // Update displays
                if (config$1.isFeatureEnabled('networth')) {
                    networthHeaderDisplay.update(networthData);
                }

                if (config$1.isFeatureEnabled('inventorySummary')) {
                    networthInventoryDisplay.update(networthData);
                }
            } catch (error) {
                console.error('[Networth] Error calculating networth:', error);
            }
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.pauseRegistry) {
                this.pauseRegistry.unregister('networth-update-interval');
                this.pauseRegistry.cleanup();
                this.pauseRegistry = null;
            }

            if (this.updateInterval) {
                clearInterval(this.updateInterval);
                this.updateInterval = null;
            }

            this.timerRegistry.clearAll();

            networthHeaderDisplay.disable();
            networthInventoryDisplay.disable();

            this.currentData = null;
            this.isActive = false;
        }

        startAutoRefresh() {
            if (this.updateInterval) {
                return;
            }

            this.updateInterval = setInterval(() => this.recalculate(), 30000);
            this.timerRegistry.registerInterval(this.updateInterval);
        }

        stopAutoRefresh() {
            if (!this.updateInterval) {
                return;
            }

            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }

        resumeAutoRefresh() {
            this.startAutoRefresh();
            this.recalculate();
        }
    }

    const networthFeature = new NetworthFeature();

    /**
     * Inventory Badge Manager
     * Centralized management for all inventory item badges
     * Prevents race conditions with React re-renders by coordinating all badge rendering
     */


    /**
     * InventoryBadgeManager class manages all inventory item badges from multiple features
     */
    class InventoryBadgeManager {
        constructor() {
            this.providers = new Map(); // name -> { renderFn, priority }
            this.currentInventoryElem = null;
            this.unregisterHandlers = [];
            this.isInitialized = false;
            this.processedItems = new WeakSet(); // Track processed item containers
            this.warnedItems = new Set(); // Track items we've already warned about
            this.isCalculating = false; // Guard flag to prevent recursive calls
            this.lastCalculationTime = 0; // Timestamp of last calculation
            this.CALCULATION_COOLDOWN = 250; // 250ms minimum between calculations
            this.inventoryLookupCache = null; // Cached inventory lookup map
            this.inventoryLookupCacheTime = 0; // Timestamp when cache was built
            this.INVENTORY_CACHE_TTL = 500; // 500ms cache lifetime
        }

        /**
         * Initialize badge manager
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            this.isInitialized = true;

            // Check if inventory is already open
            const existingInv = document.querySelector('[class*="Inventory_items"]');
            if (existingInv) {
                this.currentInventoryElem = existingInv;
            }

            // Watch for inventory panel
            const unregister = domObserver$1.onClass('InventoryBadgeManager', 'Inventory_items', (elem) => {
                this.currentInventoryElem = elem;
            });
            this.unregisterHandlers.push(unregister);

            // Watch for DOM changes to refresh badges
            const badgeRefreshUnregister = domObserver$1.register(
                'InventoryBadgeManager-Refresh',
                () => {
                    if (this.currentInventoryElem) {
                        this.renderAllBadges();
                    }
                },
                { debounce: true, debounceDelay: 150 } // 150ms debounce to reduce calculation frequency
            );
            this.unregisterHandlers.push(badgeRefreshUnregister);
        }

        /**
         * Register a badge provider
         * @param {string} name - Unique provider name
         * @param {Function} renderFn - Function(itemElem) that renders badges for an item
         * @param {number} priority - Render order (lower = earlier, default 100)
         */
        registerProvider(name, renderFn, priority = 100) {
            this.providers.set(name, { renderFn, priority });
        }

        /**
         * Unregister a badge provider
         * @param {string} name - Provider name
         */
        unregisterProvider(name) {
            this.providers.delete(name);
        }

        /**
         * Clear processed tracking (forces re-render on next pass)
         */
        clearProcessedTracking() {
            this.processedItems = new WeakSet();
        }

        /**
         * Render all badges on all items from all providers
         */
        async renderAllBadges() {
            if (!this.currentInventoryElem) return;

            // Calculate prices for all items
            await this.calculatePricesForAllItems();

            const itemElems = this.currentInventoryElem.querySelectorAll('[class*="Item_itemContainer"]');

            // Sort providers by priority
            const sortedProviders = Array.from(this.providers.entries()).sort((a, b) => a[1].priority - b[1].priority);

            for (const itemElem of itemElems) {
                // Check if already processed AND badges still exist
                // React can destroy inner content while keeping container reference
                const wasProcessed = this.processedItems.has(itemElem);
                const hasBadges = this.itemHasBadges(itemElem);

                // Skip only if processed AND badges still exist
                if (wasProcessed && hasBadges) {
                    continue;
                }

                // Call each provider's render function for this item
                for (const [name, { renderFn }] of sortedProviders) {
                    try {
                        renderFn(itemElem);
                    } catch (error) {
                        console.error(`[InventoryBadgeManager] Error in provider "${name}":`, error);
                    }
                }

                // Mark as processed
                this.processedItems.add(itemElem);
            }
        }

        /**
         * Calculate prices for all items in inventory
         */
        async calculatePricesForAllItems() {
            if (!this.currentInventoryElem) return;

            // Prevent recursive calls
            if (this.isCalculating) return;

            // Cooldown check - prevent spamming during rapid events
            const now = Date.now();
            if (now - this.lastCalculationTime < this.CALCULATION_COOLDOWN) {
                return;
            }
            this.lastCalculationTime = now;

            this.isCalculating = true;

            const inventoryElem = this.currentInventoryElem;

            // Build inventory cache once if expired or missing (500ms TTL)
            let inventory = null;
            let inventoryLookup = null;

            const cacheAge = now - this.inventoryLookupCacheTime;
            if (this.inventoryLookupCache && cacheAge < this.INVENTORY_CACHE_TTL) {
                // Use cached data
                inventory = this.inventoryLookupCache.inventory;
                inventoryLookup = this.inventoryLookupCache.lookup;
            } else {
                // Rebuild cache
                inventory = dataManager$1.getInventory();
                if (inventory) {
                    inventoryLookup = new Map();
                    for (const item of inventory) {
                        if (item.itemLocationHrid === '/item_locations/inventory') {
                            const key = `${item.itemHrid}|${item.count}`;
                            inventoryLookup.set(key, item);
                        }
                    }
                    // Store in cache
                    this.inventoryLookupCache = { inventory, lookup: inventoryLookup };
                    this.inventoryLookupCacheTime = now;
                }
            }

            // Process each category
            for (const categoryDiv of inventoryElem.children) {
                const itemElems = categoryDiv.querySelectorAll('[class*="Item_itemContainer"]');
                await this.calculateItemPrices(itemElems, inventory, inventoryLookup);
            }

            this.isCalculating = false;
        }

        /**
         * Calculate and store prices for all items (populates dataset.askValue/bidValue)
         * @param {NodeList} itemElems - Item elements
         * @param {Array} cachedInventory - Optional cached inventory data
         * @param {Map} cachedInventoryLookup - Optional cached inventory lookup map
         */
        async calculateItemPrices(itemElems, cachedInventory = null, cachedInventoryLookup = null) {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) {
                console.warn('[InventoryBadgeManager] Game data not available yet');
                return;
            }

            // Use cached inventory if provided, otherwise fetch fresh
            let inventory = cachedInventory;
            let inventoryLookup = cachedInventoryLookup;

            if (!inventory || !inventoryLookup) {
                // Get inventory data for enhancement level matching
                inventory = dataManager$1.getInventory();
                if (!inventory) {
                    console.warn('[InventoryBadgeManager] Inventory data not available yet');
                    return;
                }

                // Build lookup map: itemHrid|count -> inventory item
                inventoryLookup = new Map();
                for (const item of inventory) {
                    if (item.itemLocationHrid === '/item_locations/inventory') {
                        const key = `${item.itemHrid}|${item.count}`;
                        inventoryLookup.set(key, item);
                    }
                }
            }

            // OPTIMIZATION: Pre-fetch all market prices in one batch
            const itemsToPrice = [];
            for (const item of inventory) {
                if (item.itemLocationHrid === '/item_locations/inventory') {
                    itemsToPrice.push({
                        itemHrid: item.itemHrid,
                        enhancementLevel: item.enhancementLevel || 0,
                    });
                }
            }
            const priceCache = marketAPI.getPricesBatch(itemsToPrice);

            // Get settings for high enhancement cost mode
            const useHighEnhancementCost = config$1.getSetting('networth_highEnhancementUseCost');
            const minLevel = config$1.getSetting('networth_highEnhancementMinLevel') || 13;

            // Currency items to skip (actual currencies, not category)
            const currencyHrids = new Set([
                '/items/gold_coin',
                '/items/cowbell',
                '/items/task_token',
                '/items/chimerical_token',
                '/items/sinister_token',
                '/items/enchanted_token',
                '/items/pirate_token',
            ]);

            for (const itemElem of itemElems) {
                // Get item HRID from SVG aria-label
                const svg = itemElem.querySelector('svg');
                if (!svg) continue;

                const itemName = svg.getAttribute('aria-label');
                if (!itemName) continue;

                // Find item HRID
                const itemHrid = this.findItemHrid(itemName, gameData);
                if (!itemHrid) {
                    console.warn('[InventoryBadgeManager] Could not find HRID for item:', itemName);
                    continue;
                }

                // Skip actual currency items
                if (currencyHrids.has(itemHrid)) {
                    itemElem.dataset.askPrice = 0;
                    itemElem.dataset.bidPrice = 0;
                    itemElem.dataset.askValue = 0;
                    itemElem.dataset.bidValue = 0;
                    continue;
                }

                // Get item count
                const countElem = itemElem.querySelector('[class*="Item_count"]');
                if (!countElem) continue;

                let itemCount = countElem.textContent;
                itemCount = this.parseItemCount(itemCount);

                // Get item details (reused throughout)
                const itemDetails = gameData.itemDetailMap[itemHrid];

                // Handle trainee items (untradeable, no market data)
                if (itemHrid.includes('trainee_')) {
                    // EXCEPTION: Trainee charms should use vendor price
                    const equipmentType = itemDetails?.equipmentDetail?.type;
                    const isCharm = equipmentType === '/equipment_types/charm';
                    const sellPrice = itemDetails?.sellPrice;

                    if (isCharm && sellPrice) {
                        // Use sell price for trainee charms
                        itemElem.dataset.askPrice = sellPrice;
                        itemElem.dataset.bidPrice = sellPrice;
                        itemElem.dataset.askValue = sellPrice * itemCount;
                        itemElem.dataset.bidValue = sellPrice * itemCount;
                    } else {
                        // Other trainee items (weapons/armor) remain at 0
                        itemElem.dataset.askPrice = 0;
                        itemElem.dataset.bidPrice = 0;
                        itemElem.dataset.askValue = 0;
                        itemElem.dataset.bidValue = 0;
                    }
                    continue;
                }

                // Handle openable containers (chests, crates, caches)
                if (itemDetails?.isOpenable && expectedValueCalculator.isInitialized) {
                    const evData = expectedValueCalculator.calculateExpectedValue(itemHrid);
                    if (evData && evData.expectedValue > 0) {
                        // Use expected value for both ask and bid
                        itemElem.dataset.askPrice = evData.expectedValue;
                        itemElem.dataset.bidPrice = evData.expectedValue;
                        itemElem.dataset.askValue = evData.expectedValue * itemCount;
                        itemElem.dataset.bidValue = evData.expectedValue * itemCount;
                        continue;
                    }
                }

                // Match to inventory item to get enhancement level
                const key = `${itemHrid}|${itemCount}`;
                const inventoryItem = inventoryLookup.get(key);
                const enhancementLevel = inventoryItem?.enhancementLevel || 0;

                // Check if item is equipment
                const isEquipment = !!itemDetails?.equipmentDetail;

                let askPrice = 0;
                let bidPrice = 0;

                // Determine pricing method
                if (isEquipment && useHighEnhancementCost && enhancementLevel >= minLevel) {
                    // Use enhancement cost calculation for high-level equipment
                    const cachedCost = networthCache.get(itemHrid, enhancementLevel);

                    if (cachedCost !== null) {
                        // Use cached value for both ask and bid
                        askPrice = cachedCost;
                        bidPrice = cachedCost;
                    } else {
                        // Calculate enhancement cost
                        const enhancementParams = getEnhancingParams();
                        const enhancementPath = calculateEnhancementPath(itemHrid, enhancementLevel, enhancementParams);

                        if (enhancementPath && enhancementPath.optimalStrategy) {
                            const enhancementCost = enhancementPath.optimalStrategy.totalCost;

                            // Cache the result
                            networthCache.set(itemHrid, enhancementLevel, enhancementCost);

                            // Use enhancement cost for both ask and bid
                            askPrice = enhancementCost;
                            bidPrice = enhancementCost;
                        } else {
                            // Enhancement calculation failed, fallback to market price
                            const key = `${itemHrid}:${enhancementLevel}`;
                            const marketPrice = priceCache.get(key);
                            if (marketPrice) {
                                askPrice = marketPrice.ask > 0 ? marketPrice.ask : 0;
                                bidPrice = marketPrice.bid > 0 ? marketPrice.bid : 0;
                            }
                        }
                    }
                } else {
                    // Use market price (for non-equipment or low enhancement levels)
                    const key = `${itemHrid}:${enhancementLevel}`;
                    const marketPrice = priceCache.get(key);

                    // Start with whatever market data exists
                    if (marketPrice) {
                        askPrice = marketPrice.ask > 0 ? marketPrice.ask : 0;
                        bidPrice = marketPrice.bid > 0 ? marketPrice.bid : 0;
                    }

                    // For enhanced equipment, fill in missing prices with enhancement cost
                    if (isEquipment && enhancementLevel > 0 && (askPrice === 0 || bidPrice === 0)) {
                        // Check cache first
                        const cachedCost = networthCache.get(itemHrid, enhancementLevel);
                        let enhancementCost = cachedCost;

                        if (cachedCost === null) {
                            // Calculate enhancement cost
                            const enhancementParams = getEnhancingParams();
                            const enhancementPath = calculateEnhancementPath(itemHrid, enhancementLevel, enhancementParams);

                            if (enhancementPath && enhancementPath.optimalStrategy) {
                                enhancementCost = enhancementPath.optimalStrategy.totalCost;
                                networthCache.set(itemHrid, enhancementLevel, enhancementCost);
                            } else {
                                enhancementCost = null;
                            }
                        }

                        // Fill in missing prices
                        if (enhancementCost !== null) {
                            if (askPrice === 0) askPrice = enhancementCost;
                            if (bidPrice === 0) bidPrice = enhancementCost;
                        }
                    } else if (isEquipment && enhancementLevel === 0 && askPrice === 0 && bidPrice === 0) {
                        // For unenhanced equipment with no market data, use crafting cost
                        const craftingCost = this.calculateCraftingCost(itemHrid);
                        if (craftingCost > 0) {
                            askPrice = craftingCost;
                            bidPrice = craftingCost;
                        } else if (!this.warnedItems.has(itemHrid)) {
                            // No crafting recipe found (likely drop-only item)
                            console.warn(
                                '[InventoryBadgeManager] No market data or crafting recipe for equipment:',
                                itemName,
                                itemHrid
                            );
                            this.warnedItems.add(itemHrid);
                        }
                    } else if (!isEquipment && askPrice === 0 && bidPrice === 0) {
                        // Non-equipment with no market data
                        if (!this.warnedItems.has(itemHrid)) {
                            console.warn(
                                '[InventoryBadgeManager] No market data for non-equipment item:',
                                itemName,
                                itemHrid
                            );
                            this.warnedItems.add(itemHrid);
                        }
                        // Leave values at 0 (no badge will be shown)
                    }
                }

                // Store per-item prices (for badge display)
                itemElem.dataset.askPrice = askPrice;
                itemElem.dataset.bidPrice = bidPrice;

                // Store stack totals (for sorting and stack value badges)
                itemElem.dataset.askValue = askPrice * itemCount;
                itemElem.dataset.bidValue = bidPrice * itemCount;
            }
        }

        /**
         * Calculate crafting cost for an item (used for unenhanced equipment with no market data)
         * @param {string} itemHrid - Item HRID
         * @returns {number} Total material cost or 0 if not craftable
         */
        calculateCraftingCost(itemHrid) {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) return 0;

            // Find the action that produces this item
            for (const action of Object.values(gameData.actionDetailMap || {})) {
                if (action.outputItems) {
                    for (const output of action.outputItems) {
                        if (output.itemHrid === itemHrid) {
                            // Found the crafting action, calculate material costs
                            let inputCost = 0;

                            // Add input items
                            if (action.inputItems && action.inputItems.length > 0) {
                                for (const input of action.inputItems) {
                                    const inputPrice = getItemPrice(input.itemHrid, { mode: 'ask' }) || 0;
                                    inputCost += inputPrice * input.count;
                                }
                            }

                            // Apply Artisan Tea reduction (0.9x) to input materials
                            inputCost *= 0.9;

                            // Add upgrade item cost (not affected by Artisan Tea)
                            let upgradeCost = 0;
                            if (action.upgradeItemHrid) {
                                const upgradePrice = getItemPrice(action.upgradeItemHrid, { mode: 'ask' }) || 0;
                                upgradeCost = upgradePrice;
                            }

                            const totalCost = inputCost + upgradeCost;

                            // Divide by output count to get per-item cost
                            return totalCost / (output.count || 1);
                        }
                    }
                }
            }

            return 0;
        }

        /**
         * Find item HRID from item name
         * @param {string} itemName - Item display name
         * @param {Object} gameData - Game data
         * @returns {string|null} Item HRID
         */
        findItemHrid(itemName, gameData) {
            // Direct lookup in itemDetailMap
            for (const [hrid, item] of Object.entries(gameData.itemDetailMap)) {
                if (item.name === itemName) {
                    return hrid;
                }
            }
            return null;
        }

        /**
         * Parse item count from text (handles K, M suffixes)
         * @param {string} text - Count text
         * @returns {number} Numeric count
         */
        parseItemCount(text) {
            text = text.toLowerCase().trim();

            if (text.includes('k')) {
                return parseFloat(text.replace('k', '')) * 1000;
            } else if (text.includes('m')) {
                return parseFloat(text.replace('m', '')) * 1000000;
            } else {
                return parseFloat(text) || 0;
            }
        }

        /**
         * Check if item has any badges
         * @param {Element} itemElem - Item container element
         * @returns {boolean} True if item has any badge elements
         */
        itemHasBadges(itemElem) {
            return !!(
                itemElem.querySelector('.mwi-badge-price-bid') ||
                itemElem.querySelector('.mwi-badge-price-ask') ||
                itemElem.querySelector('.mwi-stack-price')
            );
        }

        /**
         * Disable and cleanup
         */
        disable() {
            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];
            this.providers.clear();
            this.processedItems = new WeakSet();
            this.currentInventoryElem = null;
            this.isInitialized = false;
        }
    }

    const inventoryBadgeManager = new InventoryBadgeManager();

    /**
     * Inventory Sort Module
     * Sorts inventory items by Ask/Bid price with optional stack value badges
     */


    /**
     * InventorySort class manages inventory sorting and price badges
     */
    class InventorySort {
        constructor() {
            this.currentMode = 'none'; // 'ask', 'bid', 'none'
            this.unregisterHandlers = [];
            this.controlsContainer = null;
            this.currentInventoryElem = null;
            this.warnedItems = new Set(); // Track items we've already warned about
            this.isCalculating = false; // Guard flag to prevent recursive calls
            this.isInitialized = false;
            this.itemsUpdatedHandler = null;
            this.itemsUpdatedDebounceTimer = null; // Debounce timer for items_updated events
            this.DEBOUNCE_DELAY = 300; // 300ms debounce for event handlers
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Setup settings listeners for feature toggle and color changes
         */
        setupSettingListener() {
            config$1.onSettingChange('invSort', async (value) => {
                if (value) {
                    await this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('color_accent', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize inventory sort feature
         */
        async initialize() {
            if (!config$1.getSetting('invSort')) {
                return;
            }

            if (this.unregisterHandlers.length > 0) {
                return;
            }

            // Load persisted settings
            await this.loadSettings();

            // Check if inventory is already open
            const existingInv = document.querySelector('[class*="Inventory_items"]');
            if (existingInv) {
                this.currentInventoryElem = existingInv;
                this.injectSortControls(existingInv);
                this.applyCurrentSort();
            }

            // Watch for inventory panel (for future opens/reloads)
            const unregister = domObserver$1.onClass('InventorySort', 'Inventory_items', (elem) => {
                this.currentInventoryElem = elem;
                this.injectSortControls(elem);
                this.applyCurrentSort();
            });
            this.unregisterHandlers.push(unregister);

            // Register with badge manager for coordinated rendering
            inventoryBadgeManager.registerProvider(
                'inventory-stack-price',
                (itemElem) => this.renderBadgesForItem(itemElem),
                50 // Priority: render before bid/ask badges (lower = earlier)
            );

            // Store handler reference for cleanup with debouncing
            this.itemsUpdatedHandler = () => {
                clearTimeout(this.itemsUpdatedDebounceTimer);
                this.itemsUpdatedDebounceTimer = setTimeout(() => {
                    if (this.currentInventoryElem) {
                        this.applyCurrentSort();
                    }
                }, this.DEBOUNCE_DELAY);
            };

            // Listen for inventory changes to recalculate prices
            dataManager$1.on('items_updated', this.itemsUpdatedHandler);

            // Listen for market data updates to refresh badges
            this.setupMarketDataListener();

            this.isInitialized = true;
        }

        /**
         * Setup listener for market data updates
         */
        setupMarketDataListener() {
            // If market data isn't loaded yet, retry periodically
            if (!marketAPI.isLoaded()) {
                let retryCount = 0;
                const maxRetries = 10;
                const retryInterval = 500; // 500ms between retries

                const retryCheck = setInterval(() => {
                    retryCount++;

                    if (marketAPI.isLoaded()) {
                        clearInterval(retryCheck);

                        // Refresh if inventory is still open
                        if (this.currentInventoryElem) {
                            this.applyCurrentSort();
                        }
                    } else if (retryCount >= maxRetries) {
                        console.warn('[InventorySort] Market data still not available after', maxRetries, 'retries');
                        clearInterval(retryCheck);
                    }
                }, retryInterval);

                this.timerRegistry.registerInterval(retryCheck);
            }
        }

        /**
         * Load settings from storage
         */
        async loadSettings() {
            try {
                const settings = await storage$1.getJSON('inventorySort', 'settings');
                if (settings && settings.mode) {
                    this.currentMode = settings.mode;
                }
            } catch (error) {
                console.error('[InventorySort] Failed to load settings:', error);
            }
        }

        /**
         * Save settings to storage
         */
        saveSettings() {
            try {
                storage$1.setJSON(
                    'inventorySort',
                    {
                        mode: this.currentMode,
                    },
                    'settings',
                    true // immediate write for user preference
                );
            } catch (error) {
                console.error('[InventorySort] Failed to save settings:', error);
            }
        }

        /**
         * Inject sort controls into inventory panel
         * @param {Element} inventoryElem - Inventory items container
         */
        injectSortControls(inventoryElem) {
            // Set current inventory element
            this.currentInventoryElem = inventoryElem;

            // Check if controls already exist
            if (this.controlsContainer && document.body.contains(this.controlsContainer)) {
                return;
            }

            // Create controls container
            this.controlsContainer = document.createElement('div');
            this.controlsContainer.className = 'mwi-inventory-sort-controls';
            this.controlsContainer.style.cssText = `
            color: ${config$1.COLOR_ACCENT};
            font-size: 0.875rem;
            text-align: left;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        `;

            // Sort label and buttons
            const sortLabel = document.createElement('span');
            sortLabel.textContent = 'Sort: ';

            const askButton = this.createSortButton('Ask', 'ask');
            const bidButton = this.createSortButton('Bid', 'bid');
            const noneButton = this.createSortButton('None', 'none');

            // Assemble controls
            this.controlsContainer.appendChild(sortLabel);
            this.controlsContainer.appendChild(askButton);
            this.controlsContainer.appendChild(bidButton);
            this.controlsContainer.appendChild(noneButton);

            // Insert before inventory
            inventoryElem.insertAdjacentElement('beforebegin', this.controlsContainer);

            // Update button states
            this.updateButtonStates();
        }

        /**
         * Create a sort button
         * @param {string} label - Button label
         * @param {string} mode - Sort mode
         * @returns {Element} Button element
         */
        createSortButton(label, mode) {
            const button = document.createElement('button');
            button.textContent = label;
            button.dataset.mode = mode;
            button.style.cssText = `
            border-radius: 3px;
            padding: 4px 12px;
            border: none;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        `;

            button.addEventListener('click', () => {
                this.setSortMode(mode);
            });

            return button;
        }

        /**
         * Update button visual states based on current mode
         */
        updateButtonStates() {
            if (!this.controlsContainer) return;

            const buttons = this.controlsContainer.querySelectorAll('button');
            buttons.forEach((button) => {
                const isActive = button.dataset.mode === this.currentMode;

                if (isActive) {
                    button.style.backgroundColor = config$1.COLOR_ACCENT;
                    button.style.color = 'black';
                    button.style.fontWeight = 'bold';
                } else {
                    button.style.backgroundColor = '#444';
                    button.style.color = '${config.COLOR_TEXT_SECONDARY}';
                    button.style.fontWeight = 'normal';
                }
            });
        }

        /**
         * Set sort mode and apply sorting
         * @param {string} mode - Sort mode ('ask', 'bid', 'none')
         */
        setSortMode(mode) {
            this.currentMode = mode;
            this.saveSettings();
            this.updateButtonStates();

            // Clear badge manager's processed tracking to force re-render with new mode
            inventoryBadgeManager.clearProcessedTracking();

            // Remove all existing stack price badges so they can be recreated with new settings
            const badges = document.querySelectorAll('.mwi-stack-price');
            badges.forEach((badge) => badge.remove());

            this.applyCurrentSort();
        }

        /**
         * Apply current sort mode to inventory
         */
        async applyCurrentSort() {
            if (!this.currentInventoryElem) return;

            // Prevent recursive calls (guard against DOM observer triggering during calculation)
            if (this.isCalculating) return;
            this.isCalculating = true;

            const inventoryElem = this.currentInventoryElem;

            // Trigger badge manager to calculate prices and render badges
            await inventoryBadgeManager.renderAllBadges();

            // Process each category
            for (const categoryDiv of inventoryElem.children) {
                // Get category name
                const categoryButton = categoryDiv.querySelector('[class*="Inventory_categoryButton"]');
                if (!categoryButton) continue;

                const categoryName = categoryButton.textContent.trim();

                // Equipment category: check setting for whether to enable sorting
                // Loots category: always disable sorting (but allow badges)
                const isEquipmentCategory = categoryName === 'Equipment';
                const isLootsCategory = categoryName === 'Loots';
                const shouldSort = isLootsCategory
                    ? false
                    : isEquipmentCategory
                      ? config$1.getSetting('invSort_sortEquipment')
                      : true;

                // Ensure category label stays at top
                const label = categoryDiv.querySelector('[class*="Inventory_label"]');
                if (label) {
                    label.style.order = Number.MIN_SAFE_INTEGER;
                }

                // Get all item elements
                const itemElems = categoryDiv.querySelectorAll('[class*="Item_itemContainer"]');

                if (shouldSort && this.currentMode !== 'none') {
                    // Sort by price (prices already calculated by badge manager)
                    this.sortItemsByPrice(itemElems, this.currentMode);
                } else {
                    // Reset to default order
                    itemElems.forEach((itemElem) => {
                        itemElem.style.order = 0;
                    });
                }
            }

            // Clear guard flag
            this.isCalculating = false;
        }

        /**
         * Sort items by price (ask or bid)
         * @param {NodeList} itemElems - Item elements
         * @param {string} mode - 'ask' or 'bid'
         */
        sortItemsByPrice(itemElems, mode) {
            // Convert NodeList to array with values
            const items = Array.from(itemElems).map((elem) => ({
                elem,
                value: parseFloat(elem.dataset[mode + 'Value']) || 0,
            }));

            // Sort by value descending (highest first)
            items.sort((a, b) => b.value - a.value);

            // Assign sequential order values (0, 1, 2, 3...)
            items.forEach((item, index) => {
                item.elem.style.order = index;
            });
        }

        /**
         * Render stack price badge for a single item (called by badge manager)
         * @param {Element} itemElem - Item container element
         */
        renderBadgesForItem(itemElem) {
            // Determine if badges should be shown and which value to use
            let showBadges = false;
            let badgeValueKey = null;

            if (this.currentMode === 'none') {
                // When sort mode is 'none', check invSort_badgesOnNone setting
                const badgesOnNone = config$1.getSettingValue('invSort_badgesOnNone', 'None');
                if (badgesOnNone !== 'None') {
                    showBadges = true;
                    badgeValueKey = badgesOnNone.toLowerCase() + 'Value'; // 'askValue' or 'bidValue'
                }
            } else {
                // When sort mode is 'ask' or 'bid', check invSort_showBadges setting
                const showBadgesSetting = config$1.getSetting('invSort_showBadges');
                if (showBadgesSetting) {
                    showBadges = true;
                    badgeValueKey = this.currentMode + 'Value'; // 'askValue' or 'bidValue'
                }
            }

            // Show badge if enabled and doesn't already exist
            if (showBadges && badgeValueKey) {
                const stackValue = parseFloat(itemElem.dataset[badgeValueKey]) || 0;

                if (stackValue > 0 && !itemElem.querySelector('.mwi-stack-price')) {
                    this.renderPriceBadge(itemElem, stackValue);
                }
            }
        }

        /**
         * Update price badges on all items (legacy method - now delegates to manager)
         */
        updatePriceBadges() {
            inventoryBadgeManager.renderAllBadges();
        }

        /**
         * Render price badge on item
         * @param {Element} itemElem - Item container element
         * @param {number} stackValue - Total stack value
         */
        renderPriceBadge(itemElem, stackValue) {
            // Ensure item has relative positioning
            itemElem.style.position = 'relative';

            // Create badge element
            const badge = document.createElement('div');
            badge.className = 'mwi-stack-price';
            badge.style.cssText = `
            position: absolute;
            top: 2px;
            right: 2px;
            z-index: 1;
            color: ${config$1.COLOR_ACCENT};
            font-size: 0.7rem;
            font-weight: bold;
            text-align: right;
            pointer-events: none;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 3px #000;
        `;
            badge.textContent = formatKMB(stackValue, 2);

            // Insert into item
            const itemInner = itemElem.querySelector('[class*="Item_item"]');
            if (itemInner) {
                itemInner.appendChild(badge);
            }
        }

        /**
         * Refresh badges (called when badge setting changes)
         */
        refresh() {
            // Update controls container color
            if (this.controlsContainer) {
                this.controlsContainer.style.color = config$1.COLOR_ACCENT;
            }

            // Update button states (which includes colors)
            this.updateButtonStates();

            // Update all price badge colors
            document.querySelectorAll('.mwi-stack-price').forEach((badge) => {
                badge.style.color = config$1.COLOR_ACCENT;
            });
        }

        /**
         * Disable and cleanup
         */
        disable() {
            // Clear debounce timer
            clearTimeout(this.itemsUpdatedDebounceTimer);
            this.itemsUpdatedDebounceTimer = null;

            if (this.itemsUpdatedHandler) {
                dataManager$1.off('items_updated', this.itemsUpdatedHandler);
                this.itemsUpdatedHandler = null;
            }

            this.timerRegistry.clearAll();

            // Unregister from badge manager
            inventoryBadgeManager.unregisterProvider('inventory-stack-price');

            // Remove controls
            if (this.controlsContainer) {
                this.controlsContainer.remove();
                this.controlsContainer = null;
            }

            // Remove all badges
            const badges = document.querySelectorAll('.mwi-stack-price');
            badges.forEach((badge) => badge.remove());

            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];

            this.currentInventoryElem = null;
            this.isInitialized = false;
        }
    }

    const inventorySort = new InventorySort();
    inventorySort.setupSettingListener();

    /**
     * Inventory Badge Prices Module
     * Shows ask/bid price badges on inventory item icons
     * Works independently of inventory sorting feature
     */


    /**
     * InventoryBadgePrices class manages price badge overlays on inventory items
     */
    class InventoryBadgePrices {
        constructor() {
            this.unregisterHandlers = [];
            this.currentInventoryElem = null;
            this.warnedItems = new Set();
            this.isCalculating = false;
            this.isInitialized = false;
            this.itemsUpdatedHandler = null;
            this.itemsUpdatedDebounceTimer = null; // Debounce timer for items_updated events
            this.DEBOUNCE_DELAY = 300; // 300ms debounce for event handlers
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Setup setting change listener (always active, even when feature is disabled)
         */
        setupSettingListener() {
            // Listen for main toggle changes
            config$1.onSettingChange('invBadgePrices', (enabled) => {
                if (enabled) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('color_invBadge_bid', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });

            config$1.onSettingChange('color_invBadge_ask', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize badge prices feature
         */
        initialize() {
            if (!config$1.getSetting('invBadgePrices')) {
                return;
            }

            if (this.isInitialized) {
                return;
            }

            this.isInitialized = true;

            // Check if inventory is already open
            const existingInv = document.querySelector('[class*="Inventory_items"]');
            if (existingInv) {
                this.currentInventoryElem = existingInv;
                this.updateBadges();
            }

            // Watch for inventory panel
            const unregister = domObserver$1.onClass('InventoryBadgePrices', 'Inventory_items', (elem) => {
                this.currentInventoryElem = elem;
                this.updateBadges();
            });
            this.unregisterHandlers.push(unregister);

            // Register with badge manager for coordinated rendering
            inventoryBadgeManager.registerProvider(
                'inventory-badge-prices',
                (itemElem) => this.renderBadgesForItem(itemElem),
                100 // Priority: render after stack prices
            );

            // Store handler reference for cleanup with debouncing
            this.itemsUpdatedHandler = () => {
                clearTimeout(this.itemsUpdatedDebounceTimer);
                this.itemsUpdatedDebounceTimer = setTimeout(() => {
                    if (this.currentInventoryElem) {
                        this.updateBadges();
                    }
                }, this.DEBOUNCE_DELAY);
            };

            // Listen for inventory changes to recalculate prices
            dataManager$1.on('items_updated', this.itemsUpdatedHandler);

            // Listen for market data updates
            this.setupMarketDataListener();
        }

        /**
         * Setup listener for market data updates
         */
        setupMarketDataListener() {
            if (!marketAPI.isLoaded()) {
                let retryCount = 0;
                const maxRetries = 10;
                const retryInterval = 500;

                const retryCheck = setInterval(() => {
                    retryCount++;

                    if (marketAPI.isLoaded()) {
                        clearInterval(retryCheck);
                        if (this.currentInventoryElem) {
                            this.updateBadges();
                        }
                    } else if (retryCount >= maxRetries) {
                        console.warn('[InventoryBadgePrices] Market data still not available after', maxRetries, 'retries');
                        clearInterval(retryCheck);
                    }
                }, retryInterval);

                this.timerRegistry.registerInterval(retryCheck);
            }
        }

        /**
         * Update all price badges (delegates to badge manager)
         * Skips rendering if InventorySort is active (it already handles badge rendering)
         */
        async updateBadges() {
            // Skip if InventorySort is active - it already calls renderAllBadges() in applyCurrentSort()
            // This prevents duplicate calculations when both modules are enabled
            if (inventorySort.isInitialized && config$1.getSetting('invSort')) {
                return;
            }

            await inventoryBadgeManager.renderAllBadges();
        }

        /**
         * Render price badges for a single item (called by badge manager)
         * @param {Element} itemElem - Item container element
         */
        renderBadgesForItem(itemElem) {
            // Get per-item prices from dataset
            const bidPrice = parseFloat(itemElem.dataset.bidPrice) || 0;
            const askPrice = parseFloat(itemElem.dataset.askPrice) || 0;

            // Show badges if they have values and don't already exist
            if (bidPrice > 0 && !itemElem.querySelector('.mwi-badge-price-bid')) {
                this.renderPriceBadge(itemElem, bidPrice, 'bid');
            }
            if (askPrice > 0 && !itemElem.querySelector('.mwi-badge-price-ask')) {
                this.renderPriceBadge(itemElem, askPrice, 'ask');
            }
        }

        /**
         * Render all badges (legacy method - now delegates to manager)
         */
        renderBadges() {
            inventoryBadgeManager.renderAllBadges();
        }

        /**
         * Render price badge on item
         * @param {Element} itemElem - Item container element
         * @param {number} price - Per-item price
         * @param {string} type - 'bid' or 'ask'
         */
        renderPriceBadge(itemElem, price, type) {
            itemElem.style.position = 'relative';

            const badge = document.createElement('div');
            badge.className = `mwi-badge-price-${type}`;

            // Position: vertically centered on left (ask) or right (bid)
            const isAsk = type === 'ask';
            const color = isAsk ? config$1.COLOR_INVBADGE_ASK : config$1.COLOR_INVBADGE_BID;

            badge.style.cssText = `
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            ${isAsk ? 'left: 2px;' : 'right: 2px;'}
            z-index: 1;
            color: ${color};
            font-size: 0.7rem;
            font-weight: bold;
            text-align: ${isAsk ? 'left' : 'right'};
            pointer-events: none;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 3px #000;
        `;
            badge.textContent = formatKMB(Math.round(price), 0);

            const itemInner = itemElem.querySelector('[class*="Item_item"]');
            if (itemInner) {
                itemInner.appendChild(badge);
            }
        }

        /**
         * Refresh badges (called when settings change)
         */
        refresh() {
            // Clear badge manager's processed tracking to force re-render
            inventoryBadgeManager.clearProcessedTracking();

            // Remove all existing badges so they can be recreated with new settings
            const badges = document.querySelectorAll('.mwi-badge-price-bid, .mwi-badge-price-ask');
            badges.forEach((badge) => badge.remove());

            // Trigger re-render
            this.updateBadges();
        }

        /**
         * Disable and cleanup
         */
        disable() {
            // Clear debounce timer
            clearTimeout(this.itemsUpdatedDebounceTimer);
            this.itemsUpdatedDebounceTimer = null;

            if (this.itemsUpdatedHandler) {
                dataManager$1.off('items_updated', this.itemsUpdatedHandler);
                this.itemsUpdatedHandler = null;
            }

            inventoryBadgeManager.unregisterProvider('inventory-badge-prices');

            const badges = document.querySelectorAll('.mwi-badge-price-bid, .mwi-badge-price-ask');
            badges.forEach((badge) => badge.remove());

            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];

            this.timerRegistry.clearAll();

            this.currentInventoryElem = null;
            this.isInitialized = false;
        }
    }

    const inventoryBadgePrices = new InventoryBadgePrices();

    inventoryBadgePrices.setupSettingListener();

    /**
     * Dungeon Token Shop Tooltips
     * Adds shop item lists to dungeon token tooltips with market pricing
     */


    /**
     * Dungeon token HRIDs
     */
    const DUNGEON_TOKENS = {
        '/items/chimerical_token': 'Chimerical Token',
        '/items/sinister_token': 'Sinister Token',
        '/items/enchanted_token': 'Enchanted Token',
        '/items/pirate_token': 'Pirate Token',
    };

    /**
     * DungeonTokenTooltips class handles injecting shop item lists into dungeon token tooltips
     */
    class DungeonTokenTooltips {
        constructor() {
            this.unregisterObserver = null;
            this.isActive = false;
            this.isInitialized = false;
            this.itemNameToHridCache = null; // Lazy-loaded reverse lookup cache
            this.itemNameToHridCacheSource = null; // Track source for invalidation
        }

        /**
         * Initialize the dungeon token tooltips feature
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.isFeatureEnabled('dungeonTokenTooltips')) {
                return;
            }

            this.isInitialized = true;

            // Register with centralized DOM observer
            this.setupObserver();
        }

        /**
         * Set up observer to watch for tooltip elements
         */
        setupObserver() {
            // Register with centralized DOM observer to watch for tooltip poppers
            this.unregisterObserver = domObserver$1.onClass('DungeonTokenTooltips', 'MuiTooltip-popper', (tooltipElement) => {
                this.handleTooltip(tooltipElement);
            });

            this.isActive = true;
        }

        /**
         * Handle a tooltip element
         * @param {Element} tooltipElement - The tooltip popper element
         */
        async handleTooltip(tooltipElement) {
            // Guard against duplicate processing
            if (tooltipElement.dataset.dungeonProcessed) {
                return;
            }
            tooltipElement.dataset.dungeonProcessed = 'true';

            // Check if it's a collection tooltip
            const collectionContent = tooltipElement.querySelector('div.Collection_tooltipContent__2IcSJ');
            const isCollectionTooltip = !!collectionContent;

            // Check if it's a regular item tooltip
            const nameElement = tooltipElement.querySelector('div.ItemTooltipText_name__2JAHA');
            const isItemTooltip = !!nameElement;

            if (!isCollectionTooltip && !isItemTooltip) {
                return; // Not a tooltip we can enhance
            }

            // Extract item name from appropriate element
            let itemName;
            if (isCollectionTooltip) {
                const collectionNameElement = tooltipElement.querySelector('div.Collection_name__10aep');
                if (!collectionNameElement) {
                    return;
                }
                itemName = collectionNameElement.textContent.trim();
            } else {
                itemName = nameElement.textContent.trim();
            }

            // Get the item HRID from the name
            const itemHrid = this.extractItemHridFromName(itemName);

            if (!itemHrid) {
                return;
            }

            // Check if this is a dungeon token
            if (!DUNGEON_TOKENS[itemHrid]) {
                return; // Not a dungeon token
            }

            // Get shop items for this token
            const shopItems = this.getShopItemsForToken(itemHrid);

            if (!shopItems || shopItems.length === 0) {
                return; // No shop items found
            }

            // Inject shop items display
            this.injectShopItemsDisplay(tooltipElement, shopItems, isCollectionTooltip);

            // Fix tooltip overflow
            dom.fixTooltipOverflow(tooltipElement);
        }

        /**
         * Extract item HRID from item name
         * @param {string} itemName - Item name from tooltip
         * @returns {string|null} Item HRID or null if not found
         */
        extractItemHridFromName(itemName) {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData || !gameData.itemDetailMap) {
                return null;
            }

            // Return cached map if source data hasn't changed (handles character switch)
            if (this.itemNameToHridCache && this.itemNameToHridCacheSource === gameData.itemDetailMap) {
                return this.itemNameToHridCache.get(itemName) || null;
            }

            // Build itemName -> HRID map
            const map = new Map();
            for (const [hrid, item] of Object.entries(gameData.itemDetailMap)) {
                map.set(item.name, hrid);
            }

            // Only cache if we got actual entries (avoid poisoning with empty map)
            if (map.size > 0) {
                this.itemNameToHridCache = map;
                this.itemNameToHridCacheSource = gameData.itemDetailMap;
            }

            // Return result from newly built map
            return map.get(itemName) || null;
        }

        /**
         * Get shop items purchasable with a specific token with market prices
         * @param {string} tokenHrid - Dungeon token HRID
         * @returns {Array} Array of shop items with pricing data (only tradeable items)
         */
        getShopItemsForToken(tokenHrid) {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData || !gameData.shopItemDetailMap || !gameData.itemDetailMap) {
                return [];
            }

            // Filter shop items by token cost
            const shopItems = Object.values(gameData.shopItemDetailMap)
                .filter((shopItem) => shopItem.costs && shopItem.costs[0]?.itemHrid === tokenHrid)
                .map((shopItem) => {
                    const itemDetails = gameData.itemDetailMap[shopItem.itemHrid];
                    const tokenCost = shopItem.costs[0].count;

                    // Get market ask price (same as networth calculation)
                    const prices = getItemPrices(shopItem.itemHrid, 0);
                    const askPrice = prices?.ask || null;

                    // Only include tradeable items (items with ask prices)
                    if (!askPrice || askPrice <= 0) {
                        return null;
                    }

                    // Calculate gold per token efficiency
                    const goldPerToken = askPrice / tokenCost;

                    return {
                        name: itemDetails?.name || 'Unknown Item',
                        hrid: shopItem.itemHrid,
                        cost: tokenCost,
                        askPrice: askPrice,
                        goldPerToken: goldPerToken,
                    };
                })
                .filter((item) => item !== null) // Remove non-tradeable items
                .sort((a, b) => b.goldPerToken - a.goldPerToken); // Sort by efficiency (best first)

            return shopItems;
        }

        /**
         * Inject shop items display into tooltip
         * @param {Element} tooltipElement - Tooltip element
         * @param {Array} shopItems - Array of shop items with pricing data
         * @param {boolean} isCollectionTooltip - True if this is a collection tooltip
         */
        injectShopItemsDisplay(tooltipElement, shopItems, isCollectionTooltip = false) {
            const tooltipText = isCollectionTooltip
                ? tooltipElement.querySelector('.Collection_tooltipContent__2IcSJ')
                : tooltipElement.querySelector('.ItemTooltipText_itemTooltipText__zFq3A');

            if (!tooltipText) {
                return;
            }

            if (tooltipText.querySelector('.dungeon-token-shop-injected')) {
                return;
            }

            // Create shop items display container
            const shopDiv = dom.createStyledDiv({ color: config$1.COLOR_TOOLTIP_INFO }, '', 'dungeon-token-shop-injected');

            // Build table HTML content
            let html = '<div style="margin-top: 8px;"><strong>Token Shop Value:</strong></div>';
            html += '<table style="width: 100%; margin-top: 4px; font-size: 12px;">';
            html += '<tr style="border-bottom: 1px solid #444;">';
            html += '<th style="text-align: left; padding: 2px 4px;">Item</th>';
            html += '<th style="text-align: right; padding: 2px 4px;">Cost</th>';
            html += '<th style="text-align: right; padding: 2px 4px;">Ask Price</th>';
            html += '<th style="text-align: right; padding: 2px 4px;">Gold/Token</th>';
            html += '</tr>';

            shopItems.forEach((item) => {
                // Highlight all items with the best gold/token value
                const bestGoldPerToken = shopItems[0].goldPerToken;
                const isBestValue = item.goldPerToken === bestGoldPerToken;
                const rowStyle = isBestValue ? 'background-color: rgba(4, 120, 87, 0.2);' : '';

                html += `<tr style="${rowStyle}">`;
                html += `<td style="padding: 2px 4px;">${item.name}</td>`;
                html += `<td style="text-align: right; padding: 2px 4px;">${numberFormatter(item.cost)}</td>`;
                html += `<td style="text-align: right; padding: 2px 4px;">${numberFormatter(item.askPrice)}</td>`;
                html += `<td style="text-align: right; padding: 2px 4px; font-weight: ${isBestValue ? 'bold' : 'normal'};">${numberFormatter(Math.floor(item.goldPerToken))}</td>`;
                html += '</tr>';
            });

            html += '</table>';

            shopDiv.innerHTML = html;

            tooltipText.appendChild(shopDiv);
        }

        /**
         * Cleanup
         */
        cleanup() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            this.isActive = false;
            this.isInitialized = false;
        }

        disable() {
            this.cleanup();
        }
    }

    const dungeonTokenTooltips = new DungeonTokenTooltips();

    var dungeonTokenTooltips$1 = {
        name: 'Dungeon Token Tooltips',
        initialize: async () => {
            await dungeonTokenTooltips.initialize();
        },
        cleanup: () => {
            dungeonTokenTooltips.cleanup();
        },
        disable: () => {
            dungeonTokenTooltips.disable();
        },
    };

    /**
     * Market Library
     * Market, inventory, and economy features
     *
     * Exports to: window.Toolasha.Market
     */


    // Export to global namespace
    const toolashaRoot$3 = window.Toolasha || {};
    window.Toolasha = toolashaRoot$3;

    if (typeof unsafeWindow !== 'undefined') {
        unsafeWindow.Toolasha = toolashaRoot$3;
    }

    toolashaRoot$3.Market = {
        tooltipPrices,
        expectedValueCalculator,
        tooltipConsumables,
        marketFilter,
        autoFillPrice,
        autoClickMax,
        itemCountDisplay,
        listingPriceDisplay,
        estimatedListingAge,
        marketOrderTotals,
        marketHistoryViewer,
        philoCalculator,
        tradeHistory,
        tradeHistoryDisplay,
        networkAlert,
        profitCalculator,
        alchemyProfitCalculator,
        networthFeature,
        inventoryBadgeManager,
        inventorySort,
        inventoryBadgePrices,
        dungeonTokenTooltips: dungeonTokenTooltips$1,
    };

    console.log('[Toolasha] Market library loaded');

    /**
     * Enhancement Display
     *
     * Displays enhancement calculations in the enhancement action panel.
     * Shows expected attempts, time, and protection items needed.
     */


    /**
     * Format a number with thousands separator and 2 decimal places
     * @param {number} num - Number to format
     * @returns {string} Formatted number (e.g., "1,234.56")
     */
    function formatAttempts(num) {
        return new Intl.NumberFormat('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
        }).format(num);
    }

    /**
     * Get protection item HRID from the Protection slot in the UI
     * @param {HTMLElement} panel - Enhancement action panel element
     * @returns {string|null} Protection item HRID or null if none equipped
     */
    function getProtectionItemFromUI(panel) {
        try {
            // Find the protection item container using the specific class
            const protectionContainer = panel.querySelector('[class*="protectionItemInputContainer"]');

            if (!protectionContainer) {
                return null;
            }

            // Look for SVG sprites with items_sprite pattern
            // Protection items are rendered as: <use href="/static/media/items_sprite.{hash}.svg#item_name"></use>
            const useElements = protectionContainer.querySelectorAll('use[href*="items_sprite"]');

            if (useElements.length === 0) {
                // No protection item equipped
                return null;
            }

            // Extract item HRID from the sprite reference
            const useElement = useElements[0];
            const href = useElement.getAttribute('href');

            // Extract item name after the # (fragment identifier)
            // Format: /static/media/items_sprite.{hash}.svg#mirror_of_protection
            const match = href.match(/#(.+)$/);

            if (match) {
                const itemName = match[1];
                const hrid = `/items/${itemName}`;
                return hrid;
            }

            return null;
        } catch (error) {
            console.error('[MWI Tools] Error detecting protection item:', error);
            return null;
        }
    }

    /**
     * Calculate and display enhancement statistics in the panel
     * @param {HTMLElement} panel - Enhancement action panel element
     * @param {string} itemHrid - Item HRID (e.g., "/items/cheese_sword")
     */
    async function displayEnhancementStats(panel, itemHrid) {
        try {
            if (!config$1.getSetting('enhanceSim')) {
                // Remove existing calculator if present
                const existing = panel.querySelector('#mwi-enhancement-stats');
                if (existing) {
                    existing.remove();
                }
                return;
            }

            // Get game data
            const gameData = dataManager$1.getInitClientData();

            // Get item details directly (itemHrid is passed from panel observer)
            const itemDetails = gameData.itemDetailMap[itemHrid];
            if (!itemDetails) {
                return;
            }

            const itemLevel = itemDetails.itemLevel || 1;

            // Get auto-detected enhancing parameters
            const params = getEnhancingParams();

            // Read Protect From Level from UI
            const protectFromLevel = getProtectFromLevelFromUI(panel);

            // Minimum protection level is 2 (dropping from +2 to +1)
            // Protection at +1 is meaningless (would drop to +0 anyway)
            const effectiveProtectFrom = protectFromLevel < 2 ? 0 : protectFromLevel;

            // Detect protection item once (avoid repeated DOM queries)
            const protectionItemHrid = getProtectionItemFromUI(panel);

            // Calculate per-action time (simple calculation, no Markov chain needed)
            const perActionTime = calculatePerActionTime(params.enhancingLevel, itemLevel, params.speedBonus);

            // Format and inject display
            const html = formatEnhancementDisplay(
                panel,
                params,
                perActionTime,
                itemDetails,
                effectiveProtectFrom,
                itemDetails.enhancementCosts || [],
                protectionItemHrid
            );
            injectDisplay(panel, html);
        } catch (error) {
            console.error('[MWI Tools] ❌ Error displaying enhancement stats:', error);
            console.error('[MWI Tools] Error stack:', error.stack);
        }
    }

    /**
     * Generate costs by level table HTML for all 20 enhancement levels
     * @param {HTMLElement} panel - Enhancement action panel element
     * @param {Object} params - Enhancement parameters
     * @param {number} itemLevel - Item level being enhanced
     * @param {number} protectFromLevel - Protection level from UI
     * @param {Array} enhancementCosts - Array of {itemHrid, count} for materials
     * @param {string|null} protectionItemHrid - Protection item HRID (cached, avoid repeated DOM queries)
     * @returns {string} HTML string
     */
    function generateCostsByLevelTable(panel, params, itemLevel, protectFromLevel, enhancementCosts, protectionItemHrid) {
        const lines = [];
        const gameData = dataManager$1.getInitClientData();

        lines.push('<div style="margin-top: 12px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px;">');
        lines.push('<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">');
        lines.push('<div style="color: #ffa500; font-weight: bold; font-size: 0.95em;">Costs by Enhancement Level:</div>');
        lines.push(
            '<button id="mwi-expand-costs-table-btn" style="background: rgba(0, 255, 234, 0.1); border: 1px solid #00ffe7; color: #00ffe7; cursor: pointer; font-size: 18px; font-weight: bold; padding: 4px 10px; border-radius: 4px; transition: all 0.15s ease;" title="View full table">⤢</button>'
        );
        lines.push('</div>');

        // Calculate costs for each level
        const costData = [];
        for (let level = 1; level <= 20; level++) {
            // Protection only applies when target level reaches the protection threshold
            const effectiveProtect = protectFromLevel >= 2 && level >= protectFromLevel ? protectFromLevel : 0;

            const calc = calculateEnhancement({
                enhancingLevel: params.enhancingLevel,
                houseLevel: params.houseLevel,
                toolBonus: params.toolBonus,
                speedBonus: params.speedBonus,
                itemLevel: itemLevel,
                targetLevel: level,
                protectFrom: effectiveProtect,
                blessedTea: params.teas.blessed,
                guzzlingBonus: params.guzzlingBonus,
            });

            // Calculate material cost breakdown
            let materialCost = 0;
            const materialBreakdown = {};

            if (enhancementCosts && enhancementCosts.length > 0) {
                enhancementCosts.forEach((cost) => {
                    const itemDetail = gameData.itemDetailMap[cost.itemHrid];
                    let itemPrice = 0;

                    if (cost.itemHrid === '/items/coin') {
                        itemPrice = 1;
                    } else {
                        const marketData = marketAPI.getPrice(cost.itemHrid, 0);
                        if (marketData && marketData.ask) {
                            itemPrice = marketData.ask;
                        } else {
                            itemPrice = itemDetail?.sellPrice || 0;
                        }
                    }

                    const quantity = cost.count * calc.attempts; // Use exact decimal attempts
                    const itemCost = quantity * itemPrice;
                    materialCost += itemCost;

                    // Store breakdown by item name with quantity and unit price
                    const itemName = itemDetail?.name || cost.itemHrid;
                    materialBreakdown[itemName] = {
                        cost: itemCost,
                        quantity: quantity,
                        unitPrice: itemPrice,
                    };
                });
            }

            // Add protection item cost (but NOT for Philosopher's Mirror - it uses different mechanics)
            let protectionCost = 0;
            if (calc.protectionCount > 0 && protectionItemHrid && protectionItemHrid !== '/items/philosophers_mirror') {
                const protectionItemDetail = gameData.itemDetailMap[protectionItemHrid];
                let protectionPrice = 0;

                const protectionMarketData = marketAPI.getPrice(protectionItemHrid, 0);
                if (protectionMarketData && protectionMarketData.ask) {
                    protectionPrice = protectionMarketData.ask;
                } else {
                    protectionPrice = protectionItemDetail?.sellPrice || 0;
                }

                protectionCost = calc.protectionCount * protectionPrice;
                const protectionName = protectionItemDetail?.name || protectionItemHrid;
                materialBreakdown[protectionName] = {
                    cost: protectionCost,
                    quantity: calc.protectionCount,
                    unitPrice: protectionPrice,
                };
            }

            const totalCost = materialCost + protectionCost;

            costData.push({
                level,
                attempts: calc.attempts, // Use exact decimal attempts
                protection: calc.protectionCount,
                time: calc.totalTime,
                cost: totalCost,
                breakdown: materialBreakdown,
            });
        }

        // Calculate Philosopher's Mirror costs (if mirror is equipped)
        const isPhilosopherMirror = protectionItemHrid === '/items/philosophers_mirror';
        let mirrorStartLevel = null;
        let totalSavings = 0;

        if (isPhilosopherMirror) {
            const mirrorPrice = marketAPI.getPrice('/items/philosophers_mirror', 0)?.ask || 0;

            // Calculate mirror cost for each level (starts at +3)
            for (let level = 3; level <= 20; level++) {
                const traditionalCost = costData[level - 1].cost;
                const mirrorCost = costData[level - 3].cost + costData[level - 2].cost + mirrorPrice;

                costData[level - 1].mirrorCost = mirrorCost;
                costData[level - 1].isMirrorCheaper = mirrorCost < traditionalCost;

                // Find first level where mirror becomes cheaper
                if (mirrorStartLevel === null && mirrorCost < traditionalCost) {
                    mirrorStartLevel = level;
                }
            }

            // Calculate total savings if mirror is used optimally
            if (mirrorStartLevel !== null) {
                const traditionalFinalCost = costData[19].cost; // +20 traditional cost
                const mirrorFinalCost = costData[19].mirrorCost; // +20 mirror cost
                totalSavings = traditionalFinalCost - mirrorFinalCost;
            }
        }

        // Add Philosopher's Mirror summary banner (if applicable)
        if (isPhilosopherMirror && mirrorStartLevel !== null) {
            lines.push(
                '<div style="background: linear-gradient(90deg, rgba(255, 215, 0, 0.15), rgba(255, 215, 0, 0.05)); border: 1px solid #FFD700; border-radius: 4px; padding: 8px; margin-bottom: 8px;">'
            );
            lines.push(
                '<div style="color: #FFD700; font-weight: bold; font-size: 0.95em;">💎 Philosopher\'s Mirror Strategy:</div>'
            );
            lines.push(
                `<div style="color: #fff; font-size: 0.85em; margin-top: 4px;">• Use mirrors starting at <strong>+${mirrorStartLevel}</strong></div>`
            );
            lines.push(
                `<div style="color: #88ff88; font-size: 0.85em;">• Total savings to +20: <strong>${Math.round(totalSavings).toLocaleString()}</strong> coins</div>`
            );
            lines.push(
                `<div style="color: #aaa; font-size: 0.75em; margin-top: 4px; font-style: italic;">Rows highlighted in gold show where mirror is cheaper</div>`
            );
            lines.push('</div>');
        }

        // Create scrollable table
        lines.push('<div id="mwi-enhancement-table-scroll" style="max-height: 300px; overflow-y: auto;">');
        lines.push('<table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">');

        // Get all unique material names
        const allMaterials = new Set();
        costData.forEach((data) => {
            Object.keys(data.breakdown).forEach((mat) => allMaterials.add(mat));
        });
        const materialNames = Array.from(allMaterials);

        // Header row
        lines.push(
            '<tr style="color: #888; border-bottom: 1px solid #444; position: sticky; top: 0; background: rgba(0,0,0,0.9);">'
        );
        lines.push('<th style="text-align: left; padding: 4px;">Level</th>');
        lines.push('<th style="text-align: right; padding: 4px;">Attempts</th>');
        lines.push('<th style="text-align: right; padding: 4px;">Protection</th>');

        // Add material columns
        materialNames.forEach((matName) => {
            lines.push(`<th style="text-align: right; padding: 4px;">${matName}</th>`);
        });

        lines.push('<th style="text-align: right; padding: 4px;">Time</th>');
        lines.push('<th style="text-align: right; padding: 4px;">Total Cost</th>');

        // Add Mirror Cost column if Philosopher's Mirror is equipped
        if (isPhilosopherMirror) {
            lines.push('<th style="text-align: right; padding: 4px; color: #FFD700;">Mirror Cost</th>');
        }

        lines.push('</tr>');

        costData.forEach((data, index) => {
            const isLastRow = index === costData.length - 1;
            const borderStyle = isLastRow ? '' : 'border-bottom: 1px solid #333;';

            // Highlight row if mirror is cheaper
            let rowStyle = borderStyle;
            if (isPhilosopherMirror && data.isMirrorCheaper) {
                rowStyle += ' background: linear-gradient(90deg, rgba(255, 215, 0, 0.15), rgba(255, 215, 0, 0.05));';
            }

            lines.push(`<tr style="${rowStyle}">`);
            lines.push(`<td style="padding: 6px 4px; color: #fff; font-weight: bold;">+${data.level}</td>`);
            lines.push(
                `<td style="padding: 6px 4px; text-align: right; color: #ccc;">${formatAttempts(data.attempts)}</td>`
            );
            lines.push(
                `<td style="padding: 6px 4px; text-align: right; color: ${data.protection > 0 ? '#ffa500' : '#888'};">${data.protection > 0 ? formatAttempts(data.protection) : '-'}</td>`
            );

            // Add material breakdown columns
            materialNames.forEach((matName) => {
                const matData = data.breakdown[matName];
                if (matData && matData.cost > 0) {
                    const cost = Math.round(matData.cost).toLocaleString();
                    const unitPrice = Math.round(matData.unitPrice).toLocaleString();
                    const qty =
                        matData.quantity % 1 === 0
                            ? Math.round(matData.quantity).toLocaleString()
                            : matData.quantity.toLocaleString(undefined, {
                                  minimumFractionDigits: 2,
                                  maximumFractionDigits: 2,
                              });
                    // Format as: quantity × unit price → total cost
                    lines.push(
                        `<td style="padding: 6px 4px; text-align: right; color: #ccc;">${qty} × ${unitPrice} → ${cost}</td>`
                    );
                } else {
                    lines.push(`<td style="padding: 6px 4px; text-align: right; color: #888;">-</td>`);
                }
            });

            lines.push(`<td style="padding: 6px 4px; text-align: right; color: #ccc;">${timeReadable(data.time)}</td>`);
            lines.push(
                `<td style="padding: 6px 4px; text-align: right; color: #ffa500;">${Math.round(data.cost).toLocaleString()}</td>`
            );

            // Add Mirror Cost column if Philosopher's Mirror is equipped
            if (isPhilosopherMirror) {
                if (data.mirrorCost !== undefined) {
                    const mirrorCostFormatted = Math.round(data.mirrorCost).toLocaleString();
                    const isCheaper = data.isMirrorCheaper;
                    const color = isCheaper ? '#FFD700' : '#888';
                    const symbol = isCheaper ? '✨ ' : '';
                    lines.push(
                        `<td style="padding: 6px 4px; text-align: right; color: ${color}; font-weight: ${isCheaper ? 'bold' : 'normal'};">${symbol}${mirrorCostFormatted}</td>`
                    );
                } else {
                    // Levels 1-2 cannot use mirrors
                    lines.push(`<td style="padding: 6px 4px; text-align: right; color: #666;">N/A</td>`);
                }
            }

            lines.push('</tr>');
        });

        lines.push('</table>');
        lines.push('</div>'); // Close scrollable container
        lines.push('</div>'); // Close section

        return lines.join('');
    }

    /**
     * Get Protect From Level from UI input
     * @param {HTMLElement} panel - Enhancing panel
     * @returns {number} Protect from level (0 = never, 1-20)
     */
    function getProtectFromLevelFromUI(panel) {
        // Find the "Protect From Level" input
        const labels = Array.from(panel.querySelectorAll('*')).filter(
            (el) => el.textContent.trim() === 'Protect From Level' && el.children.length === 0
        );

        if (labels.length > 0) {
            const parent = labels[0].parentElement;
            const input = parent.querySelector('input[type="number"], input[type="text"]');
            if (input && input.value) {
                const value = parseInt(input.value, 10);
                return Math.max(0, Math.min(20, value)); // Clamp 0-20
            }
        }

        return 0; // Default to never protect
    }

    /**
     * Format enhancement display HTML
     * @param {HTMLElement} panel - Enhancement action panel element (for reading protection slot)
     * @param {Object} params - Auto-detected parameters
     * @param {number} perActionTime - Per-action time in seconds
     * @param {Object} itemDetails - Item being enhanced
     * @param {number} protectFromLevel - Protection level from UI
     * @param {Array} enhancementCosts - Array of {itemHrid, count} for materials
     * @param {string|null} protectionItemHrid - Protection item HRID (cached, avoid repeated DOM queries)
     * @returns {string} HTML string
     */
    function formatEnhancementDisplay(
        panel,
        params,
        perActionTime,
        itemDetails,
        protectFromLevel,
        enhancementCosts,
        protectionItemHrid
    ) {
        const lines = [];

        // Header
        lines.push(
            '<div style="margin-top: 15px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 0.9em;">'
        );
        lines.push(
            '<div style="color: #ffa500; font-weight: bold; margin-bottom: 10px; font-size: 1.1em;">⚙️ ENHANCEMENT CALCULATOR</div>'
        );

        // Item info
        lines.push(
            `<div style="color: #ddd; margin-bottom: 12px; font-weight: bold;">${itemDetails.name} <span style="color: #888;">(Item Level ${itemDetails.itemLevel})</span></div>`
        );

        // Current stats section
        lines.push('<div style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; margin-bottom: 12px;">');
        lines.push(
            '<div style="color: #ffa500; font-weight: bold; margin-bottom: 6px; font-size: 0.95em;">Your Enhancing Stats:</div>'
        );

        // Two column layout for stats
        lines.push('<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 0.85em;">');

        // Left column
        lines.push('<div>');
        lines.push(
            `<div style="color: #ccc;"><span style="color: #888;">Level:</span> ${params.enhancingLevel - params.detectedTeaBonus}${params.detectedTeaBonus > 0 ? ` <span style="color: #88ff88;">(+${params.detectedTeaBonus.toFixed(1)} tea)</span>` : ''}</div>`
        );
        lines.push(
            `<div style="color: #ccc;"><span style="color: #888;">House:</span> Observatory Lvl ${params.houseLevel}</div>`
        );

        // Display each equipment slot
        if (params.toolSlot) {
            lines.push(
                `<div style="color: #ccc;"><span style="color: #888;">Tool:</span> ${params.toolSlot.name}${params.toolSlot.enhancementLevel > 0 ? ` +${params.toolSlot.enhancementLevel}` : ''}</div>`
            );
        }
        if (params.bodySlot) {
            lines.push(
                `<div style="color: #ccc;"><span style="color: #888;">Body:</span> ${params.bodySlot.name}${params.bodySlot.enhancementLevel > 0 ? ` +${params.bodySlot.enhancementLevel}` : ''}</div>`
            );
        }
        if (params.legsSlot) {
            lines.push(
                `<div style="color: #ccc;"><span style="color: #888;">Legs:</span> ${params.legsSlot.name}${params.legsSlot.enhancementLevel > 0 ? ` +${params.legsSlot.enhancementLevel}` : ''}</div>`
            );
        }
        if (params.handsSlot) {
            lines.push(
                `<div style="color: #ccc;"><span style="color: #888;">Hands:</span> ${params.handsSlot.name}${params.handsSlot.enhancementLevel > 0 ? ` +${params.handsSlot.enhancementLevel}` : ''}</div>`
            );
        }
        lines.push('</div>');

        // Right column
        lines.push('<div>');

        // Calculate total success (includes level advantage if applicable)
        let totalSuccess = params.toolBonus;
        let successLevelAdvantage = 0;
        if (params.enhancingLevel > itemDetails.itemLevel) {
            // For DISPLAY breakdown: show level advantage WITHOUT house (house shown separately)
            // Calculator correctly uses (enhancing + house - item), but we split for display
            successLevelAdvantage = (params.enhancingLevel - itemDetails.itemLevel) * 0.05;
            totalSuccess += successLevelAdvantage;
        }

        if (totalSuccess > 0) {
            lines.push(
                `<div style="color: #88ff88;"><span style="color: #888;">Success:</span> +${totalSuccess.toFixed(2)}%</div>`
            );

            // Show breakdown: equipment + house + level advantage
            const equipmentSuccess = params.equipmentSuccessBonus || 0;
            const houseSuccess = params.houseSuccessBonus || 0;

            if (equipmentSuccess > 0) {
                lines.push(
                    `<div style="color: #88ff88; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Equipment:</span> +${equipmentSuccess.toFixed(2)}%</div>`
                );
            }
            if (houseSuccess > 0) {
                lines.push(
                    `<div style="color: #88ff88; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">House (Observatory):</span> +${houseSuccess.toFixed(2)}%</div>`
                );
            }
            if (successLevelAdvantage > 0) {
                lines.push(
                    `<div style="color: #88ff88; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Level advantage:</span> +${successLevelAdvantage.toFixed(2)}%</div>`
                );
            }
        }

        // Calculate total speed (includes level advantage if applicable)
        let totalSpeed = params.speedBonus;
        let speedLevelAdvantage = 0;
        if (params.enhancingLevel > itemDetails.itemLevel) {
            speedLevelAdvantage = params.enhancingLevel - itemDetails.itemLevel;
            totalSpeed += speedLevelAdvantage;
        }

        if (totalSpeed > 0) {
            lines.push(
                `<div style="color: #88ccff;"><span style="color: #888;">Speed:</span> +${totalSpeed.toFixed(1)}%</div>`
            );

            // Show breakdown: equipment + house + community + tea + level advantage
            if (params.equipmentSpeedBonus > 0) {
                lines.push(
                    `<div style="color: #aaddff; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Equipment:</span> +${params.equipmentSpeedBonus.toFixed(1)}%</div>`
                );
            }
            if (params.houseSpeedBonus > 0) {
                lines.push(
                    `<div style="color: #aaddff; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">House (Observatory):</span> +${params.houseSpeedBonus.toFixed(1)}%</div>`
                );
            }
            if (params.communitySpeedBonus > 0) {
                lines.push(
                    `<div style="color: #aaddff; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Community T${params.communityBuffLevel}:</span> +${params.communitySpeedBonus.toFixed(1)}%</div>`
                );
            }
            if (params.teaSpeedBonus > 0) {
                const teaName = params.teas.ultraEnhancing ? 'Ultra' : params.teas.superEnhancing ? 'Super' : 'Enhancing';
                lines.push(
                    `<div style="color: #aaddff; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">${teaName} Tea:</span> +${params.teaSpeedBonus.toFixed(1)}%</div>`
                );
            }
            if (speedLevelAdvantage > 0) {
                lines.push(
                    `<div style="color: #aaddff; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Level advantage:</span> +${speedLevelAdvantage.toFixed(1)}%</div>`
                );
            }
        } else if (totalSpeed === 0 && speedLevelAdvantage === 0) {
            lines.push(`<div style="color: #88ccff;"><span style="color: #888;">Speed:</span> +0.0%</div>`);
        }

        if (params.teas.blessed) {
            // Calculate Blessed Tea bonus with Guzzling Pouch concentration
            const blessedBonus = 1.1; // Base 1.1% from Blessed Tea
            lines.push(
                `<div style="color: #ffdd88;"><span style="color: #888;">Blessed:</span> +${blessedBonus.toFixed(1)}%</div>`
            );
        }
        if (params.rareFindBonus > 0) {
            lines.push(
                `<div style="color: #ffaa55;"><span style="color: #888;">Rare Find:</span> +${params.rareFindBonus.toFixed(1)}%</div>`
            );

            // Show breakdown if available
            const achievementRareFind = params.achievementRareFindBonus || 0;
            if (params.houseRareFindBonus > 0 || achievementRareFind > 0) {
                const equipmentRareFind = Math.max(
                    0,
                    params.rareFindBonus - params.houseRareFindBonus - achievementRareFind
                );
                if (equipmentRareFind > 0) {
                    lines.push(
                        `<div style="color: #ffaa55; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Equipment:</span> +${equipmentRareFind.toFixed(1)}%</div>`
                    );
                }
                lines.push(
                    `<div style="color: #ffaa55; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">House Rooms:</span> +${params.houseRareFindBonus.toFixed(1)}%</div>`
                );
                if (achievementRareFind > 0) {
                    lines.push(
                        `<div style="color: #ffaa55; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Achievement:</span> +${achievementRareFind.toFixed(1)}%</div>`
                    );
                }
            }
        }
        if (params.experienceBonus > 0) {
            lines.push(
                `<div style="color: #ffdd88;"><span style="color: #888;">Experience:</span> +${params.experienceBonus.toFixed(1)}%</div>`
            );

            // Show breakdown: equipment + house wisdom + tea wisdom + community wisdom + achievement wisdom
            const teaWisdom = params.teaWisdomBonus || 0;
            const houseWisdom = params.houseWisdomBonus || 0;
            const communityWisdom = params.communityWisdomBonus || 0;
            const achievementWisdom = params.achievementWisdomBonus || 0;
            const equipmentExperience = Math.max(
                0,
                params.experienceBonus - houseWisdom - teaWisdom - communityWisdom - achievementWisdom
            );

            if (equipmentExperience > 0) {
                lines.push(
                    `<div style="color: #ffdd88; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Equipment:</span> +${equipmentExperience.toFixed(1)}%</div>`
                );
            }
            if (houseWisdom > 0) {
                lines.push(
                    `<div style="color: #ffdd88; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">House Rooms (Wisdom):</span> +${houseWisdom.toFixed(1)}%</div>`
                );
            }
            if (communityWisdom > 0) {
                const wisdomLevel = params.communityWisdomLevel || 0;
                lines.push(
                    `<div style="color: #ffdd88; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Community (Wisdom T${wisdomLevel}):</span> +${communityWisdom.toFixed(1)}%</div>`
                );
            }
            if (teaWisdom > 0) {
                lines.push(
                    `<div style="color: #ffdd88; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Wisdom Tea:</span> +${teaWisdom.toFixed(1)}%</div>`
                );
            }
            if (achievementWisdom > 0) {
                lines.push(
                    `<div style="color: #ffdd88; font-size: 0.8em; padding-left: 10px;"><span style="color: #666;">Achievement:</span> +${achievementWisdom.toFixed(1)}%</div>`
                );
            }
        }
        lines.push('</div>');

        lines.push('</div>'); // Close grid
        lines.push('</div>'); // Close stats section

        // Costs by level table for all 20 levels
        const costsByLevelHTML = generateCostsByLevelTable(
            panel,
            params,
            itemDetails.itemLevel,
            protectFromLevel,
            enhancementCosts,
            protectionItemHrid
        );
        lines.push(costsByLevelHTML);

        // Materials cost section (if enhancement costs exist) - just show per-attempt materials
        if (enhancementCosts && enhancementCosts.length > 0) {
            lines.push('<div style="margin-top: 12px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px;">');
            lines.push(
                '<div style="color: #ffa500; font-weight: bold; margin-bottom: 6px; font-size: 0.95em;">Materials Per Attempt:</div>'
            );

            // Get game data for item names
            const gameData = dataManager$1.getInitClientData();

            // Materials per attempt with pricing
            enhancementCosts.forEach((cost) => {
                const itemDetail = gameData.itemDetailMap[cost.itemHrid];
                const itemName = itemDetail ? itemDetail.name : cost.itemHrid;

                // Get price
                let itemPrice = 0;
                if (cost.itemHrid === '/items/coin') {
                    itemPrice = 1;
                } else {
                    const marketData = marketAPI.getPrice(cost.itemHrid, 0);
                    if (marketData && marketData.ask) {
                        itemPrice = marketData.ask;
                    } else {
                        itemPrice = itemDetail?.sellPrice || 0;
                    }
                }

                const totalCost = cost.count * itemPrice;
                const formattedCount = Number.isInteger(cost.count)
                    ? cost.count.toLocaleString()
                    : cost.count.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                lines.push(
                    `<div style="font-size: 0.85em; color: #ccc;">${formattedCount}× ${itemName} <span style="color: #888;">(@${itemPrice.toLocaleString()} → ${totalCost.toLocaleString()})</span></div>`
                );
            });

            // Show protection item cost if protection is active (level 2+) AND item is equipped
            if (protectFromLevel >= 2) {
                if (protectionItemHrid) {
                    const protectionItemDetail = gameData.itemDetailMap[protectionItemHrid];
                    const protectionItemName = protectionItemDetail?.name || protectionItemHrid;

                    // Get protection item price
                    let protectionPrice = 0;
                    const protectionMarketData = marketAPI.getPrice(protectionItemHrid, 0);
                    if (protectionMarketData && protectionMarketData.ask) {
                        protectionPrice = protectionMarketData.ask;
                    } else {
                        protectionPrice = protectionItemDetail?.sellPrice || 0;
                    }

                    lines.push(
                        `<div style="font-size: 0.85em; color: #ffa500; margin-top: 4px;">1× ${protectionItemName} <span style="color: #888;">(if used) (@${protectionPrice.toLocaleString()})</span></div>`
                    );
                }
            }

            lines.push('</div>');
        }

        // Footer notes
        lines.push('<div style="margin-top: 8px; color: #666; font-size: 0.75em; line-height: 1.3;">');

        // Only show protection note if actually using protection
        if (protectFromLevel >= 2) {
            lines.push(`• Protection active from +${protectFromLevel} onwards (enhancement level -1 on failure)<br>`);
        } else {
            lines.push('• No protection used (all failures return to +0)<br>');
        }

        lines.push('• Attempts and time are statistical averages<br>');

        // Calculate total speed for display (includes level advantage if applicable)
        let displaySpeed = params.speedBonus;
        if (params.enhancingLevel > itemDetails.itemLevel) {
            displaySpeed += params.enhancingLevel - itemDetails.itemLevel;
        }

        lines.push(`• Action time: ${perActionTime.toFixed(2)}s (includes ${displaySpeed.toFixed(1)}% speed bonus)`);
        lines.push('</div>');

        lines.push('</div>'); // Close targets section
        lines.push('</div>'); // Close main container

        return lines.join('');
    }

    /**
     * Find the "Current Action" tab button (cached on panel for performance)
     * @param {HTMLElement} panel - Enhancement panel element
     * @returns {HTMLButtonElement|null} Current Action tab button or null
     */
    function findCurrentActionTab(panel) {
        // Check if we already cached it
        if (panel._cachedCurrentActionTab) {
            return panel._cachedCurrentActionTab;
        }

        // Walk up the DOM to find tab buttons (only once per panel)
        let current = panel;
        let depth = 0;
        const maxDepth = 5;

        while (current && depth < maxDepth) {
            const buttons = Array.from(current.querySelectorAll('button[role="tab"]'));
            const currentActionTab = buttons.find((btn) => btn.textContent.trim() === 'Current Action');

            if (currentActionTab) {
                // Cache it on the panel for future lookups
                panel._cachedCurrentActionTab = currentActionTab;
                return currentActionTab;
            }

            current = current.parentElement;
            depth++;
        }

        return null;
    }

    /**
     * Inject enhancement display into panel
     * @param {HTMLElement} panel - Action panel element
     * @param {string} html - HTML to inject
     */
    function injectDisplay(panel, html) {
        // CRITICAL: Final safety check - verify we're on Enhance tab before injecting
        // This prevents the calculator from appearing on Current Action tab due to race conditions
        const currentActionTab = findCurrentActionTab(panel);
        if (currentActionTab) {
            // Check if Current Action tab is active
            if (
                currentActionTab.getAttribute('aria-selected') === 'true' ||
                currentActionTab.classList.contains('Mui-selected') ||
                currentActionTab.getAttribute('tabindex') === '0'
            ) {
                // Current Action tab is active, don't inject calculator
                return;
            }
        }

        // Save scroll position before removing existing display
        let savedScrollTop = 0;
        const existing = panel.querySelector('#mwi-enhancement-stats');
        if (existing) {
            const scrollContainer = existing.querySelector('#mwi-enhancement-table-scroll');
            if (scrollContainer) {
                savedScrollTop = scrollContainer.scrollTop;
            }
            existing.remove();
        }

        // Create container
        const container = document.createElement('div');
        container.id = 'mwi-enhancement-stats';
        container.innerHTML = html;

        // For enhancing panels: append to the end of the panel
        // For regular action panels: insert after drop table or exp gain
        const dropTable = panel.querySelector('div.SkillActionDetail_dropTable__3ViVp');
        const expGain = panel.querySelector('div.SkillActionDetail_expGain__F5xHu');

        if (dropTable || expGain) {
            // Regular action panel - insert after drop table or exp gain
            const insertAfter = dropTable || expGain;
            insertAfter.parentNode.insertBefore(container, insertAfter.nextSibling);
        } else {
            // Enhancing panel - append to end
            panel.appendChild(container);
        }

        // Restore scroll position after DOM insertion
        if (savedScrollTop > 0) {
            const newScrollContainer = container.querySelector('#mwi-enhancement-table-scroll');
            if (newScrollContainer) {
                // Use requestAnimationFrame to ensure DOM is fully updated
                requestAnimationFrame(() => {
                    newScrollContainer.scrollTop = savedScrollTop;
                });
            }
        }

        // Attach event listener to expand costs table button
        const expandBtn = container.querySelector('#mwi-expand-costs-table-btn');
        if (expandBtn) {
            expandBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showCostsTableModal(container);
            });
            expandBtn.addEventListener('mouseenter', () => {
                expandBtn.style.background = 'rgba(255, 0, 212, 0.2)';
                expandBtn.style.borderColor = '#ff00d4';
                expandBtn.style.color = '#ff00d4';
            });
            expandBtn.addEventListener('mouseleave', () => {
                expandBtn.style.background = 'rgba(0, 255, 234, 0.1)';
                expandBtn.style.borderColor = '#00ffe7';
                expandBtn.style.color = '#00ffe7';
            });
        }
    }

    /**
     * Show costs table in expanded modal overlay
     * @param {HTMLElement} container - Enhancement stats container with the table
     */
    function showCostsTableModal(container) {
        // Clone the table and its container
        const tableScroll = container.querySelector('#mwi-enhancement-table-scroll');
        if (!tableScroll) return;

        const table = tableScroll.querySelector('table');
        if (!table) return;

        // Create backdrop
        const backdrop = document.createElement('div');
        backdrop.id = 'mwi-costs-table-backdrop';
        Object.assign(backdrop.style, {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            background: 'rgba(0, 0, 0, 0.85)',
            zIndex: '10002',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            backdropFilter: 'blur(4px)',
        });

        // Create modal
        const modal = document.createElement('div');
        modal.id = 'mwi-costs-table-modal';
        Object.assign(modal.style, {
            background: 'rgba(5, 5, 15, 0.98)',
            border: '2px solid #00ffe7',
            borderRadius: '12px',
            padding: '20px',
            minWidth: '800px',
            maxWidth: '95vw',
            maxHeight: '90vh',
            overflow: 'auto',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.8)',
        });

        // Clone and style the table
        const clonedTable = table.cloneNode(true);
        clonedTable.style.fontSize = '1em'; // Larger font

        // Update all cell padding for better readability
        const cells = clonedTable.querySelectorAll('th, td');
        cells.forEach((cell) => {
            cell.style.padding = '8px 12px';
        });

        modal.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid rgba(0, 255, 234, 0.4); padding-bottom: 10px;">
            <h2 style="margin: 0; color: #00ffe7; font-size: 20px;">📊 Costs by Enhancement Level</h2>
            <button id="mwi-close-costs-modal" style="
                background: none;
                border: none;
                color: #e0f7ff;
                cursor: pointer;
                font-size: 28px;
                padding: 0 8px;
                line-height: 1;
                transition: all 0.15s ease;
            " title="Close">×</button>
        </div>
        <div style="color: #9b9bff; font-size: 0.9em; margin-bottom: 15px;">
            Full breakdown of enhancement costs for all levels
        </div>
    `;

        modal.appendChild(clonedTable);
        backdrop.appendChild(modal);
        document.body.appendChild(backdrop);

        // Close button handler
        const closeBtn = modal.querySelector('#mwi-close-costs-modal');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                backdrop.remove();
            });
            closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.color = '#ff0055';
            });
            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.color = '#e0f7ff';
            });
        }

        // Backdrop click to close
        backdrop.addEventListener('click', (e) => {
            if (e.target === backdrop) {
                backdrop.remove();
            }
        });

        // ESC key to close
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                backdrop.remove();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);

        // Remove ESC listener when backdrop is removed
        const observer = createMutationWatcher(
            document.body,
            () => {
                if (!document.body.contains(backdrop)) {
                    document.removeEventListener('keydown', escHandler);
                    observer();
                }
            },
            { childList: true }
        );
    }

    /**
     * Profit Display Functions
     *
     * Handles displaying profit calculations in action panels for:
     * - Gathering actions (Foraging, Woodcutting, Milking)
     * - Production actions (Brewing, Cooking, Crafting, Tailoring, Cheesesmithing)
     */


    const getMissingPriceIndicator = (isMissing) => (isMissing ? ' ⚠' : '');
    const formatMissingLabel = (isMissing, value) => (isMissing ? '-- ⚠' : value);

    const getBonusDropPerHourTotals = (drop, efficiencyMultiplier = 1) => ({
        dropsPerHour: drop.dropsPerHour * efficiencyMultiplier,
        revenuePerHour: drop.revenuePerHour * efficiencyMultiplier,
    });

    const getBonusDropTotalsForActions = (drop, actionsCount, actionsPerHour) => {
        const dropsPerAction = drop.dropsPerAction ?? drop.dropsPerHour / actionsPerHour;
        const revenuePerAction = drop.revenuePerAction ?? drop.revenuePerHour / actionsPerHour;

        return {
            totalDrops: dropsPerAction * actionsCount,
            totalRevenue: revenuePerAction * actionsCount,
        };
    };
    const formatRareFindBonusSummary = (bonusRevenue) => {
        const rareFindBonus = bonusRevenue?.rareFindBonus || 0;
        return `${rareFindBonus.toFixed(1)}% rare find`;
    };

    const getRareFindBreakdownParts = (bonusRevenue) => {
        const breakdown = bonusRevenue?.rareFindBreakdown || {};
        const parts = [];

        if (breakdown.equipment > 0) {
            parts.push(`${breakdown.equipment.toFixed(1)}% equip`);
        }
        if (breakdown.house > 0) {
            parts.push(`${breakdown.house.toFixed(1)}% house`);
        }
        if (breakdown.achievement > 0) {
            parts.push(`${breakdown.achievement.toFixed(1)}% achievement`);
        }

        return parts;
    };

    /**
     * Display gathering profit calculation in panel
     * @param {HTMLElement} panel - Action panel element
     * @param {string} actionHrid - Action HRID
     * @param {string} dropTableSelector - CSS selector for drop table element
     */
    async function displayGatheringProfit(panel, actionHrid, dropTableSelector) {
        // Calculate profit
        const profitData = await calculateGatheringProfit(actionHrid);
        if (!profitData) {
            console.error('❌ Gathering profit calculation failed for:', actionHrid);
            return;
        }

        // Check if we already added profit display
        const existingProfit = panel.querySelector('#mwi-foraging-profit');
        if (existingProfit) {
            existingProfit.remove();
        }

        // Create top-level summary
        const profit = Math.round(profitData.profitPerHour);
        const profitPerDay = Math.round(profitData.profitPerDay);
        const baseMissing = profitData.baseOutputs?.some((output) => output.missingPrice) || false;
        const gourmetMissing = profitData.gourmetBonuses?.some((output) => output.missingPrice) || false;
        const bonusMissing = profitData.bonusRevenue?.hasMissingPrices || false;
        const processingMissing = profitData.processingConversions?.some((conversion) => conversion.missingPrice) || false;
        const primaryMissing = baseMissing || gourmetMissing || processingMissing;
        const revenueMissing = primaryMissing || bonusMissing;
        const drinkCostsMissing = profitData.drinkCosts?.some((drink) => drink.missingPrice) || false;
        const costsMissing = drinkCostsMissing || revenueMissing;
        const marketTaxMissing = revenueMissing;
        const netMissing = profitData.hasMissingPrices;
        const efficiencyMultiplier = profitData.efficiencyMultiplier || 1;
        // Revenue is now gross (pre-tax)
        const revenue = Math.round(profitData.revenuePerHour);
        const marketTax = Math.round(revenue * MARKET_TAX);
        const costs = Math.round(profitData.drinkCostPerHour + marketTax);
        const summary = formatMissingLabel(
            netMissing,
            `${formatLargeNumber(profit)}/hr, ${formatLargeNumber(profitPerDay)}/day | Total profit: 0`
        );

        const detailsContent = document.createElement('div');

        // Revenue Section
        const revenueDiv = document.createElement('div');
        const revenueLabel = formatMissingLabel(revenueMissing, `${formatLargeNumber(revenue)}/hr`);
        revenueDiv.innerHTML = `<div style="font-weight: 500; color: ${config$1.COLOR_TOOLTIP_PROFIT}; margin-bottom: 4px;">Revenue: ${revenueLabel}</div>`;

        // Primary Outputs subsection
        const primaryDropsContent = document.createElement('div');
        if (profitData.baseOutputs && profitData.baseOutputs.length > 0) {
            for (const output of profitData.baseOutputs) {
                const decimals = output.itemsPerHour < 1 ? 2 : 1;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const missingPriceNote = getMissingPriceIndicator(output.missingPrice);
                line.textContent = `• ${output.name} (Base): ${output.itemsPerHour.toFixed(decimals)}/hr @ ${formatWithSeparator(output.priceEach)}${missingPriceNote} each → ${formatLargeNumber(Math.round(output.revenuePerHour))}/hr`;
                primaryDropsContent.appendChild(line);
            }
        }

        if (profitData.gourmetBonuses && profitData.gourmetBonuses.length > 0) {
            for (const output of profitData.gourmetBonuses) {
                const decimals = output.itemsPerHour < 1 ? 2 : 1;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const missingPriceNote = getMissingPriceIndicator(output.missingPrice);
                line.textContent = `• ${output.name} (Gourmet ${formatPercentage(profitData.gourmetBonus || 0, 1)}): ${output.itemsPerHour.toFixed(decimals)}/hr @ ${formatWithSeparator(output.priceEach)}${missingPriceNote} each → ${formatLargeNumber(Math.round(output.revenuePerHour))}/hr`;
                primaryDropsContent.appendChild(line);
            }
        }

        if (profitData.processingConversions && profitData.processingConversions.length > 0) {
            const netProcessingValue = Math.round(profitData.processingRevenueBonus || 0);
            const netProcessingLabel = formatMissingLabel(
                processingMissing,
                `${netProcessingValue >= 0 ? '+' : '-'}${formatLargeNumber(Math.abs(netProcessingValue))}`
            );
            const processingContent = document.createElement('div');

            for (const conversion of profitData.processingConversions) {
                const consumedLine = document.createElement('div');
                consumedLine.style.marginLeft = '8px';
                const consumedMissingNote = getMissingPriceIndicator(conversion.missingPrice);
                const consumedRevenue = conversion.rawConsumedPerHour * conversion.rawPriceEach;
                consumedLine.textContent = `• ${conversion.rawItem} consumed: -${conversion.rawConsumedPerHour.toFixed(1)}/hr @ ${formatWithSeparator(conversion.rawPriceEach)}${consumedMissingNote} → -${formatLargeNumber(Math.round(consumedRevenue))}/hr`;
                processingContent.appendChild(consumedLine);

                const producedLine = document.createElement('div');
                producedLine.style.marginLeft = '8px';
                const producedMissingNote = getMissingPriceIndicator(conversion.missingPrice);
                const producedRevenue = conversion.conversionsPerHour * conversion.processedPriceEach;
                producedLine.textContent = `• ${conversion.processedItem} produced: ${conversion.conversionsPerHour.toFixed(1)}/hr @ ${formatWithSeparator(conversion.processedPriceEach)}${producedMissingNote} → ${formatLargeNumber(Math.round(producedRevenue))}/hr`;
                processingContent.appendChild(producedLine);
            }

            const processingSection = createCollapsibleSection(
                '',
                `• Processing (${formatPercentage(profitData.processingBonus || 0, 1)} proc): Net ${netProcessingLabel}/hr`,
                null,
                processingContent,
                false,
                1
            );
            primaryDropsContent.appendChild(processingSection);
        }

        const baseRevenue = profitData.baseOutputs?.reduce((sum, o) => sum + o.revenuePerHour, 0) || 0;
        const gourmetRevenue = profitData.gourmetRevenueBonus || 0;
        const processingRevenue = profitData.processingRevenueBonus || 0;
        const primaryRevenue = baseRevenue + gourmetRevenue + processingRevenue;
        const primaryRevenueLabel = formatMissingLabel(primaryMissing, formatLargeNumber(Math.round(primaryRevenue)));
        const outputItemCount =
            (profitData.baseOutputs?.length || 0) +
            (profitData.processingConversions && profitData.processingConversions.length > 0 ? 1 : 0);
        const primaryDropsSection = createCollapsibleSection(
            '',
            `Primary Outputs: ${primaryRevenueLabel}/hr (${outputItemCount} item${outputItemCount !== 1 ? 's' : ''})`,
            null,
            primaryDropsContent,
            false,
            1
        );

        // Bonus Drops subsections - split by type (bonus drops are base actions/hour)
        const bonusDrops = profitData.bonusRevenue?.bonusDrops || [];
        const essenceDrops = bonusDrops.filter((drop) => drop.type === 'essence');
        const rareFinds = bonusDrops.filter((drop) => drop.type === 'rare_find');

        // Essence Drops subsection
        let essenceSection = null;
        if (essenceDrops.length > 0) {
            const essenceContent = document.createElement('div');
            for (const drop of essenceDrops) {
                const { dropsPerHour, revenuePerHour } = getBonusDropPerHourTotals(drop, efficiencyMultiplier);
                const decimals = dropsPerHour < 1 ? 2 : 1;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);
                line.textContent = `• ${drop.itemName}: ${dropsPerHour.toFixed(decimals)}/hr (${dropRatePct}) → ${formatLargeNumber(Math.round(revenuePerHour))}/hr`;
                essenceContent.appendChild(line);
            }

            const essenceRevenue = essenceDrops.reduce(
                (sum, drop) => sum + getBonusDropPerHourTotals(drop, efficiencyMultiplier).revenuePerHour,
                0
            );
            const essenceRevenueLabel = formatMissingLabel(bonusMissing, formatLargeNumber(Math.round(essenceRevenue)));
            const essenceFindBonus = profitData.bonusRevenue?.essenceFindBonus || 0;
            essenceSection = createCollapsibleSection(
                '',
                `Essence Drops: ${essenceRevenueLabel}/hr (${essenceDrops.length} item${essenceDrops.length !== 1 ? 's' : ''}, ${essenceFindBonus.toFixed(1)}% essence find)`,
                null,
                essenceContent,
                false,
                1
            );
        }

        // Rare Finds subsection
        let rareFindSection = null;
        if (rareFinds.length > 0) {
            const rareFindContent = document.createElement('div');
            for (const drop of rareFinds) {
                const { dropsPerHour, revenuePerHour } = getBonusDropPerHourTotals(drop, efficiencyMultiplier);
                const decimals = dropsPerHour < 1 ? 2 : 1;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);
                line.textContent = `• ${drop.itemName}: ${dropsPerHour.toFixed(decimals)}/hr (${dropRatePct}) → ${formatLargeNumber(Math.round(revenuePerHour))}/hr`;
                rareFindContent.appendChild(line);
            }

            const rareFindRevenue = rareFinds.reduce(
                (sum, drop) => sum + getBonusDropPerHourTotals(drop, efficiencyMultiplier).revenuePerHour,
                0
            );
            const rareFindRevenueLabel = formatMissingLabel(bonusMissing, formatLargeNumber(Math.round(rareFindRevenue)));
            const rareFindSummary = formatRareFindBonusSummary(profitData.bonusRevenue);
            rareFindSection = createCollapsibleSection(
                '',
                `Rare Finds: ${rareFindRevenueLabel}/hr (${rareFinds.length} item${rareFinds.length !== 1 ? 's' : ''}, ${rareFindSummary})`,
                null,
                rareFindContent,
                false,
                1
            );
        }

        revenueDiv.appendChild(primaryDropsSection);
        if (essenceSection) {
            revenueDiv.appendChild(essenceSection);
        }
        if (rareFindSection) {
            revenueDiv.appendChild(rareFindSection);
        }

        // Costs Section
        const costsDiv = document.createElement('div');
        const costsLabel = formatMissingLabel(costsMissing, `${formatLargeNumber(costs)}/hr`);
        costsDiv.innerHTML = `<div style="font-weight: 500; color: ${config$1.COLOR_TOOLTIP_LOSS}; margin-top: 12px; margin-bottom: 4px;">Costs: ${costsLabel}</div>`;

        // Drink Costs subsection
        const drinkCostsContent = document.createElement('div');
        if (profitData.drinkCosts && profitData.drinkCosts.length > 0) {
            for (const drink of profitData.drinkCosts) {
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const missingPriceNote = getMissingPriceIndicator(drink.missingPrice);
                line.textContent = `• ${drink.name}: ${drink.drinksPerHour.toFixed(1)}/hr @ ${formatWithSeparator(drink.priceEach)}${missingPriceNote} → ${formatLargeNumber(Math.round(drink.costPerHour))}/hr`;
                drinkCostsContent.appendChild(line);
            }
        }

        const drinkCount = profitData.drinkCosts?.length || 0;
        const drinkCostsLabel = drinkCostsMissing ? '-- ⚠' : formatLargeNumber(Math.round(profitData.drinkCostPerHour));
        const drinkCostsSection = createCollapsibleSection(
            '',
            `Drink Costs: ${drinkCostsLabel}/hr (${drinkCount} drink${drinkCount !== 1 ? 's' : ''})`,
            null,
            drinkCostsContent,
            false,
            1
        );

        costsDiv.appendChild(drinkCostsSection);

        // Market Tax subsection
        const marketTaxContent = document.createElement('div');
        const marketTaxLine = document.createElement('div');
        marketTaxLine.style.marginLeft = '8px';
        const marketTaxLabel = marketTaxMissing ? '-- ⚠' : `${formatLargeNumber(marketTax)}/hr`;
        marketTaxLine.textContent = `• Market Tax: 2% of revenue → ${marketTaxLabel}`;
        marketTaxContent.appendChild(marketTaxLine);

        const marketTaxHeader = marketTaxMissing ? '-- ⚠' : `${formatLargeNumber(marketTax)}/hr`;
        const marketTaxSection = createCollapsibleSection(
            '',
            `Market Tax: ${marketTaxHeader} (2%)`,
            null,
            marketTaxContent,
            false,
            1
        );

        costsDiv.appendChild(marketTaxSection);

        // Modifiers Section
        const modifiersDiv = document.createElement('div');
        modifiersDiv.style.cssText = `
        margin-top: 12px;
        color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
    `;

        const modifierLines = [];

        // Efficiency breakdown
        const effParts = [];
        if (profitData.details.levelEfficiency > 0) {
            effParts.push(`${profitData.details.levelEfficiency}% level`);
        }
        if (profitData.details.houseEfficiency > 0) {
            effParts.push(`${profitData.details.houseEfficiency.toFixed(1)}% house`);
        }
        if (profitData.details.teaEfficiency > 0) {
            effParts.push(`${profitData.details.teaEfficiency.toFixed(1)}% tea`);
        }
        if (profitData.details.equipmentEfficiency > 0) {
            effParts.push(`${profitData.details.equipmentEfficiency.toFixed(1)}% equip`);
        }
        if (profitData.details.achievementEfficiency > 0) {
            effParts.push(`${profitData.details.achievementEfficiency.toFixed(1)}% achievement`);
        }

        if (effParts.length > 0) {
            modifierLines.push(
                `<div style="font-weight: 500; color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});">Modifiers:</div>`
            );
            modifierLines.push(
                `<div style="margin-left: 8px;">• Efficiency: +${profitData.totalEfficiency.toFixed(1)}% (${effParts.join(', ')})</div>`
            );
        }

        // Gathering Quantity
        if (profitData.gatheringQuantity > 0) {
            const gatheringParts = [];
            if (profitData.details.communityBuffQuantity > 0) {
                gatheringParts.push(`${(profitData.details.communityBuffQuantity * 100).toFixed(1)}% community`);
            }
            if (profitData.details.gatheringTeaBonus > 0) {
                gatheringParts.push(`${(profitData.details.gatheringTeaBonus * 100).toFixed(1)}% tea`);
            }
            if (profitData.details.achievementGathering > 0) {
                gatheringParts.push(`${(profitData.details.achievementGathering * 100).toFixed(1)}% achievement`);
            }
            modifierLines.push(
                `<div style="margin-left: 8px;">• Gathering Quantity: +${(profitData.gatheringQuantity * 100).toFixed(1)}% (${gatheringParts.join(', ')})</div>`
            );
        }

        const gatheringRareFindParts = getRareFindBreakdownParts(profitData.bonusRevenue);
        if (gatheringRareFindParts.length > 0) {
            if (modifierLines.length === 0) {
                modifierLines.push(
                    `<div style="font-weight: 500; color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});">Modifiers:</div>`
                );
            }
            modifierLines.push(
                `<div style="margin-left: 8px;">• Rare Find: +${(profitData.bonusRevenue?.rareFindBonus || 0).toFixed(1)}% (${gatheringRareFindParts.join(', ')})</div>`
            );
        }

        modifiersDiv.innerHTML = modifierLines.join('');

        // Assemble Detailed Breakdown (WITHOUT net profit - that goes in top level)
        detailsContent.appendChild(revenueDiv);
        detailsContent.appendChild(costsDiv);
        detailsContent.appendChild(modifiersDiv);

        // Create "Detailed Breakdown" collapsible
        const topLevelContent = document.createElement('div');
        topLevelContent.innerHTML = `
        <div style="margin-bottom: 4px;">Actions: ${profitData.actionsPerHour.toFixed(1)}/hr | Efficiency: +${profitData.totalEfficiency.toFixed(1)}%</div>
    `;

        // Add Net Profit line at top level (always visible when Profitability is expanded)
        const profitColor = netMissing ? config$1.SCRIPT_COLOR_ALERT : profit >= 0 ? '#4ade80' : config$1.COLOR_LOSS; // green if positive, red if negative
        const netProfitLine = document.createElement('div');
        netProfitLine.style.cssText = `
        font-weight: 500;
        color: ${profitColor};
        margin-bottom: 8px;
    `;
        netProfitLine.textContent = netMissing
            ? 'Net Profit: -- ⚠'
            : `Net Profit: ${formatLargeNumber(profit)}/hr, ${formatLargeNumber(profitPerDay)}/day`;
        topLevelContent.appendChild(netProfitLine);

        const detailedBreakdownSection = createCollapsibleSection(
            '📊',
            'Per hour breakdown',
            null,
            detailsContent,
            false,
            0
        );

        topLevelContent.appendChild(detailedBreakdownSection);

        // Add X actions breakdown section (updates dynamically with input)
        const inputField = findActionInput(panel);
        if (inputField) {
            const inputValue = parseInt(inputField.value) || 0;

            // Add initial X actions breakdown if input has value
            if (inputValue > 0) {
                const actionsBreakdown = buildGatheringActionsBreakdown(profitData, inputValue);
                topLevelContent.appendChild(actionsBreakdown);
            }

            // Set up input listener to update X actions breakdown dynamically
            attachInputListeners(panel, inputField, (newValue) => {
                // Remove existing X actions breakdown
                const existingBreakdown = topLevelContent.querySelector('.mwi-actions-breakdown');
                if (existingBreakdown) {
                    existingBreakdown.remove();
                }

                // Add new X actions breakdown if value > 0
                if (newValue > 0) {
                    const actionsBreakdown = buildGatheringActionsBreakdown(profitData, newValue);
                    topLevelContent.appendChild(actionsBreakdown);
                }
            });
        }

        // Create main profit section
        const profitSection = createCollapsibleSection('💰', 'Profitability', summary, topLevelContent, false, 0);
        profitSection.id = 'mwi-foraging-profit';

        // Get the summary div to update it dynamically
        const profitSummaryDiv = profitSection.querySelector('.mwi-section-header + div');

        // Set up listener to update summary with total profit when input changes
        if (inputField && profitSummaryDiv) {
            const baseSummary = formatMissingLabel(
                netMissing,
                `${formatLargeNumber(profit)}/hr, ${formatLargeNumber(profitPerDay)}/day`
            );

            const updateSummary = (newValue) => {
                if (netMissing) {
                    profitSummaryDiv.textContent = `${baseSummary} | Total profit: -- ⚠`;
                    return;
                }
                const inputValue = inputField.value;

                if (inputValue === '∞') {
                    profitSummaryDiv.textContent = `${baseSummary} | Total profit: ∞`;
                } else if (newValue > 0) {
                    const totals = calculateGatheringActionTotalsFromBase({
                        actionsCount: newValue,
                        actionsPerHour: profitData.actionsPerHour,
                        baseOutputs: profitData.baseOutputs,
                        bonusDrops: profitData.bonusRevenue?.bonusDrops || [],
                        processingRevenueBonusPerAction: profitData.processingRevenueBonusPerAction,
                        gourmetRevenueBonusPerAction: profitData.gourmetRevenueBonusPerAction,
                        drinkCostPerHour: profitData.drinkCostPerHour,
                        efficiencyMultiplier: profitData.efficiencyMultiplier || 1,
                    });
                    const totalProfit = Math.round(totals.totalProfit);
                    profitSummaryDiv.textContent = `${baseSummary} | Total profit: ${formatLargeNumber(totalProfit)}`;
                } else {
                    profitSummaryDiv.textContent = `${baseSummary} | Total profit: 0`;
                }
            };

            // Update summary initially
            const initialValue = parseInt(inputField.value) || 0;
            updateSummary(initialValue);

            // Attach listener for future changes
            attachInputListeners(panel, inputField, updateSummary);
        }

        // Find insertion point - look for existing collapsible sections or drop table
        let insertionPoint = panel.querySelector('.mwi-collapsible-section');
        if (insertionPoint) {
            // Insert after last collapsible section
            while (
                insertionPoint.nextElementSibling &&
                insertionPoint.nextElementSibling.className === 'mwi-collapsible-section'
            ) {
                insertionPoint = insertionPoint.nextElementSibling;
            }
            insertionPoint.insertAdjacentElement('afterend', profitSection);
        } else {
            // Fallback: insert after drop table
            const dropTableElement = panel.querySelector(dropTableSelector);
            if (dropTableElement) {
                dropTableElement.parentNode.insertBefore(profitSection, dropTableElement.nextSibling);
            }
        }
    }

    /**
     * Display production profit calculation in panel
     * @param {HTMLElement} panel - Action panel element
     * @param {string} actionHrid - Action HRID
     * @param {string} dropTableSelector - CSS selector for drop table element
     */
    async function displayProductionProfit(panel, actionHrid, dropTableSelector) {
        // Calculate profit
        const profitData = await calculateProductionProfit(actionHrid);
        if (!profitData) {
            console.error('❌ Production profit calculation failed for:', actionHrid);
            return;
        }

        // Validate required fields
        const requiredFields = [
            'profitPerHour',
            'profitPerDay',
            'itemsPerHour',
            'priceAfterTax',
            'gourmetBonusItems',
            'materialCostPerHour',
            'totalTeaCostPerHour',
            'actionsPerHour',
            'totalEfficiency',
            'levelEfficiency',
            'houseEfficiency',
            'teaEfficiency',
            'equipmentEfficiency',
            'artisanBonus',
            'gourmetBonus',
            'materialCosts',
            'teaCosts',
        ];

        const missingFields = requiredFields.filter((field) => profitData[field] === undefined);
        if (missingFields.length > 0) {
            console.error('❌ Production profit data missing required fields:', missingFields, 'for action:', actionHrid);
            console.error('Received profitData:', profitData);
            return;
        }

        // Check if we already added profit display
        const existingProfit = panel.querySelector('#mwi-production-profit');
        if (existingProfit) {
            existingProfit.remove();
        }

        // Create top-level summary (bonus revenue now included in profitPerHour)
        const profit = Math.round(profitData.profitPerHour);
        const profitPerDay = Math.round(profitData.profitPerDay);
        const outputMissing = profitData.outputPriceMissing || false;
        const bonusMissing = profitData.bonusRevenue?.hasMissingPrices || false;
        const materialMissing = profitData.materialCosts?.some((material) => material.missingPrice) || false;
        const teaMissing = profitData.teaCosts?.some((tea) => tea.missingPrice) || false;
        const revenueMissing = outputMissing || bonusMissing;
        const costsMissing = materialMissing || teaMissing || revenueMissing;
        const marketTaxMissing = revenueMissing;
        const netMissing = profitData.hasMissingPrices;
        const bonusDrops = profitData.bonusRevenue?.bonusDrops || [];
        const bonusRevenueTotal = profitData.bonusRevenue?.totalBonusRevenue || 0;
        const efficiencyMultiplier = profitData.efficiencyMultiplier || 1;
        // Use outputPrice (pre-tax) for revenue display
        const revenue = Math.round(
            profitData.itemsPerHour * profitData.outputPrice +
                profitData.gourmetBonusItems * profitData.outputPrice +
                bonusRevenueTotal * efficiencyMultiplier
        );
        // Calculate market tax (2% of revenue)
        const marketTax = Math.round(revenue * MARKET_TAX);
        const costs = Math.round(profitData.materialCostPerHour + profitData.totalTeaCostPerHour + marketTax);
        const summary = netMissing
            ? '-- ⚠'
            : `${formatLargeNumber(profit)}/hr, ${formatLargeNumber(profitPerDay)}/day | Total profit: 0`;

        const detailsContent = document.createElement('div');

        // Revenue Section
        const revenueDiv = document.createElement('div');
        const revenueLabel = revenueMissing ? '-- ⚠' : `${formatLargeNumber(revenue)}/hr`;
        revenueDiv.innerHTML = `<div style="font-weight: 500; color: ${config$1.COLOR_TOOLTIP_PROFIT}; margin-bottom: 4px;">Revenue: ${revenueLabel}</div>`;

        // Primary Outputs subsection
        const primaryOutputContent = document.createElement('div');
        const baseOutputLine = document.createElement('div');
        baseOutputLine.style.marginLeft = '8px';
        const baseOutputMissingNote = getMissingPriceIndicator(profitData.outputPriceMissing);
        baseOutputLine.textContent = `• ${profitData.itemName} (Base): ${profitData.itemsPerHour.toFixed(1)}/hr @ ${formatWithSeparator(Math.round(profitData.outputPrice))}${baseOutputMissingNote} each → ${formatLargeNumber(Math.round(profitData.itemsPerHour * profitData.outputPrice))}/hr`;
        primaryOutputContent.appendChild(baseOutputLine);

        if (profitData.gourmetBonusItems > 0) {
            const gourmetLine = document.createElement('div');
            gourmetLine.style.marginLeft = '8px';
            gourmetLine.textContent = `• ${profitData.itemName} (Gourmet +${formatPercentage(profitData.gourmetBonus, 1)}): ${profitData.gourmetBonusItems.toFixed(1)}/hr @ ${formatWithSeparator(Math.round(profitData.outputPrice))}${baseOutputMissingNote} each → ${formatLargeNumber(Math.round(profitData.gourmetBonusItems * profitData.outputPrice))}/hr`;
            primaryOutputContent.appendChild(gourmetLine);
        }

        const baseRevenue = profitData.itemsPerHour * profitData.outputPrice;
        const gourmetRevenue = profitData.gourmetBonusItems * profitData.outputPrice;
        const primaryRevenue = baseRevenue + gourmetRevenue;
        const primaryRevenueLabel = outputMissing ? '-- ⚠' : formatWithSeparator(Math.round(primaryRevenue));
        const gourmetLabel =
            profitData.gourmetBonus > 0 ? ` (${formatPercentage(profitData.gourmetBonus, 1)} gourmet)` : '';
        const primaryOutputSection = createCollapsibleSection(
            '',
            `Primary Outputs: ${primaryRevenueLabel}/hr${gourmetLabel}`,
            null,
            primaryOutputContent,
            false,
            1
        );

        revenueDiv.appendChild(primaryOutputSection);

        // Bonus Drops subsections - split by type
        const essenceDrops = bonusDrops.filter((drop) => drop.type === 'essence');
        const rareFinds = bonusDrops.filter((drop) => drop.type === 'rare_find');

        // Essence Drops subsection
        let essenceSection = null;
        if (essenceDrops.length > 0) {
            const essenceContent = document.createElement('div');
            for (const drop of essenceDrops) {
                const { dropsPerHour, revenuePerHour } = getBonusDropPerHourTotals(drop, efficiencyMultiplier);
                const decimals = dropsPerHour < 1 ? 2 : 1;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);
                line.textContent = `• ${drop.itemName}: ${dropsPerHour.toFixed(decimals)}/hr (${dropRatePct}) → ${formatLargeNumber(Math.round(revenuePerHour))}/hr`;
                essenceContent.appendChild(line);
            }

            const essenceRevenue = essenceDrops.reduce(
                (sum, drop) => sum + getBonusDropPerHourTotals(drop, efficiencyMultiplier).revenuePerHour,
                0
            );
            const essenceRevenueLabel = bonusMissing ? '-- ⚠' : formatLargeNumber(Math.round(essenceRevenue));
            const essenceFindBonus = profitData.bonusRevenue?.essenceFindBonus || 0;
            essenceSection = createCollapsibleSection(
                '',
                `Essence Drops: ${essenceRevenueLabel}/hr (${essenceDrops.length} item${essenceDrops.length !== 1 ? 's' : ''}, ${essenceFindBonus.toFixed(1)}% essence find)`,
                null,
                essenceContent,
                false,
                1
            );
        }

        // Rare Finds subsection
        let rareFindSection = null;
        if (rareFinds.length > 0) {
            const rareFindContent = document.createElement('div');
            for (const drop of rareFinds) {
                const { dropsPerHour, revenuePerHour } = getBonusDropPerHourTotals(drop, efficiencyMultiplier);
                const decimals = dropsPerHour < 1 ? 2 : 1;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);
                line.textContent = `• ${drop.itemName}: ${dropsPerHour.toFixed(decimals)}/hr (${dropRatePct}) → ${formatLargeNumber(Math.round(revenuePerHour))}/hr`;
                rareFindContent.appendChild(line);
            }

            const rareFindRevenue = rareFinds.reduce(
                (sum, drop) => sum + getBonusDropPerHourTotals(drop, efficiencyMultiplier).revenuePerHour,
                0
            );
            const rareFindRevenueLabel = bonusMissing ? '-- ⚠' : formatLargeNumber(Math.round(rareFindRevenue));
            const rareFindSummary = formatRareFindBonusSummary(profitData.bonusRevenue);
            rareFindSection = createCollapsibleSection(
                '',
                `Rare Finds: ${rareFindRevenueLabel}/hr (${rareFinds.length} item${rareFinds.length !== 1 ? 's' : ''}, ${rareFindSummary})`,
                null,
                rareFindContent,
                false,
                1
            );
        }

        if (essenceSection) {
            revenueDiv.appendChild(essenceSection);
        }
        if (rareFindSection) {
            revenueDiv.appendChild(rareFindSection);
        }

        // Costs Section
        const costsDiv = document.createElement('div');
        const costsLabel = costsMissing ? '-- ⚠' : `${formatLargeNumber(costs)}/hr`;
        costsDiv.innerHTML = `<div style="font-weight: 500; color: ${config$1.COLOR_TOOLTIP_LOSS}; margin-top: 12px; margin-bottom: 4px;">Costs: ${costsLabel}</div>`;

        // Material Costs subsection
        const materialCostsContent = document.createElement('div');
        if (profitData.materialCosts && profitData.materialCosts.length > 0) {
            for (const material of profitData.materialCosts) {
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                // Material structure: { itemName, amount, askPrice, totalCost, baseAmount }
                const amountPerAction = material.amount || 0;
                const efficiencyMultiplier = profitData.efficiencyMultiplier;
                const amountPerHour = amountPerAction * profitData.actionsPerHour * efficiencyMultiplier;

                // Build material line with embedded Artisan information
                let materialText = `• ${material.itemName}: ${amountPerHour.toFixed(1)}/hr`;

                // Add Artisan reduction info if present (only show if actually reduced)
                if (profitData.artisanBonus > 0 && material.baseAmount && material.amount !== material.baseAmount) {
                    const baseAmountPerHour = material.baseAmount * profitData.actionsPerHour * efficiencyMultiplier;
                    materialText += ` (${baseAmountPerHour.toFixed(1)} base -${formatPercentage(profitData.artisanBonus, 1)} 🍵)`;
                }

                const missingPriceNote = getMissingPriceIndicator(material.missingPrice);
                materialText += ` @ ${formatWithSeparator(Math.round(material.askPrice))}${missingPriceNote} → ${formatLargeNumber(Math.round(material.totalCost * profitData.actionsPerHour * efficiencyMultiplier))}/hr`;

                line.textContent = materialText;
                materialCostsContent.appendChild(line);
            }
        }

        const materialCostsLabel = formatMissingLabel(
            materialMissing,
            formatLargeNumber(Math.round(profitData.materialCostPerHour))
        );
        const materialCostsSection = createCollapsibleSection(
            '',
            `Material Costs: ${materialCostsLabel}/hr (${profitData.materialCosts?.length || 0} material${profitData.materialCosts?.length !== 1 ? 's' : ''})`,
            null,
            materialCostsContent,
            false,
            1
        );

        // Tea Costs subsection
        const teaCostsContent = document.createElement('div');
        if (profitData.teaCosts && profitData.teaCosts.length > 0) {
            for (const tea of profitData.teaCosts) {
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                // Tea structure: { itemName, pricePerDrink, drinksPerHour, totalCost }
                const missingPriceNote = getMissingPriceIndicator(tea.missingPrice);
                line.textContent = `• ${tea.itemName}: ${tea.drinksPerHour.toFixed(1)}/hr @ ${formatWithSeparator(Math.round(tea.pricePerDrink))}${missingPriceNote} → ${formatLargeNumber(Math.round(tea.totalCost))}/hr`;
                teaCostsContent.appendChild(line);
            }
        }

        const teaCount = profitData.teaCosts?.length || 0;
        const teaCostsLabel = formatMissingLabel(teaMissing, formatLargeNumber(Math.round(profitData.totalTeaCostPerHour)));
        const teaCostsSection = createCollapsibleSection(
            '',
            `Drink Costs: ${teaCostsLabel}/hr (${teaCount} drink${teaCount !== 1 ? 's' : ''})`,
            null,
            teaCostsContent,
            false,
            1
        );

        costsDiv.appendChild(materialCostsSection);
        costsDiv.appendChild(teaCostsSection);

        // Market Tax subsection
        const marketTaxContent = document.createElement('div');
        const marketTaxLine = document.createElement('div');
        marketTaxLine.style.marginLeft = '8px';
        const marketTaxLabel = formatMissingLabel(marketTaxMissing, `${formatLargeNumber(marketTax)}/hr`);
        marketTaxLine.textContent = `• Market Tax: 2% of revenue → ${marketTaxLabel}`;
        marketTaxContent.appendChild(marketTaxLine);

        const marketTaxHeader = formatMissingLabel(marketTaxMissing, `${formatLargeNumber(marketTax)}/hr`);
        const marketTaxSection = createCollapsibleSection(
            '',
            `Market Tax: ${marketTaxHeader} (2%)`,
            null,
            marketTaxContent,
            false,
            1
        );

        costsDiv.appendChild(marketTaxSection);

        // Modifiers Section
        const modifiersDiv = document.createElement('div');
        modifiersDiv.style.cssText = `
        margin-top: 12px;
        color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
    `;

        const modifierLines = [];

        // Efficiency breakdown
        const effParts = [];
        if (profitData.levelEfficiency > 0) {
            effParts.push(`${profitData.levelEfficiency}% level`);
        }
        if (profitData.houseEfficiency > 0) {
            effParts.push(`${profitData.houseEfficiency.toFixed(1)}% house`);
        }
        if (profitData.teaEfficiency > 0) {
            effParts.push(`${profitData.teaEfficiency.toFixed(1)}% tea`);
        }
        if (profitData.equipmentEfficiency > 0) {
            effParts.push(`${profitData.equipmentEfficiency.toFixed(1)}% equip`);
        }
        if (profitData.communityEfficiency > 0) {
            effParts.push(`${profitData.communityEfficiency.toFixed(1)}% community`);
        }
        if (profitData.achievementEfficiency > 0) {
            effParts.push(`${profitData.achievementEfficiency.toFixed(1)}% achievement`);
        }

        if (effParts.length > 0) {
            modifierLines.push(
                `<div style="font-weight: 500; color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});">Modifiers:</div>`
            );
            modifierLines.push(
                `<div style="margin-left: 8px;">• Efficiency: +${profitData.totalEfficiency.toFixed(1)}% (${effParts.join(', ')})</div>`
            );
        }

        const productionRareFindParts = getRareFindBreakdownParts(profitData.bonusRevenue);
        if (productionRareFindParts.length > 0) {
            if (modifierLines.length === 0) {
                modifierLines.push(
                    `<div style="font-weight: 500; color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});">Modifiers:</div>`
                );
            }
            modifierLines.push(
                `<div style="margin-left: 8px;">• Rare Find: +${(profitData.bonusRevenue?.rareFindBonus || 0).toFixed(1)}% (${productionRareFindParts.join(', ')})</div>`
            );
        }

        // Artisan Bonus (still shown here for reference, also embedded in materials)
        if (profitData.artisanBonus > 0) {
            if (modifierLines.length === 0) {
                modifierLines.push(
                    `<div style="font-weight: 500; color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});">Modifiers:</div>`
                );
            }
            modifierLines.push(
                `<div style="margin-left: 8px;">• Artisan: -${formatPercentage(profitData.artisanBonus, 1)} material requirement</div>`
            );
        }

        // Gourmet Bonus
        if (profitData.gourmetBonus > 0) {
            if (modifierLines.length === 0) {
                modifierLines.push(
                    `<div style="font-weight: 500; color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});">Modifiers:</div>`
                );
            }
            modifierLines.push(
                `<div style="margin-left: 8px;">• Gourmet: +${formatPercentage(profitData.gourmetBonus, 1)} bonus items</div>`
            );
        }

        modifiersDiv.innerHTML = modifierLines.join('');

        // Assemble Detailed Breakdown (WITHOUT net profit - that goes in top level)
        detailsContent.appendChild(revenueDiv);
        detailsContent.appendChild(costsDiv);
        if (modifierLines.length > 0) {
            detailsContent.appendChild(modifiersDiv);
        }

        // Create "Detailed Breakdown" collapsible
        const topLevelContent = document.createElement('div');
        topLevelContent.innerHTML = `
        <div style="margin-bottom: 4px;">Actions: ${profitData.actionsPerHour.toFixed(1)}/hr</div>
    `;

        // Add Net Profit line at top level (always visible when Profitability is expanded)
        const profitColor = netMissing ? config$1.SCRIPT_COLOR_ALERT : profit >= 0 ? '#4ade80' : config$1.COLOR_LOSS; // green if positive, red if negative
        const netProfitLine = document.createElement('div');
        netProfitLine.style.cssText = `
        font-weight: 500;
        color: ${profitColor};
        margin-bottom: 8px;
    `;
        netProfitLine.textContent = netMissing
            ? 'Net Profit: -- ⚠'
            : `Net Profit: ${formatLargeNumber(profit)}/hr, ${formatLargeNumber(profitPerDay)}/day`;
        topLevelContent.appendChild(netProfitLine);

        const detailedBreakdownSection = createCollapsibleSection(
            '📊',
            'Per hour breakdown',
            null,
            detailsContent,
            false,
            0
        );

        topLevelContent.appendChild(detailedBreakdownSection);

        // Add X actions breakdown section (updates dynamically with input)
        const inputField = findActionInput(panel);
        if (inputField) {
            const inputValue = parseInt(inputField.value) || 0;

            // Add initial X actions breakdown if input has value
            if (inputValue > 0) {
                const actionsBreakdown = buildProductionActionsBreakdown(profitData, inputValue);
                topLevelContent.appendChild(actionsBreakdown);
            }

            // Set up input listener to update X actions breakdown dynamically
            attachInputListeners(panel, inputField, (newValue) => {
                // Remove existing X actions breakdown
                const existingBreakdown = topLevelContent.querySelector('.mwi-actions-breakdown');
                if (existingBreakdown) {
                    existingBreakdown.remove();
                }

                // Add new X actions breakdown if value > 0
                if (newValue > 0) {
                    const actionsBreakdown = buildProductionActionsBreakdown(profitData, newValue);
                    topLevelContent.appendChild(actionsBreakdown);
                }
            });
        }

        // Create main profit section
        const profitSection = createCollapsibleSection('💰', 'Profitability', summary, topLevelContent, false, 0);
        profitSection.id = 'mwi-production-profit';

        // Get the summary div to update it dynamically
        const profitSummaryDiv = profitSection.querySelector('.mwi-section-header + div');

        // Set up listener to update summary with total profit when input changes
        if (inputField && profitSummaryDiv) {
            const baseSummary = formatMissingLabel(
                netMissing,
                `${formatLargeNumber(profit)}/hr, ${formatLargeNumber(profitPerDay)}/day`
            );

            const updateSummary = (newValue) => {
                if (netMissing) {
                    profitSummaryDiv.textContent = `${baseSummary} | Total profit: -- ⚠`;
                    return;
                }
                const inputValue = inputField.value;

                if (inputValue === '∞') {
                    profitSummaryDiv.textContent = `${baseSummary} | Total profit: ∞`;
                } else if (newValue > 0) {
                    const totals = calculateProductionActionTotalsFromBase({
                        actionsCount: newValue,
                        actionsPerHour: profitData.actionsPerHour,
                        outputAmount: profitData.outputAmount || 1,
                        outputPrice: profitData.outputPrice,
                        gourmetBonus: profitData.gourmetBonus || 0,
                        bonusDrops: profitData.bonusRevenue?.bonusDrops || [],
                        materialCosts: profitData.materialCosts,
                        totalTeaCostPerHour: profitData.totalTeaCostPerHour,
                        efficiencyMultiplier: profitData.efficiencyMultiplier || 1,
                    });
                    const totalProfit = Math.round(totals.totalProfit);
                    profitSummaryDiv.textContent = `${baseSummary} | Total profit: ${formatLargeNumber(totalProfit)}`;
                } else {
                    profitSummaryDiv.textContent = `${baseSummary} | Total profit: 0`;
                }
            };

            // Update summary initially
            const initialValue = parseInt(inputField.value) || 0;
            updateSummary(initialValue);

            // Attach listener for future changes
            attachInputListeners(panel, inputField, updateSummary);
        }

        // Find insertion point - look for existing collapsible sections or drop table
        let insertionPoint = panel.querySelector('.mwi-collapsible-section');
        if (insertionPoint) {
            // Insert after last collapsible section
            while (
                insertionPoint.nextElementSibling &&
                insertionPoint.nextElementSibling.className === 'mwi-collapsible-section'
            ) {
                insertionPoint = insertionPoint.nextElementSibling;
            }
            insertionPoint.insertAdjacentElement('afterend', profitSection);
        } else {
            // Fallback: insert after drop table
            const dropTableElement = panel.querySelector(dropTableSelector);
            if (dropTableElement) {
                dropTableElement.parentNode.insertBefore(profitSection, dropTableElement.nextSibling);
            }
        }
    }

    /**
     * Build "X actions breakdown" section for gathering actions
     * @param {Object} profitData - Profit calculation data
     * @param {number} actionsCount - Number of actions from input field
     * @returns {HTMLElement} Breakdown section element
     */
    function buildGatheringActionsBreakdown(profitData, actionsCount) {
        const totals = calculateGatheringActionTotalsFromBase({
            actionsCount,
            actionsPerHour: profitData.actionsPerHour,
            baseOutputs: profitData.baseOutputs,
            bonusDrops: profitData.bonusRevenue?.bonusDrops || [],
            processingRevenueBonusPerAction: profitData.processingRevenueBonusPerAction,
            gourmetRevenueBonusPerAction: profitData.gourmetRevenueBonusPerAction,
            drinkCostPerHour: profitData.drinkCostPerHour,
            efficiencyMultiplier: profitData.efficiencyMultiplier || 1,
        });
        const hoursNeeded = totals.hoursNeeded;

        // Calculate totals
        const baseMissing = profitData.baseOutputs?.some((output) => output.missingPrice) || false;
        const gourmetMissing = profitData.gourmetBonuses?.some((output) => output.missingPrice) || false;
        const bonusMissing = profitData.bonusRevenue?.hasMissingPrices || false;
        const processingMissing = profitData.processingConversions?.some((conversion) => conversion.missingPrice) || false;
        const primaryMissing = baseMissing || gourmetMissing || processingMissing;
        const revenueMissing = primaryMissing || bonusMissing;
        const drinkCostsMissing = profitData.drinkCosts?.some((drink) => drink.missingPrice) || false;
        const costsMissing = drinkCostsMissing || revenueMissing;
        const marketTaxMissing = revenueMissing;
        const netMissing = profitData.hasMissingPrices;
        const totalRevenue = Math.round(totals.totalRevenue);
        const totalMarketTax = Math.round(totals.totalMarketTax);
        const totalDrinkCosts = Math.round(totals.totalDrinkCost);
        const totalCosts = Math.round(totals.totalCosts);
        const totalProfit = Math.round(totals.totalProfit);

        const detailsContent = document.createElement('div');

        // Revenue Section
        const revenueDiv = document.createElement('div');
        const revenueLabel = formatMissingLabel(revenueMissing, formatLargeNumber(totalRevenue));
        revenueDiv.innerHTML = `<div style="font-weight: 500; color: ${config$1.COLOR_TOOLTIP_PROFIT}; margin-bottom: 4px;">Revenue: ${revenueLabel}</div>`;

        // Primary Outputs subsection
        const primaryDropsContent = document.createElement('div');
        if (profitData.baseOutputs && profitData.baseOutputs.length > 0) {
            for (const output of profitData.baseOutputs) {
                const itemsPerAction = output.itemsPerAction ?? output.itemsPerHour / profitData.actionsPerHour;
                const revenuePerAction = output.revenuePerAction ?? output.revenuePerHour / profitData.actionsPerHour;
                const totalItems = itemsPerAction * actionsCount;
                const totalRevenueLine = revenuePerAction * actionsCount;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const missingPriceNote = getMissingPriceIndicator(output.missingPrice);
                line.textContent = `• ${output.name} (Base): ${totalItems.toFixed(1)} items @ ${formatWithSeparator(output.priceEach)}${missingPriceNote} each → ${formatLargeNumber(Math.round(totalRevenueLine))}`;
                primaryDropsContent.appendChild(line);
            }
        }

        if (profitData.gourmetBonuses && profitData.gourmetBonuses.length > 0) {
            for (const output of profitData.gourmetBonuses) {
                const itemsPerAction = output.itemsPerAction ?? output.itemsPerHour / profitData.actionsPerHour;
                const revenuePerAction = output.revenuePerAction ?? output.revenuePerHour / profitData.actionsPerHour;
                const totalItems = itemsPerAction * actionsCount;
                const totalRevenueLine = revenuePerAction * actionsCount;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const missingPriceNote = getMissingPriceIndicator(output.missingPrice);
                line.textContent = `• ${output.name} (Gourmet ${formatPercentage(profitData.gourmetBonus || 0, 1)}): ${totalItems.toFixed(1)} items @ ${formatWithSeparator(output.priceEach)}${missingPriceNote} each → ${formatLargeNumber(Math.round(totalRevenueLine))}`;
                primaryDropsContent.appendChild(line);
            }
        }

        if (profitData.processingConversions && profitData.processingConversions.length > 0) {
            const totalProcessingRevenue = totals.totalProcessingRevenue;
            const processingLabel = formatMissingLabel(
                processingMissing,
                `${totalProcessingRevenue >= 0 ? '+' : '-'}${formatLargeNumber(Math.abs(Math.round(totalProcessingRevenue)))}`
            );
            const processingContent = document.createElement('div');

            for (const conversion of profitData.processingConversions) {
                const conversionsPerAction =
                    conversion.conversionsPerAction ?? conversion.conversionsPerHour / profitData.actionsPerHour;
                const rawConsumedPerAction =
                    conversion.rawConsumedPerAction ?? conversion.rawConsumedPerHour / profitData.actionsPerHour;
                const totalConsumed = rawConsumedPerAction * actionsCount;
                const totalProduced = conversionsPerAction * actionsCount;
                const consumedRevenue = totalConsumed * conversion.rawPriceEach;
                const producedRevenue = totalProduced * conversion.processedPriceEach;
                const missingPriceNote = getMissingPriceIndicator(conversion.missingPrice);

                const consumedLine = document.createElement('div');
                consumedLine.style.marginLeft = '8px';
                consumedLine.textContent = `• ${conversion.rawItem} consumed: -${totalConsumed.toFixed(1)} items @ ${formatWithSeparator(conversion.rawPriceEach)}${missingPriceNote} → -${formatLargeNumber(Math.round(consumedRevenue))}`;
                processingContent.appendChild(consumedLine);

                const producedLine = document.createElement('div');
                producedLine.style.marginLeft = '8px';
                producedLine.textContent = `• ${conversion.processedItem} produced: ${totalProduced.toFixed(1)} items @ ${formatWithSeparator(conversion.processedPriceEach)}${missingPriceNote} → ${formatLargeNumber(Math.round(producedRevenue))}`;
                processingContent.appendChild(producedLine);
            }

            const processingSection = createCollapsibleSection(
                '',
                `• Processing (${formatPercentage(profitData.processingBonus || 0, 1)} proc): Net ${processingLabel}`,
                null,
                processingContent,
                false,
                1
            );
            primaryDropsContent.appendChild(processingSection);
        }

        const baseRevenue =
            profitData.baseOutputs?.reduce((sum, output) => {
                const revenuePerAction = output.revenuePerAction ?? output.revenuePerHour / profitData.actionsPerHour;
                return sum + revenuePerAction * actionsCount;
            }, 0) || 0;
        const gourmetRevenue = totals.totalGourmetRevenue;
        const processingRevenue = totals.totalProcessingRevenue;
        const primaryRevenue = baseRevenue + gourmetRevenue + processingRevenue;
        const primaryRevenueLabel = formatMissingLabel(primaryMissing, formatLargeNumber(Math.round(primaryRevenue)));
        const outputItemCount =
            (profitData.baseOutputs?.length || 0) +
            (profitData.processingConversions && profitData.processingConversions.length > 0 ? 1 : 0);
        const primaryDropsSection = createCollapsibleSection(
            '',
            `Primary Outputs: ${primaryRevenueLabel} (${outputItemCount} item${outputItemCount !== 1 ? 's' : ''})`,
            null,
            primaryDropsContent,
            false,
            1
        );

        // Bonus Drops subsections (bonus drops are per action)
        const bonusDrops = profitData.bonusRevenue?.bonusDrops || [];
        const essenceDrops = bonusDrops.filter((drop) => drop.type === 'essence');
        const rareFinds = bonusDrops.filter((drop) => drop.type === 'rare_find');

        // Essence Drops subsection
        let essenceSection = null;
        if (essenceDrops.length > 0) {
            const essenceContent = document.createElement('div');
            for (const drop of essenceDrops) {
                const { totalDrops, totalRevenue } = getBonusDropTotalsForActions(
                    drop,
                    actionsCount,
                    profitData.actionsPerHour
                );
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);
                line.textContent = `• ${drop.itemName}: ${totalDrops.toFixed(2)} drops (${dropRatePct}) → ${formatLargeNumber(Math.round(totalRevenue))}`;
                essenceContent.appendChild(line);
            }

            const essenceRevenue = essenceDrops.reduce((sum, drop) => {
                return sum + getBonusDropTotalsForActions(drop, actionsCount, profitData.actionsPerHour).totalRevenue;
            }, 0);
            const essenceRevenueLabel = formatMissingLabel(bonusMissing, formatLargeNumber(Math.round(essenceRevenue)));
            const essenceFindBonus = profitData.bonusRevenue?.essenceFindBonus || 0;
            essenceSection = createCollapsibleSection(
                '',
                `Essence Drops: ${essenceRevenueLabel} (${essenceDrops.length} item${essenceDrops.length !== 1 ? 's' : ''}, ${essenceFindBonus.toFixed(1)}% essence find)`,
                null,
                essenceContent,
                false,
                1
            );
        }

        // Rare Finds subsection
        let rareFindSection = null;
        if (rareFinds.length > 0) {
            const rareFindContent = document.createElement('div');
            for (const drop of rareFinds) {
                const { totalDrops, totalRevenue } = getBonusDropTotalsForActions(
                    drop,
                    actionsCount,
                    profitData.actionsPerHour
                );
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);
                line.textContent = `• ${drop.itemName}: ${totalDrops.toFixed(2)} drops (${dropRatePct}) → ${formatLargeNumber(Math.round(totalRevenue))}`;
                rareFindContent.appendChild(line);
            }

            const rareFindRevenue = rareFinds.reduce((sum, drop) => {
                return sum + getBonusDropTotalsForActions(drop, actionsCount, profitData.actionsPerHour).totalRevenue;
            }, 0);
            const rareFindRevenueLabel = formatMissingLabel(bonusMissing, formatLargeNumber(Math.round(rareFindRevenue)));
            const rareFindSummary = formatRareFindBonusSummary(profitData.bonusRevenue);
            rareFindSection = createCollapsibleSection(
                '',
                `Rare Finds: ${rareFindRevenueLabel} (${rareFinds.length} item${rareFinds.length !== 1 ? 's' : ''}, ${rareFindSummary})`,
                null,
                rareFindContent,
                false,
                1
            );
        }

        revenueDiv.appendChild(primaryDropsSection);
        if (essenceSection) {
            revenueDiv.appendChild(essenceSection);
        }
        if (rareFindSection) {
            revenueDiv.appendChild(rareFindSection);
        }

        // Costs Section
        const costsDiv = document.createElement('div');
        const costsLabel = costsMissing ? '-- ⚠' : formatLargeNumber(totalCosts);
        costsDiv.innerHTML = `<div style="font-weight: 500; color: ${config$1.COLOR_TOOLTIP_LOSS}; margin-top: 12px; margin-bottom: 4px;">Costs: ${costsLabel}</div>`;

        // Drink Costs subsection
        const drinkCostsContent = document.createElement('div');
        if (profitData.drinkCosts && profitData.drinkCosts.length > 0) {
            for (const drink of profitData.drinkCosts) {
                const totalDrinks = drink.drinksPerHour * hoursNeeded;
                const totalCostLine = drink.costPerHour * hoursNeeded;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const missingPriceNote = getMissingPriceIndicator(drink.missingPrice);
                line.textContent = `• ${drink.name}: ${totalDrinks.toFixed(1)} drinks @ ${formatWithSeparator(drink.priceEach)}${missingPriceNote} → ${formatLargeNumber(Math.round(totalCostLine))}`;
                drinkCostsContent.appendChild(line);
            }
        }

        const drinkCount = profitData.drinkCosts?.length || 0;
        const drinkCostsLabel = drinkCostsMissing ? '-- ⚠' : formatLargeNumber(totalDrinkCosts);
        const drinkCostsSection = createCollapsibleSection(
            '',
            `Drink Costs: ${drinkCostsLabel} (${drinkCount} drink${drinkCount !== 1 ? 's' : ''})`,
            null,
            drinkCostsContent,
            false,
            1
        );

        costsDiv.appendChild(drinkCostsSection);

        // Market Tax subsection
        const marketTaxContent = document.createElement('div');
        const marketTaxLine = document.createElement('div');
        marketTaxLine.style.marginLeft = '8px';
        const marketTaxLabel = marketTaxMissing ? '-- ⚠' : formatLargeNumber(totalMarketTax);
        marketTaxLine.textContent = `• Market Tax: 2% of revenue → ${marketTaxLabel}`;
        marketTaxContent.appendChild(marketTaxLine);

        const marketTaxHeader = marketTaxMissing ? '-- ⚠' : formatLargeNumber(totalMarketTax);
        const marketTaxSection = createCollapsibleSection(
            '',
            `Market Tax: ${marketTaxHeader} (2%)`,
            null,
            marketTaxContent,
            false,
            1
        );

        costsDiv.appendChild(marketTaxSection);

        // Assemble breakdown
        detailsContent.appendChild(revenueDiv);
        detailsContent.appendChild(costsDiv);

        // Add Net Profit at top
        const topLevelContent = document.createElement('div');
        const profitColor = netMissing ? config$1.SCRIPT_COLOR_ALERT : totalProfit >= 0 ? '#4ade80' : config$1.COLOR_LOSS;
        const netProfitLine = document.createElement('div');
        netProfitLine.style.cssText = `
        font-weight: 500;
        color: ${profitColor};
        margin-bottom: 8px;
    `;
        netProfitLine.textContent = netMissing ? 'Net Profit: -- ⚠' : `Net Profit: ${formatLargeNumber(totalProfit)}`;
        topLevelContent.appendChild(netProfitLine);

        const actionsSummary = `Revenue: ${formatMissingLabel(revenueMissing, formatLargeNumber(totalRevenue))} | Costs: ${formatMissingLabel(
        costsMissing,
        formatLargeNumber(totalCosts)
    )}`;
        const actionsBreakdownSection = createCollapsibleSection('', actionsSummary, null, detailsContent, false, 1);
        topLevelContent.appendChild(actionsBreakdownSection);

        const mainSection = createCollapsibleSection(
            '📋',
            `${formatWithSeparator(actionsCount)} actions breakdown`,
            null,
            topLevelContent,
            false,
            0
        );
        mainSection.className = 'mwi-collapsible-section mwi-actions-breakdown';

        return mainSection;
    }

    /**
     * Build "X actions breakdown" section for production actions
     * @param {Object} profitData - Profit calculation data
     * @param {number} actionsCount - Number of actions from input field
     * @returns {HTMLElement} Breakdown section element
     */
    function buildProductionActionsBreakdown(profitData, actionsCount) {
        // Calculate queued actions breakdown
        const outputMissing = profitData.outputPriceMissing || false;
        const bonusMissing = profitData.bonusRevenue?.hasMissingPrices || false;
        const materialMissing = profitData.materialCosts?.some((material) => material.missingPrice) || false;
        const teaMissing = profitData.teaCosts?.some((tea) => tea.missingPrice) || false;
        const revenueMissing = outputMissing || bonusMissing;
        const costsMissing = materialMissing || teaMissing || revenueMissing;
        const marketTaxMissing = revenueMissing;
        const netMissing = profitData.hasMissingPrices;
        const bonusDrops = profitData.bonusRevenue?.bonusDrops || [];
        const totals = calculateProductionActionTotalsFromBase({
            actionsCount,
            actionsPerHour: profitData.actionsPerHour,
            outputAmount: profitData.outputAmount || 1,
            outputPrice: profitData.outputPrice,
            gourmetBonus: profitData.gourmetBonus || 0,
            bonusDrops,
            materialCosts: profitData.materialCosts,
            totalTeaCostPerHour: profitData.totalTeaCostPerHour,
            efficiencyMultiplier: profitData.efficiencyMultiplier || 1,
        });
        const totalRevenue = Math.round(totals.totalRevenue);
        const totalMarketTax = Math.round(totals.totalMarketTax);
        const totalCosts = Math.round(totals.totalCosts);
        const totalProfit = Math.round(totals.totalProfit);

        const detailsContent = document.createElement('div');

        // Revenue Section
        const revenueDiv = document.createElement('div');
        const revenueLabel = formatMissingLabel(revenueMissing, formatLargeNumber(totalRevenue));
        revenueDiv.innerHTML = `<div style="font-weight: 500; color: ${config$1.COLOR_TOOLTIP_PROFIT}; margin-bottom: 4px;">Revenue: ${revenueLabel}</div>`;

        // Primary Outputs subsection
        const primaryOutputContent = document.createElement('div');
        const totalBaseItems = totals.totalBaseItems;
        const totalBaseRevenue = totals.totalBaseRevenue;
        const baseOutputLine = document.createElement('div');
        baseOutputLine.style.marginLeft = '8px';
        const baseOutputMissingNote = getMissingPriceIndicator(profitData.outputPriceMissing);
        baseOutputLine.textContent = `• ${profitData.itemName} (Base): ${totalBaseItems.toFixed(1)} items @ ${formatWithSeparator(Math.round(profitData.outputPrice))}${baseOutputMissingNote} each → ${formatLargeNumber(Math.round(totalBaseRevenue))}`;
        primaryOutputContent.appendChild(baseOutputLine);

        if (profitData.gourmetBonus > 0) {
            const totalGourmetItems = totals.totalGourmetItems;
            const totalGourmetRevenue = totals.totalGourmetRevenue;
            const gourmetLine = document.createElement('div');
            gourmetLine.style.marginLeft = '8px';
            gourmetLine.textContent = `• ${profitData.itemName} (Gourmet +${formatPercentage(profitData.gourmetBonus, 1)}): ${totalGourmetItems.toFixed(1)} items @ ${formatWithSeparator(Math.round(profitData.outputPrice))}${baseOutputMissingNote} each → ${formatLargeNumber(Math.round(totalGourmetRevenue))}`;
            primaryOutputContent.appendChild(gourmetLine);
        }

        const primaryRevenue = totals.totalBaseRevenue + totals.totalGourmetRevenue;
        const primaryOutputLabel = formatMissingLabel(outputMissing, formatLargeNumber(Math.round(primaryRevenue)));
        const gourmetLabel =
            profitData.gourmetBonus > 0 ? ` (${formatPercentage(profitData.gourmetBonus, 1)} gourmet)` : '';
        const primaryOutputSection = createCollapsibleSection(
            '',
            `Primary Outputs: ${primaryOutputLabel}${gourmetLabel}`,
            null,
            primaryOutputContent,
            false,
            1
        );

        revenueDiv.appendChild(primaryOutputSection);

        // Bonus Drops subsections
        const essenceDrops = bonusDrops.filter((drop) => drop.type === 'essence');
        const rareFinds = bonusDrops.filter((drop) => drop.type === 'rare_find');

        // Essence Drops subsection
        let essenceSection = null;
        if (essenceDrops.length > 0) {
            const essenceContent = document.createElement('div');
            for (const drop of essenceDrops) {
                const dropsPerAction =
                    drop.dropsPerAction ?? calculateProfitPerAction(drop.dropsPerHour, profitData.actionsPerHour);
                const revenuePerAction =
                    drop.revenuePerAction ?? calculateProfitPerAction(drop.revenuePerHour, profitData.actionsPerHour);
                const totalDrops = dropsPerAction * actionsCount;
                const totalRevenueLine = revenuePerAction * actionsCount;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);
                line.textContent = `• ${drop.itemName}: ${totalDrops.toFixed(2)} drops (${dropRatePct}) → ${formatLargeNumber(Math.round(totalRevenueLine))}`;
                essenceContent.appendChild(line);
            }

            const essenceRevenue = essenceDrops.reduce((sum, drop) => {
                const revenuePerAction =
                    drop.revenuePerAction ?? calculateProfitPerAction(drop.revenuePerHour, profitData.actionsPerHour);
                return sum + revenuePerAction * actionsCount;
            }, 0);
            const essenceRevenueLabel = formatMissingLabel(bonusMissing, formatLargeNumber(Math.round(essenceRevenue)));
            const essenceFindBonus = profitData.bonusRevenue?.essenceFindBonus || 0;
            essenceSection = createCollapsibleSection(
                '',
                `Essence Drops: ${essenceRevenueLabel} (${essenceDrops.length} item${essenceDrops.length !== 1 ? 's' : ''}, ${essenceFindBonus.toFixed(1)}% essence find)`,
                null,
                essenceContent,
                false,
                1
            );
        }

        // Rare Finds subsection
        let rareFindSection = null;
        if (rareFinds.length > 0) {
            const rareFindContent = document.createElement('div');
            for (const drop of rareFinds) {
                const dropsPerAction =
                    drop.dropsPerAction ?? calculateProfitPerAction(drop.dropsPerHour, profitData.actionsPerHour);
                const revenuePerAction =
                    drop.revenuePerAction ?? calculateProfitPerAction(drop.revenuePerHour, profitData.actionsPerHour);
                const totalDrops = dropsPerAction * actionsCount;
                const totalRevenueLine = revenuePerAction * actionsCount;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);
                line.textContent = `• ${drop.itemName}: ${totalDrops.toFixed(2)} drops (${dropRatePct}) → ${formatLargeNumber(Math.round(totalRevenueLine))}`;
                rareFindContent.appendChild(line);
            }

            const rareFindRevenue = rareFinds.reduce((sum, drop) => {
                const revenuePerAction =
                    drop.revenuePerAction ?? calculateProfitPerAction(drop.revenuePerHour, profitData.actionsPerHour);
                return sum + revenuePerAction * actionsCount;
            }, 0);
            const rareFindRevenueLabel = formatMissingLabel(bonusMissing, formatLargeNumber(Math.round(rareFindRevenue)));
            const rareFindSummary = formatRareFindBonusSummary(profitData.bonusRevenue);
            rareFindSection = createCollapsibleSection(
                '',
                `Rare Finds: ${rareFindRevenueLabel} (${rareFinds.length} item${rareFinds.length !== 1 ? 's' : ''}, ${rareFindSummary})`,
                null,
                rareFindContent,
                false,
                1
            );
        }

        if (essenceSection) {
            revenueDiv.appendChild(essenceSection);
        }
        if (rareFindSection) {
            revenueDiv.appendChild(rareFindSection);
        }

        // Costs Section
        const costsDiv = document.createElement('div');
        const costsLabel = costsMissing ? '-- ⚠' : formatLargeNumber(totalCosts);
        costsDiv.innerHTML = `<div style="font-weight: 500; color: ${config$1.COLOR_TOOLTIP_LOSS}; margin-top: 12px; margin-bottom: 4px;">Costs: ${costsLabel}</div>`;

        // Material Costs subsection
        const materialCostsContent = document.createElement('div');
        if (profitData.materialCosts && profitData.materialCosts.length > 0) {
            for (const material of profitData.materialCosts) {
                const totalMaterial = material.amount * actionsCount;
                const totalMaterialCost = material.totalCost * actionsCount;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';

                let materialText = `• ${material.itemName}: ${totalMaterial.toFixed(1)} items`;

                // Add Artisan reduction info if present
                if (profitData.artisanBonus > 0 && material.baseAmount && material.amount !== material.baseAmount) {
                    const baseTotalAmount = material.baseAmount * actionsCount;
                    materialText += ` (${baseTotalAmount.toFixed(1)} base -${formatPercentage(profitData.artisanBonus, 1)} 🍵)`;
                }

                const missingPriceNote = getMissingPriceIndicator(material.missingPrice);
                materialText += ` @ ${formatWithSeparator(Math.round(material.askPrice))}${missingPriceNote} → ${formatLargeNumber(Math.round(totalMaterialCost))}`;

                line.textContent = materialText;
                materialCostsContent.appendChild(line);
            }
        }

        const totalMaterialCost = totals.totalMaterialCost;
        const materialCostsLabel = formatMissingLabel(materialMissing, formatLargeNumber(Math.round(totalMaterialCost)));
        const materialCostsSection = createCollapsibleSection(
            '',
            `Material Costs: ${materialCostsLabel} (${profitData.materialCosts?.length || 0} material${profitData.materialCosts?.length !== 1 ? 's' : ''})`,
            null,
            materialCostsContent,
            false,
            1
        );

        // Tea Costs subsection
        const teaCostsContent = document.createElement('div');
        if (profitData.teaCosts && profitData.teaCosts.length > 0) {
            for (const tea of profitData.teaCosts) {
                const totalDrinks = tea.drinksPerHour * totals.hoursNeeded;
                const totalTeaCost = tea.totalCost * totals.hoursNeeded;
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                const missingPriceNote = getMissingPriceIndicator(tea.missingPrice);
                line.textContent = `• ${tea.itemName}: ${totalDrinks.toFixed(1)} drinks @ ${formatWithSeparator(Math.round(tea.pricePerDrink))}${missingPriceNote} → ${formatLargeNumber(Math.round(totalTeaCost))}`;
                teaCostsContent.appendChild(line);
            }
        }

        const totalTeaCost = totals.totalTeaCost;
        const teaCount = profitData.teaCosts?.length || 0;
        const teaCostsLabel = formatMissingLabel(teaMissing, formatLargeNumber(Math.round(totalTeaCost)));
        const teaCostsSection = createCollapsibleSection(
            '',
            `Drink Costs: ${teaCostsLabel} (${teaCount} drink${teaCount !== 1 ? 's' : ''})`,
            null,
            teaCostsContent,
            false,
            1
        );

        costsDiv.appendChild(materialCostsSection);
        costsDiv.appendChild(teaCostsSection);

        // Market Tax subsection
        const marketTaxContent = document.createElement('div');
        const marketTaxLine = document.createElement('div');
        marketTaxLine.style.marginLeft = '8px';
        const marketTaxLabel = marketTaxMissing ? '-- ⚠' : formatLargeNumber(totalMarketTax);
        marketTaxLine.textContent = `• Market Tax: 2% of revenue → ${marketTaxLabel}`;
        marketTaxContent.appendChild(marketTaxLine);

        const marketTaxHeader = marketTaxMissing ? '-- ⚠' : formatLargeNumber(totalMarketTax);
        const marketTaxSection = createCollapsibleSection(
            '',
            `Market Tax: ${marketTaxHeader} (2%)`,
            null,
            marketTaxContent,
            false,
            1
        );

        costsDiv.appendChild(marketTaxSection);

        // Assemble breakdown
        detailsContent.appendChild(revenueDiv);
        detailsContent.appendChild(costsDiv);

        // Add Net Profit at top
        const topLevelContent = document.createElement('div');
        const profitColor = netMissing ? config$1.SCRIPT_COLOR_ALERT : totalProfit >= 0 ? '#4ade80' : config$1.COLOR_LOSS;
        const netProfitLine = document.createElement('div');
        netProfitLine.style.cssText = `
        font-weight: 500;
        color: ${profitColor};
        margin-bottom: 8px;
    `;
        netProfitLine.textContent = netMissing ? 'Net Profit: -- ⚠' : `Net Profit: ${formatLargeNumber(totalProfit)}`;
        topLevelContent.appendChild(netProfitLine);

        const actionsSummary = `Revenue: ${formatMissingLabel(revenueMissing, formatLargeNumber(totalRevenue))} | Costs: ${formatMissingLabel(
        costsMissing,
        formatLargeNumber(totalCosts)
    )}`;
        const actionsBreakdownSection = createCollapsibleSection('', actionsSummary, null, detailsContent, false, 1);
        topLevelContent.appendChild(actionsBreakdownSection);

        const mainSection = createCollapsibleSection(
            '📋',
            `${formatWithSeparator(actionsCount)} actions breakdown`,
            null,
            topLevelContent,
            false,
            0
        );
        mainSection.className = 'mwi-collapsible-section mwi-actions-breakdown';

        return mainSection;
    }

    /**
     * Action Panel Observer
     *
     * Detects when action panels appear and enhances them with:
     * - Gathering profit calculations (Foraging, Woodcutting, Milking)
     * - Production profit calculations (Brewing, Cooking, Crafting, Tailoring, Cheesesmithing)
     * - Other action panel enhancements (future)
     *
     * Automatically filters out combat action panels.
     */


    /**
     * Action types for gathering skills (3 skills)
     */
    const GATHERING_TYPES$1 = ['/action_types/foraging', '/action_types/woodcutting', '/action_types/milking'];

    /**
     * Action types for production skills (5 skills)
     */
    const PRODUCTION_TYPES$2 = [
        '/action_types/brewing',
        '/action_types/cooking',
        '/action_types/cheesesmithing',
        '/action_types/crafting',
        '/action_types/tailoring',
    ];

    /**
     * Debounced update tracker for enhancement calculations
     * Maps itemHrid to timeout ID
     */
    const updateTimeouts = new Map();
    const timerRegistry$2 = createTimerRegistry();

    /**
     * Event handler debounce timers
     */
    let itemsUpdatedDebounceTimer = null;
    let consumablesUpdatedDebounceTimer = null;
    const DEBOUNCE_DELAY = 300; // 300ms debounce for event handlers
    const observedEnhancingPanels = new WeakSet();
    let itemsUpdatedHandler = null;
    let consumablesUpdatedHandler = null;

    /**
     * Trigger debounced enhancement stats update
     * @param {HTMLElement} panel - Enhancing panel element
     * @param {string} itemHrid - Item HRID
     */
    function triggerEnhancementUpdate(panel, itemHrid) {
        // Clear existing timeout for this item
        if (updateTimeouts.has(itemHrid)) {
            clearTimeout(updateTimeouts.get(itemHrid));
        }

        // Set new timeout
        const timeoutId = setTimeout(async () => {
            await displayEnhancementStats(panel, itemHrid);
            updateTimeouts.delete(itemHrid);
        }, 500); // Wait 500ms after last change

        timerRegistry$2.registerTimeout(timeoutId);

        updateTimeouts.set(itemHrid, timeoutId);
    }

    /**
     * CSS selectors for action panel detection
     */
    const SELECTORS = {
        REGULAR_PANEL: 'div.SkillActionDetail_regularComponent__3oCgr',
        ENHANCING_PANEL: 'div.SkillActionDetail_enhancingComponent__17bOx',
        EXP_GAIN: 'div.SkillActionDetail_expGain__F5xHu',
        ACTION_NAME: 'div.SkillActionDetail_name__3erHV',
        DROP_TABLE: 'div.SkillActionDetail_dropTable__3ViVp',
        ENHANCING_OUTPUT: 'div.SkillActionDetail_enhancingOutput__VPHbY', // Outputs container
        ITEM_NAME: 'div.Item_name__2C42x', // Item name (without +1)
    };

    /**
     * Initialize action panel observer
     * Sets up MutationObserver on document.body to watch for action panels
     */
    function initActionPanelObserver() {
        setupMutationObserver();

        // Check for existing enhancing panel (may already be on page)
        checkExistingEnhancingPanel();

        // Listen for equipment and consumable changes to refresh enhancement calculator
        setupEnhancementRefreshListeners();
    }

    /**
     * Set up MutationObserver to detect action panels
     */
    function setupMutationObserver() {
        domObserver$1.onClass(
            'ActionPanelObserver-Modal',
            'Modal_modalContainer__3B80m',
            (modal) => {
                const panel = modal.querySelector(SELECTORS.REGULAR_PANEL);
                if (panel) {
                    handleActionPanel(panel);
                }
            }
        );

        domObserver$1.onClass(
            'ActionPanelObserver-Enhancing',
            'SkillActionDetail_enhancingComponent__17bOx',
            (panel) => {
                handleEnhancingPanel(panel);
                registerEnhancingPanelWatcher(panel);
            }
        );
    }

    /**
     * Set up listeners for equipment and consumable changes
     * Refreshes enhancement calculator when gear or teas change
     */
    function setupEnhancementRefreshListeners() {
        // Listen for equipment changes (equipping/unequipping items) with debouncing
        if (!itemsUpdatedHandler) {
            itemsUpdatedHandler = () => {
                clearTimeout(itemsUpdatedDebounceTimer);
                itemsUpdatedDebounceTimer = setTimeout(() => {
                    refreshEnhancementCalculator();
                }, DEBOUNCE_DELAY);
            };
            dataManager$1.on('items_updated', itemsUpdatedHandler);
        }

        // Listen for consumable changes (drinking teas) with debouncing
        if (!consumablesUpdatedHandler) {
            consumablesUpdatedHandler = () => {
                clearTimeout(consumablesUpdatedDebounceTimer);
                consumablesUpdatedDebounceTimer = setTimeout(() => {
                    refreshEnhancementCalculator();
                }, DEBOUNCE_DELAY);
            };
            dataManager$1.on('consumables_updated', consumablesUpdatedHandler);
        }
    }

    /**
     * Refresh enhancement calculator if panel is currently visible
     */
    function refreshEnhancementCalculator() {
        const panel = document.querySelector(SELECTORS.ENHANCING_PANEL);
        if (!panel) return; // Not on enhancing panel, skip

        const itemHrid = panel.dataset.mwiItemHrid;
        if (!itemHrid) return; // No item detected yet, skip

        // Trigger debounced update
        triggerEnhancementUpdate(panel, itemHrid);
    }

    /**
     * Check for existing enhancing panel on page load
     * The enhancing panel may already exist when MWI Tools initializes
     */
    function checkExistingEnhancingPanel() {
        // Wait a moment for page to settle
        const checkTimeout = setTimeout(() => {
            const existingPanel = document.querySelector(SELECTORS.ENHANCING_PANEL);
            if (existingPanel) {
                handleEnhancingPanel(existingPanel);
                registerEnhancingPanelWatcher(existingPanel);
            }
        }, 500);
        timerRegistry$2.registerTimeout(checkTimeout);
    }

    /**
     * Register a mutation watcher for enhancing panels
     * @param {HTMLElement} panel - Enhancing panel element
     */
    function registerEnhancingPanelWatcher(panel) {
        if (!panel || observedEnhancingPanels.has(panel)) {
            return;
        }

        createMutationWatcher(
            panel,
            (mutations) => {
                handleEnhancingPanelMutations(panel, mutations);
            },
            {
                childList: true,
                subtree: true,
                attributes: true,
                attributeOldValue: true,
            }
        );

        observedEnhancingPanels.add(panel);
    }

    /**
     * Handle mutations within an enhancing panel
     * @param {HTMLElement} panel - Enhancing panel element
     * @param {MutationRecord[]} mutations - Mutation records
     */
    function handleEnhancingPanelMutations(panel, mutations) {
        for (const mutation of mutations) {
            if (mutation.type === 'attributes') {
                if (mutation.attributeName === 'value' && mutation.target.tagName === 'INPUT') {
                    const itemHrid = panel.dataset.mwiItemHrid;
                    if (itemHrid) {
                        triggerEnhancementUpdate(panel, itemHrid);
                    }
                }

                if (mutation.attributeName === 'href' && mutation.target.tagName === 'use') {
                    handleEnhancingPanel(panel);
                }
            }

            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach((addedNode) => {
                    if (addedNode.nodeType !== Node.ELEMENT_NODE) return;

                    if (
                        addedNode.classList?.contains('SkillActionDetail_enhancingOutput__VPHbY') ||
                        (addedNode.querySelector && addedNode.querySelector(SELECTORS.ENHANCING_OUTPUT))
                    ) {
                        handleEnhancingPanel(panel);
                    }

                    if (
                        addedNode.classList?.contains('SkillActionDetail_item__2vEAz') ||
                        addedNode.classList?.contains('Item_name__2C42x')
                    ) {
                        handleEnhancingPanel(panel);
                    }

                    if (addedNode.tagName === 'INPUT' && (addedNode.type === 'number' || addedNode.type === 'text')) {
                        const itemHrid = panel.dataset.mwiItemHrid;
                        if (itemHrid) {
                            addInputListener(addedNode, panel, itemHrid);
                        }
                    }
                });
            }
        }
    }

    /**
     * Handle action panel appearance (gathering/crafting/production)
     * @param {HTMLElement} panel - Action panel element
     */
    async function handleActionPanel(panel) {
        if (!panel) return;

        // Filter out combat action panels (they don't have XP gain display)
        const expGainElement = panel.querySelector(SELECTORS.EXP_GAIN);
        if (!expGainElement) return; // Combat panel, skip

        // Get action name
        const actionNameElement = panel.querySelector(SELECTORS.ACTION_NAME);
        if (!actionNameElement) return;

        const actionName = getOriginalText(actionNameElement);
        const actionHrid = getActionHridFromName$1(actionName);
        if (!actionHrid) return;

        const gameData = dataManager$1.getInitClientData();
        const actionDetail = gameData.actionDetailMap[actionHrid];
        if (!actionDetail) return;

        // Check if this is a gathering action
        if (GATHERING_TYPES$1.includes(actionDetail.type)) {
            const dropTableElement = panel.querySelector(SELECTORS.DROP_TABLE);
            if (dropTableElement) {
                await displayGatheringProfit(panel, actionHrid, SELECTORS.DROP_TABLE);
            }
        }

        // Check if this is a production action
        if (PRODUCTION_TYPES$2.includes(actionDetail.type)) {
            const dropTableElement = panel.querySelector(SELECTORS.DROP_TABLE);
            if (dropTableElement) {
                await displayProductionProfit(panel, actionHrid, SELECTORS.DROP_TABLE);
            }
        }
    }

    /**
     * Find and cache the Current Action tab button
     * @param {HTMLElement} panel - Enhancing panel element
     * @returns {HTMLButtonElement|null} Current Action tab button or null
     */
    function getCurrentActionTabButton(panel) {
        // Check if we already cached it
        if (panel._cachedCurrentActionTab) {
            return panel._cachedCurrentActionTab;
        }

        // Walk up the DOM to find tab buttons (only once)
        let current = panel;
        let depth = 0;
        const maxDepth = 5;

        while (current && depth < maxDepth) {
            const buttons = Array.from(current.querySelectorAll('button[role="tab"]'));
            const currentActionTab = buttons.find((btn) => btn.textContent.trim() === 'Current Action');

            if (currentActionTab) {
                // Cache it on the panel for future lookups
                panel._cachedCurrentActionTab = currentActionTab;
                return currentActionTab;
            }

            current = current.parentElement;
            depth++;
        }

        return null;
    }

    /**
     * Check if we're on the "Enhance" tab (not "Current Action" tab)
     * @param {HTMLElement} panel - Enhancing panel element
     * @returns {boolean} True if on Enhance tab
     */
    function isEnhanceTabActive(panel) {
        // Get cached tab button (DOM query happens only once per panel)
        const currentActionTab = getCurrentActionTabButton(panel);

        if (!currentActionTab) {
            // No Current Action tab found, show calculator
            return true;
        }

        // Fast checks: just 3 property accesses (no DOM queries)
        if (currentActionTab.getAttribute('aria-selected') === 'true') {
            return false; // Current Action is active
        }

        if (currentActionTab.classList.contains('Mui-selected')) {
            return false;
        }

        if (currentActionTab.getAttribute('tabindex') === '0') {
            return false;
        }

        // Enhance tab is active
        return true;
    }

    /**
     * Handle enhancing panel appearance
     * @param {HTMLElement} panel - Enhancing panel element
     */
    async function handleEnhancingPanel(panel) {
        if (!panel) return;

        // Set up tab click listeners (only once per panel)
        if (!panel.dataset.mwiTabListenersAdded) {
            setupTabClickListeners(panel);
            panel.dataset.mwiTabListenersAdded = 'true';
        }

        // Only show calculator on "Enhance" tab, not "Current Action" tab
        if (!isEnhanceTabActive(panel)) {
            // Remove calculator if it exists
            const existingDisplay = panel.querySelector('#mwi-enhancement-stats');
            if (existingDisplay) {
                existingDisplay.remove();
            }
            return;
        }

        // Find the output element that shows the enhanced item
        const outputsSection = panel.querySelector(SELECTORS.ENHANCING_OUTPUT);
        if (!outputsSection) {
            return;
        }

        // Check if there's actually an item selected (not just placeholder)
        // When no item is selected, the outputs section exists but has no item icon
        const itemIcon = outputsSection.querySelector('svg[role="img"], img');
        if (!itemIcon) {
            // No item icon = no item selected, don't show calculator
            // Remove existing calculator display if present
            const existingDisplay = panel.querySelector('#mwi-enhancement-stats');
            if (existingDisplay) {
                existingDisplay.remove();
            }
            return;
        }

        // Get the item name from the Item_name element (without +1)
        const itemNameElement = outputsSection.querySelector(SELECTORS.ITEM_NAME);
        if (!itemNameElement) {
            return;
        }

        const itemName = itemNameElement.textContent.trim();

        if (!itemName) {
            return;
        }

        // Find the item HRID from the name
        const gameData = dataManager$1.getInitClientData();
        const itemHrid = getItemHridFromName(itemName, gameData);

        if (!itemHrid) {
            return;
        }

        // Get item details
        const itemDetails = gameData.itemDetailMap[itemHrid];
        if (!itemDetails) return;

        // Store itemHrid on panel for later reference (when new inputs are added)
        panel.dataset.mwiItemHrid = itemHrid;

        // Double-check tab state right before rendering (safety check for race conditions)
        if (!isEnhanceTabActive(panel)) {
            // Current Action tab became active during processing, don't render
            return;
        }

        // Display enhancement stats using the item HRID directly
        await displayEnhancementStats(panel, itemHrid);

        // Set up observers for Target Level and Protect From Level inputs
        setupInputObservers(panel, itemHrid);
    }

    /**
     * Set up click listeners on tab buttons to show/hide calculator
     * @param {HTMLElement} panel - Enhancing panel element
     */
    function setupTabClickListeners(panel) {
        // Walk up the DOM to find tab buttons
        let current = panel;
        let depth = 0;
        const maxDepth = 5;

        let tabButtons = [];

        while (current && depth < maxDepth) {
            const buttons = Array.from(current.querySelectorAll('button[role="tab"]'));
            const foundTabs = buttons.filter((btn) => {
                const text = btn.textContent.trim();
                return text === 'Enhance' || text === 'Current Action';
            });

            if (foundTabs.length === 2) {
                tabButtons = foundTabs;
                break;
            }

            current = current.parentElement;
            depth++;
        }

        if (tabButtons.length !== 2) {
            return; // Can't find tabs, skip listener setup
        }

        // Add click listeners to both tabs
        tabButtons.forEach((button) => {
            button.addEventListener('click', async () => {
                // Small delay to let the tab change take effect
                const tabTimeout = setTimeout(async () => {
                    const isEnhanceActive = isEnhanceTabActive(panel);
                    const existingDisplay = panel.querySelector('#mwi-enhancement-stats');

                    if (!isEnhanceActive) {
                        // Current Action tab clicked - remove calculator
                        if (existingDisplay) {
                            existingDisplay.remove();
                        }
                    } else {
                        // Enhance tab clicked - show calculator if item is selected
                        const itemHrid = panel.dataset.mwiItemHrid;
                        if (itemHrid && !existingDisplay) {
                            // Re-render calculator
                            await displayEnhancementStats(panel, itemHrid);
                        }
                    }
                }, 100);
                timerRegistry$2.registerTimeout(tabTimeout);
            });
        });
    }

    /**
     * Add input listener to a single input element
     * @param {HTMLInputElement} input - Input element
     * @param {HTMLElement} panel - Enhancing panel element
     * @param {string} itemHrid - Item HRID
     */
    function addInputListener(input, panel, itemHrid) {
        // Handler that triggers the shared debounced update
        const handleInputChange = () => {
            triggerEnhancementUpdate(panel, itemHrid);
        };

        // Add change listeners
        input.addEventListener('input', handleInputChange);
        input.addEventListener('change', handleInputChange);
    }

    /**
     * Set up observers for Target Level and Protect From Level inputs
     * Re-calculates enhancement stats when user changes these values
     * @param {HTMLElement} panel - Enhancing panel element
     * @param {string} itemHrid - Item HRID
     */
    function setupInputObservers(panel, itemHrid) {
        // Find all input elements in the panel
        const inputs = panel.querySelectorAll('input[type="number"], input[type="text"]');

        // Add listeners to all existing inputs
        inputs.forEach((input) => {
            addInputListener(input, panel, itemHrid);
        });
    }

    /**
     * Convert action name to HRID
     * @param {string} actionName - Display name of action
     * @returns {string|null} Action HRID or null if not found
     */
    function getActionHridFromName$1(actionName) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData?.actionDetailMap) {
            return null;
        }

        // Search for action by name
        for (const [hrid, detail] of Object.entries(gameData.actionDetailMap)) {
            if (detail.name === actionName) {
                return hrid;
            }
        }

        return null;
    }

    /**
     * Convert item name to HRID
     * @param {string} itemName - Display name of item
     * @param {Object} gameData - Game data from dataManager
     * @returns {string|null} Item HRID or null if not found
     */
    function getItemHridFromName(itemName, gameData) {
        if (!gameData?.itemDetailMap) {
            return null;
        }

        // Search for item by name
        for (const [hrid, detail] of Object.entries(gameData.itemDetailMap)) {
            if (detail.name === itemName) {
                return hrid;
            }
        }

        return null;
    }

    /**
     * Action Time Display Module
     *
     * Displays estimated completion time for queued actions.
     * Uses WebSocket data from data-manager instead of DOM scraping.
     *
     * Features:
     * - Appends stats to game's action name (queue count, time/action, actions/hr)
     * - Shows time estimates below (total time → completion time)
     * - Updates automatically on action changes
     * - Queue tooltip enhancement (time for each action + total)
     */


    /**
     * ActionTimeDisplay class manages the time display panel and queue tooltips
     */
    class ActionTimeDisplay {
        constructor() {
            this.displayElement = null;
            this.isInitialized = false;
            this.updateTimer = null;
            this.unregisterQueueObserver = null;
            this.actionNameObserver = null;
            this.queueMenuObserver = null; // Observer for queue menu mutations
            this.unregisterActionNameObserver = null;
            this.characterInitHandler = null; // Handler for character switch
            this.activeProfitCalculationId = null; // Track active profit calculation to prevent race conditions
            this.waitForPanelTimeout = null;
            this.retryUpdateTimeout = null;
            this.cleanupRegistry = createCleanupRegistry();
        }

        /**
         * Initialize the action time display
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            const enabled = config$1.getSettingValue('totalActionTime', true);
            if (!enabled) {
                return;
            }

            // Set up handler for character switching
            if (!this.characterInitHandler) {
                this.characterInitHandler = () => {
                    this.handleCharacterSwitch();
                };
                dataManager$1.on('character_initialized', this.characterInitHandler);
                this.cleanupRegistry.registerCleanup(() => {
                    if (this.characterInitHandler) {
                        dataManager$1.off('character_initialized', this.characterInitHandler);
                        this.characterInitHandler = null;
                    }
                });
            }

            this.cleanupRegistry.registerCleanup(() => {
                const actionNameElement = document.querySelector('div[class*="Header_actionName"]');
                if (actionNameElement) {
                    this.clearAppendedStats(actionNameElement);
                }
            });

            this.cleanupRegistry.registerCleanup(() => {
                if (this.waitForPanelTimeout) {
                    clearTimeout(this.waitForPanelTimeout);
                    this.waitForPanelTimeout = null;
                }
            });

            this.cleanupRegistry.registerCleanup(() => {
                if (this.retryUpdateTimeout) {
                    clearTimeout(this.retryUpdateTimeout);
                    this.retryUpdateTimeout = null;
                }
            });

            this.cleanupRegistry.registerCleanup(() => {
                if (this.updateTimer) {
                    clearInterval(this.updateTimer);
                    this.updateTimer = null;
                }
            });

            this.cleanupRegistry.registerCleanup(() => {
                if (this.actionNameObserver) {
                    this.actionNameObserver();
                    this.actionNameObserver = null;
                }
            });

            this.cleanupRegistry.registerCleanup(() => {
                if (this.queueMenuObserver) {
                    this.queueMenuObserver();
                    this.queueMenuObserver = null;
                }
            });

            this.cleanupRegistry.registerCleanup(() => {
                if (this.unregisterActionNameObserver) {
                    this.unregisterActionNameObserver();
                    this.unregisterActionNameObserver = null;
                }
            });

            // Wait for action name element to exist
            this.waitForActionPanel();

            this.initializeActionNameWatcher();

            // Initialize queue tooltip observer
            this.initializeQueueObserver();

            this.isInitialized = true;
        }

        /**
         * Initialize observer for queue tooltip
         */
        initializeQueueObserver() {
            // Register with centralized DOM observer to watch for queue menu
            this.unregisterQueueObserver = domObserver$1.onClass(
                'ActionTimeDisplay-Queue',
                'QueuedActions_queuedActionsEditMenu',
                (queueMenu) => {
                    this.injectQueueTimes(queueMenu);

                    this.setupQueueMenuObserver(queueMenu);
                }
            );

            this.cleanupRegistry.registerCleanup(() => {
                if (this.unregisterQueueObserver) {
                    this.unregisterQueueObserver();
                    this.unregisterQueueObserver = null;
                }
            });
        }

        /**
         * Initialize observer for action name element replacement
         */
        initializeActionNameWatcher() {
            if (this.unregisterActionNameObserver) {
                return;
            }

            this.unregisterActionNameObserver = domObserver$1.onClass(
                'ActionTimeDisplay-ActionName',
                'Header_actionName',
                (actionNameElement) => {
                    if (!actionNameElement) {
                        return;
                    }

                    this.createDisplayPanel();
                    this.setupActionNameObserver(actionNameElement);
                    this.updateDisplay();
                }
            );
        }

        /**
         * Setup mutation observer for queue menu reordering
         * @param {HTMLElement} queueMenu - Queue menu container element
         */
        setupQueueMenuObserver(queueMenu) {
            if (!queueMenu) {
                return;
            }

            if (this.queueMenuObserver) {
                this.queueMenuObserver();
                this.queueMenuObserver = null;
            }

            this.queueMenuObserver = createMutationWatcher(
                queueMenu,
                () => {
                    // Disconnect to prevent infinite loop (our injection triggers mutations)
                    if (this.queueMenuObserver) {
                        this.queueMenuObserver();
                        this.queueMenuObserver = null;
                    }

                    // Queue DOM changed (reordering) - re-inject times
                    // NOTE: Reconnection happens inside injectQueueTimes after async completes
                    this.injectQueueTimes(queueMenu);
                },
                {
                    childList: true,
                    subtree: true,
                }
            );
        }

        /**
         * Handle character switch
         * Clean up old observers and re-initialize for new character's action panel
         */
        handleCharacterSwitch() {
            // Cancel any active profit calculations to prevent stale data
            this.activeProfitCalculationId = null;

            // Clear appended stats from old character's action panel (before it's removed)
            const oldActionNameElement = document.querySelector('div[class*="Header_actionName"]');
            if (oldActionNameElement) {
                this.clearAppendedStats(oldActionNameElement);
            }

            // Disconnect old action name observer (watching removed element)
            if (this.actionNameObserver) {
                this.actionNameObserver();
                this.actionNameObserver = null;
            }

            // Clear display element reference (already removed from DOM by game)
            this.displayElement = null;

            // Re-initialize action panel display for new character
            this.waitForActionPanel();
        }

        /**
         * Wait for action panel to exist in DOM
         */
        async waitForActionPanel() {
            // Try to find action name element (use wildcard for hash-suffixed class)
            const actionNameElement = document.querySelector('div[class*="Header_actionName"]');

            if (actionNameElement) {
                this.createDisplayPanel();
                this.setupActionNameObserver(actionNameElement);
                this.updateDisplay();
            } else {
                // Not found, try again in 200ms
                if (this.waitForPanelTimeout) {
                    clearTimeout(this.waitForPanelTimeout);
                }
                this.waitForPanelTimeout = setTimeout(() => {
                    this.waitForPanelTimeout = null;
                    this.waitForActionPanel();
                }, 200);
                this.cleanupRegistry.registerTimeout(this.waitForPanelTimeout);
            }
        }

        /**
         * Setup MutationObserver to watch action name changes
         * @param {HTMLElement} actionNameElement - The action name DOM element
         */
        setupActionNameObserver(actionNameElement) {
            // Watch for text content changes in the action name element
            this.actionNameObserver = createMutationWatcher(
                actionNameElement,
                () => {
                    this.updateDisplay();
                },
                {
                    childList: true,
                    characterData: true,
                    subtree: true,
                }
            );
        }

        /**
         * Create the display panel in the DOM
         */
        createDisplayPanel() {
            if (this.displayElement) {
                return; // Already created
            }

            // Find the action name container (use wildcard for hash-suffixed class)
            const actionNameContainer = document.querySelector('div[class*="Header_actionName"]');
            if (!actionNameContainer) {
                return;
            }

            // NOTE: Width overrides are now applied in updateDisplay() after we know if it's combat
            // This prevents HP/MP bar width issues when loading directly on combat actions

            // Create display element
            this.displayElement = document.createElement('div');
            this.displayElement.id = 'mwi-action-time-display';
            this.displayElement.style.cssText = `
            font-size: 0.9em;
            color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
            margin-top: 2px;
            line-height: 1.4;
            text-align: left;
            white-space: pre-wrap;
        `;

            // Insert after action name
            actionNameContainer.parentNode.insertBefore(this.displayElement, actionNameContainer.nextSibling);

            this.cleanupRegistry.registerCleanup(() => {
                if (this.displayElement && this.displayElement.parentNode) {
                    this.displayElement.parentNode.removeChild(this.displayElement);
                }
                this.displayElement = null;
            });
        }

        /**
         * Update the display with current action data
         */
        updateDisplay() {
            if (!this.displayElement) {
                return;
            }

            // Get current action - read from game UI which is always correct
            // The game updates the DOM immediately when actions change
            // Use wildcard selector to handle hash-suffixed class names
            const actionNameElement = document.querySelector('div[class*="Header_actionName"]');

            // CRITICAL: Disconnect observer before making changes to prevent infinite loop
            if (this.actionNameObserver) {
                this.actionNameObserver();
                this.actionNameObserver = null;
            }

            if (!actionNameElement || !actionNameElement.textContent) {
                this.displayElement.innerHTML = '';
                // Clear any appended stats from the game's div
                this.clearAppendedStats(actionNameElement);
                // Reconnect observer
                this.reconnectActionNameObserver(actionNameElement);
                return;
            }

            // Parse action name from DOM
            // Format can be: "Action Name (#123)", "Action Name (123)", "Action Name: Item (123)", etc.
            // First, strip any stats we previously appended
            const actionNameText = this.getCleanActionName(actionNameElement);

            // Check if no action is running ("Doing nothing...")
            if (actionNameText.includes('Doing nothing')) {
                this.displayElement.innerHTML = '';
                this.clearAppendedStats(actionNameElement);
                // Reconnect observer
                this.reconnectActionNameObserver(actionNameElement);
                return;
            }

            // Extract inventory count from parentheses (e.g., "Coinify: Item (4312)" -> 4312)
            const inventoryCountMatch = actionNameText.match(/\(([\d,]+)\)$/);
            const inventoryCount = inventoryCountMatch ? parseInt(inventoryCountMatch[1].replace(/,/g, ''), 10) : null;

            // Find the matching action in cache
            const cachedActions = dataManager$1.getCurrentActions();
            let action;

            // ONLY match against the first action (current action), not queued actions
            // This prevents showing stats from queued actions when party combat interrupts
            if (cachedActions.length > 0) {
                action = this.matchCurrentActionFromText(cachedActions, actionNameText);
            }

            if (!action) {
                this.displayElement.innerHTML = '';
                this.scheduleUpdateRetry();
                // Reconnect observer
                this.reconnectActionNameObserver(actionNameElement);
                return;
            }

            const actionDetails = dataManager$1.getActionDetails(action.actionHrid);
            if (!actionDetails) {
                // Reconnect observer
                this.reconnectActionNameObserver(actionNameElement);
                return;
            }

            // Skip combat actions - no time display for combat
            if (actionDetails.type === '/action_types/combat') {
                this.displayElement.innerHTML = '';
                this.clearAppendedStats(actionNameElement);

                // REMOVE CSS overrides for combat to restore normal HP/MP bar width
                actionNameElement.style.removeProperty('overflow');
                actionNameElement.style.removeProperty('text-overflow');
                actionNameElement.style.removeProperty('white-space');
                actionNameElement.style.removeProperty('max-width');
                actionNameElement.style.removeProperty('width');
                actionNameElement.style.removeProperty('min-width');

                // Remove from parent chain as well
                let parent = actionNameElement.parentElement;
                let levels = 0;
                while (parent && levels < 5) {
                    parent.style.removeProperty('overflow');
                    parent.style.removeProperty('text-overflow');
                    parent.style.removeProperty('white-space');
                    parent.style.removeProperty('max-width');
                    parent.style.removeProperty('width');
                    parent.style.removeProperty('min-width');
                    parent = parent.parentElement;
                    levels++;
                }

                this.reconnectActionNameObserver(actionNameElement);
                return;
            }

            // Re-apply CSS override on every update to prevent game's CSS from truncating text
            // ONLY for non-combat actions (combat needs normal width for HP/MP bars)
            // Use setProperty with 'important' to ensure we override game's styles

            // Check if compact mode is enabled
            const compactMode = config$1.getSettingValue('actions_compactActionBar', false);

            if (compactMode) {
                // COMPACT MODE: Only modify action name element, NOT parents
                // This prevents breaking the header layout (community buffs, profile, etc.)
                actionNameElement.style.setProperty('max-width', '800px', 'important');
                actionNameElement.style.setProperty('overflow', 'hidden', 'important');
                actionNameElement.style.setProperty('text-overflow', 'clip', 'important');
                actionNameElement.style.setProperty('white-space', 'nowrap', 'important');

                // DO NOT modify parent containers - let game's CSS control header layout
            } else {
                // FULL WIDTH MODE (default): Expand to show all text
                actionNameElement.style.setProperty('overflow', 'visible', 'important');
                actionNameElement.style.setProperty('text-overflow', 'clip', 'important');
                actionNameElement.style.setProperty('white-space', 'nowrap', 'important');
                actionNameElement.style.setProperty('max-width', 'none', 'important');
                actionNameElement.style.setProperty('width', 'auto', 'important');
                actionNameElement.style.setProperty('min-width', 'max-content', 'important');

                // Apply to entire parent chain (up to 5 levels)
                let parent = actionNameElement.parentElement;
                let levels = 0;
                while (parent && levels < 5) {
                    parent.style.setProperty('overflow', 'visible', 'important');
                    parent.style.setProperty('text-overflow', 'clip', 'important');
                    parent.style.setProperty('white-space', 'nowrap', 'important');
                    parent.style.setProperty('max-width', 'none', 'important');
                    parent.style.setProperty('width', 'auto', 'important');
                    parent.style.setProperty('min-width', 'max-content', 'important');
                    parent = parent.parentElement;
                    levels++;
                }
            }

            // Get character data
            const equipment = dataManager$1.getEquipment();
            const skills = dataManager$1.getSkills();
            const itemDetailMap = dataManager$1.getInitClientData()?.itemDetailMap || {};

            // Use shared calculator
            const stats = calculateActionStats(actionDetails, {
                skills,
                equipment,
                itemDetailMap,
                actionHrid: action.actionHrid, // Pass action HRID for task detection
                includeCommunityBuff: true,
                includeBreakdown: false,
                floorActionLevel: true,
            });

            if (!stats) {
                // Reconnect observer
                this.reconnectActionNameObserver(actionNameElement);
                return;
            }

            const { actionTime, totalEfficiency } = stats;
            const baseActionsPerHour = calculateActionsPerHour(actionTime);

            // Efficiency model:
            // - Queue input counts completed actions (including instant repeats)
            // - Efficiency adds instant repeats with no extra time
            // - Time is based on time-consuming actions (queuedActions / avgActionsPerBaseAction)
            // - Materials are consumed per completed action, including repeats
            // Calculate average queued actions completed per time-consuming action
            const avgActionsPerBaseAction = calculateEfficiencyMultiplier(totalEfficiency);

            // Calculate actions per hour WITH efficiency (total action completions including instant repeats)
            const actionsPerHourWithEfficiency = baseActionsPerHour * avgActionsPerBaseAction;

            // Calculate items per hour based on action type
            let itemsPerHour;

            // Gathering action types (need special handling for dropTable)
            const GATHERING_TYPES = ['/action_types/foraging', '/action_types/woodcutting', '/action_types/milking'];

            // Production action types that benefit from Gourmet Tea
            const PRODUCTION_TYPES = ['/action_types/brewing', '/action_types/cooking'];

            if (
                actionDetails.dropTable &&
                actionDetails.dropTable.length > 0 &&
                GATHERING_TYPES.includes(actionDetails.type)
            ) {
                // Gathering action - use dropTable with gathering quantity bonus
                const mainDrop = actionDetails.dropTable[0];
                const baseAvgAmount = (mainDrop.minCount + mainDrop.maxCount) / 2;

                // Calculate gathering quantity bonus (same as gathering-profit.js)
                const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);
                const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);
                const gatheringTea = parseGatheringBonus(activeDrinks, itemDetailMap, drinkConcentration);

                // Community buff
                const communityBuffLevel = dataManager$1.getCommunityBuffLevel('/community_buff_types/gathering_quantity');
                const communityGathering = communityBuffLevel ? 0.2 + (communityBuffLevel - 1) * 0.005 : 0;

                // Achievement buffs
                const achievementGathering = dataManager$1.getAchievementBuffFlatBoost(
                    actionDetails.type,
                    '/buff_types/gathering'
                );

                // Total gathering bonus (all additive)
                const totalGathering = gatheringTea + communityGathering + achievementGathering;

                // Apply gathering bonus to average amount
                const avgAmountPerAction = baseAvgAmount * (1 + totalGathering);

                // Items per hour = actions × drop rate × avg amount × efficiency
                itemsPerHour = baseActionsPerHour * mainDrop.dropRate * avgAmountPerAction * avgActionsPerBaseAction;
            } else if (actionDetails.outputItems && actionDetails.outputItems.length > 0) {
                // Production action - use outputItems
                const outputAmount = actionDetails.outputItems[0].count || 1;
                itemsPerHour = baseActionsPerHour * outputAmount * avgActionsPerBaseAction;

                // Apply Gourmet bonus for brewing/cooking (extra items chance)
                if (PRODUCTION_TYPES.includes(actionDetails.type)) {
                    const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);
                    const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);
                    const gourmetBonus = parseGourmetBonus(activeDrinks, itemDetailMap, drinkConcentration);

                    // Gourmet gives a chance for extra items (e.g., 0.1344 = 13.44% more items)
                    const gourmetBonusItems = itemsPerHour * gourmetBonus;
                    itemsPerHour += gourmetBonusItems;
                }
            } else {
                // Fallback - no items produced
                itemsPerHour = actionsPerHourWithEfficiency;
            }

            // Calculate material limit for infinite actions
            let materialLimit = null;
            let limitType = null;
            if (!action.hasMaxCount) {
                // Get inventory and calculate Artisan bonus
                const inventory = dataManager$1.getInventory();
                const inventoryLookup = this.buildInventoryLookup(inventory);
                const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);
                const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);
                const artisanBonus = parseArtisanBonus(activeDrinks, itemDetailMap, drinkConcentration);

                // Calculate max actions based on materials and costs
                const limitResult = this.calculateMaterialLimit(actionDetails, inventoryLookup, artisanBonus, action);
                if (limitResult) {
                    materialLimit = limitResult.maxActions;
                    limitType = limitResult.limitType;
                }
            }

            // Get queue size for display (total queued, doesn't change)
            // For infinite actions with inventory count, use that; otherwise use maxCount or Infinity
            let queueSizeDisplay;
            if (action.hasMaxCount) {
                queueSizeDisplay = action.maxCount;
            } else if (materialLimit !== null) {
                // Material-limited infinite action - show infinity but we'll add "max: X" separately
                queueSizeDisplay = Infinity;
            } else if (inventoryCount !== null) {
                queueSizeDisplay = inventoryCount;
            } else {
                queueSizeDisplay = Infinity;
            }

            // Get remaining actions for time calculation
            // For infinite actions, use material limit if available, then inventory count
            let remainingQueuedActions;
            if (action.hasMaxCount) {
                // Finite action: maxCount is the target, currentCount is progress toward that target
                remainingQueuedActions = action.maxCount - action.currentCount;
            } else if (materialLimit !== null) {
                // Infinite action limited by materials (materialLimit is queued actions)
                remainingQueuedActions = materialLimit;
            } else if (inventoryCount !== null) {
                // Infinite action: currentCount is lifetime total, so just use inventory count directly
                remainingQueuedActions = inventoryCount;
            } else {
                remainingQueuedActions = Infinity;
            }

            // Calculate time-consuming actions needed
            let baseActionsNeeded;
            if (!action.hasMaxCount && materialLimit !== null) {
                // Material-limited infinite action - convert queued actions to time-consuming actions
                baseActionsNeeded = Math.ceil(materialLimit / avgActionsPerBaseAction);
            } else {
                // Finite action or inventory-count infinite - remainingQueuedActions is queued actions
                baseActionsNeeded = Math.ceil(remainingQueuedActions / avgActionsPerBaseAction);
            }
            const totalTimeSeconds = baseActionsNeeded * actionTime;

            // Calculate completion time
            const completionTime = new Date();
            completionTime.setSeconds(completionTime.getSeconds() + totalTimeSeconds);

            // Format time strings (timeReadable handles days/hours/minutes properly)
            const timeStr = timeReadable(totalTimeSeconds);

            // Format completion time
            const now = new Date();
            const isToday = completionTime.toDateString() === now.toDateString();

            let clockTime;
            if (isToday) {
                // Today: Just show time in 12-hour format
                clockTime = completionTime.toLocaleString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true,
                });
            } else {
                // Future date: Show date and time in 12-hour format
                clockTime = completionTime.toLocaleString('en-US', {
                    month: 'numeric',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true,
                });
            }

            // Build display HTML
            // Line 1: Append stats to game's action name div
            const statsToAppend = [];

            // Queue size (with thousand separators)
            if (queueSizeDisplay !== Infinity) {
                statsToAppend.push(`(${queueSizeDisplay.toLocaleString()} queued)`);
            } else if (materialLimit !== null) {
                // Show infinity with material limit and what's limiting it
                let limitLabel = '';
                if (limitType === 'gold') {
                    limitLabel = 'gold limit';
                } else if (limitType && limitType.startsWith('material:')) {
                    limitLabel = 'mat limit';
                } else if (limitType && limitType.startsWith('upgrade:')) {
                    limitLabel = 'upgrade limit';
                } else if (limitType === 'alchemy_item') {
                    limitLabel = 'item limit';
                } else {
                    limitLabel = 'max';
                }
                statsToAppend.push(`(∞ · ${limitLabel}: ${this.formatLargeNumber(materialLimit)})`);
            } else {
                statsToAppend.push(`(∞)`);
            }

            // Time per action and actions/hour
            statsToAppend.push(`${actionTime.toFixed(2)}s/action`);

            // Show both actions/hr (with efficiency) and items/hr (actual item output)
            statsToAppend.push(
                `${actionsPerHourWithEfficiency.toFixed(0)} actions/hr (${itemsPerHour.toFixed(0)} items/hr)`
            );

            // Append to game's div (with marker for cleanup)
            this.appendStatsToActionName(actionNameElement, statsToAppend.join(' · '));

            // Line 2: Time estimates in our div
            // Show time info if we have a finite number of remaining actions
            // This includes both finite actions (hasMaxCount) and infinite actions with inventory count
            if (remainingQueuedActions !== Infinity && !isNaN(remainingQueuedActions) && remainingQueuedActions > 0) {
                this.displayElement.innerHTML = `<span style="display: inline-block; margin-right: 0.25em;">⏱</span> ${timeStr} → ${clockTime}`;
            } else {
                this.displayElement.innerHTML = '';
            }

            // Reconnect observer to watch for game's updates
            this.reconnectActionNameObserver(actionNameElement);
        }

        /**
         * Reconnect action name observer after making our changes
         * @param {HTMLElement} actionNameElement - Action name element
         */
        reconnectActionNameObserver(actionNameElement) {
            if (!actionNameElement) {
                return;
            }

            if (this.actionNameObserver) {
                this.actionNameObserver();
            }

            this.actionNameObserver = createMutationWatcher(
                actionNameElement,
                () => {
                    this.updateDisplay();
                },
                {
                    childList: true,
                    characterData: true,
                    subtree: true,
                }
            );
        }

        parseActionNameFromDom(actionNameText) {
            // Strip ALL trailing parentheses groups (e.g., "(T3) (Party)" or "(50)")
            // This handles combat tiers and party indicators: "Infernal Abyss (T3) (Party)" → "Infernal Abyss"
            const actionNameMatch = actionNameText.match(/^(.+?)(?:\s*\([^)]+\))*$/);
            const fullNameFromDom = actionNameMatch ? actionNameMatch[1].trim() : actionNameText;

            if (fullNameFromDom.includes(':')) {
                const parts = fullNameFromDom.split(':');
                return {
                    actionNameFromDom: parts[0].trim(),
                    itemNameFromDom: parts.slice(1).join(':').trim(),
                };
            }

            return {
                actionNameFromDom: fullNameFromDom,
                itemNameFromDom: null,
            };
        }

        buildItemHridFromName(itemName) {
            return `/items/${itemName.toLowerCase().replace(/\s+/g, '_')}`;
        }

        matchCurrentActionFromText(currentActions, actionNameText) {
            const { actionNameFromDom, itemNameFromDom } = this.parseActionNameFromDom(actionNameText);
            const itemHridFromDom = this.buildItemHridFromName(itemNameFromDom || actionNameFromDom);

            return currentActions.find((currentAction) => {
                const actionDetails = dataManager$1.getActionDetails(currentAction.actionHrid);
                if (!actionDetails) {
                    return false;
                }

                const outputItems = actionDetails.outputItems || [];
                const dropTable = actionDetails.dropTable || [];
                const matchesOutput = outputItems.some((item) => item.itemHrid === itemHridFromDom);
                const matchesDrop = dropTable.some((drop) => drop.itemHrid === itemHridFromDom);
                const matchesName = actionDetails.name === actionNameFromDom;

                if (!matchesName && !matchesOutput && !matchesDrop) {
                    return false;
                }

                if (itemNameFromDom && currentAction.primaryItemHash) {
                    return currentAction.primaryItemHash.includes(itemHridFromDom);
                }

                return true;
            });
        }

        scheduleUpdateRetry() {
            if (this.retryUpdateTimeout) {
                return;
            }

            this.retryUpdateTimeout = setTimeout(() => {
                this.retryUpdateTimeout = null;
                this.updateDisplay();
            }, 150);
            this.cleanupRegistry.registerTimeout(this.retryUpdateTimeout);
        }

        /**
         * Get clean action name from element, stripping any stats we appended
         * @param {HTMLElement} actionNameElement - Action name element
         * @returns {string} Clean action name text
         */
        getCleanActionName(actionNameElement) {
            // Find our marker span (if it exists)
            const markerSpan = actionNameElement.querySelector('.mwi-appended-stats');
            if (markerSpan) {
                // Remove the marker span temporarily to get clean text
                const cleanText = actionNameElement.textContent.replace(markerSpan.textContent, '').trim();
                return cleanText;
            }
            // No marker found, return as-is
            return actionNameElement.textContent.trim();
        }

        /**
         * Clear any stats we previously appended to action name
         * @param {HTMLElement} actionNameElement - Action name element
         */
        clearAppendedStats(actionNameElement) {
            if (!actionNameElement) return;
            const markerSpan = actionNameElement.querySelector('.mwi-appended-stats');
            if (markerSpan) {
                markerSpan.remove();
            }
        }

        /**
         * Append stats to game's action name element
         * @param {HTMLElement} actionNameElement - Action name element
         * @param {string} statsText - Stats text to append
         */
        appendStatsToActionName(actionNameElement, statsText) {
            // Clear any previous appended stats
            this.clearAppendedStats(actionNameElement);

            // Get clean action name before appending stats
            const cleanActionName = this.getCleanActionName(actionNameElement);

            // Create marker span for our additions
            const statsSpan = document.createElement('span');
            statsSpan.className = 'mwi-appended-stats';

            // Check if compact mode is enabled
            const compactMode = config$1.getSettingValue('actions_compactActionBar', false);

            if (compactMode) {
                // COMPACT MODE: Truncate stats if too long
                statsSpan.style.cssText = `
                color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
                display: inline-block;
                max-width: 400px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                vertical-align: bottom;
            `;
                // Set full text as tooltip on both stats span and parent element
                const fullText = cleanActionName + ' ' + statsText;
                statsSpan.setAttribute('title', fullText);
                actionNameElement.setAttribute('title', fullText);
            } else {
                // FULL WIDTH MODE: Show all stats
                statsSpan.style.cssText = `color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});`;
                // Remove tooltip in full width mode
                actionNameElement.removeAttribute('title');
            }

            statsSpan.textContent = ' ' + statsText;

            // Append to action name element
            actionNameElement.appendChild(statsSpan);
        }

        /**
         * Calculate action time for a given action
         * @param {Object} actionDetails - Action details from data manager
         * @param {string} actionHrid - Action HRID for task detection (optional)
         * @returns {Object} {actionTime, totalEfficiency} or null if calculation fails
         */
        calculateActionTime(actionDetails, actionHrid = null) {
            const skills = dataManager$1.getSkills();
            const equipment = dataManager$1.getEquipment();
            const itemDetailMap = dataManager$1.getInitClientData()?.itemDetailMap || {};

            // Use shared calculator with same parameters as main display
            return calculateActionStats(actionDetails, {
                skills,
                equipment,
                itemDetailMap,
                actionHrid, // Pass action HRID for task detection
                includeCommunityBuff: true,
                includeBreakdown: false,
                floorActionLevel: true,
            });
        }

        /**
         * Format a number with K/M suffix for large values
         * @param {number} num - Number to format
         * @returns {string} Formatted string (e.g., "1.23K", "5.67M")
         */
        formatLargeNumber(num) {
            if (num < 10000) {
                return num.toLocaleString(); // Under 10K: show full number with commas
            } else if (num < 1000000) {
                return (num / 1000).toFixed(1) + 'K'; // 10K-999K: show with K
            } else {
                return (num / 1000000).toFixed(2) + 'M'; // 1M+: show with M
            }
        }

        /**
         * Build inventory lookup maps for fast material queries
         * @param {Array} inventory - Character inventory items
         * @returns {Object} Lookup maps by HRID and enhancement
         */
        buildInventoryLookup(inventory) {
            const byHrid = {};
            const byEnhancedKey = {};

            if (!Array.isArray(inventory)) {
                return { byHrid, byEnhancedKey };
            }

            for (const item of inventory) {
                if (item.itemLocationHrid !== '/item_locations/inventory') {
                    continue;
                }

                const count = item.count || 0;
                if (!count) {
                    continue;
                }

                byHrid[item.itemHrid] = (byHrid[item.itemHrid] || 0) + count;

                const enhancementLevel = item.enhancementLevel || 0;
                const enhancedKey = `${item.itemHrid}::${enhancementLevel}`;
                byEnhancedKey[enhancedKey] = (byEnhancedKey[enhancedKey] || 0) + count;
            }

            return { byHrid, byEnhancedKey };
        }

        /**
         * Calculate maximum actions possible based on inventory materials
         * @param {Object} actionDetails - Action detail object
         * @param {Object|Array} inventoryLookup - Inventory lookup maps or raw inventory array
         * @param {number} artisanBonus - Artisan material reduction (0-1 decimal)
         * @param {Object} actionObj - Character action object (for primaryItemHash)
         * @returns {Object|null} {maxActions: number, limitType: string} or null if unlimited
         */
        calculateMaterialLimit(actionDetails, inventoryLookup, artisanBonus, actionObj = null) {
            if (!actionDetails || !inventoryLookup) {
                return null;
            }

            // Materials are consumed per queued action. Efficiency only affects time, not materials.

            const lookup = Array.isArray(inventoryLookup) ? this.buildInventoryLookup(inventoryLookup) : inventoryLookup;
            const byHrid = lookup?.byHrid || {};
            const byEnhancedKey = lookup?.byEnhancedKey || {};

            // Check for primaryItemHash (ONLY for Alchemy actions: Coinify, Decompose, Transmute)
            // Crafting actions also have primaryItemHash but should use the standard input/upgrade logic
            // Format: "characterID::itemLocation::itemHrid::enhancementLevel"
            const isAlchemyAction = actionDetails.type === '/action_types/alchemy';
            if (isAlchemyAction && actionObj && actionObj.primaryItemHash) {
                const parts = actionObj.primaryItemHash.split('::');
                if (parts.length >= 3) {
                    const itemHrid = parts[2]; // Extract item HRID
                    const enhancementLevel = parts.length >= 4 ? parseInt(parts[3]) : 0;

                    const enhancedKey = `${itemHrid}::${enhancementLevel}`;
                    const availableCount = byEnhancedKey[enhancedKey] || 0;

                    // Get bulk multiplier from item details (how many items per action)
                    const itemDetails = dataManager$1.getItemDetails(itemHrid);
                    const bulkMultiplier = itemDetails?.alchemyDetail?.bulkMultiplier || 1;

                    // Calculate max queued actions based on available items
                    const maxActions = Math.floor(availableCount / bulkMultiplier);

                    return { maxActions, limitType: 'alchemy_item' };
                }
            }

            // Check if action requires input materials or has costs
            const hasInputItems = actionDetails.inputItems && actionDetails.inputItems.length > 0;
            const hasUpgradeItem = actionDetails.upgradeItemHrid;
            const hasCoinCost = actionDetails.coinCost && actionDetails.coinCost > 0;

            if (!hasInputItems && !hasUpgradeItem && !hasCoinCost) {
                return null; // No materials or costs required - unlimited
            }

            let minLimit = Infinity;
            let limitType = 'unknown';

            // Check gold/coin constraint (if action has a coin cost)
            if (hasCoinCost) {
                const availableGold = byHrid['/items/gold_coin'] || 0;
                const maxActionsFromGold = Math.floor(availableGold / actionDetails.coinCost);

                if (maxActionsFromGold < minLimit) {
                    minLimit = maxActionsFromGold;
                    limitType = 'gold';
                }
            }

            // Check input items (affected by Artisan Tea)
            if (hasInputItems) {
                for (const inputItem of actionDetails.inputItems) {
                    const availableCount = byHrid[inputItem.itemHrid] || 0;

                    // Apply Artisan reduction to required materials
                    const requiredPerAction = inputItem.count * (1 - artisanBonus);

                    // Calculate max queued actions for this material
                    const maxActions = Math.floor(availableCount / requiredPerAction);

                    if (maxActions < minLimit) {
                        minLimit = maxActions;
                        limitType = `material:${inputItem.itemHrid}`;
                    }
                }
            }

            // Check upgrade item (NOT affected by Artisan Tea)
            if (hasUpgradeItem) {
                const availableCount = byHrid[hasUpgradeItem] || 0;

                if (availableCount < minLimit) {
                    minLimit = availableCount;
                    limitType = `upgrade:${hasUpgradeItem}`;
                }
            }

            if (minLimit === Infinity) {
                return null;
            }

            return { maxActions: minLimit, limitType };
        }

        /**
         * Match an action from cache by reading its name from a queue div
         * @param {HTMLElement} actionDiv - The queue action div element
         * @param {Array} cachedActions - Array of actions from dataManager
         * @returns {Object|null} Matched action object or null
         */
        matchActionFromDiv(actionDiv, cachedActions, usedActionIds = new Set()) {
            // Find the action text element within the div
            const actionTextContainer = actionDiv.querySelector('[class*="QueuedActions_actionText"]');
            if (!actionTextContainer) {
                return null;
            }

            // The first child div contains the action name: "#3 🧪 Coinify: Foraging Essence"
            const firstChildDiv = actionTextContainer.querySelector('[class*="QueuedActions_text__"]');
            if (!firstChildDiv) {
                return null;
            }

            // Check if this is an enhancing action by looking at the SVG icon
            const svgIcon = firstChildDiv.querySelector('svg use');
            const isEnhancingAction = svgIcon && svgIcon.getAttribute('href')?.includes('#enhancing');

            // Get the text content (format: "#3Coinify: Foraging Essence" - no space after number!)
            const fullText = firstChildDiv.textContent.trim();

            // Remove position number: "#3Coinify: Foraging Essence" → "Coinify: Foraging Essence"
            // Note: No space after the number in the actual text
            const actionNameText = fullText.replace(/^#\d+/, '').trim();

            // Handle enhancing actions specially
            if (isEnhancingAction) {
                // For enhancing, the text is just the item name (e.g., "Cheese Sword")
                const itemName = actionNameText;
                const itemHrid = '/items/' + itemName.toLowerCase().replace(/\s+/g, '_');

                // Find enhancing action matching this item (excluding already-used actions)
                return cachedActions.find((a) => {
                    if (usedActionIds.has(a.id)) {
                        return false; // Skip already-matched actions
                    }

                    const actionDetails = dataManager$1.getActionDetails(a.actionHrid);
                    if (!actionDetails || actionDetails.type !== '/action_types/enhancing') {
                        return false;
                    }

                    // Match on primaryItemHash (the item being enhanced)
                    return a.primaryItemHash && a.primaryItemHash.includes(itemHrid);
                });
            }

            // Parse action name (same logic as main display)
            let actionNameFromDiv, itemNameFromDiv;
            if (actionNameText.includes(':')) {
                const parts = actionNameText.split(':');
                actionNameFromDiv = parts[0].trim();
                itemNameFromDiv = parts.slice(1).join(':').trim();
            } else {
                actionNameFromDiv = actionNameText;
                itemNameFromDiv = null;
            }

            // Match action from cache (same logic as main display, excluding already-used actions)
            return cachedActions.find((a) => {
                if (usedActionIds.has(a.id)) {
                    return false; // Skip already-matched actions
                }

                const actionDetails = dataManager$1.getActionDetails(a.actionHrid);
                if (!actionDetails) {
                    return false;
                }

                if (actionDetails.name !== actionNameFromDiv) {
                    const itemHridFromDiv = itemNameFromDiv
                        ? `/items/${itemNameFromDiv.toLowerCase().replace(/\s+/g, '_')}`
                        : `/items/${actionNameFromDiv.toLowerCase().replace(/\s+/g, '_')}`;
                    const outputItems = actionDetails.outputItems || [];
                    const dropTable = actionDetails.dropTable || [];
                    const matchesOutput = outputItems.some((item) => item.itemHrid === itemHridFromDiv);
                    const matchesDrop = dropTable.some((drop) => drop.itemHrid === itemHridFromDiv);

                    if (!matchesOutput && !matchesDrop) {
                        return false;
                    }
                }

                // If there's an item name, match on primaryItemHash
                if (itemNameFromDiv && a.primaryItemHash) {
                    const itemHrid = '/items/' + itemNameFromDiv.toLowerCase().replace(/\s+/g, '_');
                    return a.primaryItemHash.includes(itemHrid);
                }

                return true;
            });
        }

        /**
         * Inject time display into queue tooltip
         * @param {HTMLElement} queueMenu - Queue menu container element
         */
        injectQueueTimes(queueMenu) {
            // Track if we need to reconnect observer at the end
            let shouldReconnectObserver = false;

            try {
                // Get all queued actions
                const currentActions = dataManager$1.getCurrentActions();
                if (!currentActions || currentActions.length === 0) {
                    return;
                }

                // Find all action divs in the queue (individual actions only, not wrapper or text containers)
                const actionDivs = queueMenu.querySelectorAll('[class^="QueuedActions_action__"]');
                if (actionDivs.length === 0) {
                    return;
                }

                const inventoryLookup = this.buildInventoryLookup(dataManager$1.getInventory());

                // Clear all existing time and profit displays to prevent duplicates
                queueMenu.querySelectorAll('.mwi-queue-action-time').forEach((el) => el.remove());
                queueMenu.querySelectorAll('.mwi-queue-action-profit').forEach((el) => el.remove());
                const existingTotal = document.querySelector('#mwi-queue-total-time');
                if (existingTotal) {
                    existingTotal.remove();
                }

                // Observer is already disconnected by callback - we'll reconnect in finally
                shouldReconnectObserver = true;

                let accumulatedTime = 0;
                let hasInfinite = false;
                const actionsToCalculate = []; // Store actions for async profit calculation (with time in seconds)

                // Detect current action from DOM so we can avoid double-counting
                let currentAction = null;
                const actionNameElement = document.querySelector('div[class*="Header_actionName"]');
                if (actionNameElement && actionNameElement.textContent) {
                    // Use getCleanActionName to strip any stats we previously appended
                    const actionNameText = this.getCleanActionName(actionNameElement);

                    // Parse action name (same logic as main display)
                    // Also handles formatted numbers like "Farmland (276K)" or "Zone (1.2M)"
                    const actionNameMatch = actionNameText.match(/^(.+?)(?:\s*\([^)]+\))?$/);
                    const fullNameFromDom = actionNameMatch ? actionNameMatch[1].trim() : actionNameText;

                    let actionNameFromDom, itemNameFromDom;
                    if (fullNameFromDom.includes(':')) {
                        const parts = fullNameFromDom.split(':');
                        actionNameFromDom = parts[0].trim();
                        itemNameFromDom = parts.slice(1).join(':').trim();
                    } else {
                        actionNameFromDom = fullNameFromDom;
                        itemNameFromDom = null;
                    }

                    // Match current action from cache
                    currentAction = currentActions.find((a) => {
                        const actionDetails = dataManager$1.getActionDetails(a.actionHrid);
                        if (!actionDetails || actionDetails.name !== actionNameFromDom) {
                            return false;
                        }

                        if (itemNameFromDom && a.primaryItemHash) {
                            const itemHrid = '/items/' + itemNameFromDom.toLowerCase().replace(/\s+/g, '_');
                            const matches = a.primaryItemHash.includes(itemHrid);
                            return matches;
                        }

                        return true;
                    });

                    if (currentAction) {
                        // Current action matched
                    }
                }

                // Calculate time for current action to include in total
                // Always include current action time, even if it appears in queue
                if (currentAction) {
                    const actionDetails = dataManager$1.getActionDetails(currentAction.actionHrid);
                    if (actionDetails) {
                        // Check if infinite BEFORE calculating count
                        const isInfinite = !currentAction.hasMaxCount || currentAction.actionHrid.includes('/combat/');

                        let actionTimeSeconds = 0; // Time spent on this action (for profit calculation)
                        let count = 0; // Queued action count for profit calculation
                        let baseActionsNeeded = 0; // Time-consuming actions for time calculation

                        if (isInfinite) {
                            // Check for material limit on infinite actions
                            const equipment = dataManager$1.getEquipment();
                            const itemDetailMap = dataManager$1.getInitClientData()?.itemDetailMap || {};
                            const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);
                            const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);
                            const artisanBonus = parseArtisanBonus(activeDrinks, itemDetailMap, drinkConcentration);

                            // Calculate action stats to get efficiency
                            const timeData = this.calculateActionTime(actionDetails, currentAction.actionHrid);
                            if (timeData) {
                                const { actionTime, totalEfficiency } = timeData;
                                const limitResult = this.calculateMaterialLimit(
                                    actionDetails,
                                    inventoryLookup,
                                    artisanBonus,
                                    currentAction
                                );

                                const materialLimit = limitResult?.maxActions || null;

                                if (materialLimit !== null) {
                                    // Material-limited infinite action - calculate time
                                    count = materialLimit; // Max queued actions based on materials
                                    const avgActionsPerBaseAction = calculateEfficiencyMultiplier(totalEfficiency);
                                    baseActionsNeeded = Math.ceil(count / avgActionsPerBaseAction);
                                    const totalTime = baseActionsNeeded * actionTime;
                                    accumulatedTime += totalTime;
                                    actionTimeSeconds = totalTime;
                                }
                            } else {
                                // Could not calculate action time
                                hasInfinite = true;
                            }
                        } else {
                            count = currentAction.maxCount - currentAction.currentCount;
                            const timeData = this.calculateActionTime(actionDetails, currentAction.actionHrid);
                            if (timeData) {
                                const { actionTime, totalEfficiency } = timeData;

                                // Calculate average queued actions per time-consuming action
                                const avgActionsPerBaseAction = calculateEfficiencyMultiplier(totalEfficiency);

                                // Calculate time-consuming actions needed
                                baseActionsNeeded = Math.ceil(count / avgActionsPerBaseAction);
                                const totalTime = baseActionsNeeded * actionTime;
                                accumulatedTime += totalTime;
                                actionTimeSeconds = totalTime;
                            }
                        }

                        // Store action for profit calculation (done async after UI renders)
                        if (actionTimeSeconds > 0) {
                            actionsToCalculate.push({
                                actionHrid: currentAction.actionHrid,
                                timeSeconds: actionTimeSeconds,
                                count: count,
                                baseActionsNeeded: baseActionsNeeded,
                            });
                        }
                    }
                }

                // Now process queued actions by reading from each div
                // Each div shows a queued action, and we match it to cache by name
                // Track used action IDs to prevent duplicate matching (e.g., two identical infinite actions)
                const usedActionIds = new Set();

                // CRITICAL FIX: Always mark current action as used to prevent queue from matching it
                // The isCurrentActionInQueue flag only controls whether we add current action time to total
                if (currentAction) {
                    usedActionIds.add(currentAction.id);
                }

                for (let divIndex = 0; divIndex < actionDivs.length; divIndex++) {
                    const actionDiv = actionDivs[divIndex];

                    // Match this div's action from the cache (excluding already-matched actions)
                    const actionObj = this.matchActionFromDiv(actionDiv, currentActions, usedActionIds);

                    if (!actionObj) {
                        // Could not match action - show unknown
                        const timeDiv = document.createElement('div');
                        timeDiv.className = 'mwi-queue-action-time';
                        timeDiv.style.cssText = `
                        color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
                        font-size: 0.85em;
                        margin-top: 2px;
                    `;
                        timeDiv.textContent = '[Unknown action]';

                        const actionTextContainer = actionDiv.querySelector('[class*="QueuedActions_actionText"]');
                        if (actionTextContainer) {
                            actionTextContainer.appendChild(timeDiv);
                        } else {
                            actionDiv.appendChild(timeDiv);
                        }

                        continue;
                    }

                    // Mark this action as used for subsequent divs
                    usedActionIds.add(actionObj.id);

                    const actionDetails = dataManager$1.getActionDetails(actionObj.actionHrid);
                    if (!actionDetails) {
                        console.warn('[Action Time Display] Unknown queued action:', actionObj.actionHrid);
                        continue;
                    }

                    // Check if infinite BEFORE calculating count
                    const isInfinite = !actionObj.hasMaxCount || actionObj.actionHrid.includes('/combat/');

                    // Calculate action time first to get efficiency
                    const timeData = this.calculateActionTime(actionDetails, actionObj.actionHrid);
                    if (!timeData) continue;

                    const { actionTime, totalEfficiency } = timeData;

                    // Calculate material limit for infinite actions
                    let materialLimit = null;
                    let limitType = null;
                    if (isInfinite) {
                        const equipment = dataManager$1.getEquipment();
                        const itemDetailMap = dataManager$1.getInitClientData()?.itemDetailMap || {};
                        const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);
                        const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);
                        const artisanBonus = parseArtisanBonus(activeDrinks, itemDetailMap, drinkConcentration);

                        const limitResult = this.calculateMaterialLimit(
                            actionDetails,
                            inventoryLookup,
                            artisanBonus,
                            actionObj
                        );

                        if (limitResult) {
                            materialLimit = limitResult.maxActions;
                            limitType = limitResult.limitType;
                        }
                    }

                    // Determine if truly infinite (no material limit)
                    const isTrulyInfinite = isInfinite && materialLimit === null;

                    if (isTrulyInfinite) {
                        hasInfinite = true;
                    }

                    // Calculate count for finite actions or material-limited infinite actions
                    let count = 0;
                    if (!isInfinite) {
                        count = actionObj.maxCount - actionObj.currentCount;
                    } else if (materialLimit !== null) {
                        count = materialLimit;
                    }

                    // Calculate total time for this action
                    let totalTime;
                    let actionTimeSeconds = 0; // Time spent on this action (for profit calculation)
                    let baseActionsNeeded = 0; // Time-consuming actions for time calculation
                    if (isTrulyInfinite) {
                        totalTime = Infinity;
                    } else {
                        // Calculate time-consuming actions needed
                        const avgActionsPerBaseAction = calculateEfficiencyMultiplier(totalEfficiency);
                        baseActionsNeeded = Math.ceil(count / avgActionsPerBaseAction);
                        totalTime = baseActionsNeeded * actionTime;
                        accumulatedTime += totalTime;
                        actionTimeSeconds = totalTime;
                    }

                    // Store action for profit calculation (done async after UI renders)
                    if (actionTimeSeconds > 0 && !isTrulyInfinite) {
                        actionsToCalculate.push({
                            actionHrid: actionObj.actionHrid,
                            timeSeconds: actionTimeSeconds,
                            count: count,
                            baseActionsNeeded: baseActionsNeeded,
                            divIndex: divIndex, // Store index to match back to DOM element
                        });
                    }

                    // Format completion time
                    let completionText = '';
                    if (!hasInfinite && !isTrulyInfinite) {
                        const completionDate = new Date();
                        completionDate.setSeconds(completionDate.getSeconds() + accumulatedTime);

                        const hours = String(completionDate.getHours()).padStart(2, '0');
                        const minutes = String(completionDate.getMinutes()).padStart(2, '0');
                        const seconds = String(completionDate.getSeconds()).padStart(2, '0');

                        completionText = ` Complete at ${hours}:${minutes}:${seconds}`;
                    }

                    // Create time display element
                    const timeDiv = document.createElement('div');
                    timeDiv.className = 'mwi-queue-action-time';
                    timeDiv.style.cssText = `
                    color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
                    font-size: 0.85em;
                    margin-top: 2px;
                `;

                    if (isTrulyInfinite) {
                        timeDiv.textContent = '[∞]';
                    } else if (isInfinite && materialLimit !== null) {
                        // Material-limited infinite action
                        let limitLabel = '';
                        if (limitType === 'gold') {
                            limitLabel = 'gold';
                        } else if (limitType && limitType.startsWith('material:')) {
                            limitLabel = 'mat';
                        } else if (limitType && limitType.startsWith('upgrade:')) {
                            limitLabel = 'upgrade';
                        } else if (limitType === 'alchemy_item') {
                            limitLabel = 'item';
                        } else {
                            limitLabel = 'max';
                        }
                        const timeStr = timeReadable(totalTime);
                        timeDiv.textContent = `[${timeStr} · ${limitLabel}: ${this.formatLargeNumber(materialLimit)}]${completionText}`;
                    } else {
                        const timeStr = timeReadable(totalTime);
                        timeDiv.textContent = `[${timeStr}]${completionText}`;
                    }

                    // Find the actionText container and append inside it
                    const actionTextContainer = actionDiv.querySelector('[class*="QueuedActions_actionText"]');
                    if (actionTextContainer) {
                        actionTextContainer.appendChild(timeDiv);
                    } else {
                        // Fallback: append to action div
                        actionDiv.appendChild(timeDiv);
                    }

                    // Create empty profit div for this action (will be populated asynchronously)
                    if (!isTrulyInfinite && actionTimeSeconds > 0) {
                        const profitDiv = document.createElement('div');
                        profitDiv.className = 'mwi-queue-action-profit';
                        profitDiv.dataset.divIndex = divIndex;
                        profitDiv.style.cssText = `
                        color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
                        font-size: 0.85em;
                        margin-top: 2px;
                    `;
                        // Leave empty - will be filled by async calculation
                        profitDiv.textContent = '';

                        if (actionTextContainer) {
                            actionTextContainer.appendChild(profitDiv);
                        } else {
                            actionDiv.appendChild(profitDiv);
                        }
                    }
                }

                // Add total time at bottom (includes current action + all queued)
                const totalDiv = document.createElement('div');
                totalDiv.id = 'mwi-queue-total-time';
                totalDiv.style.cssText = `
                color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});
                font-weight: bold;
                margin-top: 12px;
                padding: 8px;
                border-top: 1px solid var(--border-color, ${config$1.COLOR_BORDER});
                text-align: center;
            `;

                // Build total time text
                let totalText = '';
                if (hasInfinite) {
                    // Show finite time first, then add infinity indicator
                    if (accumulatedTime > 0) {
                        totalText = `Total time: ${timeReadable(accumulatedTime)} + [∞]`;
                    } else {
                        totalText = 'Total time: [∞]';
                    }
                } else {
                    totalText = `Total time: ${timeReadable(accumulatedTime)}`;
                }

                totalDiv.innerHTML = totalText;

                // Insert after queue menu
                queueMenu.insertAdjacentElement('afterend', totalDiv);

                // Calculate profit asynchronously (non-blocking)
                if (actionsToCalculate.length > 0 && marketAPI.isLoaded()) {
                    // Async will handle observer reconnection after updates complete
                    shouldReconnectObserver = false;
                    this.calculateAndDisplayTotalProfit(totalDiv, actionsToCalculate, totalText, queueMenu);
                }
            } catch (error) {
                console.error('[MWI Tools] Error injecting queue times:', error);
            } finally {
                // Reconnect observer only if async didn't take over
                if (shouldReconnectObserver) {
                    this.setupQueueMenuObserver(queueMenu);
                }
            }
        }

        /**
         * Calculate and display total profit asynchronously (non-blocking)
         * @param {HTMLElement} totalDiv - The total display div element
         * @param {Array} actionsToCalculate - Array of {actionHrid, timeSeconds, count, baseActionsNeeded, divIndex} objects
         * @param {string} baseText - Base text (time) to prepend
         * @param {HTMLElement} queueMenu - Queue menu element to reconnect observer after updates
         */
        async calculateAndDisplayTotalProfit(totalDiv, actionsToCalculate, baseText, queueMenu) {
            // Generate unique ID for this calculation to prevent race conditions
            const calculationId = Date.now() + Math.random();
            this.activeProfitCalculationId = calculationId;

            try {
                let totalProfit = 0;
                let hasProfitData = false;

                // Create all profit calculation promises at once (parallel execution)
                const profitPromises = actionsToCalculate.map(
                    (action) =>
                        Promise.race([
                            this.calculateProfitForAction(action),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 500)),
                        ]).catch(() => null) // Convert rejections to null
                );

                // Wait for all calculations to complete in parallel
                const results = await Promise.allSettled(profitPromises);

                // Check if this calculation is still valid (character might have switched)
                if (this.activeProfitCalculationId !== calculationId) {
                    return;
                }

                // Aggregate results and update individual action profit displays
                results.forEach((result, index) => {
                    const actionProfit = result.status === 'fulfilled' && result.value !== null ? result.value : null;

                    if (actionProfit !== null) {
                        totalProfit += actionProfit;
                        hasProfitData = true;

                        // Update individual action's profit display
                        const action = actionsToCalculate[index];
                        if (action.divIndex !== undefined) {
                            const profitDiv = document.querySelector(
                                `.mwi-queue-action-profit[data-div-index="${action.divIndex}"]`
                            );
                            if (profitDiv) {
                                const profitColor =
                                    actionProfit >= 0
                                        ? config$1.getSettingValue('color_profit', '#4ade80')
                                        : config$1.getSettingValue('color_loss', '#f87171');
                                const profitSign = actionProfit >= 0 ? '+' : '';
                                profitDiv.innerHTML = `Profit: <span style="color: ${profitColor};">${profitSign}${formatWithSeparator(Math.round(actionProfit))}</span>`;
                            }
                        }
                    }
                });

                // Update display with value
                if (hasProfitData) {
                    // Get value mode setting to determine label and color
                    const valueMode = config$1.getSettingValue('actionQueue_valueMode', 'profit');
                    const isEstimatedValue = valueMode === 'estimated_value';

                    // Estimated value is always positive (revenue), so always use profit color
                    // Profit can be negative, so use appropriate color
                    const valueColor =
                        isEstimatedValue || totalProfit >= 0
                            ? config$1.getSettingValue('color_profit', '#4ade80')
                            : config$1.getSettingValue('color_loss', '#f87171');
                    const valueSign = totalProfit >= 0 ? '+' : '';
                    const valueLabel = isEstimatedValue ? 'Estimated value' : 'Total profit';
                    const valueText = `<br>${valueLabel}: <span style="color: ${valueColor};">${valueSign}${formatWithSeparator(Math.round(totalProfit))}</span>`;
                    totalDiv.innerHTML = baseText + valueText;
                }
            } catch (error) {
                console.warn('[Action Time Display] Error calculating total profit:', error);
            } finally {
                // CRITICAL: Reconnect mutation observer after ALL DOM updates are complete
                // This prevents infinite loop by ensuring observer only reconnects once all profit divs are updated
                this.setupQueueMenuObserver(queueMenu);
            }
        }

        /**
         * Calculate profit or estimated value for a single action based on action count
         * @param {Object} action - Action object with {actionHrid, timeSeconds, count, baseActionsNeeded}
         * @returns {Promise<number|null>} Total value (profit or revenue) or null if unavailable
         */
        async calculateProfitForAction(action) {
            const actionDetails = dataManager$1.getActionDetails(action.actionHrid);
            if (!actionDetails) {
                return null;
            }

            const valueMode = config$1.getSettingValue('actionQueue_valueMode', 'profit');

            // Get profit data (already has profitPerAction calculated)
            let profitData = null;
            const gatheringProfit = await calculateGatheringProfit(action.actionHrid);
            if (gatheringProfit) {
                profitData = gatheringProfit;
            } else if (actionDetails.outputItems?.[0]?.itemHrid) {
                profitData = await profitCalculator.calculateProfit(actionDetails.outputItems[0].itemHrid);
            }

            if (!profitData) {
                return null;
            }

            const actionsCount = action.count ?? 0;
            if (!actionsCount) {
                return 0;
            }

            if (typeof profitData.actionsPerHour !== 'number') {
                return null;
            }

            if (gatheringProfit) {
                const totals = calculateGatheringActionTotalsFromBase({
                    actionsCount,
                    actionsPerHour: profitData.actionsPerHour,
                    baseOutputs: profitData.baseOutputs,
                    bonusDrops: profitData.bonusRevenue?.bonusDrops || [],
                    processingRevenueBonusPerAction: profitData.processingRevenueBonusPerAction,
                    gourmetRevenueBonusPerAction: profitData.gourmetRevenueBonusPerAction,
                    drinkCostPerHour: profitData.drinkCostPerHour,
                    efficiencyMultiplier: profitData.efficiencyMultiplier || 1,
                });
                return valueMode === 'estimated_value' ? totals.totalRevenue : totals.totalProfit;
            }

            const totals = calculateProductionActionTotalsFromBase({
                actionsCount,
                actionsPerHour: profitData.actionsPerHour,
                outputAmount: profitData.outputAmount || 1,
                outputPrice: profitData.outputPrice,
                gourmetBonus: profitData.gourmetBonus || 0,
                bonusDrops: profitData.bonusRevenue?.bonusDrops || [],
                materialCosts: profitData.materialCosts,
                totalTeaCostPerHour: profitData.totalTeaCostPerHour,
                efficiencyMultiplier: profitData.efficiencyMultiplier || 1,
            });

            return valueMode === 'estimated_value' ? totals.totalRevenue : totals.totalProfit;
        }

        /**
         * Disable the action time display (cleanup)
         */
        disable() {
            this.cleanupRegistry.cleanupAll();
            this.displayElement = null;
            this.updateTimer = null;
            this.unregisterQueueObserver = null;
            this.actionNameObserver = null;
            this.queueMenuObserver = null;
            this.characterInitHandler = null;
            this.waitForPanelTimeout = null;
            this.activeProfitCalculationId = null;
            this.isInitialized = false;
        }
    }

    const actionTimeDisplay = new ActionTimeDisplay();

    /**
     * Quick Input Buttons Module
     *
     * Adds quick action buttons (10, 100, 1000, Max) to action panels
     * for fast queue input without manual typing.
     *
     * Features:
     * - Preset buttons: 10, 100, 1000
     * - Max button (fills to maximum inventory amount)
     * - Works on all action panels (gathering, production, combat)
     * - Uses React's internal _valueTracker for proper state updates
     * - Auto-detects input fields and injects buttons
     */


    /**
     * QuickInputButtons class manages quick input button injection
     */
    class QuickInputButtons {
        constructor() {
            this.isInitialized = false;
            this.unregisterObserver = null;
            this.presetHours = [0.5, 1, 2, 3, 4, 5, 6, 10, 12, 24];
            this.presetValues = [10, 100, 1000];
            this.cleanupRegistry = createCleanupRegistry();
        }

        /**
         * Initialize the quick input buttons feature
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            // Start observing for action panels
            this.startObserving();
            this.isInitialized = true;
        }

        /**
         * Start observing for action panels using centralized observer
         */
        startObserving() {
            // Register with centralized DOM observer
            this.unregisterObserver = domObserver$1.onClass(
                'QuickInputButtons',
                'SkillActionDetail_skillActionDetail',
                (panel) => {
                    this.injectButtons(panel);
                }
            );

            this.cleanupRegistry.registerCleanup(() => {
                if (this.unregisterObserver) {
                    this.unregisterObserver();
                    this.unregisterObserver = null;
                }
            });

            // Check for existing action panels that may already be open
            const existingPanels = document.querySelectorAll('[class*="SkillActionDetail_skillActionDetail"]');
            existingPanels.forEach((panel) => {
                this.injectButtons(panel);
            });
        }

        /**
         * Inject quick input buttons into action panel
         * @param {HTMLElement} panel - Action panel element
         */
        injectButtons(panel) {
            try {
                // Check if already injected
                if (panel.querySelector('.mwi-collapsible-section')) {
                    return;
                }

                // Find the number input field first to skip panels that don't have queue inputs
                // (Enhancing, Alchemy, etc.)
                let numberInput = panel.querySelector('input[type="number"]');
                if (!numberInput) {
                    // Try finding input within maxActionCountInput container
                    const inputContainer = panel.querySelector('[class*="maxActionCountInput"]');
                    if (inputContainer) {
                        numberInput = inputContainer.querySelector('input');
                    }
                }
                if (!numberInput) {
                    // This is a panel type that doesn't have queue inputs (Enhancing, Alchemy, etc.)
                    // Skip silently - not an error, just not applicable
                    return;
                }

                // Cache game data once for all method calls
                const gameData = dataManager$1.getInitClientData();
                if (!gameData) {
                    console.warn('[Quick Input Buttons] No game data available');
                    return;
                }

                // Get action details for time-based calculations
                const actionNameElement = panel.querySelector('[class*="SkillActionDetail_name"]');
                if (!actionNameElement) {
                    console.warn('[Quick Input Buttons] No action name element found');
                    return;
                }

                const actionName = actionNameElement.textContent.trim();
                const actionDetails = this.getActionDetailsByName(actionName, gameData);
                if (!actionDetails) {
                    console.warn('[Quick Input Buttons] No action details found for:', actionName);
                    return;
                }

                // Check if this action has normal XP gain (skip speed section for combat)
                const experienceGain = actionDetails.experienceGain;
                const hasNormalXP = experienceGain && experienceGain.skillHrid && experienceGain.value > 0;

                // Calculate action duration and efficiency
                const { actionTime, totalEfficiency, efficiencyBreakdown } = this.calculateActionMetrics(
                    actionDetails,
                    gameData
                );
                const efficiencyMultiplier = 1 + totalEfficiency / 100;

                // Find the container to insert after (same as original MWI Tools)
                const inputContainer = numberInput.parentNode.parentNode.parentNode;
                if (!inputContainer) {
                    return;
                }

                // Get equipment details for display
                const equipment = dataManager$1.getEquipment();
                const itemDetailMap = gameData.itemDetailMap || {};

                // Calculate speed breakdown
                const baseTime = actionDetails.baseTimeCost / 1e9;
                const speedBonus = parseEquipmentSpeedBonuses(equipment, actionDetails.type, itemDetailMap);

                let speedSection = null;

                if (hasNormalXP) {
                    const speedContent = document.createElement('div');
                    speedContent.style.cssText = `
                color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
                font-size: 0.9em;
                line-height: 1.6;
            `;

                    const speedLines = [];

                    // Check if task speed applies (need to calculate before display)
                    const isTaskAction = actionDetails.hrid && dataManager$1.isTaskAction(actionDetails.hrid);
                    const taskSpeedBonus = isTaskAction ? dataManager$1.getTaskSpeedBonus() : 0;

                    // Calculate intermediate time (after equipment speed, before task speed)
                    const timeAfterEquipment = baseTime / (1 + speedBonus);

                    speedLines.push(`Base: ${baseTime.toFixed(2)}s → ${timeAfterEquipment.toFixed(2)}s`);
                    if (speedBonus > 0) {
                        speedLines.push(
                            `Speed: +${formatPercentage(speedBonus, 1)} | ${calculateActionsPerHour(timeAfterEquipment).toFixed(0)}/hr`
                        );
                    } else {
                        speedLines.push(`${calculateActionsPerHour(timeAfterEquipment).toFixed(0)}/hr`);
                    }

                    // Add speed breakdown
                    const speedBreakdown = this.calculateSpeedBreakdown(actionDetails, equipment, itemDetailMap);
                    if (speedBreakdown.total > 0) {
                        // Equipment and tools (combined from debugEquipmentSpeedBonuses)
                        for (const item of speedBreakdown.equipmentAndTools) {
                            const enhText = item.enhancementLevel > 0 ? ` +${item.enhancementLevel}` : '';
                            const detailText =
                                item.enhancementBonus > 0
                                    ? ` (${formatPercentage(item.baseBonus, 1)} + ${formatPercentage(item.enhancementBonus * item.enhancementLevel, 1)})`
                                    : '';
                            speedLines.push(
                                `  - ${item.itemName}${enhText}: +${formatPercentage(item.scaledBonus, 1)}${detailText}`
                            );
                        }

                        // Consumables
                        for (const item of speedBreakdown.consumables) {
                            const detailText =
                                item.drinkConcentration > 0
                                    ? ` (${item.baseSpeed.toFixed(1)}% × ${(1 + item.drinkConcentration / 100).toFixed(2)})`
                                    : '';
                            speedLines.push(`  - ${item.name}: +${item.speed.toFixed(1)}%${detailText}`);
                        }
                    }

                    // Task Speed section (multiplicative, separate from equipment speed)
                    if (isTaskAction && taskSpeedBonus > 0) {
                        speedLines.push(''); // Empty line separator
                        speedLines.push(
                            `<span style="font-weight: 500;">Task Speed (multiplicative): +${taskSpeedBonus.toFixed(1)}%</span>`
                        );
                        speedLines.push(
                            `${timeAfterEquipment.toFixed(2)}s → ${actionTime.toFixed(2)}s | ${calculateActionsPerHour(actionTime).toFixed(0)}/hr`
                        );

                        // Find equipped task badge for details
                        const trinketSlot = equipment.get('/item_locations/trinket');
                        if (trinketSlot && trinketSlot.itemHrid) {
                            const itemDetails = itemDetailMap[trinketSlot.itemHrid];
                            if (itemDetails) {
                                const enhText = trinketSlot.enhancementLevel > 0 ? ` +${trinketSlot.enhancementLevel}` : '';

                                // Calculate breakdown
                                const baseTaskSpeed = itemDetails.equipmentDetail?.noncombatStats?.taskSpeed || 0;
                                const enhancementBonus =
                                    itemDetails.equipmentDetail?.noncombatEnhancementBonuses?.taskSpeed || 0;
                                const enhancementLevel = trinketSlot.enhancementLevel || 0;

                                const detailText =
                                    enhancementBonus > 0
                                        ? ` (${(baseTaskSpeed * 100).toFixed(1)}% + ${(enhancementBonus * enhancementLevel * 100).toFixed(1)}%)`
                                        : '';

                                speedLines.push(
                                    `  - ${itemDetails.name}${enhText}: +${taskSpeedBonus.toFixed(1)}%${detailText}`
                                );
                            }
                        }
                    }

                    // Add Efficiency breakdown
                    speedLines.push(''); // Empty line
                    speedLines.push(
                        `<span style="font-weight: 500; color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});">Efficiency: +${totalEfficiency.toFixed(1)}% → Output: ×${efficiencyMultiplier.toFixed(2)} (${Math.round(calculateActionsPerHour(actionTime) * efficiencyMultiplier)}/hr)</span>`
                    );

                    // Detailed efficiency breakdown
                    if (
                        efficiencyBreakdown.levelEfficiency > 0 ||
                        (efficiencyBreakdown.actionLevelBreakdown && efficiencyBreakdown.actionLevelBreakdown.length > 0)
                    ) {
                        // Calculate raw level delta (before any Action Level bonuses)
                        const rawLevelDelta = efficiencyBreakdown.skillLevel - efficiencyBreakdown.baseRequirement;

                        // Show final level efficiency
                        speedLines.push(`  - Level: +${efficiencyBreakdown.levelEfficiency.toFixed(1)}%`);

                        // Show raw level delta (what you'd get without Action Level bonuses)
                        speedLines.push(
                            `    - Raw level delta: +${rawLevelDelta.toFixed(1)}% (${efficiencyBreakdown.skillLevel} - ${efficiencyBreakdown.baseRequirement} base requirement)`
                        );

                        // Show Action Level bonus teas that reduce level efficiency
                        if (
                            efficiencyBreakdown.actionLevelBreakdown &&
                            efficiencyBreakdown.actionLevelBreakdown.length > 0
                        ) {
                            for (const tea of efficiencyBreakdown.actionLevelBreakdown) {
                                // Calculate impact: base tea effect reduces efficiency
                                const baseTeaImpact = -tea.baseActionLevel;
                                speedLines.push(
                                    `    - ${tea.name} impact: ${baseTeaImpact.toFixed(1)}% (raises requirement)`
                                );

                                // Show DC contribution as additional reduction if > 0
                                if (tea.dcContribution > 0) {
                                    const dcImpact = -tea.dcContribution;
                                    speedLines.push(`      - Drink Concentration: ${dcImpact.toFixed(1)}%`);
                                }
                            }
                        }
                    }
                    if (efficiencyBreakdown.houseEfficiency > 0) {
                        // Get house room name
                        const houseRoomName = this.getHouseRoomName(actionDetails.type);
                        speedLines.push(
                            `  - House: +${efficiencyBreakdown.houseEfficiency.toFixed(1)}% (${houseRoomName})`
                        );
                    }
                    if (efficiencyBreakdown.equipmentEfficiency > 0) {
                        speedLines.push(`  - Equipment: +${efficiencyBreakdown.equipmentEfficiency.toFixed(1)}%`);
                    }
                    if (efficiencyBreakdown.achievementEfficiency > 0) {
                        speedLines.push(`  - Achievement: +${efficiencyBreakdown.achievementEfficiency.toFixed(1)}%`);
                    }
                    // Break out individual teas - show BASE efficiency on main line, DC as sub-line
                    if (efficiencyBreakdown.teaBreakdown && efficiencyBreakdown.teaBreakdown.length > 0) {
                        for (const tea of efficiencyBreakdown.teaBreakdown) {
                            // Show BASE efficiency (without DC scaling) on main line
                            speedLines.push(`  - ${tea.name}: +${tea.baseEfficiency.toFixed(1)}%`);
                            // Show DC contribution as sub-line if > 0
                            if (tea.dcContribution > 0) {
                                speedLines.push(`    - Drink Concentration: +${tea.dcContribution.toFixed(1)}%`);
                            }
                        }
                    }
                    if (efficiencyBreakdown.communityEfficiency > 0) {
                        const communityBuffLevel = dataManager$1.getCommunityBuffLevel(
                            '/community_buff_types/production_efficiency'
                        );
                        speedLines.push(
                            `  - Community: +${efficiencyBreakdown.communityEfficiency.toFixed(1)}% (Production Efficiency T${communityBuffLevel})`
                        );
                    }

                    // Total time (dynamic)
                    const totalTimeLine = document.createElement('div');
                    totalTimeLine.style.cssText = `
                color: var(--text-color-main, ${config$1.COLOR_INFO});
                font-weight: 500;
                margin-top: 4px;
            `;

                    const updateTotalTime = () => {
                        const inputValue = numberInput.value;

                        if (inputValue === '∞') {
                            totalTimeLine.textContent = 'Total time: ∞';
                            return;
                        }

                        const queueCount = parseInt(inputValue) || 0;
                        if (queueCount > 0) {
                            // Input is number of ACTIONS to complete
                            // With efficiency, queued actions complete more quickly
                            // Calculate time-consuming actions needed
                            const baseActionsNeeded = Math.ceil(queueCount / efficiencyMultiplier);
                            const totalSeconds = baseActionsNeeded * actionTime;
                            totalTimeLine.textContent = `Total time: ${timeReadable(totalSeconds)}`;
                        } else {
                            totalTimeLine.textContent = 'Total time: 0s';
                        }
                    };

                    speedLines.push(''); // Empty line before total time
                    speedContent.innerHTML = speedLines.join('<br>');
                    speedContent.appendChild(totalTimeLine);

                    // Initial update
                    updateTotalTime();

                    // Watch for input changes
                    let inputObserverCleanup = createMutationWatcher(
                        numberInput,
                        () => {
                            updateTotalTime();
                        },
                        {
                            attributes: true,
                            attributeFilter: ['value'],
                        }
                    );
                    this.cleanupRegistry.registerCleanup(() => {
                        if (inputObserverCleanup) {
                            inputObserverCleanup();
                            inputObserverCleanup = null;
                        }
                    });

                    const updateOnInput = () => updateTotalTime();
                    const updateOnChange = () => updateTotalTime();
                    const updateOnClick = () => {
                        const clickTimeout = setTimeout(updateTotalTime, 50);
                        this.cleanupRegistry.registerTimeout(clickTimeout);
                    };

                    numberInput.addEventListener('input', updateOnInput);
                    numberInput.addEventListener('change', updateOnChange);
                    panel.addEventListener('click', updateOnClick);

                    this.cleanupRegistry.registerListener(numberInput, 'input', updateOnInput);
                    this.cleanupRegistry.registerListener(numberInput, 'change', updateOnChange);
                    this.cleanupRegistry.registerListener(panel, 'click', updateOnClick);

                    // Create initial summary for Action Speed & Time
                    const actionsPerHourWithEfficiency = Math.round(
                        calculateActionsPerHour(actionTime) * efficiencyMultiplier
                    );
                    const initialSummary = `${actionsPerHourWithEfficiency}/hr | Total time: 0s`;

                    speedSection = createCollapsibleSection(
                        '⏱',
                        'Action Speed & Time',
                        initialSummary,
                        speedContent,
                        false // Collapsed by default
                    );

                    // Get the summary div to update it dynamically
                    const speedSummaryDiv = speedSection.querySelector('.mwi-section-header + div');

                    // Enhanced updateTotalTime to also update the summary
                    const originalUpdateTotalTime = updateTotalTime;
                    const enhancedUpdateTotalTime = () => {
                        originalUpdateTotalTime();

                        // Update summary when collapsed
                        if (speedSummaryDiv) {
                            const inputValue = numberInput.value;
                            if (inputValue === '∞') {
                                speedSummaryDiv.textContent = `${actionsPerHourWithEfficiency}/hr | Total time: ∞`;
                            } else {
                                const queueCount = parseInt(inputValue) || 0;
                                if (queueCount > 0) {
                                    const baseActionsNeeded = Math.ceil(queueCount / efficiencyMultiplier);
                                    const totalSeconds = baseActionsNeeded * actionTime;
                                    speedSummaryDiv.textContent = `${actionsPerHourWithEfficiency}/hr | Total time: ${timeReadable(totalSeconds)}`;
                                } else {
                                    speedSummaryDiv.textContent = `${actionsPerHourWithEfficiency}/hr | Total time: 0s`;
                                }
                            }
                        }
                    };

                    // Replace all updateTotalTime calls with enhanced version
                    if (inputObserverCleanup) {
                        inputObserverCleanup();
                        inputObserverCleanup = null;
                    }

                    const newInputObserverCleanup = createMutationWatcher(
                        numberInput,
                        () => {
                            enhancedUpdateTotalTime();
                        },
                        {
                            attributes: true,
                            attributeFilter: ['value'],
                        }
                    );
                    this.cleanupRegistry.registerCleanup(() => {
                        newInputObserverCleanup();
                    });

                    numberInput.removeEventListener('input', updateOnInput);
                    numberInput.removeEventListener('change', updateOnChange);
                    panel.removeEventListener('click', updateOnClick);

                    const updateOnInputEnhanced = () => enhancedUpdateTotalTime();
                    const updateOnChangeEnhanced = () => enhancedUpdateTotalTime();
                    const updateOnClickEnhanced = () => {
                        const clickTimeout = setTimeout(enhancedUpdateTotalTime, 50);
                        this.cleanupRegistry.registerTimeout(clickTimeout);
                    };

                    numberInput.addEventListener('input', updateOnInputEnhanced);
                    numberInput.addEventListener('change', updateOnChangeEnhanced);
                    panel.addEventListener('click', updateOnClickEnhanced);

                    this.cleanupRegistry.registerListener(numberInput, 'input', updateOnInputEnhanced);
                    this.cleanupRegistry.registerListener(numberInput, 'change', updateOnChangeEnhanced);
                    this.cleanupRegistry.registerListener(panel, 'click', updateOnClickEnhanced);

                    // Initial update with enhanced version
                    enhancedUpdateTotalTime();
                } // End hasNormalXP check - speedSection only created for non-combat

                const levelProgressSection = this.createLevelProgressSection(
                    actionDetails,
                    actionTime,
                    gameData,
                    numberInput
                );

                let queueContent = null;

                if (hasNormalXP) {
                    queueContent = document.createElement('div');
                    queueContent.style.cssText = `
                    color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
                    font-size: 0.9em;
                    margin-top: 8px;
                    margin-bottom: 8px;
                `;

                    // FIRST ROW: Time-based buttons (hours)
                    queueContent.appendChild(document.createTextNode('Do '));

                    this.presetHours.forEach((hours) => {
                        const button = this.createButton(hours === 0.5 ? '0.5' : hours.toString(), () => {
                            // How many actions fit in X hours?
                            // With efficiency, queued actions complete more quickly
                            // Time (seconds) = hours × 3600
                            // Time-consuming actions = Time / actionTime
                            // Queue count (actions) = Time-consuming actions × efficiencyMultiplier
                            // Round to whole number (input doesn't accept decimals)
                            const totalSeconds = hours * 60 * 60;
                            const baseActions = totalSeconds / actionTime;
                            const actionCount = Math.round(baseActions * efficiencyMultiplier);
                            this.setInputValue(numberInput, actionCount);
                        });
                        queueContent.appendChild(button);
                    });

                    queueContent.appendChild(document.createTextNode(' hours'));
                    queueContent.appendChild(document.createElement('div')); // Line break

                    // SECOND ROW: Count-based buttons (times)
                    queueContent.appendChild(document.createTextNode('Do '));

                    this.presetValues.forEach((value) => {
                        const button = this.createButton(value.toLocaleString(), () => {
                            this.setInputValue(numberInput, value);
                        });
                        queueContent.appendChild(button);
                    });

                    const maxButton = this.createButton('Max', () => {
                        const maxValue = this.calculateMaxValue(panel, actionDetails, gameData);
                        // Handle both infinity symbol and numeric values
                        if (maxValue === '∞' || maxValue > 0) {
                            this.setInputValue(numberInput, maxValue);
                        }
                    });
                    queueContent.appendChild(maxButton);

                    queueContent.appendChild(document.createTextNode(' times'));
                } // End hasNormalXP check - queueContent only created for non-combat

                // Insert sections into DOM
                if (queueContent) {
                    // Non-combat: Insert queueContent first
                    inputContainer.insertAdjacentElement('afterend', queueContent);

                    if (speedSection) {
                        queueContent.insertAdjacentElement('afterend', speedSection);
                        if (levelProgressSection) {
                            speedSection.insertAdjacentElement('afterend', levelProgressSection);
                        }
                    } else if (levelProgressSection) {
                        queueContent.insertAdjacentElement('afterend', levelProgressSection);
                    }
                } else if (levelProgressSection) {
                    // Combat: Insert levelProgressSection directly after inputContainer
                    inputContainer.insertAdjacentElement('afterend', levelProgressSection);
                }
            } catch (error) {
                console.error('[Toolasha] Error injecting quick input buttons:', error);
            }
        }

        /**
         * Disable quick input buttons and cleanup observers/listeners
         */
        disable() {
            this.cleanupRegistry.cleanupAll();
            document.querySelectorAll('.mwi-collapsible-section').forEach((section) => section.remove());
            document.querySelectorAll('.mwi-quick-input-btn').forEach((button) => button.remove());
            this.isInitialized = false;
        }

        /**
         * Get action details by name
         * @param {string} actionName - Display name of the action
         * @param {Object} gameData - Cached game data from dataManager
         * @returns {Object|null} Action details or null if not found
         */
        getActionDetailsByName(actionName, gameData) {
            const actionDetailMap = gameData?.actionDetailMap;
            if (!actionDetailMap) {
                return null;
            }

            // Find action by matching name
            for (const [hrid, details] of Object.entries(actionDetailMap)) {
                if (details.name === actionName) {
                    // Include hrid in returned object for task detection
                    return { ...details, hrid };
                }
            }

            return null;
        }

        /**
         * Calculate action time and efficiency for current character state
         * Uses shared calculator with community buffs and detailed breakdown
         * @param {Object} actionDetails - Action details from game data
         * @param {Object} gameData - Cached game data from dataManager
         * @returns {Object} {actionTime, totalEfficiency, efficiencyBreakdown}
         */
        calculateActionMetrics(actionDetails, gameData) {
            const equipment = dataManager$1.getEquipment();
            const skills = dataManager$1.getSkills();
            const itemDetailMap = gameData?.itemDetailMap || {};

            // Use shared calculator with community buffs and breakdown
            const stats = calculateActionStats(actionDetails, {
                skills,
                equipment,
                itemDetailMap,
                actionHrid: actionDetails.hrid, // Pass action HRID for task detection
                includeCommunityBuff: true,
                includeBreakdown: true,
                floorActionLevel: true,
            });

            if (!stats) {
                // Fallback values
                return {
                    actionTime: 1,
                    totalEfficiency: 0,
                    efficiencyBreakdown: {
                        levelEfficiency: 0,
                        houseEfficiency: 0,
                        equipmentEfficiency: 0,
                        teaEfficiency: 0,
                        teaBreakdown: [],
                        communityEfficiency: 0,
                        achievementEfficiency: 0,
                        skillLevel: 1,
                        baseRequirement: 1,
                        actionLevelBonus: 0,
                        actionLevelBreakdown: [],
                        effectiveRequirement: 1,
                    },
                };
            }

            return stats;
        }

        /**
         * Get house room name for an action type
         * @param {string} actionType - Action type HRID
         * @returns {string} House room name with level
         */
        getHouseRoomName(actionType) {
            const houseRooms = dataManager$1.getHouseRooms();
            const roomMapping = {
                '/action_types/cheesesmithing': '/house_rooms/forge',
                '/action_types/cooking': '/house_rooms/kitchen',
                '/action_types/crafting': '/house_rooms/workshop',
                '/action_types/foraging': '/house_rooms/garden',
                '/action_types/milking': '/house_rooms/dairy_barn',
                '/action_types/tailoring': '/house_rooms/sewing_parlor',
                '/action_types/woodcutting': '/house_rooms/log_shed',
                '/action_types/brewing': '/house_rooms/brewery',
            };

            const roomHrid = roomMapping[actionType];
            if (!roomHrid) return 'Unknown Room';

            const room = houseRooms.get(roomHrid);
            const roomName = roomHrid
                .split('/')
                .pop()
                .split('_')
                .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
                .join(' ');
            const level = room?.level || 0;

            return `${roomName} level ${level}`;
        }

        /**
         * Calculate speed breakdown from all sources
         * @param {Object} actionData - Action data
         * @param {Map} equipment - Equipment map
         * @param {Object} itemDetailMap - Item detail map from game data
         * @returns {Object} Speed breakdown by source
         */
        calculateSpeedBreakdown(actionData, equipment, itemDetailMap) {
            const breakdown = {
                equipmentAndTools: [],
                consumables: [],
                total: 0,
            };

            // Get all equipment speed bonuses using the existing parser
            const allSpeedBonuses = debugEquipmentSpeedBonuses(equipment, itemDetailMap);

            // Determine which speed types are relevant for this action
            const actionType = actionData.type;
            const skillName = actionType.replace('/action_types/', '');
            const skillSpecificSpeed = skillName + 'Speed';

            // Filter for relevant speeds (skill-specific or generic skillingSpeed)
            const relevantSpeeds = allSpeedBonuses.filter((item) => {
                return item.speedType === skillSpecificSpeed || item.speedType === 'skillingSpeed';
            });

            // Add to breakdown
            for (const item of relevantSpeeds) {
                breakdown.equipmentAndTools.push(item);
                breakdown.total += item.scaledBonus * 100; // Convert to percentage
            }

            // Consumables (teas)
            const consumableSpeed = this.getConsumableSpeed(actionData, equipment, itemDetailMap);
            breakdown.consumables = consumableSpeed;
            breakdown.total += consumableSpeed.reduce((sum, c) => sum + c.speed, 0);

            return breakdown;
        }

        /**
         * Get consumable speed bonuses (Enhancing Teas only)
         * @param {Object} actionData - Action data
         * @param {Map} equipment - Equipment map
         * @param {Object} itemDetailMap - Item detail map
         * @returns {Array} Consumable speed info
         */
        getConsumableSpeed(actionData, equipment, itemDetailMap) {
            const actionType = actionData.type;
            const drinkSlots = dataManager$1.getActionDrinkSlots(actionType);
            if (!drinkSlots || drinkSlots.length === 0) return [];

            const consumables = [];

            // Only Enhancing is relevant (all actions except combat)
            if (actionType === '/action_types/combat') {
                return consumables;
            }

            // Get drink concentration using existing utility
            const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);

            // Check drink slots for Enhancing Teas
            const enhancingTeas = {
                '/items/enhancing_tea': { name: 'Enhancing Tea', baseSpeed: 0.02 },
                '/items/super_enhancing_tea': { name: 'Super Enhancing Tea', baseSpeed: 0.04 },
                '/items/ultra_enhancing_tea': { name: 'Ultra Enhancing Tea', baseSpeed: 0.06 },
            };

            for (const drink of drinkSlots) {
                if (!drink || !drink.itemHrid) continue;

                const teaInfo = enhancingTeas[drink.itemHrid];
                if (teaInfo) {
                    const scaledSpeed = teaInfo.baseSpeed * (1 + drinkConcentration);
                    consumables.push({
                        name: teaInfo.name,
                        baseSpeed: teaInfo.baseSpeed * 100,
                        drinkConcentration: drinkConcentration * 100,
                        speed: scaledSpeed * 100,
                    });
                }
            }

            return consumables;
        }

        /**
         * Create a quick input button
         * @param {string} label - Button label
         * @param {Function} onClick - Click handler
         * @returns {HTMLElement} Button element
         */
        createButton(label, onClick) {
            const button = document.createElement('button');
            button.textContent = label;
            button.className = 'mwi-quick-input-btn';
            button.style.cssText = `
            background-color: white;
            color: black;
            padding: 1px 6px;
            margin: 1px;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        `;

            // Hover effect
            button.addEventListener('mouseenter', () => {
                button.style.backgroundColor = '#f0f0f0';
            });
            button.addEventListener('mouseleave', () => {
                button.style.backgroundColor = 'white';
            });

            button.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                onClick();
            });

            return button;
        }

        /**
         * Set input value using React utility
         * @param {HTMLInputElement} input - Number input element
         * @param {number} value - Value to set
         */
        setInputValue(input, value) {
            setReactInputValue(input, value, { focus: true });
        }

        /**
         * Calculate maximum possible value based on inventory
         * @param {HTMLElement} panel - Action panel element
         * @param {Object} actionDetails - Action details from game data
         * @param {Object} gameData - Cached game data from dataManager
         * @returns {number|string} Maximum value (number for production, '∞' for gathering)
         */
        calculateMaxValue(panel, actionDetails, gameData) {
            try {
                // Gathering actions (no materials needed) - return infinity symbol
                if (!actionDetails.inputItems && !actionDetails.upgradeItemHrid) {
                    return '∞';
                }

                // Production actions - calculate based on available materials
                const inventory = dataManager$1.getInventory();
                if (!inventory) {
                    return 0; // No inventory data available
                }

                // Get Artisan Tea reduction if active
                const equipment = dataManager$1.getEquipment();
                const itemDetailMap = gameData?.itemDetailMap || {};
                const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);
                const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);
                const artisanBonus = parseArtisanBonus(activeDrinks, itemDetailMap, drinkConcentration);

                let maxActions = Infinity;

                // Check upgrade item first (e.g., Crimson Staff → Azure Staff)
                if (actionDetails.upgradeItemHrid) {
                    // Upgrade recipes require base item (enhancement level 0)
                    const upgradeItem = inventory.find(
                        (item) => item.itemHrid === actionDetails.upgradeItemHrid && item.enhancementLevel === 0
                    );
                    const availableAmount = upgradeItem?.count || 0;
                    const baseRequirement = 1; // Upgrade items always require exactly 1

                    // Upgrade items are NOT affected by Artisan Tea (only regular inputItems are)
                    // Materials are consumed PER ACTION (including instant repeats)
                    // Efficiency gives bonus actions for FREE (no material cost)
                    const materialsPerAction = baseRequirement;

                    if (materialsPerAction > 0) {
                        const possibleActions = Math.floor(availableAmount / materialsPerAction);
                        maxActions = Math.min(maxActions, possibleActions);
                    }
                }

                // Check regular input items (materials like lumber, etc.)
                if (actionDetails.inputItems && actionDetails.inputItems.length > 0) {
                    for (const input of actionDetails.inputItems) {
                        // Find ALL items with this HRID (different enhancement levels stack separately)
                        const allMatchingItems = inventory.filter((item) => item.itemHrid === input.itemHrid);

                        // Sum up counts across all enhancement levels
                        const availableAmount = allMatchingItems.reduce((total, item) => total + (item.count || 0), 0);
                        const baseRequirement = input.count;

                        // Apply Artisan reduction
                        // Materials are consumed PER ACTION (including instant repeats)
                        // Efficiency gives bonus actions for FREE (no material cost)
                        const materialsPerAction = baseRequirement * (1 - artisanBonus);

                        if (materialsPerAction > 0) {
                            const possibleActions = Math.floor(availableAmount / materialsPerAction);
                            maxActions = Math.min(maxActions, possibleActions);
                        }
                    }
                }

                // If we couldn't calculate (no materials found), return 0
                if (maxActions === Infinity) {
                    return 0;
                }

                return maxActions;
            } catch (error) {
                console.error('[Toolasha] Error calculating max value:', error);
                return 10000; // Safe fallback on error
            }
        }

        /**
         * Get character skill level for a skill type
         * @param {Array} skills - Character skills array
         * @param {string} skillType - Skill type HRID (e.g., "/action_types/cheesesmithing")
         * @returns {number} Skill level
         */
        getSkillLevel(skills, skillType) {
            // Map action type to skill HRID
            const skillHrid = skillType.replace('/action_types/', '/skills/');
            const skill = skills.find((s) => s.skillHrid === skillHrid);
            return skill?.level || 1;
        }

        /**
         * Get total efficiency percentage for current action
         * @param {Object} actionDetails - Action details
         * @param {Object} gameData - Game data
         * @returns {number} Total efficiency percentage
         */
        getTotalEfficiency(actionDetails, gameData) {
            const equipment = dataManager$1.getEquipment();
            const skills = dataManager$1.getSkills();
            const itemDetailMap = gameData?.itemDetailMap || {};

            // Calculate all efficiency components (reuse existing logic)
            const skillLevel = this.getSkillLevel(skills, actionDetails.type);
            const baseRequirement = actionDetails.levelRequirement?.level || 1;

            const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);
            const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);

            const actionLevelBonus = parseActionLevelBonus(activeDrinks, itemDetailMap, drinkConcentration);
            const effectiveRequirement = baseRequirement + Math.floor(actionLevelBonus);

            // Calculate tea skill level bonus (e.g., +8 Cheesesmithing from Ultra Cheesesmithing Tea)
            const teaSkillLevelBonus = parseTeaSkillLevelBonus(
                actionDetails.type,
                activeDrinks,
                itemDetailMap,
                drinkConcentration
            );

            // Apply tea skill level bonus to effective player level
            const effectiveLevel = skillLevel + teaSkillLevelBonus;
            const levelEfficiency = Math.max(0, effectiveLevel - effectiveRequirement);
            const houseEfficiency = calculateHouseEfficiency(actionDetails.type);
            const equipmentEfficiency = parseEquipmentEfficiencyBonuses(equipment, actionDetails.type, itemDetailMap);

            const teaBreakdown = parseTeaEfficiencyBreakdown(
                actionDetails.type,
                activeDrinks,
                itemDetailMap,
                drinkConcentration
            );
            const teaEfficiency = teaBreakdown.reduce((sum, tea) => sum + tea.efficiency, 0);

            const communityBuffLevel = dataManager$1.getCommunityBuffLevel('/community_buff_types/production_efficiency');
            const communityEfficiency = communityBuffLevel ? (0.14 + (communityBuffLevel - 1) * 0.003) * 100 : 0;

            return stackAdditive(levelEfficiency, houseEfficiency, equipmentEfficiency, teaEfficiency, communityEfficiency);
        }

        /**
         * Calculate actions and time needed to reach target level
         * Accounts for progressive efficiency gains (+1% per level)
         * Efficiency reduces actions needed (each action gives more XP) but not time per action
         * @param {number} currentLevel - Current skill level
         * @param {number} currentXP - Current experience points
         * @param {number} targetLevel - Target skill level
         * @param {number} baseEfficiency - Starting efficiency percentage
         * @param {number} actionTime - Time per action in seconds
         * @param {number} xpPerAction - Modified XP per action (with multipliers)
         * @param {Object} levelExperienceTable - XP requirements per level
         * @returns {Object} {actionsNeeded, timeNeeded}
         */
        calculateMultiLevelProgress(
            currentLevel,
            currentXP,
            targetLevel,
            baseEfficiency,
            actionTime,
            xpPerAction,
            levelExperienceTable
        ) {
            let totalActions = 0;
            let totalTime = 0;

            for (let level = currentLevel; level < targetLevel; level++) {
                // Calculate XP needed for this level
                let xpNeeded;
                if (level === currentLevel) {
                    // First level: Account for current progress
                    xpNeeded = levelExperienceTable[level + 1] - currentXP;
                } else {
                    // Subsequent levels: Full level requirement
                    xpNeeded = levelExperienceTable[level + 1] - levelExperienceTable[level];
                }

                // Progressive efficiency: +1% per level gained during grind
                const levelsGained = level - currentLevel;
                const progressiveEfficiency = baseEfficiency + levelsGained;
                const efficiencyMultiplier = 1 + progressiveEfficiency / 100;

                // Calculate XP per performed action (base XP × efficiency multiplier)
                // Efficiency means each action repeats, giving more XP per performed action
                const xpPerPerformedAction = xpPerAction * efficiencyMultiplier;

                // Calculate time-consuming actions needed for this level
                const baseActionsForLevel = Math.ceil(xpNeeded / xpPerPerformedAction);

                // Convert time-consuming actions to queued actions (instant repeats count toward queue total)
                const actionsToQueue = Math.round(baseActionsForLevel * efficiencyMultiplier);
                totalActions += actionsToQueue;

                // Time is based on time-consuming actions, not instant repeats
                totalTime += baseActionsForLevel * actionTime;
            }

            return { actionsNeeded: totalActions, timeNeeded: totalTime };
        }

        /**
         * Create level progress section
         * @param {Object} actionDetails - Action details from game data
         * @param {number} actionTime - Time per action in seconds
         * @param {Object} gameData - Cached game data from dataManager
         * @param {HTMLInputElement} numberInput - Queue input element
         * @returns {HTMLElement|null} Level progress section or null if not applicable
         */
        createLevelProgressSection(actionDetails, actionTime, gameData, numberInput) {
            try {
                // Get XP information from action
                const experienceGain = actionDetails.experienceGain;
                if (!experienceGain || !experienceGain.skillHrid || experienceGain.value <= 0) {
                    return null; // No XP gain for this action
                }

                const skillHrid = experienceGain.skillHrid;
                const xpPerAction = experienceGain.value;

                // Get character skills
                const skills = dataManager$1.getSkills();
                if (!skills) {
                    return null;
                }

                // Find the skill
                const skill = skills.find((s) => s.skillHrid === skillHrid);
                if (!skill) {
                    return null;
                }

                // Get level experience table
                const levelExperienceTable = gameData?.levelExperienceTable;
                if (!levelExperienceTable) {
                    return null;
                }

                // Current level and XP
                const currentLevel = skill.level;
                const currentXP = skill.experience || 0;

                // XP needed for next level
                const nextLevel = currentLevel + 1;
                const xpForNextLevel = levelExperienceTable[nextLevel];

                if (!xpForNextLevel) {
                    // Max level reached
                    return null;
                }

                // Calculate progress (XP gained this level / XP needed for this level)
                const xpForCurrentLevel = levelExperienceTable[currentLevel] || 0;
                const xpGainedThisLevel = currentXP - xpForCurrentLevel;
                const xpNeededThisLevel = xpForNextLevel - xpForCurrentLevel;
                const progressPercent = (xpGainedThisLevel / xpNeededThisLevel) * 100;
                const xpNeeded = xpForNextLevel - currentXP;

                // Calculate XP multipliers and breakdown (MUST happen before calculating actions/rates)
                const xpData = calculateExperienceMultiplier(skillHrid, actionDetails.type);

                // Calculate modified XP per action (base XP × multiplier)
                const baseXP = xpPerAction;
                const modifiedXP = xpPerAction * xpData.totalMultiplier;

                // Calculate actions and time needed (using modified XP)
                const actionsNeeded = Math.ceil(xpNeeded / modifiedXP);
                const _timeNeeded = actionsNeeded * actionTime;

                // Calculate rates using shared utility (includes efficiency)
                const expData = calculateExpPerHour(actionDetails.hrid);
                const xpPerHour =
                    expData?.expPerHour || (actionsNeeded > 0 ? calculateActionsPerHour(actionTime) * modifiedXP : 0);
                const xpPerDay = xpPerHour * 24;

                // Calculate daily level progress
                const _dailyLevelProgress = xpPerDay / xpNeededThisLevel;

                // Create content
                const content = document.createElement('div');
                content.style.cssText = `
                color: var(--text-color-secondary, ${config$1.COLOR_TEXT_SECONDARY});
                font-size: 0.9em;
                line-height: 1.6;
            `;

                const lines = [];

                // Current level and progress
                lines.push(`Current: Level ${currentLevel} | ${progressPercent.toFixed(1)}% to Level ${nextLevel}`);
                lines.push('');

                // Action details
                lines.push(
                    `XP per action: ${formatWithSeparator(baseXP.toFixed(1))} base → ${formatWithSeparator(modifiedXP.toFixed(1))} (×${xpData.totalMultiplier.toFixed(2)})`
                );

                // XP breakdown (if any bonuses exist)
                if (xpData.totalWisdom > 0 || xpData.charmExperience > 0) {
                    const totalXPBonus = xpData.totalWisdom + xpData.charmExperience;
                    lines.push(`  Total XP Bonus: +${totalXPBonus.toFixed(1)}%`);

                    // List all sources that contribute

                    // Equipment skill-specific XP (e.g., Celestial Shears foragingExperience)
                    if (xpData.charmBreakdown && xpData.charmBreakdown.length > 0) {
                        for (const item of xpData.charmBreakdown) {
                            const enhText = item.enhancementLevel > 0 ? ` +${item.enhancementLevel}` : '';
                            lines.push(`    • ${item.name}${enhText}: +${item.value.toFixed(1)}%`);
                        }
                    }

                    // Equipment wisdom (e.g., Necklace Of Wisdom, Philosopher's Necklace skillingExperience)
                    if (xpData.wisdomBreakdown && xpData.wisdomBreakdown.length > 0) {
                        for (const item of xpData.wisdomBreakdown) {
                            const enhText = item.enhancementLevel > 0 ? ` +${item.enhancementLevel}` : '';
                            lines.push(`    • ${item.name}${enhText}: +${item.value.toFixed(1)}%`);
                        }
                    }

                    // House rooms
                    if (xpData.breakdown.houseWisdom > 0) {
                        lines.push(`    • House Rooms: +${xpData.breakdown.houseWisdom.toFixed(1)}%`);
                    }

                    // Community buff
                    if (xpData.breakdown.communityWisdom > 0) {
                        lines.push(`    • Community Buff: +${xpData.breakdown.communityWisdom.toFixed(1)}%`);
                    }

                    // Tea/Coffee
                    if (xpData.breakdown.consumableWisdom > 0) {
                        lines.push(`    • Wisdom Tea: +${xpData.breakdown.consumableWisdom.toFixed(1)}%`);
                    }

                    // Achievement wisdom
                    if (xpData.breakdown.achievementWisdom > 0) {
                        lines.push(`    • Achievement: +${xpData.breakdown.achievementWisdom.toFixed(1)}%`);
                    }
                }

                // Get base efficiency for this action
                const baseEfficiency = this.getTotalEfficiency(actionDetails, gameData);

                lines.push('');

                // Single level progress (always shown)
                const singleLevel = this.calculateMultiLevelProgress(
                    currentLevel,
                    currentXP,
                    nextLevel,
                    baseEfficiency,
                    actionTime,
                    modifiedXP,
                    levelExperienceTable
                );

                lines.push(
                    `<span style="font-weight: 500; color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});">To Level ${nextLevel}:</span>`
                );
                lines.push(`  Actions: ${formatWithSeparator(singleLevel.actionsNeeded)}`);
                lines.push(`  Time: ${timeReadable(singleLevel.timeNeeded)}`);

                lines.push('');

                // Multi-level calculator (interactive section)
                lines.push(
                    `<span style="font-weight: 500; color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});">Target Level Calculator:</span>`
                );
                lines.push(`<div style="margin-top: 4px;">
                <span>To level </span>
                <input
                    type="number"
                    id="mwi-target-level-input"
                    value="${nextLevel}"
                    min="${nextLevel}"
                    max="200"
                    style="
                        width: 50px;
                        padding: 2px 4px;
                        background: var(--background-secondary, #2a2a2a);
                        color: var(--text-color-primary, ${config$1.COLOR_TEXT_PRIMARY});
                        border: 1px solid var(--border-color, ${config$1.COLOR_BORDER});
                        border-radius: 3px;
                        font-size: 0.9em;
                    "
                >
                <span>:</span>
            </div>`);

                // Dynamic result line (will be updated by JS)
                lines.push(`<div id="mwi-target-level-result" style="margin-top: 4px; margin-left: 8px;">
                ${formatWithSeparator(singleLevel.actionsNeeded)} actions | ${timeReadable(singleLevel.timeNeeded)}
            </div>`);

                lines.push('');
                lines.push(
                    `XP/hour: ${formatWithSeparator(Math.round(xpPerHour))} | XP/day: ${formatWithSeparator(Math.round(xpPerDay))}`
                );

                content.innerHTML = lines.join('<br>');

                // Set up event listeners for interactive calculator
                const targetLevelInput = content.querySelector('#mwi-target-level-input');
                const targetLevelResult = content.querySelector('#mwi-target-level-result');

                const updateTargetLevel = () => {
                    const targetLevel = parseInt(targetLevelInput.value);

                    if (targetLevel > currentLevel && targetLevel <= 200) {
                        const result = this.calculateMultiLevelProgress(
                            currentLevel,
                            currentXP,
                            targetLevel,
                            baseEfficiency,
                            actionTime,
                            modifiedXP,
                            levelExperienceTable
                        );

                        targetLevelResult.innerHTML = `
                        ${formatWithSeparator(result.actionsNeeded)} actions | ${timeReadable(result.timeNeeded)}
                    `;
                        targetLevelResult.style.color = 'var(--text-color-primary, ${config.COLOR_TEXT_PRIMARY})';

                        // Auto-fill queue input when target level changes
                        this.setInputValue(numberInput, result.actionsNeeded);
                    } else {
                        targetLevelResult.textContent = 'Invalid level';
                        targetLevelResult.style.color = 'var(--color-error, #ff4444)';
                    }
                };

                targetLevelInput.addEventListener('input', updateTargetLevel);
                targetLevelInput.addEventListener('change', updateTargetLevel);

                // Create summary for collapsed view (time to next level)
                const summary = `${timeReadable(singleLevel.timeNeeded)} to Level ${nextLevel}`;

                // Create collapsible section
                return createCollapsibleSection(
                    '📈',
                    'Level Progress',
                    summary,
                    content,
                    false // Collapsed by default
                );
            } catch (error) {
                console.error('[Toolasha] Error creating level progress section:', error);
                return null;
            }
        }

        /**
         * Disable quick input buttons (cleanup)
         */
        disable() {
            // Disconnect main observer
            if (this.observer) {
                this.observer.disconnect();
                this.observer = null;
            }

            // Note: inputObserver and newInputObserver are created locally in injectQuickInputButtons()
            // and attached to panels, which will be garbage collected when panels are removed.
            // They cannot be explicitly disconnected here, but this is acceptable as they're
            // short-lived observers tied to specific panel instances.

            this.isActive = false;
        }
    }

    const quickInputButtons = new QuickInputButtons();

    /**
     * Output Totals Display Module
     *
     * Shows total expected outputs below per-action outputs when user enters
     * a quantity in the action input box.
     *
     * Example:
     * - Game shows: "Outputs: 1.3 - 3.9 Flax"
     * - User enters: 100 actions
     * - Module shows: "130.0 - 390.0" below the per-action output
     */


    class OutputTotals {
        constructor() {
            this.observedInputs = new Map(); // input element → cleanup function
            this.unregisterObserver = null;
            this.isInitialized = false;
        }

        /**
         * Initialize the output totals display
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('actionPanel_outputTotals')) {
                return;
            }

            this.isInitialized = true;
            this.setupObserver();
        }

        /**
         * Setup DOM observer to watch for action detail panels
         */
        setupObserver() {
            // Watch for action detail panels appearing
            // The game shows action details when you click an action
            this.unregisterObserver = domObserver$1.onClass(
                'OutputTotals',
                'SkillActionDetail_skillActionDetail',
                (detailPanel) => {
                    this.attachToActionPanel(detailPanel);
                }
            );
        }

        /**
         * Attach input listener to an action panel
         * @param {HTMLElement} detailPanel - The action detail panel element
         */
        attachToActionPanel(detailPanel) {
            // Find the input box using utility
            const inputBox = findActionInput(detailPanel);
            if (!inputBox) {
                return;
            }

            // Avoid duplicate observers
            if (this.observedInputs.has(inputBox)) {
                return;
            }

            // Attach input listeners using utility
            const cleanup = attachInputListeners(detailPanel, inputBox, (_value) => {
                this.updateOutputTotals(detailPanel, inputBox);
            });

            // Store cleanup function
            this.observedInputs.set(inputBox, cleanup);

            // Initial update if there's already a value
            performInitialUpdate(inputBox, () => {
                this.updateOutputTotals(detailPanel, inputBox);
            });
        }

        /**
         * Update output totals based on input value
         * @param {HTMLElement} detailPanel - The action detail panel
         * @param {HTMLInputElement} inputBox - The action count input
         */
        updateOutputTotals(detailPanel, inputBox) {
            const amount = parseFloat(inputBox.value);

            // Remove existing totals (cloned outputs and XP)
            detailPanel.querySelectorAll('.mwi-output-total').forEach((el) => el.remove());

            // No amount entered - nothing to calculate
            if (isNaN(amount) || amount <= 0) {
                return;
            }

            // Find main drop container
            let dropTable = detailPanel.querySelector('[class*="SkillActionDetail_dropTable"]');
            if (!dropTable) return;

            const outputItems = detailPanel.querySelector('[class*="SkillActionDetail_outputItems"]');
            if (outputItems) dropTable = outputItems;

            // Track processed containers to avoid duplicates
            const processedContainers = new Set();

            // Process main outputs
            this.processDropContainer(dropTable, amount);
            processedContainers.add(dropTable);

            // Process Essences and Rares - find all dropTable containers
            const allDropTables = detailPanel.querySelectorAll('[class*="SkillActionDetail_dropTable"]');

            allDropTables.forEach((container) => {
                if (processedContainers.has(container)) {
                    return;
                }

                // Check for essences
                if (container.innerText.toLowerCase().includes('essence')) {
                    this.processDropContainer(container, amount);
                    processedContainers.add(container);
                    return;
                }

                // Check for rares (< 5% drop rate, not essences)
                if (container.innerText.includes('%')) {
                    const percentageMatch = container.innerText.match(/([\d.]+)%/);
                    if (percentageMatch && parseFloat(percentageMatch[1]) < 5) {
                        this.processDropContainer(container, amount);
                        processedContainers.add(container);
                    }
                }
            });

            // Process XP element
            this.processXpElement(detailPanel, amount);
        }

        /**
         * Process drop container (matches MWIT-E implementation)
         * @param {HTMLElement} container - The drop table container
         * @param {number} amount - Number of actions
         */
        processDropContainer(container, amount) {
            if (!container) return;

            const children = Array.from(container.children);

            children.forEach((child) => {
                // Skip if this child already has a total next to it
                if (child.nextSibling?.classList?.contains('mwi-output-total')) {
                    return;
                }

                // Check if this child has multiple drop elements
                const hasDropElements =
                    child.children.length > 1 && child.querySelector('[class*="SkillActionDetail_drop"]');

                if (hasDropElements) {
                    // Process multiple drop elements (typical for outputs/essences/rares)
                    const dropElements = child.querySelectorAll('[class*="SkillActionDetail_drop"]');
                    dropElements.forEach((dropEl) => {
                        // Skip if this drop element already has a total
                        if (dropEl.nextSibling?.classList?.contains('mwi-output-total')) {
                            return;
                        }
                        const clone = this.processChildElement(dropEl, amount);
                        if (clone) {
                            dropEl.after(clone);
                        }
                    });
                } else {
                    // Process single element
                    const clone = this.processChildElement(child, amount);
                    if (clone) {
                        child.parentNode.insertBefore(clone, child.nextSibling);
                    }
                }
            });
        }

        /**
         * Process a single child element and return clone with calculated total
         * @param {HTMLElement} child - The child element to process
         * @param {number} amount - Number of actions
         * @returns {HTMLElement|null} Clone element or null
         */
        processChildElement(child, amount) {
            // Look for output element (first child with numbers or ranges)
            const hasRange = child.children[0]?.innerText?.includes('-');
            const hasNumbers = child.children[0]?.innerText?.match(/[\d.]+/);

            const outputElement = hasRange || hasNumbers ? child.children[0] : null;

            if (!outputElement) return null;

            // Extract drop rate from the child's text
            const dropRateText = child.innerText;
            const rateMatch = dropRateText.match(/~?([\d.]+)%/);
            const dropRate = rateMatch ? parseFloat(rateMatch[1]) / 100 : 1; // Default to 100%

            // Parse output values
            const output = outputElement.innerText.split('-');

            // Create styled clone (same as MWIT-E)
            const clone = outputElement.cloneNode(true);
            clone.classList.add('mwi-output-total');

            // Determine color based on item type
            let color = config$1.COLOR_INFO; // Default blue for outputs

            if (child.innerText.toLowerCase().includes('essence')) {
                color = config$1.COLOR_ESSENCE; // Purple for essences
            } else if (dropRate < 0.05) {
                color = config$1.COLOR_WARNING; // Orange for rares (< 5% drop)
            }

            clone.style.cssText = `
            color: ${color};
            font-weight: 600;
            margin-top: 2px;
        `;

            // Calculate and set the expected output
            if (output.length > 1) {
                // Range output (e.g., "1.3 - 4")
                const minOutput = parseFloat(output[0].trim());
                const maxOutput = parseFloat(output[1].trim());
                const expectedMin = (minOutput * amount * dropRate).toLocaleString('en-US', {
                    minimumFractionDigits: 1,
                    maximumFractionDigits: 1,
                });
                const expectedMax = (maxOutput * amount * dropRate).toLocaleString('en-US', {
                    minimumFractionDigits: 1,
                    maximumFractionDigits: 1,
                });
                clone.innerText = `${expectedMin} - ${expectedMax}`;
            } else {
                // Single value output
                const value = parseFloat(output[0].trim());
                const expectedValue = (value * amount * dropRate).toLocaleString('en-US', {
                    minimumFractionDigits: 1,
                    maximumFractionDigits: 1,
                });
                clone.innerText = `${expectedValue}`;
            }

            return clone;
        }

        /**
         * Extract action HRID from detail panel
         * @param {HTMLElement} detailPanel - The action detail panel element
         * @returns {string|null} Action HRID or null
         */
        getActionHridFromPanel(detailPanel) {
            // Find action name element
            const nameElement = detailPanel.querySelector('[class*="SkillActionDetail_name"]');

            if (!nameElement) {
                return null;
            }

            const actionName = nameElement.textContent.trim();

            // Look up action by name in game data
            const initData = dataManager$1.getInitClientData();
            if (!initData) {
                return null;
            }

            for (const [hrid, action] of Object.entries(initData.actionDetailMap)) {
                if (action.name === actionName) {
                    return hrid;
                }
            }

            return null;
        }

        /**
         * Process XP element and display total XP
         * @param {HTMLElement} detailPanel - The action detail panel
         * @param {number} amount - Number of actions
         */
        processXpElement(detailPanel, amount) {
            // Find XP element
            const xpElement = detailPanel.querySelector('[class*="SkillActionDetail_expGain"]');
            if (!xpElement) {
                return;
            }

            // Get action HRID
            const actionHrid = this.getActionHridFromPanel(detailPanel);
            if (!actionHrid) {
                return;
            }

            const actionDetails = dataManager$1.getActionDetails(actionHrid);
            if (!actionDetails || !actionDetails.experienceGain) {
                return;
            }

            // Calculate experience multiplier (Wisdom + Charm Experience)
            const skillHrid = actionDetails.experienceGain.skillHrid;
            const xpData = calculateExperienceMultiplier(skillHrid, actionDetails.type);

            // Calculate total XP
            const baseXP = actionDetails.experienceGain.value;
            const modifiedXP = baseXP * xpData.totalMultiplier;
            const totalXP = modifiedXP * amount;

            // Create clone for total display
            const clone = xpElement.cloneNode(true);
            clone.classList.add('mwi-output-total');

            // Apply blue color for XP
            clone.style.cssText = `
            color: ${config$1.COLOR_INFO};
            font-weight: 600;
            margin-top: 2px;
        `;

            // Set total XP text (formatted with 1 decimal place and thousand separators)
            clone.childNodes[0].textContent = totalXP.toLocaleString('en-US', {
                minimumFractionDigits: 1,
                maximumFractionDigits: 1,
            });

            // Insert after original XP element
            xpElement.parentNode.insertBefore(clone, xpElement.nextSibling);
        }

        /**
         * Disable the output totals display
         */
        disable() {
            // Clean up all input observers
            for (const cleanup of this.observedInputs.values()) {
                cleanup();
            }
            this.observedInputs.clear();

            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            // Remove all injected elements
            document.querySelectorAll('.mwi-output-total').forEach((el) => el.remove());

            this.isInitialized = false;
        }
    }

    const outputTotals = new OutputTotals();

    /**
     * Action Panel Sort Manager
     *
     * Centralized sorting logic for action panels.
     * Handles both profit-based sorting and pin priority.
     * Used by max-produceable and gathering-stats features.
     */


    class ActionPanelSort {
        constructor() {
            this.panels = new Map(); // actionPanel → {actionHrid, profitPerHour}
            this.pinnedActions = new Set(); // Set of pinned action HRIDs
            this.sortTimeout = null; // Debounce timer
            this.initialized = false;
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Initialize - load pinned actions from storage
         */
        async initialize() {
            if (this.initialized) return;

            const pinnedData = await storage$1.getJSON('pinnedActions', 'settings', []);
            this.pinnedActions = new Set(pinnedData);
            this.initialized = true;
        }

        /**
         * Register a panel for sorting
         * @param {HTMLElement} actionPanel - The action panel element
         * @param {string} actionHrid - The action HRID
         * @param {number|null} profitPerHour - Profit per hour (null if not calculated yet)
         */
        registerPanel(actionPanel, actionHrid, profitPerHour = null) {
            this.panels.set(actionPanel, {
                actionHrid: actionHrid,
                profitPerHour: profitPerHour,
            });
        }

        /**
         * Update profit for a registered panel
         * @param {HTMLElement} actionPanel - The action panel element
         * @param {number|null} profitPerHour - Profit per hour
         */
        updateProfit(actionPanel, profitPerHour) {
            const data = this.panels.get(actionPanel);
            if (data) {
                data.profitPerHour = profitPerHour;
            }
        }

        /**
         * Unregister a panel (cleanup when panel removed from DOM)
         * @param {HTMLElement} actionPanel - The action panel element
         */
        unregisterPanel(actionPanel) {
            this.panels.delete(actionPanel);
        }

        /**
         * Toggle pin state for an action
         * @param {string} actionHrid - Action HRID to toggle
         * @returns {boolean} New pin state
         */
        async togglePin(actionHrid) {
            if (this.pinnedActions.has(actionHrid)) {
                this.pinnedActions.delete(actionHrid);
            } else {
                this.pinnedActions.add(actionHrid);
            }

            // Save to storage
            await storage$1.setJSON('pinnedActions', Array.from(this.pinnedActions), 'settings', true);

            return this.pinnedActions.has(actionHrid);
        }

        /**
         * Check if action is pinned
         * @param {string} actionHrid - Action HRID
         * @returns {boolean}
         */
        isPinned(actionHrid) {
            return this.pinnedActions.has(actionHrid);
        }

        /**
         * Get all pinned actions
         * @returns {Set<string>}
         */
        getPinnedActions() {
            return this.pinnedActions;
        }

        /**
         * Clear all panel references (called during character switch to prevent memory leaks)
         */
        clearAllPanels() {
            // Clear sort timeout
            if (this.sortTimeout) {
                clearTimeout(this.sortTimeout);
                this.sortTimeout = null;
            }

            this.timerRegistry.clearAll();

            // Clear all panel references
            this.panels.clear();
        }

        /**
         * Trigger a debounced sort
         */
        triggerSort() {
            this.scheduleSortIfEnabled();
        }

        /**
         * Schedule a sort to run after a short delay (debounced)
         */
        scheduleSortIfEnabled() {
            const sortByProfitEnabled = config$1.getSetting('actionPanel_sortByProfit');
            const hasPinnedActions = this.pinnedActions.size > 0;

            // Only sort if either profit sorting is enabled OR there are pinned actions
            if (!sortByProfitEnabled && !hasPinnedActions) {
                return;
            }

            // Clear existing timeout
            if (this.sortTimeout) {
                clearTimeout(this.sortTimeout);
            }

            // Schedule new sort after 300ms of inactivity (reduced from 500ms)
            this.sortTimeout = setTimeout(() => {
                this.sortPanelsByProfit();
                this.sortTimeout = null;
            }, 300);
            this.timerRegistry.registerTimeout(this.sortTimeout);
        }

        /**
         * Sort action panels by profit/hr (highest first), with pinned actions at top
         */
        sortPanelsByProfit() {
            const sortByProfitEnabled = config$1.getSetting('actionPanel_sortByProfit');

            // Group panels by their parent container
            const containerMap = new Map();

            // Clean up stale panels and group by container
            for (const [actionPanel, data] of this.panels.entries()) {
                const container = actionPanel.parentElement;

                // If no parent, panel is detached - clean it up
                if (!container) {
                    this.panels.delete(actionPanel);
                    continue;
                }

                if (!containerMap.has(container)) {
                    containerMap.set(container, []);
                }

                const isPinned = this.pinnedActions.has(data.actionHrid);
                const profitPerHour = data.profitPerHour ?? null;

                containerMap.get(container).push({
                    panel: actionPanel,
                    profit: profitPerHour,
                    pinned: isPinned,
                    originalIndex: containerMap.get(container).length,
                    actionHrid: data.actionHrid,
                });
            }

            // Dismiss any open tooltips before reordering (prevents stuck tooltips)
            // Only dismiss if a tooltip exists and its trigger is not hovered
            const openTooltip = document.querySelector('.MuiTooltip-popper');
            if (openTooltip) {
                const trigger = document.querySelector(`[aria-describedby="${openTooltip.id}"]`);
                if (!trigger || !trigger.matches(':hover')) {
                    dismissTooltips();
                }
            }

            // Sort and reorder each container
            for (const [container, panels] of containerMap.entries()) {
                panels.sort((a, b) => {
                    // Pinned actions always come first
                    if (a.pinned && !b.pinned) return -1;
                    if (!a.pinned && b.pinned) return 1;

                    // Both pinned - sort by profit if enabled, otherwise by original order
                    if (a.pinned && b.pinned) {
                        if (sortByProfitEnabled) {
                            if (a.profit === null && b.profit === null) return 0;
                            if (a.profit === null) return 1;
                            if (b.profit === null) return -1;
                            return b.profit - a.profit;
                        } else {
                            return a.originalIndex - b.originalIndex;
                        }
                    }

                    // Both unpinned - only sort by profit if setting is enabled
                    if (sortByProfitEnabled) {
                        if (a.profit === null && b.profit === null) return 0;
                        if (a.profit === null) return 1;
                        if (b.profit === null) return -1;
                        return b.profit - a.profit;
                    } else {
                        // Keep original order
                        return a.originalIndex - b.originalIndex;
                    }
                });

                // Reorder DOM elements using DocumentFragment to batch reflows
                // This prevents 50 individual reflows (one per appendChild)
                const fragment = document.createDocumentFragment();
                panels.forEach(({ panel }) => {
                    fragment.appendChild(panel);
                });
                container.appendChild(fragment);
            }
        }
    }

    const actionPanelSort = new ActionPanelSort();

    /**
     * Max Produceable Display Module
     *
     * Shows maximum craftable quantity on action panels based on current inventory.
     *
     * Example:
     * - Cheesy Sword requires: 10 Cheese, 5 Iron Bar
     * - Inventory: 120 Cheese, 65 Iron Bar
     * - Display: "Can produce: 12" (limited by 120/10 = 12)
     */


    /**
     * Action type constants for classification
     */
    const GATHERING_TYPES = ['/action_types/foraging', '/action_types/woodcutting', '/action_types/milking'];
    const PRODUCTION_TYPES$1 = [
        '/action_types/brewing',
        '/action_types/cooking',
        '/action_types/cheesesmithing',
        '/action_types/crafting',
        '/action_types/tailoring',
    ];

    /**
     * Build inventory index map for O(1) lookups
     * @param {Array} inventory - Inventory array from dataManager
     * @returns {Map} Map of itemHrid → inventory item
     */
    function buildInventoryIndex(inventory) {
        const index = new Map();
        for (const item of inventory) {
            if (item.itemLocationHrid === '/item_locations/inventory') {
                index.set(item.itemHrid, item);
            }
        }
        return index;
    }

    class MaxProduceable {
        constructor() {
            this.actionElements = new Map(); // actionPanel → {actionHrid, displayElement, pinElement}
            this.unregisterObserver = null;
            this.lastCrimsonMilkCount = null; // For debugging inventory updates
            this.itemsUpdatedHandler = null;
            this.actionCompletedHandler = null;
            this.characterSwitchingHandler = null; // Handler for character switch cleanup
            this.profitCalcTimeout = null; // Debounce timer for deferred profit calculations
            this.actionNameToHridCache = null; // Cached reverse lookup map (name → hrid)
            this.isInitialized = false;
            this.itemsUpdatedDebounceTimer = null; // Debounce timer for items_updated events
            this.actionCompletedDebounceTimer = null; // Debounce timer for action_completed events
            this.DEBOUNCE_DELAY = 300; // 300ms debounce for event handlers
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Initialize the max produceable display
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('actionPanel_maxProduceable')) {
                return;
            }

            this.isInitialized = true;

            // Initialize shared sort manager
            await actionPanelSort.initialize();

            this.setupObserver();

            // Store handler references for cleanup with debouncing
            this.itemsUpdatedHandler = () => {
                clearTimeout(this.itemsUpdatedDebounceTimer);
                this.itemsUpdatedDebounceTimer = setTimeout(() => {
                    this.updateAllCounts();
                }, this.DEBOUNCE_DELAY);
            };
            this.actionCompletedHandler = () => {
                clearTimeout(this.actionCompletedDebounceTimer);
                this.actionCompletedDebounceTimer = setTimeout(() => {
                    this.updateAllCounts();
                }, this.DEBOUNCE_DELAY);
            };
            this.characterSwitchingHandler = () => {
                this.clearAllReferences();
            };

            // Event-driven updates (no polling needed)
            dataManager$1.on('items_updated', this.itemsUpdatedHandler);
            dataManager$1.on('action_completed', this.actionCompletedHandler);
            dataManager$1.on('character_switching', this.characterSwitchingHandler);
        }

        /**
         * Setup DOM observer to watch for action panels
         */
        setupObserver() {
            // Watch for skill action panels (in skill screen, not detail modal)
            this.unregisterObserver = domObserver$1.onClass('MaxProduceable', 'SkillAction_skillAction', (actionPanel) => {
                this.injectMaxProduceable(actionPanel);

                // Schedule profit calculation after panels settle
                // This prevents 20-50 simultaneous API calls during character switch
                clearTimeout(this.profitCalcTimeout);
                this.profitCalcTimeout = setTimeout(() => {
                    this.updateAllCounts();
                }, 50); // Wait 50ms after last panel appears for better responsiveness
                this.timerRegistry.registerTimeout(this.profitCalcTimeout);
            });

            // Check for existing action panels that may already be open
            const existingPanels = document.querySelectorAll('[class*="SkillAction_skillAction"]');
            existingPanels.forEach((panel) => {
                this.injectMaxProduceable(panel);
            });

            // Calculate profits for existing panels after initial load
            if (existingPanels.length > 0) {
                clearTimeout(this.profitCalcTimeout);
                this.profitCalcTimeout = setTimeout(() => {
                    this.updateAllCounts();
                }, 50); // Fast initial load for better responsiveness
                this.timerRegistry.registerTimeout(this.profitCalcTimeout);
            }
        }

        /**
         * Inject max produceable display and pin icon into an action panel
         * @param {HTMLElement} actionPanel - The action panel element
         */
        injectMaxProduceable(actionPanel) {
            // Extract action HRID from panel
            const actionHrid = this.getActionHridFromPanel(actionPanel);

            if (!actionHrid) {
                return;
            }

            const actionDetails = dataManager$1.getActionDetails(actionHrid);
            if (!actionDetails) {
                return;
            }

            // Check if production action with inputs (for max produceable display)
            const isProductionAction = actionDetails.inputItems && actionDetails.inputItems.length > 0;

            // Check if already injected
            const existingDisplay = actionPanel.querySelector('.mwi-max-produceable');
            const existingPin = actionPanel.querySelector('.mwi-action-pin');
            if (existingPin) {
                // Re-register existing elements
                this.actionElements.set(actionPanel, {
                    actionHrid: actionHrid,
                    displayElement: existingDisplay || null,
                    pinElement: existingPin,
                });
                // Update pin state
                this.updatePinIcon(existingPin, actionHrid);
                // Note: Profit update is deferred to updateAllCounts() in setupObserver()
                return;
            }

            // Make sure the action panel has relative positioning
            if (actionPanel.style.position !== 'relative' && actionPanel.style.position !== 'absolute') {
                actionPanel.style.position = 'relative';
            }

            let display = null;

            // Only create max produceable display for production actions
            if (isProductionAction) {
                actionPanel.style.marginBottom = '70px';

                // Create display element
                display = document.createElement('div');
                display.className = 'mwi-max-produceable';
                display.style.cssText = `
                position: absolute;
                bottom: -65px;
                left: 0;
                right: 0;
                font-size: 0.85em;
                padding: 4px 8px;
                text-align: center;
                background: rgba(0, 0, 0, 0.7);
                border-top: 1px solid var(--border-color, ${config$1.COLOR_BORDER});
                z-index: 10;
            `;

                // Append stats display to action panel with absolute positioning
                actionPanel.appendChild(display);
            }

            // Create pin icon (for ALL actions - gathering and production)
            const pinIcon = document.createElement('div');
            pinIcon.className = 'mwi-action-pin';
            pinIcon.innerHTML = '📌'; // Pin emoji
            pinIcon.style.cssText = `
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 11;
            user-select: none;
            filter: grayscale(100%) brightness(0.7);
        `;
            pinIcon.title = 'Pin this action to keep it visible';

            // Pin hover effect
            pinIcon.addEventListener('mouseenter', () => {
                if (!actionPanelSort.isPinned(actionHrid)) {
                    pinIcon.style.filter = 'grayscale(50%) brightness(1)';
                }
            });
            pinIcon.addEventListener('mouseleave', () => {
                this.updatePinIcon(pinIcon, actionHrid);
            });

            // Pin click handler
            pinIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                this.togglePin(actionHrid, pinIcon);
            });

            // Set initial pin state
            this.updatePinIcon(pinIcon, actionHrid);

            actionPanel.appendChild(pinIcon);

            // Store reference
            this.actionElements.set(actionPanel, {
                actionHrid: actionHrid,
                displayElement: display,
                pinElement: pinIcon,
            });

            // Register panel with shared sort manager
            actionPanelSort.registerPanel(actionPanel, actionHrid);

            // Note: Profit calculation is deferred to updateAllCounts() in setupObserver()
            // This prevents 20-50 simultaneous API calls during character switch

            // Trigger debounced sort after panels are loaded
            actionPanelSort.triggerSort();
        }

        /**
         * Extract action HRID from action panel
         * @param {HTMLElement} actionPanel - The action panel element
         * @returns {string|null} Action HRID or null
         */
        getActionHridFromPanel(actionPanel) {
            // Try to find action name from panel
            const nameElement = actionPanel.querySelector('div[class*="SkillAction_name"]');

            if (!nameElement) {
                return null;
            }

            const actionName = nameElement.textContent.trim();

            // Build reverse lookup cache on first use (name → hrid)
            if (!this.actionNameToHridCache) {
                const initData = dataManager$1.getInitClientData();
                if (!initData) {
                    return null;
                }

                this.actionNameToHridCache = new Map();
                for (const [hrid, action] of Object.entries(initData.actionDetailMap)) {
                    this.actionNameToHridCache.set(action.name, hrid);
                }
            }

            // O(1) lookup instead of O(n) iteration
            return this.actionNameToHridCache.get(actionName) || null;
        }

        /**
         * Calculate max produceable count for an action
         * @param {string} actionHrid - The action HRID
         * @param {Map} inventoryIndex - Inventory index map (itemHrid → item)
         * @param {Object} gameData - Game data (optional, will fetch if not provided)
         * @returns {number|null} Max produceable count or null
         */
        calculateMaxProduceable(actionHrid, inventoryIndex = null, gameData = null) {
            const actionDetails = dataManager$1.getActionDetails(actionHrid);

            // Get inventory index if not provided
            if (!inventoryIndex) {
                const inventory = dataManager$1.getInventory();
                inventoryIndex = buildInventoryIndex(inventory);
            }

            if (!actionDetails || !inventoryIndex) {
                return null;
            }

            // Get Artisan Tea reduction if active (applies to input materials only, not upgrade items)
            const equipment = dataManager$1.getEquipment();
            const itemDetailMap = gameData?.itemDetailMap || dataManager$1.getInitClientData()?.itemDetailMap || {};
            const drinkConcentration = getDrinkConcentration(equipment, itemDetailMap);
            const activeDrinks = dataManager$1.getActionDrinkSlots(actionDetails.type);
            const artisanBonus = parseArtisanBonus(activeDrinks, itemDetailMap, drinkConcentration);

            // Calculate max crafts per input (using O(1) Map lookup instead of O(n) array find)
            const maxCraftsPerInput = actionDetails.inputItems.map((input) => {
                const invItem = inventoryIndex.get(input.itemHrid);
                const invCount = invItem?.count || 0;

                // Apply Artisan reduction (10% base, scaled by Drink Concentration)
                // Materials consumed per action = base requirement × (1 - artisan bonus)
                const materialsPerAction = input.count * (1 - artisanBonus);
                const maxCrafts = Math.floor(invCount / materialsPerAction);

                return maxCrafts;
            });

            let minCrafts = Math.min(...maxCraftsPerInput);

            // Check upgrade item (e.g., Enhancement Stones)
            // NOTE: Upgrade items are NOT affected by Artisan Tea (only regular inputItems are)
            if (actionDetails.upgradeItemHrid) {
                const upgradeItem = inventoryIndex.get(actionDetails.upgradeItemHrid);
                const upgradeCount = upgradeItem?.count || 0;
                minCrafts = Math.min(minCrafts, upgradeCount);
            }

            return minCrafts;
        }

        /**
         * Update display count for a single action panel
         * @param {HTMLElement} actionPanel - The action panel element
         * @param {Map} inventoryIndex - Inventory index map (optional)
         */
        async updateCount(actionPanel, inventoryIndex = null) {
            const data = this.actionElements.get(actionPanel);

            if (!data) {
                return;
            }

            // Only calculate max crafts for production actions with display element
            let maxCrafts = null;
            if (data.displayElement) {
                maxCrafts = this.calculateMaxProduceable(data.actionHrid, inventoryIndex, dataManager$1.getInitClientData());

                if (maxCrafts === null) {
                    data.displayElement.style.display = 'none';
                    return;
                }
            }

            // Calculate profit/hr (for both gathering and production)
            let profitPerHour = null;
            let hasMissingPrices = false;
            const actionDetails = dataManager$1.getActionDetails(data.actionHrid);

            if (actionDetails) {
                if (GATHERING_TYPES.includes(actionDetails.type)) {
                    const profitData = await calculateGatheringProfit(data.actionHrid);
                    profitPerHour = profitData?.profitPerHour || null;
                    hasMissingPrices = profitData?.hasMissingPrices || false;
                } else if (PRODUCTION_TYPES$1.includes(actionDetails.type)) {
                    const profitData = await calculateProductionProfit(data.actionHrid);
                    profitPerHour = profitData?.profitPerHour || null;
                    hasMissingPrices = profitData?.hasMissingPrices || false;
                }
            }

            // Store profit value for sorting and update shared sort manager
            const resolvedProfitPerHour = hasMissingPrices ? null : profitPerHour;
            data.profitPerHour = resolvedProfitPerHour;
            actionPanelSort.updateProfit(actionPanel, resolvedProfitPerHour);

            // Check if we should hide actions with negative profit (unless pinned)
            const hideNegativeProfit = config$1.getSetting('actionPanel_hideNegativeProfit');
            const isPinned = actionPanelSort.isPinned(data.actionHrid);
            if (hideNegativeProfit && resolvedProfitPerHour !== null && resolvedProfitPerHour < 0 && !isPinned) {
                // Hide the entire action panel (unless it's pinned)
                actionPanel.style.display = 'none';
                return;
            } else {
                // Show the action panel (in case it was previously hidden)
                actionPanel.style.display = '';
            }

            // Only update display element if it exists (production actions only)
            if (!data.displayElement) {
                return;
            }

            // Calculate exp/hr using shared utility
            const expData = calculateExpPerHour(data.actionHrid);
            const expPerHour = expData?.expPerHour || null;

            // Color coding for "Can produce"
            let canProduceColor;
            if (maxCrafts === 0) {
                canProduceColor = config$1.COLOR_LOSS; // Red - can't craft
            } else if (maxCrafts < 5) {
                canProduceColor = config$1.COLOR_WARNING; // Orange/yellow - low materials
            } else {
                canProduceColor = config$1.COLOR_PROFIT; // Green - plenty of materials
            }

            // Build display HTML
            let html = `<span style="color: ${canProduceColor};">Can produce: ${maxCrafts.toLocaleString()}</span>`;

            // Add profit/hr line if available
            if (hasMissingPrices) {
                html += `<br><span style="color: ${config$1.SCRIPT_COLOR_ALERT};">Profit/hr: -- ⚠</span>`;
            } else if (resolvedProfitPerHour !== null) {
                const profitColor = resolvedProfitPerHour >= 0 ? config$1.COLOR_PROFIT : config$1.COLOR_LOSS;
                const profitSign = resolvedProfitPerHour >= 0 ? '' : '-';
                html += `<br><span style="color: ${profitColor};">Profit/hr: ${profitSign}${formatKMB(Math.abs(resolvedProfitPerHour))}</span>`;
            }

            // Add exp/hr line if available
            if (expPerHour !== null && expPerHour > 0) {
                html += `<br><span style="color: #fff;">Exp/hr: ${formatKMB(expPerHour)}</span>`;
            }

            data.displayElement.style.display = 'block';
            data.displayElement.innerHTML = html;
        }

        /**
         * Update all counts
         */
        async updateAllCounts() {
            // Pre-load market API ONCE before all profit calculations
            // This prevents all 20+ calculations from triggering simultaneous fetches
            if (!marketAPI.isLoaded()) {
                await marketAPI.fetch();
            }

            // Get inventory once and build index for O(1) lookups
            const inventory = dataManager$1.getInventory();

            if (!inventory) {
                return;
            }

            // Build inventory index once (O(n) cost, but amortized across all panels)
            const inventoryIndex = buildInventoryIndex(inventory);

            // Clean up stale references and update valid ones
            const updatePromises = [];
            for (const actionPanel of [...this.actionElements.keys()]) {
                if (document.body.contains(actionPanel)) {
                    updatePromises.push(this.updateCount(actionPanel, inventoryIndex));
                } else {
                    // Panel no longer in DOM - remove injected elements BEFORE deleting from Map
                    const data = this.actionElements.get(actionPanel);
                    if (data) {
                        if (data.displayElement) {
                            data.displayElement.innerHTML = ''; // Clear innerHTML to break references
                            data.displayElement.remove();
                            data.displayElement = null; // Null out reference for GC
                        }
                        if (data.pinElement) {
                            data.pinElement.innerHTML = ''; // Clear innerHTML to break references
                            data.pinElement.remove();
                            data.pinElement = null; // Null out reference for GC
                        }
                    }
                    this.actionElements.delete(actionPanel);
                    actionPanelSort.unregisterPanel(actionPanel);
                }
            }

            // Wait for all updates to complete
            await Promise.all(updatePromises);

            // Trigger sort via shared manager
            actionPanelSort.triggerSort();
        }

        /**
         * Toggle pin state for an action
         * @param {string} actionHrid - Action HRID to toggle
         * @param {HTMLElement} pinIcon - Pin icon element
         */
        async togglePin(actionHrid, pinIcon) {
            await actionPanelSort.togglePin(actionHrid);

            // Update icon appearance
            this.updatePinIcon(pinIcon, actionHrid);

            // Re-sort and re-filter panels
            await this.updateAllCounts();
        }

        /**
         * Update pin icon appearance based on pinned state
         * @param {HTMLElement} pinIcon - Pin icon element
         * @param {string} actionHrid - Action HRID
         */
        updatePinIcon(pinIcon, actionHrid) {
            const isPinned = actionPanelSort.isPinned(actionHrid);
            if (isPinned) {
                // Pinned: Full color, bright, larger
                pinIcon.style.filter = 'grayscale(0%) brightness(1.2) drop-shadow(0 0 3px rgba(255, 100, 0, 0.8))';
                pinIcon.style.transform = 'scale(1.1)';
            } else {
                // Unpinned: Grayscale, dimmed, normal size
                pinIcon.style.filter = 'grayscale(100%) brightness(0.7)';
                pinIcon.style.transform = 'scale(1)';
            }
            pinIcon.title = isPinned ? 'Unpin this action' : 'Pin this action to keep it visible';
        }

        /**
         * Clear all DOM references to prevent memory leaks during character switch
         */
        clearAllReferences() {
            // Clear profit calculation timeout
            if (this.profitCalcTimeout) {
                clearTimeout(this.profitCalcTimeout);
                this.profitCalcTimeout = null;
            }

            this.timerRegistry.clearAll();

            // CRITICAL: Remove injected DOM elements BEFORE clearing Maps
            // This prevents detached SVG elements from accumulating
            // Note: .remove() is safe to call even if element is already detached
            for (const [_actionPanel, data] of this.actionElements.entries()) {
                if (data.displayElement) {
                    data.displayElement.innerHTML = ''; // Clear innerHTML to break event listener references
                    data.displayElement.remove();
                    data.displayElement = null; // Null out reference for GC
                }
                if (data.pinElement) {
                    data.pinElement.innerHTML = ''; // Clear innerHTML to break event listener references
                    data.pinElement.remove();
                    data.pinElement = null; // Null out reference for GC
                }
            }

            // Clear all action element references (prevents detached DOM memory leak)
            this.actionElements.clear();

            // Clear action name cache
            if (this.actionNameToHridCache) {
                this.actionNameToHridCache.clear();
                this.actionNameToHridCache = null;
            }

            // Clear shared sort manager's panel references
            actionPanelSort.clearAllPanels();
        }

        /**
         * Disable the max produceable display
         */
        disable() {
            // Clear debounce timers
            clearTimeout(this.itemsUpdatedDebounceTimer);
            clearTimeout(this.actionCompletedDebounceTimer);
            this.itemsUpdatedDebounceTimer = null;
            this.actionCompletedDebounceTimer = null;

            if (this.itemsUpdatedHandler) {
                dataManager$1.off('items_updated', this.itemsUpdatedHandler);
                this.itemsUpdatedHandler = null;
            }
            if (this.actionCompletedHandler) {
                dataManager$1.off('action_completed', this.actionCompletedHandler);
                this.actionCompletedHandler = null;
            }
            if (this.characterSwitchingHandler) {
                dataManager$1.off('character_switching', this.characterSwitchingHandler);
                this.characterSwitchingHandler = null;
            }

            // Clear all DOM references
            this.clearAllReferences();

            // Remove DOM observer
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            if (this.mutationObserver) {
                this.mutationObserver.disconnect();
                this.mutationObserver = null;
            }

            // Remove all injected elements
            document.querySelectorAll('.mwi-max-produceable').forEach((el) => el.remove());
            document.querySelectorAll('.mwi-action-pin').forEach((el) => el.remove());
            this.actionElements.clear();

            this.isInitialized = false;
        }
    }

    const maxProduceable = new MaxProduceable();

    /**
     * Gathering Stats Display Module
     *
     * Shows profit/hr and exp/hr on gathering action tiles
     * (foraging, woodcutting, milking)
     */


    class GatheringStats {
        constructor() {
            this.actionElements = new Map(); // actionPanel → {actionHrid, displayElement}
            this.unregisterObserver = null;
            this.itemsUpdatedHandler = null;
            this.actionCompletedHandler = null;
            this.characterSwitchingHandler = null; // Handler for character switch cleanup
            this.isInitialized = false;
            this.itemsUpdatedDebounceTimer = null; // Debounce timer for items_updated events
            this.actionCompletedDebounceTimer = null; // Debounce timer for action_completed events
            this.DEBOUNCE_DELAY = 300; // 300ms debounce for event handlers
        }

        /**
         * Initialize the gathering stats display
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('actionPanel_gatheringStats')) {
                return;
            }

            this.isInitialized = true;

            // Initialize shared sort manager
            await actionPanelSort.initialize();

            this.setupObserver();

            // Store handler references for cleanup with debouncing
            this.itemsUpdatedHandler = () => {
                clearTimeout(this.itemsUpdatedDebounceTimer);
                this.itemsUpdatedDebounceTimer = setTimeout(() => {
                    this.updateAllStats();
                }, this.DEBOUNCE_DELAY);
            };
            this.actionCompletedHandler = () => {
                clearTimeout(this.actionCompletedDebounceTimer);
                this.actionCompletedDebounceTimer = setTimeout(() => {
                    this.updateAllStats();
                }, this.DEBOUNCE_DELAY);
            };

            this.characterSwitchingHandler = () => {
                this.clearAllReferences();
            };

            // Event-driven updates (no polling needed)
            dataManager$1.on('items_updated', this.itemsUpdatedHandler);
            dataManager$1.on('action_completed', this.actionCompletedHandler);
            dataManager$1.on('character_switching', this.characterSwitchingHandler);
        }

        /**
         * Setup DOM observer to watch for action panels
         */
        setupObserver() {
            // Watch for skill action panels (in skill screen, not detail modal)
            this.unregisterObserver = domObserver$1.onClass('GatheringStats', 'SkillAction_skillAction', (actionPanel) => {
                this.injectGatheringStats(actionPanel);
            });

            // Check for existing action panels that may already be open
            const existingPanels = document.querySelectorAll('[class*="SkillAction_skillAction"]');
            existingPanels.forEach((panel) => {
                this.injectGatheringStats(panel);
            });
        }

        /**
         * Inject gathering stats display into an action panel
         * @param {HTMLElement} actionPanel - The action panel element
         */
        injectGatheringStats(actionPanel) {
            // Extract action HRID from panel
            const actionHrid = this.getActionHridFromPanel(actionPanel);

            if (!actionHrid) {
                return;
            }

            const actionDetails = dataManager$1.getActionDetails(actionHrid);

            // Only show for gathering actions (no inputItems)
            const gatheringTypes = ['/action_types/foraging', '/action_types/woodcutting', '/action_types/milking'];
            if (!actionDetails || !gatheringTypes.includes(actionDetails.type)) {
                return;
            }

            // Check if already injected
            const existingDisplay = actionPanel.querySelector('.mwi-gathering-stats');
            if (existingDisplay) {
                // Re-register existing display (DOM elements may be reused across navigation)
                this.actionElements.set(actionPanel, {
                    actionHrid: actionHrid,
                    displayElement: existingDisplay,
                });
                // Update with fresh data
                this.updateStats(actionPanel);
                // Register with shared sort manager
                actionPanelSort.registerPanel(actionPanel, actionHrid);
                // Trigger sort
                actionPanelSort.triggerSort();
                return;
            }

            // Create display element
            const display = document.createElement('div');
            display.className = 'mwi-gathering-stats';
            display.style.cssText = `
            position: absolute;
            bottom: -45px;
            left: 0;
            right: 0;
            font-size: 0.85em;
            padding: 4px 8px;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            border-top: 1px solid var(--border-color, ${config$1.COLOR_BORDER});
            z-index: 10;
        `;

            // Make sure the action panel has relative positioning and extra bottom margin
            if (actionPanel.style.position !== 'relative' && actionPanel.style.position !== 'absolute') {
                actionPanel.style.position = 'relative';
            }
            actionPanel.style.marginBottom = '50px';

            // Append directly to action panel with absolute positioning
            actionPanel.appendChild(display);

            // Store reference
            this.actionElements.set(actionPanel, {
                actionHrid: actionHrid,
                displayElement: display,
            });

            // Register with shared sort manager
            actionPanelSort.registerPanel(actionPanel, actionHrid);

            // Initial update
            this.updateStats(actionPanel);

            // Trigger sort
            actionPanelSort.triggerSort();
        }

        /**
         * Extract action HRID from action panel
         * @param {HTMLElement} actionPanel - The action panel element
         * @returns {string|null} Action HRID or null
         */
        getActionHridFromPanel(actionPanel) {
            // Try to find action name from panel
            const nameElement = actionPanel.querySelector('div[class*="SkillAction_name"]');

            if (!nameElement) {
                return null;
            }

            const actionName = nameElement.textContent.trim();

            // Look up action by name in game data
            const initData = dataManager$1.getInitClientData();
            if (!initData) {
                return null;
            }

            for (const [hrid, action] of Object.entries(initData.actionDetailMap)) {
                if (action.name === actionName) {
                    return hrid;
                }
            }

            return null;
        }

        /**
         * Update stats display for a single action panel
         * @param {HTMLElement} actionPanel - The action panel element
         */
        async updateStats(actionPanel) {
            const data = this.actionElements.get(actionPanel);

            if (!data) {
                return;
            }

            // Calculate profit/hr
            const profitData = await calculateGatheringProfit(data.actionHrid);
            const profitPerHour = profitData?.profitPerHour || null;

            // Calculate exp/hr using shared utility
            const expData = calculateExpPerHour(data.actionHrid);
            const expPerHour = expData?.expPerHour || null;

            // Store profit value for sorting and update shared sort manager
            data.profitPerHour = profitPerHour;
            actionPanelSort.updateProfit(actionPanel, profitPerHour);

            // Check if we should hide actions with negative profit (unless pinned)
            const hideNegativeProfit = config$1.getSetting('actionPanel_hideNegativeProfit');
            const isPinned = actionPanelSort.isPinned(data.actionHrid);
            if (hideNegativeProfit && profitPerHour !== null && profitPerHour < 0 && !isPinned) {
                // Hide the entire action panel
                actionPanel.style.display = 'none';
                return;
            } else {
                // Show the action panel (in case it was previously hidden)
                actionPanel.style.display = '';
            }

            // Build display HTML
            let html = '';

            // Add profit/hr line if available
            if (profitPerHour !== null) {
                const profitColor = profitPerHour >= 0 ? config$1.COLOR_PROFIT : config$1.COLOR_LOSS;
                const profitSign = profitPerHour >= 0 ? '' : '-';
                html += `<span style="color: ${profitColor};">Profit/hr: ${profitSign}${formatKMB(Math.abs(profitPerHour))}</span>`;
            }

            // Add exp/hr line if available
            if (expPerHour !== null && expPerHour > 0) {
                if (html) html += '<br>';
                html += `<span style="color: #fff;">Exp/hr: ${formatKMB(expPerHour)}</span>`;
            }

            data.displayElement.style.display = 'block';
            data.displayElement.innerHTML = html;
        }

        /**
         * Update all stats
         */
        async updateAllStats() {
            // Clean up stale references and update valid ones
            const updatePromises = [];
            for (const actionPanel of [...this.actionElements.keys()]) {
                if (document.body.contains(actionPanel)) {
                    updatePromises.push(this.updateStats(actionPanel));
                } else {
                    // Panel no longer in DOM - remove injected elements BEFORE deleting from Map
                    const data = this.actionElements.get(actionPanel);
                    if (data && data.displayElement) {
                        data.displayElement.innerHTML = ''; // Clear innerHTML to break references
                        data.displayElement.remove();
                        data.displayElement = null; // Null out reference for GC
                    }
                    this.actionElements.delete(actionPanel);
                    actionPanelSort.unregisterPanel(actionPanel);
                }
            }

            // Wait for all updates to complete
            await Promise.all(updatePromises);

            // Trigger sort via shared manager
            actionPanelSort.triggerSort();
        }

        /**
         * Clear all DOM references to prevent memory leaks during character switch
         */
        clearAllReferences() {
            // CRITICAL: Remove injected DOM elements BEFORE clearing Maps
            // This prevents detached SVG elements from accumulating
            // Note: .remove() is safe to call even if element is already detached
            for (const [_actionPanel, data] of this.actionElements.entries()) {
                if (data.displayElement) {
                    data.displayElement.innerHTML = ''; // Clear innerHTML to break event listener references
                    data.displayElement.remove();
                    data.displayElement = null; // Null out reference for GC
                }
            }

            // Clear all action element references (prevents detached DOM memory leak)
            this.actionElements.clear();

            // Clear shared sort manager's panel references
            actionPanelSort.clearAllPanels();
        }

        /**
         * Disable the gathering stats display
         */
        disable() {
            // Clear debounce timers
            clearTimeout(this.itemsUpdatedDebounceTimer);
            clearTimeout(this.actionCompletedDebounceTimer);
            this.itemsUpdatedDebounceTimer = null;
            this.actionCompletedDebounceTimer = null;

            if (this.itemsUpdatedHandler) {
                dataManager$1.off('items_updated', this.itemsUpdatedHandler);
                this.itemsUpdatedHandler = null;
            }
            if (this.actionCompletedHandler) {
                dataManager$1.off('action_completed', this.actionCompletedHandler);
                this.actionCompletedHandler = null;
            }
            if (this.characterSwitchingHandler) {
                dataManager$1.off('character_switching', this.characterSwitchingHandler);
                this.characterSwitchingHandler = null;
            }

            // Clear all DOM references
            this.clearAllReferences();

            // Remove DOM observer
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            // Remove all injected elements
            document.querySelectorAll('.mwi-gathering-stats').forEach((el) => el.remove());
            this.actionElements.clear();

            this.isInitialized = false;
        }
    }

    const gatheringStats = new GatheringStats();

    /**
     * Required Materials Display
     * Shows total required materials and missing amounts for production actions
     */


    class RequiredMaterials {
        constructor() {
            this.initialized = false;
            this.observers = [];
            this.processedPanels = new WeakSet();
        }

        initialize() {
            if (this.initialized) return;

            // Watch for action panels appearing
            const unregister = domObserver$1.onClass(
                'RequiredMaterials-ActionPanel',
                'SkillActionDetail_skillActionDetail',
                () => this.processActionPanels()
            );
            this.observers.push(unregister);

            // Process existing panels
            this.processActionPanels();

            this.initialized = true;
        }

        processActionPanels() {
            const panels = document.querySelectorAll('[class*="SkillActionDetail_skillActionDetail"]');

            panels.forEach((panel) => {
                if (this.processedPanels.has(panel)) {
                    return;
                }

                // Find the input box using utility
                const inputField = findActionInput(panel);
                if (!inputField) {
                    return;
                }

                // Mark as processed
                this.processedPanels.add(panel);

                // Attach input listeners using utility
                attachInputListeners(panel, inputField, (value) => {
                    this.updateRequiredMaterials(panel, value);
                });

                // Initial update if there's already a value
                performInitialUpdate(inputField, (value) => {
                    this.updateRequiredMaterials(panel, value);
                });
            });
        }

        updateRequiredMaterials(panel, amount) {
            // Remove existing displays
            const existingDisplays = panel.querySelectorAll('.mwi-required-materials');
            existingDisplays.forEach((el) => el.remove());

            const numActions = parseInt(amount) || 0;
            if (numActions <= 0) {
                return;
            }

            // Get action HRID from panel
            const actionHrid = this.getActionHridFromPanel(panel);
            if (!actionHrid) {
                return;
            }

            // Use shared material calculator with queue accounting (always enabled for Required Materials)
            const materials = calculateMaterialRequirements(actionHrid, numActions, true);
            if (!materials || materials.length === 0) {
                return;
            }

            // Find requirements container for regular materials
            const requiresDiv = panel.querySelector('[class*="SkillActionDetail_itemRequirements"]');
            if (!requiresDiv) {
                return;
            }

            // Process each material
            const children = Array.from(requiresDiv.children);
            let materialIndex = 0;

            // Separate upgrade items from regular materials
            const regularMaterials = materials.filter((m) => !m.isUpgradeItem);
            const upgradeMaterial = materials.find((m) => m.isUpgradeItem);

            // Process upgrade item first (if exists)
            if (upgradeMaterial) {
                this.processUpgradeItemWithData(panel, upgradeMaterial);
            }

            // Process regular materials
            children.forEach((child, index) => {
                if (child.className && child.className.includes('inputCount')) {
                    // Found an inputCount span - the next sibling is our target container
                    const targetContainer = requiresDiv.children[index + 1];
                    if (!targetContainer) return;

                    // Get corresponding material data
                    if (materialIndex >= regularMaterials.length) return;
                    const material = regularMaterials[materialIndex];

                    // Create display element
                    const displaySpan = document.createElement('span');
                    displaySpan.className = 'mwi-required-materials';
                    displaySpan.style.cssText = `
                    display: block;
                    font-size: 0.85em;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    margin-top: 2px;
                `;

                    // Build text with queue info
                    const queuedText = material.queued > 0 ? ` (${numberFormatter(material.queued)} Q'd)` : '';
                    let text = `Required: ${numberFormatter(material.required)}${queuedText}`;

                    if (material.missing > 0) {
                        const missingQueuedText = material.queued > 0 ? ` (${numberFormatter(material.queued)} Q'd)` : '';
                        text += ` || Missing: ${numberFormatter(material.missing)}${missingQueuedText}`;
                        displaySpan.style.color = config$1.COLOR_LOSS; // Missing materials
                    } else {
                        displaySpan.style.color = config$1.COLOR_PROFIT; // Sufficient materials
                    }

                    displaySpan.textContent = text;

                    // Append to target container
                    targetContainer.appendChild(displaySpan);

                    materialIndex++;
                }
            });
        }

        /**
         * Process upgrade item display with material data
         * @param {HTMLElement} panel - Action panel element
         * @param {Object} material - Material object from calculateMaterialRequirements
         */
        processUpgradeItemWithData(panel, material) {
            try {
                // Find upgrade item selector container
                const upgradeContainer = panel.querySelector('[class*="SkillActionDetail_upgradeItemSelectorInput"]');
                if (!upgradeContainer) {
                    return;
                }

                // Create display element (matching style of regular materials)
                const displaySpan = document.createElement('span');
                displaySpan.className = 'mwi-required-materials';
                displaySpan.style.cssText = `
                display: block;
                font-size: 0.85em;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                margin-top: 2px;
            `;

                // Build text with queue info
                const queuedText = material.queued > 0 ? ` (${numberFormatter(material.queued)} Q'd)` : '';
                let text = `Required: ${numberFormatter(material.required)}${queuedText}`;

                if (material.missing > 0) {
                    const missingQueuedText = material.queued > 0 ? ` (${numberFormatter(material.queued)} Q'd)` : '';
                    text += ` || Missing: ${numberFormatter(material.missing)}${missingQueuedText}`;
                    displaySpan.style.color = config$1.COLOR_LOSS; // Missing materials
                } else {
                    displaySpan.style.color = config$1.COLOR_PROFIT; // Sufficient materials
                }

                displaySpan.textContent = text;

                // Insert after entire upgrade container (not inside it)
                upgradeContainer.after(displaySpan);
            } catch (error) {
                console.error('[Required Materials] Error processing upgrade item:', error);
            }
        }

        /**
         * Get action HRID from panel
         * @param {HTMLElement} panel - Action panel element
         * @returns {string|null} Action HRID or null
         */
        getActionHridFromPanel(panel) {
            // Get action name from panel
            const actionNameElement = panel.querySelector('[class*="SkillActionDetail_name"]');
            if (!actionNameElement) {
                return null;
            }

            const actionName = actionNameElement.textContent.trim();
            return this.getActionHridFromName(actionName);
        }

        /**
         * Convert action name to HRID
         * @param {string} actionName - Display name of action
         * @returns {string|null} Action HRID or null if not found
         */
        getActionHridFromName(actionName) {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData?.actionDetailMap) {
                return null;
            }

            // Search for action by name
            for (const [hrid, detail] of Object.entries(gameData.actionDetailMap)) {
                if (detail.name === actionName) {
                    return hrid;
                }
            }

            return null;
        }
        cleanup() {
            this.observers.forEach((unregister) => unregister());
            this.observers = [];
            this.processedPanels = new WeakSet();

            document.querySelectorAll('.mwi-required-materials').forEach((el) => el.remove());

            this.initialized = false;
        }

        disable() {
            this.cleanup();
        }
    }

    const requiredMaterials = new RequiredMaterials();

    /**
     * Missing Materials Marketplace Button
     * Adds button to production panels that opens marketplace with tabs for missing materials
     */


    /**
     * Module-level state
     */
    let cleanupObserver = null;
    let currentMaterialsTabs = [];
    let domObserverUnregister = null;
    let processedPanels = new WeakSet();
    let inventoryUpdateHandler = null;
    let storedActionHrid = null;
    let storedNumActions = 0;
    let buyModalObserverUnregister = null;
    let activeMissingQuantity = null;
    const timerRegistry$1 = createTimerRegistry();

    /**
     * Production action types (where button should appear)
     */
    const PRODUCTION_TYPES = [
        '/action_types/brewing',
        '/action_types/cooking',
        '/action_types/cheesesmithing',
        '/action_types/crafting',
        '/action_types/tailoring',
    ];

    /**
     * Get the game object via React fiber
     * @returns {Object|null} Game component instance or null
     */
    function getGameObject() {
        const gamePageEl = document.querySelector('[class^="GamePage"]');
        if (!gamePageEl) return null;

        const fiberKey = Object.keys(gamePageEl).find((k) => k.startsWith('__reactFiber$'));
        if (!fiberKey) return null;

        return gamePageEl[fiberKey]?.return?.stateNode;
    }

    /**
     * Navigate to marketplace for a specific item
     * @param {string} itemHrid - Item HRID
     * @param {number} enhancementLevel - Enhancement level (default 0)
     */
    function goToMarketplace(itemHrid, enhancementLevel = 0) {
        const game = getGameObject();
        if (game?.handleGoToMarketplace) {
            game.handleGoToMarketplace(itemHrid, enhancementLevel);
        }
    }

    /**
     * Initialize missing materials button feature
     */
    function initialize$2() {
        setupMarketplaceCleanupObserver();
        setupBuyModalObserver();

        // Watch for action panels appearing
        domObserverUnregister = domObserver$1.onClass(
            'MissingMaterialsButton-ActionPanel',
            'SkillActionDetail_skillActionDetail',
            () => processActionPanels()
        );

        // Process existing panels
        processActionPanels();
    }

    /**
     * Cleanup function
     */
    function cleanup$1() {
        if (domObserverUnregister) {
            domObserverUnregister();
            domObserverUnregister = null;
        }

        // Disconnect marketplace cleanup observer
        if (cleanupObserver) {
            cleanupObserver();
            cleanupObserver = null;
        }

        if (buyModalObserverUnregister) {
            buyModalObserverUnregister();
            buyModalObserverUnregister = null;
        }

        // Remove any existing custom tabs
        removeMissingMaterialTabs();

        // Clear processed panels
        processedPanels = new WeakSet();

        timerRegistry$1.clearAll();
    }

    /**
     * Process action panels - watch for input changes
     */
    function processActionPanels() {
        const panels = document.querySelectorAll('[class*="SkillActionDetail_skillActionDetail"]');

        panels.forEach((panel) => {
            if (processedPanels.has(panel)) {
                return;
            }

            // Find the input box using utility
            const inputField = findActionInput(panel);
            if (!inputField) {
                return;
            }

            // Mark as processed
            processedPanels.add(panel);

            // Attach input listeners using utility
            attachInputListeners(panel, inputField, (value) => {
                updateButtonForPanel(panel, value);
            });

            // Initial update if there's already a value
            performInitialUpdate(inputField, (value) => {
                updateButtonForPanel(panel, value);
            });
        });
    }

    /**
     * Update button visibility and content for a panel based on input value
     * @param {HTMLElement} panel - Action panel element
     * @param {string} value - Input value (number of actions)
     */
    function updateButtonForPanel(panel, value) {
        const numActions = parseInt(value) || 0;

        // Remove existing button
        const existingButton = panel.querySelector('#mwi-missing-mats-button');
        if (existingButton) {
            existingButton.remove();
        }

        // Don't show button if no quantity entered
        if (numActions <= 0) {
            return;
        }

        // Check setting early
        if (!config$1.getSetting('actions_missingMaterialsButton')) {
            return;
        }

        const actionHrid = getActionHridFromPanel(panel);
        if (!actionHrid) {
            return;
        }

        const gameData = dataManager$1.getInitClientData();
        const actionDetail = gameData.actionDetailMap[actionHrid];
        if (!actionDetail) {
            return;
        }

        // Verify this is a production action
        if (!PRODUCTION_TYPES.includes(actionDetail.type)) {
            return;
        }

        // Check if action has input materials
        if (!actionDetail.inputItems || actionDetail.inputItems.length === 0) {
            return;
        }

        // Get missing materials using shared utility
        // Check if user wants to ignore queue (default: false, meaning we DO account for queue)
        const ignoreQueue = config$1.getSetting('actions_missingMaterialsButton_ignoreQueue') || false;
        const accountForQueue = !ignoreQueue; // Invert: ignoreQueue=false means accountForQueue=true
        const missingMaterials = calculateMaterialRequirements(actionHrid, numActions, accountForQueue);
        if (missingMaterials.length === 0) {
            return;
        }

        // Create and insert button with actionHrid and numActions for live updates
        const button = createMissingMaterialsButton(missingMaterials, actionHrid, numActions);

        // Find insertion point (beneath item requirements field)
        const itemRequirements = panel.querySelector('.SkillActionDetail_itemRequirements__3SPnA');
        if (itemRequirements) {
            itemRequirements.parentNode.insertBefore(button, itemRequirements.nextSibling);
        } else {
            // Fallback: insert at top of panel
            panel.insertBefore(button, panel.firstChild);
        }

        // Don't manipulate modal styling - let the game handle it
        // The modal will scroll naturally if content overflows
    }

    /**
     * Get action HRID from panel
     * @param {HTMLElement} panel - Action panel element
     * @returns {string|null} Action HRID or null
     */
    function getActionHridFromPanel(panel) {
        // Get action name from panel
        const actionNameElement = panel.querySelector('[class*="SkillActionDetail_name"]');
        if (!actionNameElement) {
            return null;
        }

        const actionName = actionNameElement.textContent.trim();
        return getActionHridFromName(actionName);
    }

    /**
     * Convert action name to HRID
     * @param {string} actionName - Display name of action
     * @returns {string|null} Action HRID or null if not found
     */
    function getActionHridFromName(actionName) {
        const gameData = dataManager$1.getInitClientData();
        if (!gameData?.actionDetailMap) {
            return null;
        }

        // Search for action by name
        for (const [hrid, detail] of Object.entries(gameData.actionDetailMap)) {
            if (detail.name === actionName) {
                return hrid;
            }
        }

        return null;
    }

    /**
     * Create missing materials marketplace button
     * @param {Array} missingMaterials - Array of missing material objects
     * @param {string} actionHrid - Action HRID for recalculating materials
     * @param {number} numActions - Number of actions for recalculating materials
     * @returns {HTMLElement} Button element
     */
    function createMissingMaterialsButton(missingMaterials, actionHrid, numActions) {
        const button = document.createElement('button');
        button.id = 'mwi-missing-mats-button';
        button.textContent = 'Missing Mats Marketplace';
        button.style.cssText = `
        width: 100%;
        padding: 10px 16px;
        margin: 8px 0 16px 0;
        background: linear-gradient(180deg, rgba(91, 141, 239, 0.2) 0%, rgba(91, 141, 239, 0.1) 100%);
        color: #ffffff;
        border: 1px solid rgba(91, 141, 239, 0.4);
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    `;

        // Hover effect
        button.addEventListener('mouseenter', () => {
            button.style.background = 'linear-gradient(180deg, rgba(91, 141, 239, 0.35) 0%, rgba(91, 141, 239, 0.25) 100%)';
            button.style.borderColor = 'rgba(91, 141, 239, 0.6)';
            button.style.boxShadow = '0 3px 6px rgba(0, 0, 0, 0.3)';
        });

        button.addEventListener('mouseleave', () => {
            button.style.background = 'linear-gradient(180deg, rgba(91, 141, 239, 0.2) 0%, rgba(91, 141, 239, 0.1) 100%)';
            button.style.borderColor = 'rgba(91, 141, 239, 0.4)';
            button.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.2)';
        });

        // Click handler
        button.addEventListener('click', async () => {
            await handleMissingMaterialsClick(missingMaterials, actionHrid, numActions);
        });

        return button;
    }

    /**
     * Handle missing materials button click
     * @param {Array} missingMaterials - Array of missing material objects
     * @param {string} actionHrid - Action HRID for recalculating materials
     * @param {number} numActions - Number of actions for recalculating materials
     */
    async function handleMissingMaterialsClick(missingMaterials, actionHrid, numActions) {
        // Store context for live updates
        storedActionHrid = actionHrid;
        storedNumActions = numActions;

        // Navigate to marketplace
        const success = await navigateToMarketplace();
        if (!success) {
            console.error('[MissingMats] Failed to navigate to marketplace');
            return;
        }

        // Wait a moment for marketplace to settle
        await new Promise((resolve) => {
            const delayTimeout = setTimeout(resolve, 200);
            timerRegistry$1.registerTimeout(delayTimeout);
        });

        // Create custom tabs
        createMissingMaterialTabs(missingMaterials);

        // Setup inventory listener for live updates
        setupInventoryListener();
    }

    /**
     * Navigate to marketplace by simulating click on navbar
     * @returns {Promise<boolean>} True if successful
     */
    async function navigateToMarketplace() {
        // Find marketplace navbar button
        const navButtons = document.querySelectorAll('.NavigationBar_nav__3uuUl');
        const marketplaceButton = Array.from(navButtons).find((nav) => {
            const svg = nav.querySelector('svg[aria-label="navigationBar.marketplace"]');
            return svg !== null;
        });

        if (!marketplaceButton) {
            console.error('[MissingMats] Marketplace navbar button not found');
            return false;
        }

        // Simulate click
        marketplaceButton.click();

        // Wait for marketplace panel to appear
        return await waitForMarketplace();
    }

    /**
     * Wait for marketplace panel to appear
     * @returns {Promise<boolean>} True if marketplace appeared within timeout
     */
    async function waitForMarketplace() {
        const maxAttempts = 50;
        const delayMs = 100;

        for (let i = 0; i < maxAttempts; i++) {
            // Check for marketplace panel by looking for tabs container
            const tabsContainer = document.querySelector('.MuiTabs-flexContainer[role="tablist"]');
            if (tabsContainer) {
                // Verify it's the marketplace tabs (has "Market Listings" tab)
                const hasMarketListings = Array.from(tabsContainer.children).some((btn) =>
                    btn.textContent.includes('Market Listings')
                );
                if (hasMarketListings) {
                    return true;
                }
            }

            await new Promise((resolve) => {
                const delayTimeout = setTimeout(resolve, delayMs);
                timerRegistry$1.registerTimeout(delayTimeout);
            });
        }

        console.error('[MissingMats] Marketplace did not open within timeout');
        return false;
    }

    /**
     * Create custom tabs for missing materials
     * @param {Array} missingMaterials - Array of missing material objects
     */
    function createMissingMaterialTabs(missingMaterials) {
        const tabsContainer = document.querySelector('.MuiTabs-flexContainer[role="tablist"]');

        if (!tabsContainer) {
            console.error('[MissingMats] Tabs container not found');
            return;
        }

        // Remove any existing custom tabs first
        removeMissingMaterialTabs();

        // Get reference tab for cloning (use "My Listings" as template)
        const referenceTab = Array.from(tabsContainer.children).find((btn) => btn.textContent.includes('My Listings'));

        if (!referenceTab) {
            console.error('[MissingMats] Reference tab not found');
            return;
        }

        // Enable flex wrapping for multiple rows (like game's native tabs)
        if (tabsContainer) {
            tabsContainer.style.flexWrap = 'wrap';
        }

        // Add click listeners to regular tabs to clear active quantity
        const regularTabs = tabsContainer.querySelectorAll('button:not([data-mwi-custom-tab])');
        regularTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                activeMissingQuantity = null;
            });
        });

        // Create tab for each missing material
        currentMaterialsTabs = [];
        for (const material of missingMaterials) {
            const tab = createCustomTab(material, referenceTab);
            tabsContainer.appendChild(tab);
            currentMaterialsTabs.push(tab);
        }
    }

    /**
     * Setup inventory listener for live tab updates
     * Listens for inventory changes via websocket and updates tabs accordingly
     */
    function setupInventoryListener() {
        // Remove existing listener if any
        if (inventoryUpdateHandler) {
            webSocketHook$1.off('*', inventoryUpdateHandler);
        }

        // Create new listener that watches for inventory-related messages
        inventoryUpdateHandler = (data) => {
            // Check if this message might affect inventory
            // Common message types that update inventory:
            // - item_added, item_removed, items_updated
            // - market_buy_complete, market_sell_complete
            // - Or any message with inventory field
            if (
                data.type?.includes('item') ||
                data.type?.includes('inventory') ||
                data.type?.includes('market') ||
                data.inventory ||
                data.characterItems
            ) {
                updateTabsOnInventoryChange();
            }
        };

        webSocketHook$1.on('*', inventoryUpdateHandler);
    }

    /**
     * Update all custom tabs when inventory changes
     * Recalculates materials and updates badge display
     */
    function updateTabsOnInventoryChange() {
        // Check if we have valid context
        if (!storedActionHrid || storedNumActions <= 0) {
            return;
        }

        // Check if tabs still exist
        if (currentMaterialsTabs.length === 0) {
            return;
        }

        // Recalculate materials with current inventory (respecting queue setting)
        const ignoreQueue = config$1.getSetting('actions_missingMaterialsButton_ignoreQueue') || false;
        const accountForQueue = !ignoreQueue;
        const updatedMaterials = calculateMaterialRequirements(storedActionHrid, storedNumActions, accountForQueue);

        // Update each existing tab
        currentMaterialsTabs.forEach((tab) => {
            const itemHrid = tab.getAttribute('data-item-hrid');
            const material = updatedMaterials.find((m) => m.itemHrid === itemHrid);

            if (material) {
                updateTabBadge(tab, material);
            }
        });
    }

    /**
     * Update a single tab's badge with new material data
     * @param {HTMLElement} tab - Tab element to update
     * @param {Object} material - Material object with updated counts
     */
    function updateTabBadge(tab, material) {
        const badgeSpan = tab.querySelector('.TabsComponent_badge__1Du26');
        if (!badgeSpan) {
            return;
        }

        // Color coding:
        // - Red: Missing materials (missing > 0)
        // - Green: Sufficient materials (missing = 0)
        // - Gray: Not tradeable
        let statusColor;
        let statusText;

        if (!material.isTradeable) {
            statusColor = '#888888'; // Gray - not tradeable
            statusText = 'Not Tradeable';
        } else if (material.missing > 0) {
            statusColor = '#ef4444'; // Red - missing materials
            // Show queued amount if any materials are reserved by queue
            const queuedText = material.queued > 0 ? ` (${formatWithSeparator(material.queued)} Q'd)` : '';
            statusText = `Missing: ${formatWithSeparator(material.missing)}${queuedText}`;
        } else {
            statusColor = '#4ade80'; // Green - sufficient materials
            statusText = 'Sufficient';
        }

        // Title case: capitalize first letter of each word
        const titleCaseName = material.itemName
            .split(' ')
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join(' ');

        // Update badge HTML
        badgeSpan.innerHTML = `
        <div style="text-align: center;">
            <div>${titleCaseName}</div>
            <div style="font-size: 0.75em; color: ${statusColor};">
                ${statusText}
            </div>
        </div>
    `;

        // Update tab styling based on state
        if (!material.isTradeable) {
            tab.style.opacity = '0.5';
            tab.style.cursor = 'not-allowed';
        } else {
            tab.style.opacity = '1';
            tab.style.cursor = 'pointer';
            tab.title = '';
        }
    }

    /**
     * Create a custom tab for a material
     * @param {Object} material - Material object with itemHrid, itemName, missing, have, isTradeable
     * @param {HTMLElement} referenceTab - Reference tab to clone structure from
     * @returns {HTMLElement} Custom tab element
     */
    function createCustomTab(material, referenceTab) {
        // Clone reference tab structure
        const tab = referenceTab.cloneNode(true);

        // Mark as custom tab for later identification
        tab.setAttribute('data-mwi-custom-tab', 'true');
        tab.setAttribute('data-item-hrid', material.itemHrid);
        tab.setAttribute('data-missing-quantity', material.missing.toString());

        // Color coding:
        // - Red: Missing materials (missing > 0)
        // - Green: Sufficient materials (missing = 0)
        // - Gray: Not tradeable
        let statusColor;
        let statusText;

        if (!material.isTradeable) {
            statusColor = '#888888'; // Gray - not tradeable
            statusText = 'Not Tradeable';
        } else if (material.missing > 0) {
            statusColor = '#ef4444'; // Red - missing materials
            // Show queued amount if any materials are reserved by queue
            const queuedText = material.queued > 0 ? ` (${formatWithSeparator(material.queued)} Q'd)` : '';
            statusText = `Missing: ${formatWithSeparator(material.missing)}${queuedText}`;
        } else {
            statusColor = '#4ade80'; // Green - sufficient materials
            statusText = 'Sufficient';
        }

        // Update text content
        const badgeSpan = tab.querySelector('.TabsComponent_badge__1Du26');
        if (badgeSpan) {
            // Title case: capitalize first letter of each word
            const titleCaseName = material.itemName
                .split(' ')
                .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');

            badgeSpan.innerHTML = `
            <div style="text-align: center;">
                <div>${titleCaseName}</div>
                <div style="font-size: 0.75em; color: ${statusColor};">
                    ${statusText}
                </div>
            </div>
        `;
        }

        // Gray out if not tradeable
        if (!material.isTradeable) {
            tab.style.opacity = '0.5';
            tab.style.cursor = 'not-allowed';
        }

        // Remove selected state
        tab.classList.remove('Mui-selected');
        tab.setAttribute('aria-selected', 'false');
        tab.setAttribute('tabindex', '-1');

        // Add click handler
        tab.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            if (!material.isTradeable) {
                // Not tradeable - do nothing
                return;
            }

            // Store the missing quantity for auto-fill when buy modal opens
            activeMissingQuantity = material.missing;

            // Navigate to marketplace using game API
            goToMarketplace(material.itemHrid, 0);
        });

        return tab;
    }

    /**
     * Remove all missing material tabs
     */
    function removeMissingMaterialTabs() {
        const customTabs = document.querySelectorAll('[data-mwi-custom-tab="true"]');
        customTabs.forEach((tab) => tab.remove());
        currentMaterialsTabs = [];

        // Clean up inventory listener
        if (inventoryUpdateHandler) {
            webSocketHook$1.off('*', inventoryUpdateHandler);
            inventoryUpdateHandler = null;
        }

        // Clear stored context
        storedActionHrid = null;
        storedNumActions = 0;
        activeMissingQuantity = null;
    }

    /**
     * Setup marketplace cleanup observer
     * Watches for marketplace panel removal and cleans up custom tabs
     */
    function setupMarketplaceCleanupObserver() {
        let debounceTimer = null;

        cleanupObserver = createMutationWatcher(
            document.body,
            (_mutations) => {
                // Only check if we have custom tabs
                if (currentMaterialsTabs.length === 0) {
                    return;
                }

                // Clear existing debounce timer
                if (debounceTimer) {
                    clearTimeout(debounceTimer);
                    debounceTimer = null;
                }

                // Debounce to avoid false positives from rapid DOM changes
                debounceTimer = setTimeout(() => {
                    // Check if we still have custom tabs
                    if (currentMaterialsTabs.length === 0) {
                        return;
                    }

                    // Check if our custom tabs still exist in the DOM
                    const hasCustomTabsInDOM = currentMaterialsTabs.some((tab) => document.body.contains(tab));

                    // If our tabs were removed from DOM, clean up references
                    if (!hasCustomTabsInDOM) {
                        removeMissingMaterialTabs();
                        return;
                    }

                    // Check if marketplace navbar is active
                    const marketplaceNavActive = Array.from(document.querySelectorAll('.NavigationBar_nav__3uuUl')).some(
                        (nav) => {
                            const svg = nav.querySelector('svg[aria-label="navigationBar.marketplace"]');
                            return svg && nav.classList.contains('NavigationBar_active__2Oj_e');
                        }
                    );

                    // Check if tabs container still exists (marketplace panel is open)
                    const tabsContainer = document.querySelector('.MuiTabs-flexContainer[role="tablist"]');
                    const hasMarketListingsTab =
                        tabsContainer &&
                        Array.from(tabsContainer.children).some((btn) => btn.textContent.includes('Market Listings'));

                    // Only cleanup if BOTH navbar is inactive AND marketplace tabs are gone
                    // This prevents cleanup during transitions when navbar might briefly be inactive
                    if (!marketplaceNavActive && !hasMarketListingsTab) {
                        removeMissingMaterialTabs();
                    }
                }, 100);
            },
            {
                childList: true,
                subtree: true,
            }
        );
    }

    /**
     * Setup buy modal observer
     * Watches for buy modals appearing and auto-fills quantity if from missing materials tab
     */
    function setupBuyModalObserver() {
        buyModalObserverUnregister = domObserver$1.onClass(
            'MissingMaterialsButton-BuyModal',
            'Modal_modalContainer',
            (modal) => {
                handleBuyModal(modal);
            }
        );
    }

    /**
     * Handle buy modal appearance
     * Auto-fills quantity if we have an active missing quantity
     * @param {HTMLElement} modal - Modal container element
     */
    function handleBuyModal(modal) {
        // Check if we have an active missing quantity to fill
        if (!activeMissingQuantity || activeMissingQuantity <= 0) {
            return;
        }

        // Check if this is a "Buy Now" modal
        const header = modal.querySelector('div[class*="MarketplacePanel_header"]');
        if (!header) {
            return;
        }

        const headerText = header.textContent.trim();
        if (!headerText.includes('Buy Now')) {
            return;
        }

        // Find the quantity input - need to be specific to avoid enhancement level input
        const quantityInput = findQuantityInput(modal);
        if (!quantityInput) {
            return;
        }

        // Set the quantity value
        const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;
        nativeInputValueSetter.call(quantityInput, activeMissingQuantity.toString());

        // Trigger input event to notify React
        const inputEvent = new Event('input', { bubbles: true });
        quantityInput.dispatchEvent(inputEvent);
    }

    /**
     * Find the quantity input in the buy modal
     * For equipment items, there are multiple number inputs (enhancement level + quantity)
     * We need to find the correct one by checking parent containers for label text
     * @param {HTMLElement} modal - Modal container element
     * @returns {HTMLInputElement|null} Quantity input element or null
     */
    function findQuantityInput(modal) {
        // Get all number inputs in the modal
        const allInputs = Array.from(modal.querySelectorAll('input[type="number"]'));

        if (allInputs.length === 0) {
            return null;
        }

        if (allInputs.length === 1) {
            // Only one input - must be quantity
            return allInputs[0];
        }

        // Multiple inputs - identify by checking CLOSEST parent first
        // Strategy 1: Check each parent level individually, prioritizing closer parents
        // This prevents matching on the outermost container that has all text
        for (let level = 0; level < 4; level++) {
            for (let i = 0; i < allInputs.length; i++) {
                const input = allInputs[i];
                let parent = input.parentElement;

                // Navigate to the specific level
                for (let j = 0; j < level && parent; j++) {
                    parent = parent.parentElement;
                }

                if (!parent) continue;

                const text = parent.textContent;

                // At this specific level, check if it contains "Quantity" but NOT "Enhancement Level"
                if (text.includes('Quantity') && !text.includes('Enhancement Level')) {
                    return input;
                }
            }
        }

        // Strategy 2: Exclude inputs that have "Enhancement Level" in close parents (level 0-2)
        for (let i = 0; i < allInputs.length; i++) {
            const input = allInputs[i];
            let parent = input.parentElement;
            let isEnhancementInput = false;

            // Check only the first 3 levels (not the outermost container)
            for (let j = 0; j < 3 && parent; j++) {
                const text = parent.textContent;

                if (text.includes('Enhancement Level') && !text.includes('Quantity')) {
                    isEnhancementInput = true;
                    break;
                }

                parent = parent.parentElement;
            }

            if (!isEnhancementInput) {
                return input;
            }
        }

        // Fallback: Return first input and log warning
        console.warn('[MissingMats] Could not definitively identify quantity input, using first input');
        return allInputs[0];
    }

    var missingMaterialsButton = {
        initialize: initialize$2,
        cleanup: cleanup$1,
    };

    /**
     * Alchemy Profit Calculator Module
     * Calculates real-time profit for alchemy actions accounting for:
     * - Success rate (failures consume materials but not catalyst)
     * - Efficiency bonuses
     * - Tea buff costs and duration
     * - Market prices (ask/bid based on pricing mode)
     */


    class AlchemyProfit {
        constructor() {
            this.cachedData = null;
            this.lastFingerprint = null;
        }

        /**
         * Extract alchemy action data from the DOM
         * @returns {Object|null} Action data or null if extraction fails
         */
        async extractActionData() {
            try {
                const alchemyComponent = document.querySelector('[class*="SkillActionDetail_alchemyComponent"]');
                if (!alchemyComponent) return null;

                // Get action HRID from current actions
                const actionHrid = this.getCurrentActionHrid();

                // Get success rate with breakdown
                const successRateBreakdown = this.extractSuccessRate();
                if (successRateBreakdown === null) return null;

                // Get action time (base 20 seconds)
                const actionSpeedBreakdown = this.extractActionSpeed();
                const actionTime = 20 / (1 + actionSpeedBreakdown.total);

                // Get efficiency
                const efficiencyBreakdown = this.extractEfficiency();

                // Get rare find
                const rareFindBreakdown = this.extractRareFind();

                // Get essence find
                const essenceFindBreakdown = this.extractEssenceFind();

                // Get requirements (inputs)
                const requirements = await this.extractRequirements();

                // Get drops (outputs) - now passing actionHrid for game data lookup
                const drops = await this.extractDrops(actionHrid);

                // Get catalyst
                const catalyst = await this.extractCatalyst();

                // Get consumables (tea/drinks)
                const consumables = await this.extractConsumables();
                const teaDuration = this.extractTeaDuration();

                return {
                    successRate: successRateBreakdown.total,
                    successRateBreakdown,
                    actionTime,
                    efficiency: efficiencyBreakdown.total,
                    efficiencyBreakdown,
                    actionSpeedBreakdown,
                    rareFindBreakdown,
                    essenceFindBreakdown,
                    requirements,
                    drops,
                    catalyst,
                    consumables,
                    teaDuration,
                };
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract action data:', error);
                return null;
            }
        }

        /**
         * Get current alchemy action HRID
         * @returns {string|null} Action HRID or null
         */
        getCurrentActionHrid() {
            try {
                // Get current actions from dataManager
                const currentActions = dataManager$1.getCurrentActions();
                if (!currentActions || currentActions.length === 0) return null;

                // Find alchemy action (type = /action_types/alchemy)
                for (const action of currentActions) {
                    if (action.actionHrid && action.actionHrid.startsWith('/actions/alchemy/')) {
                        return action.actionHrid;
                    }
                }

                return null;
            } catch (error) {
                console.error('[AlchemyProfit] Failed to get current action HRID:', error);
                return null;
            }
        }

        /**
         * Extract success rate with breakdown from the DOM and active buffs
         * @returns {Object} Success rate breakdown { total, base, tea }
         */
        extractSuccessRate() {
            try {
                const element = document.querySelector(
                    '[class*="SkillActionDetail_successRate"] [class*="SkillActionDetail_value"]'
                );
                if (!element) return null;

                const text = element.textContent.trim();
                const match = text.match(/(\d+\.?\d*)/);
                if (!match) return null;

                const totalSuccessRate = parseFloat(match[1]) / 100;

                // Calculate tea bonus from active drinks
                const gameData = dataManager$1.getInitClientData();
                if (!gameData) {
                    return {
                        total: totalSuccessRate,
                        base: totalSuccessRate,
                        tea: 0,
                    };
                }

                const actionTypeHrid = '/action_types/alchemy';
                const drinkSlots = dataManager$1.getActionDrinkSlots(actionTypeHrid);
                const equipment = dataManager$1.getEquipment();

                // Get drink concentration from equipment
                const drinkConcentration = getDrinkConcentration(equipment, gameData.itemDetailMap);

                // Calculate tea success rate bonus
                let teaBonus = 0;

                if (drinkSlots && drinkSlots.length > 0) {
                    for (const drink of drinkSlots) {
                        if (!drink || !drink.itemHrid) continue;

                        const itemDetails = gameData.itemDetailMap[drink.itemHrid];
                        if (!itemDetails || !itemDetails.consumableDetail || !itemDetails.consumableDetail.buffs) {
                            continue;
                        }

                        // Check for alchemy_success buff
                        for (const buff of itemDetails.consumableDetail.buffs) {
                            if (buff.typeHrid === '/buff_types/alchemy_success') {
                                // ratioBoost is a percentage multiplier (e.g., 0.05 = 5% of base)
                                // It scales with drink concentration
                                const ratioBoost = buff.ratioBoost * (1 + drinkConcentration);
                                teaBonus += ratioBoost;
                            }
                        }
                    }
                }

                // Calculate base success rate (before tea bonus)
                // Formula: total = base × (1 + tea_ratio_boost)
                // So: base = total / (1 + tea_ratio_boost)
                const baseSuccessRate = totalSuccessRate / (1 + teaBonus);

                return {
                    total: totalSuccessRate,
                    base: baseSuccessRate,
                    tea: teaBonus,
                };
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract success rate:', error);
                return null;
            }
        }

        /**
         * Extract action speed buff using dataManager (matches Action Panel pattern)
         * @returns {Object} Action speed breakdown { total, equipment, tea }
         */
        extractActionSpeed() {
            try {
                const gameData = dataManager$1.getInitClientData();
                if (!gameData) {
                    return { total: 0, equipment: 0, tea: 0 };
                }

                const equipment = dataManager$1.getEquipment();
                const actionTypeHrid = '/action_types/alchemy';

                // Parse equipment speed bonuses using utility
                const equipmentSpeed = parseEquipmentSpeedBonuses(equipment, actionTypeHrid, gameData.itemDetailMap);

                // TODO: Add tea speed bonuses when tea-parser supports it
                const teaSpeed = 0;

                const total = equipmentSpeed + teaSpeed;

                return {
                    total,
                    equipment: equipmentSpeed,
                    tea: teaSpeed,
                };
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract action speed:', error);
                return { total: 0, equipment: 0, tea: 0 };
            }
        }

        /**
         * Extract efficiency using dataManager (matches Action Panel pattern)
         * @returns {Object} Efficiency breakdown { total, level, house, tea, equipment, community }
         */
        extractEfficiency() {
            try {
                const gameData = dataManager$1.getInitClientData();
                if (!gameData) {
                    return { total: 0, level: 0, house: 0, tea: 0, equipment: 0, community: 0 };
                }

                const equipment = dataManager$1.getEquipment();
                const skills = dataManager$1.getSkills();
                const houseRooms = Array.from(dataManager$1.getHouseRooms().values());
                const actionTypeHrid = '/action_types/alchemy';

                // Get required level from the DOM (action-specific)
                const requiredLevel = this.extractRequiredLevel();

                // Get current alchemy level from character skills
                let currentLevel = requiredLevel;
                for (const skill of skills) {
                    if (skill.skillHrid === '/skills/alchemy') {
                        currentLevel = skill.level;
                        break;
                    }
                }

                // Calculate house efficiency bonus (room level × 1.5%)
                let houseEfficiency = 0;
                for (const room of houseRooms) {
                    const roomDetail = gameData.houseRoomDetailMap?.[room.houseRoomHrid];
                    if (roomDetail?.usableInActionTypeMap?.[actionTypeHrid]) {
                        houseEfficiency += (room.level || 0) * 1.5;
                    }
                }

                // Get equipped drink slots for alchemy
                const drinkSlots = dataManager$1.getActionDrinkSlots(actionTypeHrid);

                // Get drink concentration from equipment
                const drinkConcentration = getDrinkConcentration(equipment, gameData.itemDetailMap);

                // Parse tea efficiency bonus using utility
                const teaEfficiency = parseTeaEfficiency(
                    actionTypeHrid,
                    drinkSlots,
                    gameData.itemDetailMap,
                    drinkConcentration
                );

                // Parse tea skill level bonus (e.g., +8 Cheesesmithing from Ultra Cheesesmithing Tea)
                const teaLevelBonus = parseTeaSkillLevelBonus(
                    actionTypeHrid,
                    drinkSlots,
                    gameData.itemDetailMap,
                    drinkConcentration
                );

                // Calculate equipment efficiency bonus using utility
                const equipmentEfficiency = parseEquipmentEfficiencyBonuses(
                    equipment,
                    actionTypeHrid,
                    gameData.itemDetailMap
                );

                // Get community buff efficiency (Production Efficiency)
                const communityBuffLevel = dataManager$1.getCommunityBuffLevel('/community_buff_types/production_efficiency');
                let communityEfficiency = 0;
                if (communityBuffLevel > 0) {
                    // Formula: 0.14 + ((level - 1) × 0.003) = 14% base, +0.3% per level
                    const flatBoost = 0.14;
                    const flatBoostLevelBonus = 0.003;
                    const communityBonus = flatBoost + (communityBuffLevel - 1) * flatBoostLevelBonus;
                    communityEfficiency = communityBonus * 100; // Convert to percentage
                }

                // Get achievement buffs (Adept tier: +2% efficiency per tier)
                const achievementEfficiency =
                    dataManager$1.getAchievementBuffFlatBoost(actionTypeHrid, '/buff_types/efficiency') * 100;

                const efficiencyBreakdown = calculateEfficiencyBreakdown({
                    requiredLevel,
                    skillLevel: currentLevel,
                    teaSkillLevelBonus: teaLevelBonus,
                    houseEfficiency,
                    teaEfficiency,
                    equipmentEfficiency,
                    communityEfficiency,
                    achievementEfficiency,
                });
                const totalEfficiency = efficiencyBreakdown.totalEfficiency;
                const levelEfficiency = efficiencyBreakdown.levelEfficiency;

                return {
                    total: totalEfficiency / 100, // Convert percentage to decimal
                    level: levelEfficiency,
                    house: houseEfficiency,
                    tea: teaEfficiency,
                    equipment: equipmentEfficiency,
                    community: communityEfficiency,
                    achievement: achievementEfficiency,
                };
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract efficiency:', error);
                return { total: 0, level: 0, house: 0, tea: 0, equipment: 0, community: 0, achievement: 0 };
            }
        }

        /**
         * Extract rare find bonus from equipment and buffs
         * @returns {Object} Rare find breakdown { total, equipment, achievement }
         */
        extractRareFind() {
            try {
                const gameData = dataManager$1.getInitClientData();
                if (!gameData) {
                    return { total: 0, equipment: 0, achievement: 0 };
                }

                const equipment = dataManager$1.getEquipment();
                const actionTypeHrid = '/action_types/alchemy';

                // Parse equipment rare find bonuses
                let equipmentRareFind = 0;
                for (const slot of equipment) {
                    if (!slot || !slot.itemHrid) continue;

                    const itemDetail = gameData.itemDetailMap[slot.itemHrid];
                    if (!itemDetail?.noncombatStats?.rareFind) continue;

                    const enhancementLevel = slot.enhancementLevel || 0;
                    const enhancementBonus = this.getEnhancementBonus(enhancementLevel);
                    const slotMultiplier = this.getSlotMultiplier(itemDetail.equipmentType);

                    equipmentRareFind += itemDetail.noncombatStats.rareFind * (1 + enhancementBonus * slotMultiplier);
                }

                // Get achievement rare find bonus (Veteran tier: +2%)
                const achievementRareFind =
                    dataManager$1.getAchievementBuffFlatBoost(actionTypeHrid, '/buff_types/rare_find') * 100;

                const total = equipmentRareFind + achievementRareFind;

                return {
                    total: total / 100, // Convert to decimal
                    equipment: equipmentRareFind,
                    achievement: achievementRareFind,
                };
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract rare find:', error);
                return { total: 0, equipment: 0, achievement: 0 };
            }
        }

        /**
         * Extract essence find bonus from equipment and buffs
         * @returns {Object} Essence find breakdown { total, equipment }
         */
        extractEssenceFind() {
            try {
                const gameData = dataManager$1.getInitClientData();
                if (!gameData) {
                    return { total: 0, equipment: 0 };
                }

                const equipment = dataManager$1.getEquipment();

                // Parse equipment essence find bonuses
                let equipmentEssenceFind = 0;
                for (const slot of equipment) {
                    if (!slot || !slot.itemHrid) continue;

                    const itemDetail = gameData.itemDetailMap[slot.itemHrid];
                    if (!itemDetail?.noncombatStats?.essenceFind) continue;

                    const enhancementLevel = slot.enhancementLevel || 0;
                    const enhancementBonus = this.getEnhancementBonus(enhancementLevel);
                    const slotMultiplier = this.getSlotMultiplier(itemDetail.equipmentType);

                    equipmentEssenceFind += itemDetail.noncombatStats.essenceFind * (1 + enhancementBonus * slotMultiplier);
                }

                return {
                    total: equipmentEssenceFind / 100, // Convert to decimal
                    equipment: equipmentEssenceFind,
                };
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract essence find:', error);
                return { total: 0, equipment: 0 };
            }
        }

        /**
         * Get enhancement bonus percentage for a given enhancement level
         * @param {number} enhancementLevel - Enhancement level (0-20)
         * @returns {number} Enhancement bonus as decimal
         */
        getEnhancementBonus(enhancementLevel) {
            const bonuses = {
                0: 0,
                1: 0.02,
                2: 0.042,
                3: 0.066,
                4: 0.092,
                5: 0.12,
                6: 0.15,
                7: 0.182,
                8: 0.216,
                9: 0.252,
                10: 0.29,
                11: 0.334,
                12: 0.384,
                13: 0.44,
                14: 0.502,
                15: 0.57,
                16: 0.644,
                17: 0.724,
                18: 0.81,
                19: 0.902,
                20: 1.0,
            };
            return bonuses[enhancementLevel] || 0;
        }

        /**
         * Get slot multiplier for enhancement bonuses
         * @param {string} equipmentType - Equipment type HRID
         * @returns {number} Multiplier (1 or 5)
         */
        getSlotMultiplier(equipmentType) {
            // 5× multiplier for accessories, back, trinket, charm, pouch
            const fiveXSlots = [
                '/equipment_types/neck',
                '/equipment_types/ring',
                '/equipment_types/earrings',
                '/equipment_types/back',
                '/equipment_types/trinket',
                '/equipment_types/charm',
                '/equipment_types/pouch',
            ];
            return fiveXSlots.includes(equipmentType) ? 5 : 1;
        }

        /**
         * Extract required level from notes
         * @returns {number} Required alchemy level
         */
        extractRequiredLevel() {
            try {
                const notesEl = document.querySelector('[class*="SkillActionDetail_notes"]');
                if (!notesEl) return 0;

                const text = notesEl.textContent;
                const match = text.match(/(\d+)/);
                return match ? parseInt(match[1]) : 0;
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract required level:', error);
                return 0;
            }
        }

        /**
         * Extract tea buff duration from React props
         * @returns {number} Duration in seconds (default 300)
         */
        extractTeaDuration() {
            try {
                const container = document.querySelector('[class*="SkillActionDetail_alchemyComponent"]');
                if (!container || !container._reactProps) {
                    return 300;
                }

                let fiber = container._reactProps;
                for (const key in fiber) {
                    if (key.startsWith('__reactFiber') || key.startsWith('__reactInternalInstance')) {
                        fiber = fiber[key];
                        break;
                    }
                }

                let current = fiber;
                let depth = 0;

                while (current && depth < 20) {
                    if (current.memoizedProps?.actionBuffs) {
                        const buffs = current.memoizedProps.actionBuffs;

                        for (const buff of buffs) {
                            if (buff.uniqueHrid && buff.uniqueHrid.endsWith('tea')) {
                                const duration = buff.duration || 0;
                                return duration / 1e9; // Convert nanoseconds to seconds
                            }
                        }
                        break;
                    }

                    current = current.return;
                    depth++;
                }

                return 300; // Default 5 minutes
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract tea duration:', error);
                return 300;
            }
        }

        /**
         * Extract requirements (input materials) from the DOM
         * @returns {Promise<Array>} Array of requirement objects
         */
        async extractRequirements() {
            try {
                const elements = document.querySelectorAll(
                    '[class*="SkillActionDetail_itemRequirements"] [class*="Item_itemContainer"]'
                );
                const requirements = [];

                for (let i = 0; i < elements.length; i++) {
                    const el = elements[i];
                    const itemData = await this.extractItemData(el, true, i);
                    if (itemData) {
                        requirements.push(itemData);
                    }
                }

                return requirements;
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract requirements:', error);
                return [];
            }
        }

        /**
         * Extract drops (outputs) from the DOM
         * @returns {Promise<Array>} Array of drop objects
         */
        async extractDrops(actionHrid) {
            try {
                const elements = document.querySelectorAll(
                    '[class*="SkillActionDetail_dropTable"] [class*="Item_itemContainer"]'
                );
                const drops = [];

                // Get action details from game data for drop rates
                const gameData = dataManager$1.getInitClientData();
                const actionDetail = actionHrid && gameData ? gameData.actionDetailMap?.[actionHrid] : null;

                for (let i = 0; i < elements.length; i++) {
                    const el = elements[i];
                    const itemData = await this.extractItemData(el, false, i, actionDetail);
                    if (itemData) {
                        drops.push(itemData);
                    }
                }

                return drops;
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract drops:', error);
                return [];
            }
        }

        /**
         * Extract catalyst from the DOM
         * @returns {Promise<Object>} Catalyst object with prices
         */
        async extractCatalyst() {
            try {
                const element =
                    document.querySelector(
                        '[class*="SkillActionDetail_catalystItemInputContainer"] [class*="ItemSelector_itemContainer"]'
                    ) ||
                    document.querySelector(
                        '[class*="SkillActionDetail_catalystItemInputContainer"] [class*="SkillActionDetail_itemContainer"]'
                    );

                if (!element) {
                    return { ask: 0, bid: 0 };
                }

                const itemData = await this.extractItemData(element, false, -1);
                return itemData || { ask: 0, bid: 0 };
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract catalyst:', error);
                return { ask: 0, bid: 0 };
            }
        }

        /**
         * Extract consumables (tea/drinks) from the DOM
         * @returns {Promise<Array>} Array of consumable objects
         */
        async extractConsumables() {
            try {
                const elements = document.querySelectorAll(
                    '[class*="ActionTypeConsumableSlots_consumableSlots"] [class*="Item_itemContainer"]'
                );
                const consumables = [];

                for (const el of elements) {
                    const itemData = await this.extractItemData(el, false, -1);
                    if (itemData && itemData.itemHrid !== '/items/coin') {
                        consumables.push(itemData);
                    }
                }

                return consumables;
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract consumables:', error);
                return [];
            }
        }

        /**
         * Calculate the cost to create an enhanced item
         * @param {string} itemHrid - Item HRID
         * @param {number} targetLevel - Target enhancement level
         * @param {string} priceType - 'ask' or 'bid'
         * @returns {number} Total cost to create the enhanced item
         */
        calculateEnhancementCost(itemHrid, targetLevel, priceType) {
            if (targetLevel === 0) {
                const priceData = marketAPI.getPrice(itemHrid, 0);
                return priceType === 'ask' ? priceData?.ask || 0 : priceData?.bid || 0;
            }

            const gameData = dataManager$1.getInitClientData();
            if (!gameData) return 0;

            const itemData = gameData.itemDetailMap?.[itemHrid];
            if (!itemData) return 0;

            // Start with base item cost
            const basePriceData = marketAPI.getPrice(itemHrid, 0);
            let totalCost = priceType === 'ask' ? basePriceData?.ask || 0 : basePriceData?.bid || 0;

            // Add enhancement material costs for each level
            const enhancementMaterials = itemData.enhancementCosts;
            if (!enhancementMaterials || !Array.isArray(enhancementMaterials)) {
                return totalCost;
            }

            // Enhance from level 0 to targetLevel
            for (let level = 0; level < targetLevel; level++) {
                for (const cost of enhancementMaterials) {
                    const materialHrid = cost.itemHrid;
                    const materialCount = cost.count || 0;

                    if (materialHrid === '/items/coin') {
                        totalCost += materialCount; // Coins are 1:1
                    } else {
                        const materialPrice = marketAPI.getPrice(materialHrid, 0);
                        const price = priceType === 'ask' ? materialPrice?.ask || 0 : materialPrice?.bid || 0;
                        totalCost += price * materialCount;
                    }
                }
            }

            return totalCost;
        }

        /**
         * Calculate value recovered from decomposing an enhanced item
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level
         * @param {string} priceType - 'ask' or 'bid'
         * @returns {number} Total value recovered from decomposition
         */
        calculateDecompositionValue(itemHrid, enhancementLevel, priceType) {
            if (enhancementLevel === 0) return 0;

            const gameData = dataManager$1.getInitClientData();
            if (!gameData) return 0;

            const itemDetails = gameData.itemDetailMap?.[itemHrid];
            if (!itemDetails) return 0;

            let totalValue = 0;

            // 1. Base item decomposition outputs
            if (itemDetails.decompositionDetail?.results) {
                for (const result of itemDetails.decompositionDetail.results) {
                    const priceData = marketAPI.getPrice(result.itemHrid, 0);
                    if (priceData) {
                        const price = priceType === 'ask' ? priceData.ask : priceData.bid;
                        totalValue += calculatePriceAfterTax(price * result.amount); // 2% market tax
                    }
                }
            }

            // 2. Enhancing Essence from enhancement level
            // Formula: round(2 × (0.5 + 0.1 × (1.05^itemLevel)) × (2^enhancementLevel))
            const itemLevel = itemDetails.itemLevel || 1;
            const essenceAmount = Math.round(2 * (0.5 + 0.1 * Math.pow(1.05, itemLevel)) * Math.pow(2, enhancementLevel));

            const essencePriceData = marketAPI.getPrice('/items/enhancing_essence', 0);
            if (essencePriceData) {
                const essencePrice = priceType === 'ask' ? essencePriceData.ask : essencePriceData.bid;
                totalValue += calculatePriceAfterTax(essencePrice * essenceAmount); // 2% market tax
            }

            return totalValue;
        }

        /**
         * Extract item data (HRID, prices, count, drop rate) from DOM element
         * @param {HTMLElement} element - Item container element
         * @param {boolean} isRequirement - True if this is a requirement (has count), false if drop (has drop rate)
         * @param {number} index - Index in the list (for extracting count/rate text)
         * @returns {Promise<Object|null>} Item data object or null
         */
        async extractItemData(element, isRequirement, index, actionDetail = null) {
            try {
                // Get item HRID from SVG use element
                const use = element.querySelector('svg use');
                if (!use) return null;

                const href = use.getAttribute('href');
                if (!href) return null;

                const itemId = href.split('#')[1];
                if (!itemId) return null;

                const itemHrid = `/items/${itemId}`;

                // Get enhancement level
                let enhancementLevel = 0;
                if (isRequirement) {
                    const enhEl = element.querySelector('[class*="Item_enhancementLevel"]');
                    if (enhEl) {
                        const match = enhEl.textContent.match(/\+(\d+)/);
                        enhancementLevel = match ? parseInt(match[1]) : 0;
                    }
                }

                // Get market prices
                let ask = 0,
                    bid = 0;
                if (itemHrid === '/items/coin') {
                    ask = bid = 1;
                } else {
                    // Check if this is an openable container (loot crate)
                    const itemDetails = dataManager$1.getItemDetails(itemHrid);
                    if (itemDetails?.isOpenable) {
                        // Use expected value calculator for openable containers
                        const containerValue = expectedValueCalculator.getCachedValue(itemHrid);
                        if (containerValue !== null && containerValue > 0) {
                            ask = bid = containerValue;
                        } else {
                            // Fallback to marketplace if EV not available
                            const priceData = marketAPI.getPrice(itemHrid, enhancementLevel);
                            ask = priceData?.ask || 0;
                            bid = priceData?.bid || 0;
                        }
                    } else {
                        // Regular item - use marketplace price
                        const priceData = marketAPI.getPrice(itemHrid, enhancementLevel);
                        if (priceData && (priceData.ask > 0 || priceData.bid > 0)) {
                            // Market data exists for this specific enhancement level
                            ask = priceData.ask || 0;
                            bid = priceData.bid || 0;
                        } else {
                            // No market data for this enhancement level - calculate cost
                            ask = this.calculateEnhancementCost(itemHrid, enhancementLevel, 'ask');
                            bid = this.calculateEnhancementCost(itemHrid, enhancementLevel, 'bid');
                        }
                    }
                }

                const result = { itemHrid, ask, bid, enhancementLevel };

                // Get count or drop rate
                if (isRequirement && index >= 0) {
                    // Extract count from requirement
                    const countElements = document.querySelectorAll(
                        '[class*="SkillActionDetail_itemRequirements"] [class*="SkillActionDetail_inputCount"]'
                    );

                    if (countElements[index]) {
                        const text = countElements[index].textContent.trim();
                        // Extract number after the "/" character (format: "/ 2" or "/ 450")
                        const match = text.match(/\/\s*([\d,]+)/);
                        let parsedCount = 1;

                        if (match) {
                            const cleaned = match[1].replace(/,/g, '');
                            parsedCount = parseFloat(cleaned);
                        }

                        result.count = parsedCount || 1;
                    } else {
                        result.count = 1;
                    }
                } else if (!isRequirement) {
                    // Extract count and drop rate from action detail (game data) or DOM fallback
                    let dropRateFromGameData = null;

                    // Try to get drop rate from game data first
                    if (actionDetail && actionDetail.dropTable) {
                        const dropEntry = actionDetail.dropTable.find((drop) => drop.itemHrid === itemHrid);
                        if (dropEntry) {
                            dropRateFromGameData = dropEntry.dropRate;
                        }
                    }

                    // Extract count from DOM
                    const dropElements = document.querySelectorAll(
                        '[class*="SkillActionDetail_drop"], [class*="SkillActionDetail_essence"], [class*="SkillActionDetail_rare"]'
                    );

                    for (const dropElement of dropElements) {
                        // Check if this drop element contains our item
                        const dropItemElement = dropElement.querySelector('[class*="Item_itemContainer"] svg use');
                        if (dropItemElement) {
                            const dropHref = dropItemElement.getAttribute('href');
                            const dropItemId = dropHref ? dropHref.split('#')[1] : null;
                            const dropItemHrid = dropItemId ? `/items/${dropItemId}` : null;

                            if (dropItemHrid === itemHrid) {
                                // Found the matching drop element
                                const text = dropElement.textContent.trim();

                                // Extract count (at start of text)
                                const countMatch = text.match(/^([\d\s,.]+)/);
                                if (countMatch) {
                                    const cleaned = countMatch[1].replace(/,/g, '').trim();
                                    result.count = parseFloat(cleaned) || 1;
                                } else {
                                    result.count = 1;
                                }

                                // Use drop rate from game data if available, otherwise try DOM
                                if (dropRateFromGameData !== null) {
                                    result.dropRate = dropRateFromGameData;
                                } else {
                                    // Extract drop rate percentage from DOM (handles both "7.29%" and "~7.29%")
                                    const rateMatch = text.match(/~?([\d,.]+)%/);
                                    if (rateMatch) {
                                        const cleaned = rateMatch[1].replace(/,/g, '');
                                        result.dropRate = parseFloat(cleaned) / 100 || 1;
                                    } else {
                                        result.dropRate = 1;
                                    }
                                }

                                break; // Found it, stop searching
                            }
                        }
                    }

                    // If we didn't find a matching drop element, set defaults
                    if (result.count === undefined) {
                        result.count = 1;
                    }
                    if (result.dropRate === undefined) {
                        // Use game data drop rate if available, otherwise default to 1
                        result.dropRate = dropRateFromGameData !== null ? dropRateFromGameData : 1;
                    }
                }

                return result;
            } catch (error) {
                console.error('[AlchemyProfit] Failed to extract item data:', error);
                return null;
            }
        }

        /**
         * Generate state fingerprint for change detection
         * @returns {string} Fingerprint string
         */
        getStateFingerprint() {
            try {
                const successRate =
                    document.querySelector('[class*="SkillActionDetail_successRate"] [class*="SkillActionDetail_value"]')
                        ?.textContent || '';
                const consumables = Array.from(
                    document.querySelectorAll(
                        '[class*="ActionTypeConsumableSlots_consumableSlots"] [class*="Item_itemContainer"]'
                    )
                )
                    .map((el) => el.querySelector('svg use')?.getAttribute('href') || 'empty')
                    .join('|');

                // Get catalyst (from the catalyst input container)
                const catalyst =
                    document
                        .querySelector('[class*="SkillActionDetail_catalystItemInputContainer"] svg use')
                        ?.getAttribute('href') || 'none';

                // Get requirements (input materials)
                const requirements = Array.from(
                    document.querySelectorAll('[class*="SkillActionDetail_itemRequirements"] [class*="Item_itemContainer"]')
                )
                    .map((el) => {
                        const href = el.querySelector('svg use')?.getAttribute('href') || 'empty';
                        const enh = el.querySelector('[class*="Item_enhancementLevel"]')?.textContent || '0';
                        return `${href}${enh}`;
                    })
                    .join('|');

                // Don't include infoText - it contains our profit display which causes update loops
                return `${successRate}:${consumables}:${catalyst}:${requirements}`;
            } catch {
                return '';
            }
        }
    }

    const alchemyProfit = new AlchemyProfit();

    /**
     * Alchemy Profit Display Module
     * Displays profit calculator in alchemy action detail panel
     */


    class AlchemyProfitDisplay {
        constructor() {
            this.isActive = false;
            this.unregisterObserver = null;
            this.displayElement = null;
            this.updateTimeout = null;
            this.lastFingerprint = null;
            this.pollInterval = null;
            this.isInitialized = false;
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Initialize the display system
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('alchemy_profitDisplay')) {
                return;
            }

            this.isInitialized = true;
            this.setupObserver();
            this.isActive = true;
        }

        /**
         * Setup DOM observer to watch for alchemy panel
         */
        setupObserver() {
            // Observer for alchemy component appearing
            this.unregisterObserver = domObserver$1.onClass(
                'AlchemyProfitDisplay',
                'SkillActionDetail_alchemyComponent',
                (_alchemyComponent) => {
                    this.checkAndUpdateDisplay();
                }
            );

            // Initial check for existing panel
            this.checkAndUpdateDisplay();

            // Polling interval to check DOM state (like enhancement-ui.js does)
            // This catches state changes that the observer might miss
            this.pollInterval = setInterval(() => {
                this.checkAndUpdateDisplay();
            }, 200); // Check 5× per second for responsive updates
            this.timerRegistry.registerInterval(this.pollInterval);
        }

        /**
         * Check DOM state and update display accordingly
         * Pattern from enhancement-ui.js
         */
        checkAndUpdateDisplay() {
            // Query current DOM state
            const alchemyComponent = document.querySelector('[class*="SkillActionDetail_alchemyComponent"]');
            const instructionsEl = document.querySelector('[class*="SkillActionDetail_instructions"]');
            const infoContainer = document.querySelector('[class*="SkillActionDetail_info"]');

            // Determine if display should be shown
            // Show if: alchemy component exists AND instructions NOT present AND info container exists
            const shouldShow = alchemyComponent && !instructionsEl && infoContainer;

            if (shouldShow && (!this.displayElement || !this.displayElement.parentNode)) {
                // Should show but doesn't exist - create it
                this.handleAlchemyPanelUpdate(alchemyComponent);
            } else if (!shouldShow && this.displayElement?.parentNode) {
                // Shouldn't show but exists - remove it
                this.removeDisplay();
            } else if (shouldShow && this.displayElement?.parentNode) {
                // Should show and exists - check if state changed
                const fingerprint = alchemyProfit.getStateFingerprint();
                if (fingerprint !== this.lastFingerprint) {
                    this.handleAlchemyPanelUpdate(alchemyComponent);
                }
            }
        }

        /**
         * Handle alchemy panel update
         * @param {HTMLElement} alchemyComponent - Alchemy component container
         */
        handleAlchemyPanelUpdate(alchemyComponent) {
            // Get info container
            const infoContainer = alchemyComponent.querySelector('[class*="SkillActionDetail_info"]');
            if (!infoContainer) {
                this.removeDisplay();
                return;
            }

            // Check if state has changed
            const fingerprint = alchemyProfit.getStateFingerprint();
            if (fingerprint === this.lastFingerprint && this.displayElement?.parentNode) {
                return; // No change, display still valid
            }
            this.lastFingerprint = fingerprint;

            // Debounce updates
            if (this.updateTimeout) {
                clearTimeout(this.updateTimeout);
            }

            this.updateTimeout = setTimeout(() => {
                this.updateDisplay(infoContainer);
            }, 100);
            this.timerRegistry.registerTimeout(this.updateTimeout);
        }

        /**
         * Update or create profit display
         * @param {HTMLElement} infoContainer - Info container to append display to
         */
        async updateDisplay(infoContainer) {
            try {
                // Get current action HRID to determine action type
                const actionHrid = alchemyProfit.getCurrentActionHrid();

                let profitData = null;

                // Check alchemy action type by examining the drops and requirements
                const drops = await alchemyProfit.extractDrops(actionHrid);
                const requirements = await alchemyProfit.extractRequirements();

                // Determine action type from actionHrid (most reliable) or DOM tab state
                let isCoinify = false;
                let isTransmute = false;
                let isDecompose = false;

                if (actionHrid) {
                    // Player is actively performing an alchemy action - use actionHrid
                    isCoinify = actionHrid === '/actions/alchemy/coinify';
                    isTransmute = actionHrid === '/actions/alchemy/transmute';
                    isDecompose = actionHrid === '/actions/alchemy/decompose';
                } else {
                    // Not actively performing - check which tab is selected in the DOM
                    const selectedTab = document.querySelector(
                        '[class*="AlchemyPanel_tabButton"][aria-selected="true"], ' +
                            '[class*="AlchemyPanel_tab"][aria-selected="true"]'
                    );
                    const tabText = selectedTab?.textContent?.trim()?.toLowerCase() || '';

                    if (tabText.includes('coinify')) {
                        isCoinify = true;
                    } else if (tabText.includes('transmute')) {
                        isTransmute = true;
                    } else if (tabText.includes('decompose')) {
                        isDecompose = true;
                    } else {
                        // Final fallback: use drop/item data heuristics
                        isCoinify = drops.length > 0 && drops[0].itemHrid === '/items/coin';
                        if (!isCoinify && requirements && requirements.length > 0) {
                            const reqItemHrid = requirements[0].itemHrid;
                            const reqItemDetails = dataManager$1.getItemDetails(reqItemHrid);
                            isTransmute = !!reqItemDetails?.alchemyDetail?.transmuteDropTable;
                        }
                        isDecompose = !isCoinify && !isTransmute;
                    }
                }

                if (isCoinify) {
                    // Use unified calculator for coinify
                    if (requirements && requirements.length > 0) {
                        const itemHrid = requirements[0].itemHrid;
                        const enhancementLevel = requirements[0].enhancementLevel || 0;

                        // Call unified calculator
                        profitData = alchemyProfitCalculator.calculateCoinifyProfit(itemHrid, enhancementLevel);
                    }
                } else if (isTransmute) {
                    // Use unified calculator for transmute
                    if (requirements && requirements.length > 0) {
                        const itemHrid = requirements[0].itemHrid;

                        // Call unified calculator
                        profitData = alchemyProfitCalculator.calculateTransmuteProfit(itemHrid);
                    }
                } else if ((isDecompose || (!isCoinify && !isTransmute)) && requirements && requirements.length > 0) {
                    // Use unified calculator for decompose
                    const itemHrid = requirements[0].itemHrid;
                    const enhancementLevel = requirements[0].enhancementLevel || 0;

                    // Call unified calculator
                    profitData = alchemyProfitCalculator.calculateDecomposeProfit(itemHrid, enhancementLevel);
                }

                if (!profitData) {
                    this.removeDisplay();
                    return;
                }

                // Save expanded/collapsed state before recreating
                const expandedState = this.saveExpandedState();

                // Always recreate display (complex collapsible structure makes refresh difficult)
                this.createDisplay(infoContainer, profitData);

                // Restore expanded/collapsed state
                this.restoreExpandedState(expandedState);
            } catch (error) {
                console.error('[AlchemyProfitDisplay] Failed to update display:', error);
                this.removeDisplay();
            }
        }

        /**
         * Save the expanded/collapsed state of all collapsible sections
         * @returns {Map<string, boolean>} Map of section titles to their expanded state
         */
        saveExpandedState() {
            const state = new Map();

            if (!this.displayElement) {
                return state;
            }

            // Find all collapsible sections and save their state
            const sections = this.displayElement.querySelectorAll('.mwi-collapsible-section');
            sections.forEach((section) => {
                const header = section.querySelector('.mwi-section-header');
                const content = section.querySelector('.mwi-section-content');
                const label = header?.querySelector('span:last-child');

                if (label && content) {
                    const title = label.textContent.trim();
                    const isExpanded = content.style.display === 'block';
                    state.set(title, isExpanded);
                }
            });

            return state;
        }

        /**
         * Restore the expanded/collapsed state of collapsible sections
         * @param {Map<string, boolean>} state - Map of section titles to their expanded state
         */
        restoreExpandedState(state) {
            if (!this.displayElement || state.size === 0) {
                return;
            }

            // Find all collapsible sections and restore their state
            const sections = this.displayElement.querySelectorAll('.mwi-collapsible-section');
            sections.forEach((section) => {
                const header = section.querySelector('.mwi-section-header');
                const content = section.querySelector('.mwi-section-content');
                const summary = section.querySelector('div[style*="margin-left: 16px"]');
                const arrow = header?.querySelector('span:first-child');
                const label = header?.querySelector('span:last-child');

                if (label && content && arrow) {
                    const title = label.textContent.trim();
                    const shouldBeExpanded = state.get(title);

                    if (shouldBeExpanded !== undefined && shouldBeExpanded) {
                        // Expand this section
                        content.style.display = 'block';
                        if (summary) {
                            summary.style.display = 'none';
                        }
                        arrow.textContent = '▼';
                    }
                }
            });
        }

        /**
         * Create profit display element with detailed breakdown
         * @param {HTMLElement} container - Container to append to
         * @param {Object} profitData - Profit calculation results from calculateProfit()
         */
        createDisplay(container, profitData) {
            // Remove any existing display
            this.removeDisplay();

            // Validate required data
            if (
                !profitData ||
                !profitData.dropRevenues ||
                !profitData.requirementCosts ||
                !profitData.catalystCost ||
                !profitData.consumableCosts
            ) {
                console.error('[AlchemyProfitDisplay] Missing required profit data fields:', profitData);
                return;
            }

            // Extract summary values
            const profit = Math.round(profitData.profitPerHour);
            const profitPerDay = Math.round(profitData.profitPerDay);
            const revenue = Math.round(profitData.revenuePerHour);
            const costs = Math.round(
                profitData.materialCostPerHour + profitData.catalystCostPerHour + profitData.totalTeaCostPerHour
            );
            const summary = `${formatLargeNumber(profit)}/hr, ${formatLargeNumber(profitPerDay)}/day`;

            const detailsContent = document.createElement('div');

            // Revenue Section
            const revenueDiv = document.createElement('div');
            revenueDiv.innerHTML = `<div style="font-weight: 500; color: var(--text-color-primary, #fff); margin-bottom: 4px;">Revenue: ${formatLargeNumber(revenue)}/hr</div>`;

            // Split drops into normal, essence, and rare
            const normalDrops = profitData.dropRevenues.filter((drop) => !drop.isEssence && !drop.isRare);
            const essenceDrops = profitData.dropRevenues.filter((drop) => drop.isEssence);
            const rareDrops = profitData.dropRevenues.filter((drop) => drop.isRare);

            // Normal Drops subsection
            if (normalDrops.length > 0) {
                const normalDropsContent = document.createElement('div');
                let normalDropsRevenue = 0;

                for (const drop of normalDrops) {
                    const itemDetails = dataManager$1.getItemDetails(drop.itemHrid);
                    const itemName = itemDetails?.name || drop.itemHrid;
                    const decimals = drop.dropsPerHour < 1 ? 2 : 1;
                    const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);

                    const dropsDisplay =
                        drop.dropsPerHour >= 10000
                            ? formatLargeNumber(Math.round(drop.dropsPerHour))
                            : drop.dropsPerHour.toFixed(decimals);

                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';
                    line.textContent = `• ${itemName}: ${dropsDisplay}/hr (${dropRatePct} × ${formatPercentage(profitData.successRate, 1)} success) @ ${formatWithSeparator(Math.round(drop.price))} → ${formatLargeNumber(Math.round(drop.revenuePerHour))}/hr`;
                    normalDropsContent.appendChild(line);

                    normalDropsRevenue += drop.revenuePerHour;
                }

                const normalDropsSection = createCollapsibleSection(
                    '',
                    `Normal Drops: ${formatLargeNumber(Math.round(normalDropsRevenue))}/hr (${normalDrops.length} item${normalDrops.length !== 1 ? 's' : ''})`,
                    null,
                    normalDropsContent,
                    false,
                    1
                );
                revenueDiv.appendChild(normalDropsSection);
            }

            // Essence Drops subsection
            if (essenceDrops.length > 0) {
                const essenceContent = document.createElement('div');
                let essenceRevenue = 0;

                for (const drop of essenceDrops) {
                    const itemDetails = dataManager$1.getItemDetails(drop.itemHrid);
                    const itemName = itemDetails?.name || drop.itemHrid;
                    const decimals = drop.dropsPerHour < 1 ? 2 : 1;
                    const dropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);

                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';
                    line.textContent = `• ${itemName}: ${drop.dropsPerHour.toFixed(decimals)}/hr (${dropRatePct}, not affected by success rate) @ ${formatWithSeparator(Math.round(drop.price))} → ${formatLargeNumber(Math.round(drop.revenuePerHour))}/hr`;
                    essenceContent.appendChild(line);

                    essenceRevenue += drop.revenuePerHour;
                }

                const essenceSection = createCollapsibleSection(
                    '',
                    `Essence Drops: ${formatLargeNumber(Math.round(essenceRevenue))}/hr (${essenceDrops.length} item${essenceDrops.length !== 1 ? 's' : ''})`,
                    null,
                    essenceContent,
                    false,
                    1
                );
                revenueDiv.appendChild(essenceSection);
            }

            // Rare Drops subsection
            if (rareDrops.length > 0) {
                const rareContent = document.createElement('div');
                let rareRevenue = 0;

                for (const drop of rareDrops) {
                    const itemDetails = dataManager$1.getItemDetails(drop.itemHrid);
                    const itemName = itemDetails?.name || drop.itemHrid;
                    const decimals = drop.dropsPerHour < 1 ? 2 : 1;
                    const baseDropRatePct = formatPercentage(drop.dropRate, drop.dropRate < 0.01 ? 3 : 2);
                    const effectiveDropRatePct = formatPercentage(
                        drop.effectiveDropRate,
                        drop.effectiveDropRate < 0.01 ? 3 : 2
                    );

                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';

                    // Show both base and effective drop rate (not affected by success rate)
                    if (profitData.rareFindBreakdown && profitData.rareFindBreakdown.total > 0) {
                        const rareFindBonus = `${profitData.rareFindBreakdown.total.toFixed(1)}%`;
                        line.textContent = `• ${itemName}: ${drop.dropsPerHour.toFixed(decimals)}/hr (${baseDropRatePct} base × ${rareFindBonus} rare find = ${effectiveDropRatePct}, not affected by success rate) @ ${formatWithSeparator(Math.round(drop.price))} → ${formatLargeNumber(Math.round(drop.revenuePerHour))}/hr`;
                    } else {
                        line.textContent = `• ${itemName}: ${drop.dropsPerHour.toFixed(decimals)}/hr (${baseDropRatePct}, not affected by success rate) @ ${formatWithSeparator(Math.round(drop.price))} → ${formatLargeNumber(Math.round(drop.revenuePerHour))}/hr`;
                    }

                    rareContent.appendChild(line);

                    rareRevenue += drop.revenuePerHour;
                }

                const rareSection = createCollapsibleSection(
                    '',
                    `Rare Drops: ${formatLargeNumber(Math.round(rareRevenue))}/hr (${rareDrops.length} item${rareDrops.length !== 1 ? 's' : ''})`,
                    null,
                    rareContent,
                    false,
                    1
                );
                revenueDiv.appendChild(rareSection);
            }

            // Costs Section
            const costsDiv = document.createElement('div');
            costsDiv.innerHTML = `<div style="font-weight: 500; color: var(--text-color-primary, #fff); margin-top: 12px; margin-bottom: 4px;">Costs: ${formatLargeNumber(costs)}/hr</div>`;

            // Material Costs subsection (consumed on ALL attempts)
            if (profitData.requirementCosts && profitData.requirementCosts.length > 0) {
                const materialCostsContent = document.createElement('div');
                for (const material of profitData.requirementCosts) {
                    const itemDetails = dataManager$1.getItemDetails(material.itemHrid);
                    const itemName = itemDetails?.name || material.itemHrid;
                    const amountPerHour = material.count * profitData.actionsPerHour;

                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';

                    // Show enhancement level if > 0
                    const enhText = material.enhancementLevel > 0 ? ` +${material.enhancementLevel}` : '';

                    // Show decomposition value if enhanced
                    if (material.enhancementLevel > 0 && material.decompositionValuePerHour > 0) {
                        const netCostPerHour = material.costPerHour - material.decompositionValuePerHour;
                        line.textContent = `• ${itemName}${enhText}: ${amountPerHour.toFixed(1)}/hr @ ${formatWithSeparator(Math.round(material.price))} → ${formatLargeNumber(Math.round(material.costPerHour))}/hr (recovers ${formatLargeNumber(Math.round(material.decompositionValuePerHour))}/hr, net ${formatLargeNumber(Math.round(netCostPerHour))}/hr)`;
                    } else {
                        line.textContent = `• ${itemName}${enhText}: ${amountPerHour.toFixed(1)}/hr (consumed on all attempts) @ ${formatWithSeparator(Math.round(material.price))} → ${formatLargeNumber(Math.round(material.costPerHour))}/hr`;
                    }

                    materialCostsContent.appendChild(line);
                }

                const materialCostsSection = createCollapsibleSection(
                    '',
                    `Material Costs: ${formatLargeNumber(Math.round(profitData.materialCostPerHour))}/hr (${profitData.requirementCosts.length} material${profitData.requirementCosts.length !== 1 ? 's' : ''})`,
                    null,
                    materialCostsContent,
                    false,
                    1
                );
                costsDiv.appendChild(materialCostsSection);
            }

            // Catalyst Cost subsection (consumed only on success)
            if (profitData.catalystCost && profitData.catalystCost.itemHrid) {
                const catalystContent = document.createElement('div');
                const itemDetails = dataManager$1.getItemDetails(profitData.catalystCost.itemHrid);
                const itemName = itemDetails?.name || profitData.catalystCost.itemHrid;

                // Calculate catalysts per hour (only consumed on success)
                const catalystsPerHour = profitData.actionsPerHour * profitData.successRate;

                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                line.textContent = `• ${itemName}: ${catalystsPerHour.toFixed(1)}/hr (consumed only on success, ${formatPercentage(profitData.successRate, 1)}) @ ${formatWithSeparator(Math.round(profitData.catalystCost.price))} → ${formatLargeNumber(Math.round(profitData.catalystCost.costPerHour))}/hr`;
                catalystContent.appendChild(line);

                const catalystSection = createCollapsibleSection(
                    '',
                    `Catalyst Cost: ${formatLargeNumber(Math.round(profitData.catalystCost.costPerHour))}/hr`,
                    null,
                    catalystContent,
                    false,
                    1
                );
                costsDiv.appendChild(catalystSection);
            }

            // Drink Costs subsection
            if (profitData.consumableCosts && profitData.consumableCosts.length > 0) {
                const drinkCostsContent = document.createElement('div');
                for (const drink of profitData.consumableCosts) {
                    const itemDetails = dataManager$1.getItemDetails(drink.itemHrid);
                    const itemName = itemDetails?.name || drink.itemHrid;

                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';
                    line.textContent = `• ${itemName}: ${drink.drinksPerHour.toFixed(1)}/hr @ ${formatWithSeparator(Math.round(drink.price))} → ${formatLargeNumber(Math.round(drink.costPerHour))}/hr`;
                    drinkCostsContent.appendChild(line);
                }

                const drinkCount = profitData.consumableCosts.length;
                const drinkCostsSection = createCollapsibleSection(
                    '',
                    `Drink Costs: ${formatLargeNumber(Math.round(profitData.totalTeaCostPerHour))}/hr (${drinkCount} drink${drinkCount !== 1 ? 's' : ''})`,
                    null,
                    drinkCostsContent,
                    false,
                    1
                );
                costsDiv.appendChild(drinkCostsSection);
            }

            // Modifiers Section
            const modifiersDiv = document.createElement('div');
            modifiersDiv.style.cssText = `
            margin-top: 12px;
        `;

            // Main modifiers header
            const modifiersHeader = document.createElement('div');
            modifiersHeader.style.cssText = 'font-weight: 500; color: var(--text-color-primary, #fff); margin-bottom: 4px;';
            modifiersHeader.textContent = 'Modifiers:';
            modifiersDiv.appendChild(modifiersHeader);

            // Success Rate breakdown
            if (profitData.successRateBreakdown) {
                const successBreakdown = profitData.successRateBreakdown;
                const successContent = document.createElement('div');

                // Base success rate (from player level vs recipe requirement)
                const line = document.createElement('div');
                line.style.marginLeft = '8px';
                line.textContent = `• Base Success Rate: ${formatPercentage(successBreakdown.base, 1)}`;
                successContent.appendChild(line);

                // Tea bonus (from Catalytic Tea)
                if (successBreakdown.tea > 0) {
                    const teaLine = document.createElement('div');
                    teaLine.style.marginLeft = '8px';
                    teaLine.textContent = `• Tea Bonus: +${formatPercentage(successBreakdown.tea, 1)} (multiplicative)`;
                    successContent.appendChild(teaLine);
                }

                const successSection = createCollapsibleSection(
                    '',
                    `Success Rate: ${formatPercentage(profitData.successRate, 1)}`,
                    null,
                    successContent,
                    false,
                    1
                );
                modifiersDiv.appendChild(successSection);
            } else {
                // Fallback if breakdown not available
                const successRateLine = document.createElement('div');
                successRateLine.style.marginLeft = '8px';
                successRateLine.textContent = `• Success Rate: ${formatPercentage(profitData.successRate, 1)}`;
                modifiersDiv.appendChild(successRateLine);
            }

            // Efficiency breakdown
            if (profitData.efficiencyBreakdown) {
                const effBreakdown = profitData.efficiencyBreakdown;
                const effContent = document.createElement('div');

                if (effBreakdown.levelEfficiency > 0) {
                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';
                    line.textContent = `• Level Bonus: +${effBreakdown.levelEfficiency.toFixed(1)}%`;
                    effContent.appendChild(line);
                }

                if (effBreakdown.houseEfficiency > 0) {
                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';
                    line.textContent = `• House Bonus: +${effBreakdown.houseEfficiency.toFixed(1)}%`;
                    effContent.appendChild(line);
                }

                if (effBreakdown.teaEfficiency > 0) {
                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';
                    line.textContent = `• Tea Bonus: +${effBreakdown.teaEfficiency.toFixed(1)}%`;
                    effContent.appendChild(line);
                }

                if (effBreakdown.equipmentEfficiency > 0) {
                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';
                    line.textContent = `• Equipment Bonus: +${effBreakdown.equipmentEfficiency.toFixed(1)}%`;
                    effContent.appendChild(line);
                }

                if (effBreakdown.communityEfficiency > 0) {
                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';
                    line.textContent = `• Community Buff: +${effBreakdown.communityEfficiency.toFixed(1)}%`;
                    effContent.appendChild(line);
                }

                if (effBreakdown.achievementEfficiency > 0) {
                    const line = document.createElement('div');
                    line.style.marginLeft = '8px';
                    line.textContent = `• Achievement Bonus: +${effBreakdown.achievementEfficiency.toFixed(1)}%`;
                    effContent.appendChild(line);
                }

                const effSection = createCollapsibleSection(
                    '',
                    `Efficiency: +${formatPercentage(profitData.efficiency, 1)}`,
                    null,
                    effContent,
                    false,
                    1
                );
                modifiersDiv.appendChild(effSection);
            }

            // Action Speed breakdown
            if (profitData.actionSpeedBreakdown) {
                const speedBreakdown = profitData.actionSpeedBreakdown;
                const baseActionTime = 20; // Alchemy base time is 20 seconds
                const actionSpeed = baseActionTime / profitData.actionTime - 1;

                if (actionSpeed > 0) {
                    const speedContent = document.createElement('div');

                    if (speedBreakdown.equipment > 0) {
                        const line = document.createElement('div');
                        line.style.marginLeft = '8px';
                        line.textContent = `• Equipment Bonus: +${formatPercentage(speedBreakdown.equipment, 1)}`;
                        speedContent.appendChild(line);
                    }

                    if (speedBreakdown.tea > 0) {
                        const line = document.createElement('div');
                        line.style.marginLeft = '8px';
                        line.textContent = `• Tea Bonus: +${formatPercentage(speedBreakdown.tea, 1)}`;
                        speedContent.appendChild(line);
                    }

                    const speedSection = createCollapsibleSection(
                        '',
                        `Action Speed: +${formatPercentage(actionSpeed, 1)}`,
                        null,
                        speedContent,
                        false,
                        1
                    );
                    modifiersDiv.appendChild(speedSection);
                }
            }

            // Rare Find breakdown
            if (profitData.rareFindBreakdown) {
                const rareBreakdown = profitData.rareFindBreakdown;

                if (rareBreakdown.total > 0) {
                    const rareContent = document.createElement('div');

                    if (rareBreakdown.equipment > 0) {
                        const line = document.createElement('div');
                        line.style.marginLeft = '8px';
                        line.textContent = `• Equipment Bonus: +${rareBreakdown.equipment.toFixed(1)}%`;
                        rareContent.appendChild(line);
                    }

                    if (rareBreakdown.house > 0) {
                        const line = document.createElement('div');
                        line.style.marginLeft = '8px';
                        line.textContent = `• House Bonus: +${rareBreakdown.house.toFixed(1)}%`;
                        rareContent.appendChild(line);
                    }

                    if (rareBreakdown.achievement > 0) {
                        const line = document.createElement('div');
                        line.style.marginLeft = '8px';
                        line.textContent = `• Achievement Bonus: +${rareBreakdown.achievement.toFixed(1)}%`;
                        rareContent.appendChild(line);
                    }

                    const rareSection = createCollapsibleSection(
                        '',
                        `Rare Find: +${rareBreakdown.total.toFixed(1)}%`,
                        null,
                        rareContent,
                        false,
                        1
                    );
                    modifiersDiv.appendChild(rareSection);
                }
            }

            // Essence Find breakdown
            if (profitData.essenceFindBreakdown) {
                const essenceBreakdown = profitData.essenceFindBreakdown;

                if (essenceBreakdown.total > 0) {
                    const essenceContent = document.createElement('div');

                    if (essenceBreakdown.equipment > 0) {
                        const line = document.createElement('div');
                        line.style.marginLeft = '8px';
                        line.textContent = `• Equipment Bonus: +${essenceBreakdown.equipment.toFixed(1)}%`;
                        essenceContent.appendChild(line);
                    }

                    const essenceSection = createCollapsibleSection(
                        '',
                        `Essence Find: +${essenceBreakdown.total.toFixed(1)}%`,
                        null,
                        essenceContent,
                        false,
                        1
                    );
                    modifiersDiv.appendChild(essenceSection);
                }
            }

            // Assemble Detailed Breakdown
            detailsContent.appendChild(revenueDiv);
            detailsContent.appendChild(costsDiv);
            detailsContent.appendChild(modifiersDiv);

            // Create "Detailed Breakdown" collapsible
            const topLevelContent = document.createElement('div');
            topLevelContent.innerHTML = `
            <div style="margin-bottom: 4px;">Actions: ${profitData.actionsPerHour.toFixed(1)}/hr | Success Rate: ${formatPercentage(profitData.successRate, 1)}</div>
        `;

            // Add Net Profit line at top level (always visible when Profitability is expanded)
            const profitColor = profit >= 0 ? '#4ade80' : config$1.getSetting('color_loss') || '#f87171';
            const netProfitLine = document.createElement('div');
            netProfitLine.style.cssText = `
            font-weight: 500;
            color: ${profitColor};
            margin-bottom: 8px;
        `;
            netProfitLine.textContent = `Net Profit: ${formatLargeNumber(profit)}/hr, ${formatLargeNumber(profitPerDay)}/day`;
            topLevelContent.appendChild(netProfitLine);

            // Add pricing mode label
            const pricingMode = profitData.pricingMode || 'hybrid';
            const modeLabel =
                {
                    conservative: 'Conservative',
                    hybrid: 'Hybrid',
                    optimistic: 'Optimistic',
                }[pricingMode] || 'Hybrid';

            const modeDiv = document.createElement('div');
            modeDiv.style.cssText = `
            margin-bottom: 8px;
            color: #888;
            font-size: 0.85em;
        `;
            modeDiv.textContent = `Pricing Mode: ${modeLabel}`;
            topLevelContent.appendChild(modeDiv);

            const detailedBreakdownSection = createCollapsibleSection(
                '📊',
                'Detailed Breakdown',
                null,
                detailsContent,
                false,
                0
            );

            topLevelContent.appendChild(detailedBreakdownSection);

            // Create main profit section
            const profitSection = createCollapsibleSection('💰', 'Profitability', summary, topLevelContent, false, 0);
            profitSection.id = 'mwi-alchemy-profit';
            profitSection.classList.add('mwi-alchemy-profit');

            // Append to container
            container.appendChild(profitSection);
            this.displayElement = profitSection;
        }

        /**
         * Remove profit display
         */
        removeDisplay() {
            if (this.displayElement && this.displayElement.parentNode) {
                this.displayElement.remove();
            }
            this.displayElement = null;
            // Don't clear lastFingerprint here - we need to track state across recreations
        }

        /**
         * Disable the display
         */
        disable() {
            if (this.updateTimeout) {
                clearTimeout(this.updateTimeout);
                this.updateTimeout = null;
            }

            if (this.pollInterval) {
                clearInterval(this.pollInterval);
                this.pollInterval = null;
            }

            this.timerRegistry.clearAll();

            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            this.removeDisplay();
            this.lastFingerprint = null; // Clear fingerprint on disable
            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const alchemyProfitDisplay = new AlchemyProfitDisplay();

    /**
     * Actions Library
     * Production, gathering, and alchemy features
     *
     * Exports to: window.Toolasha.Actions
     */


    // Export to global namespace
    const toolashaRoot$2 = window.Toolasha || {};
    window.Toolasha = toolashaRoot$2;

    if (typeof unsafeWindow !== 'undefined') {
        unsafeWindow.Toolasha = toolashaRoot$2;
    }

    toolashaRoot$2.Actions = {
        initActionPanelObserver,
        actionTimeDisplay,
        quickInputButtons,
        outputTotals,
        maxProduceable,
        gatheringStats,
        requiredMaterials,
        missingMaterialsButton,
        alchemyProfitDisplay,
    };

    console.log('[Toolasha] Actions library loaded');

    /**
     * Combat Zone Indices
     * Shows index numbers on combat zone buttons and task cards
     */


    // Compiled regex pattern (created once, reused for performance)
    const REGEX_COMBAT_TASK = /(?:Kill|Defeat)\s*-\s*(.+)$/;

    /**
     * ZoneIndices class manages zone index display on maps and tasks
     */
    class ZoneIndices {
        constructor() {
            this.unregisterObserver = null; // Unregister function from centralized observer
            this.isActive = false;
            this.monsterZoneCache = null; // Cache monster name -> zone index mapping
            this.taskMapIndexEnabled = false;
            this.mapIndexEnabled = false;
            this.isInitialized = false;
        }

        /**
         * Setup setting change listener (always active, even when feature is disabled)
         */
        setupSettingListener() {
            // Listen for feature toggle changes
            config$1.onSettingChange('taskMapIndex', () => {
                this.taskMapIndexEnabled = config$1.getSetting('taskMapIndex');
                if (this.taskMapIndexEnabled || this.mapIndexEnabled) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('mapIndex', () => {
                this.mapIndexEnabled = config$1.getSetting('mapIndex');
                if (this.taskMapIndexEnabled || this.mapIndexEnabled) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('color_accent', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize zone indices feature
         */
        initialize() {
            // Check if either feature is enabled
            this.taskMapIndexEnabled = config$1.getSetting('taskMapIndex');
            this.mapIndexEnabled = config$1.getSetting('mapIndex');

            if (!this.taskMapIndexEnabled && !this.mapIndexEnabled) {
                return;
            }

            if (this.isInitialized) {
                return;
            }

            // Build monster->zone cache once on initialization
            if (this.taskMapIndexEnabled) {
                this.buildMonsterZoneCache();
            }

            // Register with centralized observer with debouncing enabled
            this.unregisterObserver = domObserver$1.register(
                'ZoneIndices',
                () => {
                    if (this.taskMapIndexEnabled) {
                        this.addTaskIndices();
                    }
                    if (this.mapIndexEnabled) {
                        this.addMapIndices();
                    }
                },
                { debounce: true, debounceDelay: 100 } // Use centralized debouncing
            );

            // Process existing elements
            if (this.taskMapIndexEnabled) {
                this.addTaskIndices();
            }
            if (this.mapIndexEnabled) {
                this.addMapIndices();
            }

            this.isActive = true;
            this.isInitialized = true;
        }

        /**
         * Build a cache of monster names to zone indices
         * Run once on initialization to avoid repeated traversals
         */
        buildMonsterZoneCache() {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) {
                return;
            }

            this.monsterZoneCache = new Map();

            for (const action of Object.values(gameData.actionDetailMap)) {
                // Only check combat actions
                if (!action.hrid?.includes('/combat/')) {
                    continue;
                }

                const categoryHrid = action.category;
                if (!categoryHrid) {
                    continue;
                }

                const category = gameData.actionCategoryDetailMap[categoryHrid];
                const zoneIndex = category?.sortIndex;
                if (!zoneIndex) {
                    continue;
                }

                // Cache action name -> zone index
                if (action.name) {
                    this.monsterZoneCache.set(action.name.toLowerCase(), zoneIndex);
                }

                // Cache boss names -> zone index
                if (action.combatZoneInfo?.fightInfo?.bossSpawns) {
                    for (const boss of action.combatZoneInfo.fightInfo.bossSpawns) {
                        const bossHrid = boss.combatMonsterHrid;
                        if (bossHrid) {
                            const bossName = bossHrid.replace('/monsters/', '').replace(/_/g, ' ');
                            this.monsterZoneCache.set(bossName.toLowerCase(), zoneIndex);
                        }
                    }
                }
            }
        }

        /**
         * Add zone indices to task cards
         * Shows "Z5" next to monster kill tasks
         */
        addTaskIndices() {
            // Find all task name elements
            const taskNameElements = document.querySelectorAll('div[class*="RandomTask_name"]');

            for (const nameElement of taskNameElements) {
                // Always remove any existing index first (in case task was rerolled)
                const existingIndex = nameElement.querySelector('span.script_taskMapIndex');
                if (existingIndex) {
                    existingIndex.remove();
                }

                const taskText = nameElement.textContent;

                // Check if this is a combat task (contains "Kill" or "Defeat")
                if (!taskText.includes('Kill') && !taskText.includes('Defeat')) {
                    continue; // Not a combat task, skip
                }

                // Extract monster name from task text
                // Format: "Defeat - Jerry" or "Kill - Monster Name"
                const match = taskText.match(REGEX_COMBAT_TASK);
                if (!match) {
                    continue; // Couldn't parse monster name
                }

                const monsterName = match[1].trim();

                // Find the combat action for this monster
                const zoneIndex = this.getZoneIndexForMonster(monsterName);

                if (zoneIndex) {
                    // Add index to the name element
                    nameElement.insertAdjacentHTML(
                        'beforeend',
                        `<span class="script_taskMapIndex" style="margin-left: 4px; color: ${config$1.SCRIPT_COLOR_MAIN};">Z${zoneIndex}</span>`
                    );
                }
            }
        }

        /**
         * Add sequential indices to combat zone buttons on maps page
         * Shows "1. Zone Name", "2. Zone Name", etc.
         */
        addMapIndices() {
            // Find all combat zone tab buttons
            // Target the vertical tabs in the combat panel
            const buttons = document.querySelectorAll(
                'div.MainPanel_subPanelContainer__1i-H9 div.CombatPanel_tabsComponentContainer__GsQlg div.MuiTabs-root.MuiTabs-vertical button.MuiButtonBase-root.MuiTab-root span.MuiBadge-root'
            );

            if (buttons.length === 0) {
                return;
            }

            let index = 1;
            for (const button of buttons) {
                // Skip if already has index
                if (button.querySelector('span.script_mapIndex')) {
                    continue;
                }

                // Add index at the beginning
                button.insertAdjacentHTML(
                    'afterbegin',
                    `<span class="script_mapIndex" style="color: ${config$1.SCRIPT_COLOR_MAIN};">${index}. </span>`
                );

                index++;
            }
        }

        /**
         * Get zone index for a monster name
         * @param {string} monsterName - Monster display name
         * @returns {number|null} Zone index or null if not found
         */
        getZoneIndexForMonster(monsterName) {
            // Use cache if available
            if (this.monsterZoneCache) {
                return this.monsterZoneCache.get(monsterName.toLowerCase()) || null;
            }

            // Fallback to direct lookup if cache not built (shouldn't happen)
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) {
                return null;
            }

            const normalizedName = monsterName.toLowerCase();

            for (const action of Object.values(gameData.actionDetailMap)) {
                if (!action.hrid?.includes('/combat/')) {
                    continue;
                }

                if (action.name?.toLowerCase() === normalizedName) {
                    const categoryHrid = action.category;
                    if (categoryHrid) {
                        const category = gameData.actionCategoryDetailMap[categoryHrid];
                        if (category?.sortIndex) {
                            return category.sortIndex;
                        }
                    }
                }

                if (action.combatZoneInfo?.fightInfo?.bossSpawns) {
                    for (const boss of action.combatZoneInfo.fightInfo.bossSpawns) {
                        const bossHrid = boss.combatMonsterHrid;
                        if (bossHrid) {
                            const bossName = bossHrid.replace('/monsters/', '').replace(/_/g, ' ');
                            if (bossName === normalizedName) {
                                const categoryHrid = action.category;
                                if (categoryHrid) {
                                    const category = gameData.actionCategoryDetailMap[categoryHrid];
                                    if (category?.sortIndex) {
                                        return category.sortIndex;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return null;
        }

        /**
         * Refresh colors (called when settings change)
         */
        refresh() {
            // Update all existing zone index spans with new color
            const taskIndices = document.querySelectorAll('span.script_taskMapIndex');
            taskIndices.forEach((span) => {
                span.style.color = config$1.COLOR_ACCENT;
            });

            const mapIndices = document.querySelectorAll('span.script_mapIndex');
            mapIndices.forEach((span) => {
                span.style.color = config$1.COLOR_ACCENT;
            });
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            // Remove all added indices
            const taskIndices = document.querySelectorAll('span.script_taskMapIndex');
            for (const span of taskIndices) {
                span.remove();
            }

            const mapIndices = document.querySelectorAll('span.script_mapIndex');
            for (const span of mapIndices) {
                span.remove();
            }

            // Clear cache
            this.monsterZoneCache = null;
            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const zoneIndices = new ZoneIndices();

    zoneIndices.setupSettingListener();

    /**
     * Dungeon Tracker Storage
     * Manages IndexedDB storage for dungeon run history
     */


    const TIERS = [0, 1, 2];

    // Hardcoded max waves for each dungeon (fallback if maxCount is 0)
    const DUNGEON_MAX_WAVES = {
        '/actions/combat/chimerical_den': 50,
        '/actions/combat/sinister_circus': 60,
        '/actions/combat/enchanted_fortress': 65,
        '/actions/combat/pirate_cove': 65,
    };

    class DungeonTrackerStorage {
        constructor() {
            this.unifiedStoreName = 'unifiedRuns'; // Unified storage for all runs
        }

        /**
         * Get dungeon+tier key
         * @param {string} dungeonHrid - Dungeon action HRID
         * @param {number} tier - Difficulty tier (0-2)
         * @returns {string} Storage key
         */
        getDungeonKey(dungeonHrid, tier) {
            return `${dungeonHrid}::T${tier}`;
        }

        /**
         * Get dungeon info from game data
         * @param {string} dungeonHrid - Dungeon action HRID
         * @returns {Object|null} Dungeon info or null
         */
        getDungeonInfo(dungeonHrid) {
            const actionDetails = dataManager$1.getActionDetails(dungeonHrid);
            if (!actionDetails) {
                return null;
            }

            // Extract name from HRID (e.g., "/actions/combat/chimerical_den" -> "Chimerical Den")
            const namePart = dungeonHrid.split('/').pop();
            const name = namePart
                .split('_')
                .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');

            // Get max waves from nested combatZoneInfo.dungeonInfo.maxWaves
            let maxWaves = actionDetails.combatZoneInfo?.dungeonInfo?.maxWaves || 0;

            // Fallback to hardcoded values if not found in game data
            if (maxWaves === 0 && DUNGEON_MAX_WAVES[dungeonHrid]) {
                maxWaves = DUNGEON_MAX_WAVES[dungeonHrid];
            }

            return {
                name: actionDetails.name || name,
                maxWaves: maxWaves,
            };
        }

        /**
         * Get run history for a dungeon+tier
         * @param {string} dungeonHrid - Dungeon action HRID
         * @param {number} tier - Difficulty tier
         * @param {number} limit - Max runs to return (0 = all)
         * @returns {Promise<Array>} Run history
         */
        async getRunHistory(dungeonHrid, tier, limit = 0) {
            // Get all runs from unified storage
            const allRuns = await storage$1.getJSON('allRuns', this.unifiedStoreName, []);

            // Filter by dungeon HRID and tier
            const runs = allRuns.filter((r) => r.dungeonHrid === dungeonHrid && r.tier === tier);

            if (limit > 0 && runs.length > limit) {
                return runs.slice(0, limit);
            }

            return runs;
        }

        /**
         * Get statistics for a dungeon+tier
         * @param {string} dungeonHrid - Dungeon action HRID
         * @param {number} tier - Difficulty tier
         * @returns {Promise<Object>} Statistics
         */
        async getStats(dungeonHrid, tier) {
            const runs = await this.getRunHistory(dungeonHrid, tier);

            if (runs.length === 0) {
                return {
                    totalRuns: 0,
                    avgTime: 0,
                    fastestTime: 0,
                    slowestTime: 0,
                    avgWaveTime: 0,
                };
            }

            const totalTime = runs.reduce((sum, run) => sum + run.totalTime, 0);
            const avgTime = totalTime / runs.length;
            const fastestTime = Math.min(...runs.map((r) => r.totalTime));
            const slowestTime = Math.max(...runs.map((r) => r.totalTime));

            const totalAvgWaveTime = runs.reduce((sum, run) => sum + run.avgWaveTime, 0);
            const avgWaveTime = totalAvgWaveTime / runs.length;

            return {
                totalRuns: runs.length,
                avgTime,
                fastestTime,
                slowestTime,
                avgWaveTime,
            };
        }

        /**
         * Get statistics for a dungeon by name (for chat-based runs)
         * @param {string} dungeonName - Dungeon display name
         * @returns {Promise<Object>} Statistics
         */
        async getStatsByName(dungeonName) {
            const allRuns = await storage$1.getJSON('allRuns', this.unifiedStoreName, []);
            const runs = allRuns.filter((r) => r.dungeonName === dungeonName);

            if (runs.length === 0) {
                return {
                    totalRuns: 0,
                    avgTime: 0,
                    fastestTime: 0,
                    slowestTime: 0,
                    avgWaveTime: 0,
                };
            }

            // Use 'duration' field (chat-based) or 'totalTime' field (websocket-based)
            const durations = runs.map((r) => r.duration || r.totalTime || 0);
            const totalTime = durations.reduce((sum, d) => sum + d, 0);
            const avgTime = totalTime / runs.length;
            const fastestTime = Math.min(...durations);
            const slowestTime = Math.max(...durations);

            const avgWaveTime = runs.reduce((sum, run) => sum + (run.avgWaveTime || 0), 0) / runs.length;

            return {
                totalRuns: runs.length,
                avgTime,
                fastestTime,
                slowestTime,
                avgWaveTime,
            };
        }

        /**
         * Get last N runs for a dungeon+tier
         * @param {string} dungeonHrid - Dungeon action HRID
         * @param {number} tier - Difficulty tier
         * @param {number} count - Number of runs to return
         * @returns {Promise<Array>} Last N runs
         */
        async getLastRuns(dungeonHrid, tier, count = 10) {
            return this.getRunHistory(dungeonHrid, tier, count);
        }

        /**
         * Get personal best for a dungeon+tier
         * @param {string} dungeonHrid - Dungeon action HRID
         * @param {number} tier - Difficulty tier
         * @returns {Promise<Object|null>} Personal best run or null
         */
        async getPersonalBest(dungeonHrid, tier) {
            const runs = await this.getRunHistory(dungeonHrid, tier);

            if (runs.length === 0) {
                return null;
            }

            // Find fastest run
            return runs.reduce((best, run) => {
                if (!best || run.totalTime < best.totalTime) {
                    return run;
                }
                return best;
            }, null);
        }

        /**
         * Delete a specific run from history
         * @param {string} dungeonHrid - Dungeon action HRID
         * @param {number} tier - Difficulty tier
         * @param {number} runIndex - Index of run to delete (0 = most recent)
         * @returns {Promise<boolean>} Success status
         */
        async deleteRun(dungeonHrid, tier, runIndex) {
            // Get all runs from unified storage
            const allRuns = await storage$1.getJSON('allRuns', this.unifiedStoreName, []);

            // Filter to this dungeon+tier
            const dungeonRuns = allRuns.filter((r) => r.dungeonHrid === dungeonHrid && r.tier === tier);

            if (runIndex < 0 || runIndex >= dungeonRuns.length) {
                console.warn('[Dungeon Tracker Storage] Invalid run index:', runIndex);
                return false;
            }

            // Find the run to delete in the full array
            const runToDelete = dungeonRuns[runIndex];
            const indexInAllRuns = allRuns.findIndex(
                (r) =>
                    r.timestamp === runToDelete.timestamp &&
                    r.dungeonHrid === runToDelete.dungeonHrid &&
                    r.tier === runToDelete.tier
            );

            if (indexInAllRuns === -1) {
                console.warn('[Dungeon Tracker Storage] Run not found in unified storage');
                return false;
            }

            // Remove the run
            allRuns.splice(indexInAllRuns, 1);

            // Save updated list
            return storage$1.setJSON('allRuns', allRuns, this.unifiedStoreName, true);
        }

        /**
         * Delete all run history for a dungeon+tier
         * @param {string} dungeonHrid - Dungeon action HRID
         * @param {number} tier - Difficulty tier
         * @returns {Promise<boolean>} Success status
         */
        async clearHistory(dungeonHrid, tier) {
            // Get all runs from unified storage
            const allRuns = await storage$1.getJSON('allRuns', this.unifiedStoreName, []);

            // Filter OUT the runs we want to delete
            const filteredRuns = allRuns.filter((r) => !(r.dungeonHrid === dungeonHrid && r.tier === tier));

            // Save back the filtered list
            return storage$1.setJSON('allRuns', filteredRuns, this.unifiedStoreName, true);
        }

        /**
         * Get all dungeon+tier combinations with stored data
         * @returns {Promise<Array>} Array of {dungeonHrid, tier, runCount}
         */
        async getAllDungeonStats() {
            const results = [];

            // Get all dungeon actions from game data
            const initData = dataManager$1.getInitClientData();
            if (!initData?.actionDetailMap) {
                return results;
            }

            // Find all dungeon actions (combat actions with maxCount field)
            const dungeonHrids = Object.entries(initData.actionDetailMap)
                .filter(([hrid, details]) => hrid.startsWith('/actions/combat/') && details.maxCount !== undefined)
                .map(([hrid]) => hrid);

            // Check each dungeon+tier combination
            for (const dungeonHrid of dungeonHrids) {
                for (const tier of TIERS) {
                    const runs = await this.getRunHistory(dungeonHrid, tier);
                    if (runs.length > 0) {
                        const dungeonInfo = this.getDungeonInfo(dungeonHrid);
                        results.push({
                            dungeonHrid,
                            tier,
                            dungeonName: dungeonInfo?.name || 'Unknown',
                            runCount: runs.length,
                        });
                    }
                }
            }

            return results;
        }

        /**
         * Get team key from sorted player names
         * @param {Array<string>} playerNames - Array of player names
         * @returns {string} Team key (sorted, comma-separated)
         */
        getTeamKey(playerNames) {
            return playerNames.sort().join(',');
        }

        /**
         * Save a team-based run (from backfill)
         * @param {string} teamKey - Team key (sorted player names)
         * @param {Object} run - Run data
         * @param {string} run.timestamp - Run start timestamp (ISO string)
         * @param {number} run.duration - Run duration (ms)
         * @param {string} run.dungeonName - Dungeon name (from Phase 2)
         * @returns {Promise<boolean>} Success status
         */
        async saveTeamRun(teamKey, run) {
            // Get all runs from unified storage
            const allRuns = await storage$1.getJSON('allRuns', this.unifiedStoreName, []);

            // Parse incoming timestamp
            const newTimestamp = new Date(run.timestamp).getTime();

            // Check for duplicates (same time window, team, and duration)
            const isDuplicate = allRuns.some((r) => {
                const existingTimestamp = new Date(r.timestamp).getTime();
                const timeDiff = Math.abs(existingTimestamp - newTimestamp);
                const durationDiff = Math.abs(r.duration - run.duration);

                // Consider duplicate if:
                // - Within 10 seconds of each other (handles timestamp precision differences)
                // - Same team
                // - Duration within 2 seconds (handles minor timing differences)
                return timeDiff < 10000 && r.teamKey === teamKey && durationDiff < 2000;
            });

            if (!isDuplicate) {
                // Create unified format run
                const team = teamKey.split(',').sort();
                const unifiedRun = {
                    timestamp: run.timestamp,
                    dungeonName: run.dungeonName || 'Unknown',
                    dungeonHrid: null,
                    tier: null,
                    team: team,
                    teamKey: teamKey,
                    duration: run.duration,
                    validated: true,
                    source: 'chat',
                    waveTimes: null,
                    avgWaveTime: null,
                    keyCountsMap: run.keyCountsMap || null, // Include key counts if available
                };

                // Add to front of list (most recent first)
                allRuns.unshift(unifiedRun);

                // Save to unified storage
                await storage$1.setJSON('allRuns', allRuns, this.unifiedStoreName, true);

                return true;
            }

            return false;
        }

        /**
         * Get all runs (unfiltered)
         * @returns {Promise<Array>} All runs
         */
        async getAllRuns() {
            return storage$1.getJSON('allRuns', this.unifiedStoreName, []);
        }

        /**
         * Get runs filtered by dungeon and/or team
         * @param {Object} filters - Filter options
         * @param {string} filters.dungeonName - Filter by dungeon name (optional)
         * @param {string} filters.teamKey - Filter by team key (optional)
         * @returns {Promise<Array>} Filtered runs
         */
        async getFilteredRuns(filters = {}) {
            const allRuns = await this.getAllRuns();

            let filtered = allRuns;

            if (filters.dungeonName && filters.dungeonName !== 'all') {
                filtered = filtered.filter((r) => r.dungeonName === filters.dungeonName);
            }

            if (filters.teamKey && filters.teamKey !== 'all') {
                filtered = filtered.filter((r) => r.teamKey === filters.teamKey);
            }

            return filtered;
        }

        /**
         * Get all teams with stored runs
         * @returns {Promise<Array>} Array of {teamKey, runCount, avgTime, bestTime, worstTime}
         */
        async getAllTeamStats() {
            // Get all runs from unified storage
            const allRuns = await storage$1.getJSON('allRuns', this.unifiedStoreName, []);

            // Group by teamKey
            const teamGroups = {};
            for (const run of allRuns) {
                if (!run.teamKey) continue; // Skip solo runs (no team)

                if (!teamGroups[run.teamKey]) {
                    teamGroups[run.teamKey] = [];
                }
                teamGroups[run.teamKey].push(run);
            }

            // Calculate stats for each team
            const results = [];
            for (const [teamKey, runs] of Object.entries(teamGroups)) {
                const durations = runs.map((r) => r.duration);
                const avgTime = durations.reduce((a, b) => a + b, 0) / durations.length;
                const bestTime = Math.min(...durations);
                const worstTime = Math.max(...durations);

                results.push({
                    teamKey,
                    runCount: runs.length,
                    avgTime,
                    bestTime,
                    worstTime,
                });
            }

            return results;
        }
    }

    const dungeonTrackerStorage = new DungeonTrackerStorage();

    /**
     * Dungeon Tracker Core
     * Tracks dungeon progress in real-time using WebSocket messages
     */


    class DungeonTracker {
        constructor() {
            this.isTracking = false;
            this.isInitialized = false; // Guard flag
            this.currentRun = null;
            this.waveStartTime = null;
            this.waveTimes = [];
            this.updateCallbacks = [];
            this.pendingDungeonInfo = null; // Store dungeon info before tracking starts
            this.currentBattleId = null; // Current battle ID for persistence verification

            // Party message tracking for server-validated duration
            this.firstKeyCountTimestamp = null; // Timestamp from first "Key counts" message
            this.lastKeyCountTimestamp = null; // Timestamp from last "Key counts" message
            this.keyCountMessages = []; // Store all key count messages for this run
            this.battleStartedTimestamp = null; // Timestamp from "Battle started" message

            // Character ID for data isolation
            this.characterId = null;

            // WebSocket message history (last 100 party messages for reliable timestamp capture)
            this.recentChatMessages = [];

            // Hibernation detection (for UI time label switching)
            this.hibernationDetected = false;
            this.timerRegistry = createTimerRegistry();
            this.visibilityHandler = null;

            // Store handler references for cleanup
            this.handlers = {
                newBattle: null,
                actionCompleted: null,
                actionsUpdated: null,
                chatMessage: null,
            };
        }

        /**
         * Get character ID from URL
         * @returns {string|null} Character ID or null
         */
        getCharacterIdFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('characterId');
        }

        /**
         * Get namespaced storage key for this character
         * @param {string} key - Base key
         * @returns {string} Namespaced key
         */
        getCharacterKey(key) {
            if (!this.characterId) {
                return key;
            }
            return `${key}_${this.characterId}`;
        }

        /**
         * Check if an action is a dungeon action
         * @param {string} actionHrid - Action HRID to check
         * @returns {boolean} True if action is a dungeon
         */
        isDungeonAction(actionHrid) {
            if (!actionHrid || !actionHrid.startsWith('/actions/combat/')) {
                return false;
            }

            const actionDetails = dataManager$1.getActionDetails(actionHrid);
            return actionDetails?.combatZoneInfo?.isDungeon === true;
        }

        /**
         * Save in-progress run to IndexedDB
         * @returns {Promise<boolean>} Success status
         */
        async saveInProgressRun() {
            if (!this.isTracking || !this.currentRun || !this.currentBattleId) {
                return false;
            }

            const stateToSave = {
                battleId: this.currentBattleId,
                dungeonHrid: this.currentRun.dungeonHrid,
                tier: this.currentRun.tier,
                startTime: this.currentRun.startTime,
                currentWave: this.currentRun.currentWave,
                maxWaves: this.currentRun.maxWaves,
                wavesCompleted: this.currentRun.wavesCompleted,
                waveTimes: [...this.waveTimes],
                waveStartTime: this.waveStartTime?.getTime() || null,
                keyCountsMap: this.currentRun.keyCountsMap || {},
                lastUpdateTime: Date.now(),
                // Save timestamp tracking fields for completion detection
                firstKeyCountTimestamp: this.firstKeyCountTimestamp,
                lastKeyCountTimestamp: this.lastKeyCountTimestamp,
                battleStartedTimestamp: this.battleStartedTimestamp,
                keyCountMessages: this.keyCountMessages,
                hibernationDetected: this.hibernationDetected,
            };

            return storage$1.setJSON('dungeonTracker_inProgressRun', stateToSave, 'settings', true);
        }

        /**
         * Restore in-progress run from IndexedDB
         * @param {number} currentBattleId - Current battle ID from new_battle message
         * @returns {Promise<boolean>} True if restored successfully
         */
        async restoreInProgressRun(currentBattleId) {
            const saved = await storage$1.getJSON('dungeonTracker_inProgressRun', 'settings', null);

            if (!saved) {
                return false; // No saved state
            }

            // Verify battleId matches (same run)
            if (saved.battleId !== currentBattleId) {
                await this.clearInProgressRun();
                return false;
            }

            // Verify dungeon action is still active
            const currentActions = dataManager$1.getCurrentActions();
            const dungeonAction = currentActions.find((a) => this.isDungeonAction(a.actionHrid) && !a.isDone);

            if (!dungeonAction || dungeonAction.actionHrid !== saved.dungeonHrid) {
                await this.clearInProgressRun();
                return false;
            }

            // Check staleness (older than 10 minutes = likely invalid)
            const age = Date.now() - saved.lastUpdateTime;
            if (age > 10 * 60 * 1000) {
                await this.clearInProgressRun();
                return false;
            }

            // Restore state
            this.isTracking = true;
            this.currentBattleId = saved.battleId;
            this.waveTimes = saved.waveTimes || [];
            this.waveStartTime = saved.waveStartTime ? new Date(saved.waveStartTime) : null;

            // Restore timestamp tracking fields
            this.firstKeyCountTimestamp = saved.firstKeyCountTimestamp || null;
            this.lastKeyCountTimestamp = saved.lastKeyCountTimestamp || null;
            this.battleStartedTimestamp = saved.battleStartedTimestamp || null;
            this.keyCountMessages = saved.keyCountMessages || [];

            // Restore hibernation detection flag
            this.hibernationDetected = saved.hibernationDetected || false;

            this.currentRun = {
                dungeonHrid: saved.dungeonHrid,
                tier: saved.tier,
                startTime: saved.startTime,
                currentWave: saved.currentWave,
                maxWaves: saved.maxWaves,
                wavesCompleted: saved.wavesCompleted,
                keyCountsMap: saved.keyCountsMap || {},
                hibernationDetected: saved.hibernationDetected || false,
            };

            this.notifyUpdate();
            return true;
        }

        /**
         * Clear saved in-progress run from IndexedDB
         * @returns {Promise<boolean>} Success status
         */
        async clearInProgressRun() {
            return storage$1.delete('dungeonTracker_inProgressRun', 'settings');
        }

        /**
         * Initialize dungeon tracker
         */
        async initialize() {
            // Guard FIRST
            if (this.isInitialized) {
                return;
            }

            this.isInitialized = true;

            // Get character ID from URL for data isolation
            this.characterId = this.getCharacterIdFromURL();

            // Create and store handler references for cleanup
            this.handlers.newBattle = (data) => this.onNewBattle(data);
            this.handlers.actionCompleted = (data) => this.onActionCompleted(data);
            this.handlers.actionsUpdated = (data) => this.onActionsUpdated(data);
            this.handlers.chatMessage = (data) => this.onChatMessage(data);

            // Listen for new_battle messages (wave start)
            webSocketHook$1.on('new_battle', this.handlers.newBattle);

            // Listen for action_completed messages (wave complete)
            webSocketHook$1.on('action_completed', this.handlers.actionCompleted);

            // Listen for actions_updated to detect flee/cancel
            webSocketHook$1.on('actions_updated', this.handlers.actionsUpdated);

            // Listen for party chat messages (for server-validated duration and battle started)
            webSocketHook$1.on('chat_message_received', this.handlers.chatMessage);

            // Setup hibernation detection using Visibility API
            this.setupHibernationDetection();

            // Check for active dungeon on page load and try to restore state
            const checkTimeout = setTimeout(() => this.checkForActiveDungeon(), 1000);
            this.timerRegistry.registerTimeout(checkTimeout);

            dataManager$1.on('character_switching', () => {
                this.cleanup();
            });
        }

        /**
         * Setup hibernation detection using Visibility API
         * Detects when computer sleeps/wakes to flag elapsed time as potentially inaccurate
         */
        setupHibernationDetection() {
            let wasHidden = false;

            this.visibilityHandler = () => {
                if (document.hidden) {
                    // Tab hidden or computer going to sleep
                    wasHidden = true;
                } else if (wasHidden && this.isTracking) {
                    // Tab visible again after being hidden during active run
                    // Mark hibernation detected (elapsed time may be wrong)
                    this.hibernationDetected = true;
                    if (this.currentRun) {
                        this.currentRun.hibernationDetected = true;
                    }
                    this.notifyUpdate();
                    this.saveInProgressRun(); // Persist flag to IndexedDB
                    wasHidden = false;
                }
            };

            document.addEventListener('visibilitychange', this.visibilityHandler);
        }

        /**
         * Check if there's an active dungeon on page load and restore tracking
         */
        async checkForActiveDungeon() {
            // Check if already tracking (shouldn't be, but just in case)
            if (this.isTracking) {
                return;
            }

            // Get current actions from dataManager
            const currentActions = dataManager$1.getCurrentActions();

            // Find active dungeon action
            const dungeonAction = currentActions.find((a) => this.isDungeonAction(a.actionHrid) && !a.isDone);

            if (!dungeonAction) {
                return;
            }

            // Try to restore saved state from IndexedDB
            const saved = await storage$1.getJSON('dungeonTracker_inProgressRun', 'settings', null);

            if (saved && saved.dungeonHrid === dungeonAction.actionHrid) {
                // Restore state immediately so UI appears
                this.isTracking = true;
                this.currentBattleId = saved.battleId;
                this.waveTimes = saved.waveTimes || [];
                this.waveStartTime = saved.waveStartTime ? new Date(saved.waveStartTime) : null;

                // Restore timestamp tracking fields
                this.firstKeyCountTimestamp = saved.firstKeyCountTimestamp || null;
                this.lastKeyCountTimestamp = saved.lastKeyCountTimestamp || null;
                this.battleStartedTimestamp = saved.battleStartedTimestamp || null;
                this.keyCountMessages = saved.keyCountMessages || [];

                this.currentRun = {
                    dungeonHrid: saved.dungeonHrid,
                    tier: saved.tier,
                    startTime: saved.startTime,
                    currentWave: saved.currentWave,
                    maxWaves: saved.maxWaves,
                    wavesCompleted: saved.wavesCompleted,
                    keyCountsMap: saved.keyCountsMap || {},
                };

                // Trigger UI update to show immediately
                this.notifyUpdate();
            } else {
                // Store pending dungeon info for when new_battle fires
                this.pendingDungeonInfo = {
                    dungeonHrid: dungeonAction.actionHrid,
                    tier: dungeonAction.difficultyTier,
                };
            }
        }

        /**
         * Scan existing chat messages for "Battle started" and "Key counts" (in case we joined mid-dungeon)
         */
        scanExistingChatMessages() {
            if (!this.isTracking) {
                return;
            }

            try {
                let battleStartedFound = false;
                let latestKeyCountsMap = null;
                let latestTimestamp = null;

                // FIRST: Try to find messages in memory (most reliable)
                if (this.recentChatMessages.length > 0) {
                    for (const message of this.recentChatMessages) {
                        // Look for "Battle started" messages
                        if (message.m === 'systemChatMessage.partyBattleStarted') {
                            const timestamp = new Date(message.t).getTime();
                            this.battleStartedTimestamp = timestamp;
                            battleStartedFound = true;
                        }

                        // Look for "Key counts" messages
                        if (message.m === 'systemChatMessage.partyKeyCount') {
                            const timestamp = new Date(message.t).getTime();

                            // Parse key counts from systemMetadata
                            try {
                                const metadata = JSON.parse(message.systemMetadata || '{}');
                                const keyCountString = metadata.keyCountString || '';
                                const keyCountsMap = this.parseKeyCountsFromMessage(keyCountString);

                                if (Object.keys(keyCountsMap).length > 0) {
                                    latestKeyCountsMap = keyCountsMap;
                                    latestTimestamp = timestamp;
                                }
                            } catch (error) {
                                console.warn('[Dungeon Tracker] Failed to parse Key counts from message history:', error);
                            }
                        }
                    }
                }

                // FALLBACK: If no messages in memory, scan DOM (for messages that arrived before script loaded)
                if (!latestKeyCountsMap) {
                    const messages = document.querySelectorAll('[class^="ChatMessage_chatMessage"]');

                    // Scan all messages to find Battle started and most recent key counts
                    for (const msg of messages) {
                        const text = msg.textContent || '';

                        // FILTER: Skip player messages
                        // Check for username element (player messages have a username child element)
                        const hasUsername = msg.querySelector('[class*="ChatMessage_username"]') !== null;
                        if (hasUsername) {
                            continue; // Skip player messages
                        }

                        // FALLBACK: Check if text starts with non-timestamp text followed by colon
                        if (/^[^[]+:/.test(text)) {
                            continue; // Skip player messages
                        }

                        // Look for "Battle started:" messages
                        if (text.includes('Battle started:')) {
                            // Try to extract timestamp
                            // Try to extract timestamp from message display format: [MM/DD HH:MM:SS AM/PM] or [DD-M HH:MM:SS]
                            const timestampMatch = text.match(
                                /\[(\d{1,2})([-/])(\d{1,2})\s+(\d{1,2}):(\d{2}):(\d{2})\s*([AP]M)?\]/
                            );

                            if (timestampMatch) {
                                const part1 = parseInt(timestampMatch[1], 10);
                                const separator = timestampMatch[2];
                                const part2 = parseInt(timestampMatch[3], 10);
                                let hour = parseInt(timestampMatch[4], 10);
                                const min = parseInt(timestampMatch[5], 10);
                                const sec = parseInt(timestampMatch[6], 10);
                                const period = timestampMatch[7];

                                // Determine format based on separator
                                let month, day;
                                if (separator === '/') {
                                    // MM/DD format
                                    month = part1;
                                    day = part2;
                                } else {
                                    // DD-M format (dash separator)
                                    day = part1;
                                    month = part2;
                                }

                                // Handle AM/PM if present
                                if (period === 'PM' && hour < 12) hour += 12;
                                if (period === 'AM' && hour === 12) hour = 0;

                                // Create timestamp (assumes current year)
                                const now = new Date();
                                const timestamp = new Date(now.getFullYear(), month - 1, day, hour, min, sec, 0);

                                this.battleStartedTimestamp = timestamp.getTime();
                                battleStartedFound = true;
                            }
                        }

                        // Look for "Key counts:" messages
                        if (text.includes('Key counts:')) {
                            // Parse the message
                            const keyCountsMap = this.parseKeyCountsFromMessage(text);

                            if (Object.keys(keyCountsMap).length > 0) {
                                // Try to extract timestamp from message display format: [MM/DD HH:MM:SS AM/PM] or [DD-M HH:MM:SS]
                                const timestampMatch = text.match(
                                    /\[(\d{1,2})([-/])(\d{1,2})\s+(\d{1,2}):(\d{2}):(\d{2})\s*([AP]M)?\]/
                                );

                                if (timestampMatch) {
                                    const part1 = parseInt(timestampMatch[1], 10);
                                    const separator = timestampMatch[2];
                                    const part2 = parseInt(timestampMatch[3], 10);
                                    let hour = parseInt(timestampMatch[4], 10);
                                    const min = parseInt(timestampMatch[5], 10);
                                    const sec = parseInt(timestampMatch[6], 10);
                                    const period = timestampMatch[7];

                                    // Determine format based on separator
                                    let month, day;
                                    if (separator === '/') {
                                        // MM/DD format
                                        month = part1;
                                        day = part2;
                                    } else {
                                        // DD-M format (dash separator)
                                        day = part1;
                                        month = part2;
                                    }

                                    // Handle AM/PM if present
                                    if (period === 'PM' && hour < 12) hour += 12;
                                    if (period === 'AM' && hour === 12) hour = 0;

                                    // Create timestamp (assumes current year)
                                    const now = new Date();
                                    const timestamp = new Date(now.getFullYear(), month - 1, day, hour, min, sec, 0);

                                    // Keep this as the latest (will be overwritten if we find a newer one)
                                    latestKeyCountsMap = keyCountsMap;
                                    latestTimestamp = timestamp.getTime();
                                } else {
                                    console.warn(
                                        '[Dungeon Tracker] Found Key counts but could not parse timestamp from:',
                                        text.substring(0, 50)
                                    );
                                    latestKeyCountsMap = keyCountsMap;
                                }
                            }
                        }
                    }
                }

                // Update current run with the most recent key counts found
                if (latestKeyCountsMap && this.currentRun) {
                    this.currentRun.keyCountsMap = latestKeyCountsMap;

                    // Set firstKeyCountTimestamp and lastKeyCountTimestamp from DOM scan
                    // Priority: Use Battle started timestamp if found, otherwise use Key counts timestamp
                    if (this.firstKeyCountTimestamp === null) {
                        if (battleStartedFound && this.battleStartedTimestamp) {
                            // Use battle started as anchor point, key counts as first run timestamp
                            this.firstKeyCountTimestamp = latestTimestamp;
                            this.lastKeyCountTimestamp = latestTimestamp;
                        } else if (latestTimestamp) {
                            this.firstKeyCountTimestamp = latestTimestamp;
                            this.lastKeyCountTimestamp = latestTimestamp;
                        }

                        // Store this message for history
                        if (this.firstKeyCountTimestamp) {
                            this.keyCountMessages.push({
                                timestamp: this.firstKeyCountTimestamp,
                                keyCountsMap: latestKeyCountsMap,
                                text:
                                    'Key counts: ' +
                                    Object.entries(latestKeyCountsMap)
                                        .map(([name, count]) => `[${name} - ${count}]`)
                                        .join(', '),
                            });
                        }
                    }

                    this.notifyUpdate();
                    this.saveInProgressRun(); // Persist to IndexedDB
                } else if (!this.currentRun) {
                    console.warn('[Dungeon Tracker] Current run is null, cannot update');
                }
            } catch (error) {
                console.error('[Dungeon Tracker] Error scanning existing messages:', error);
            }
        }

        /**
         * Handle actions_updated message (detect flee/cancel and dungeon start)
         * @param {Object} data - actions_updated message data
         */
        onActionsUpdated(data) {
            // Check if any dungeon action was added or removed
            if (data.endCharacterActions) {
                for (const action of data.endCharacterActions) {
                    // Check if this is a dungeon action using explicit verification
                    if (this.isDungeonAction(action.actionHrid)) {
                        if (action.isDone === false) {
                            // Dungeon action added to queue - store info for when new_battle fires
                            this.pendingDungeonInfo = {
                                dungeonHrid: action.actionHrid,
                                tier: action.difficultyTier,
                            };

                            // If already tracking (somehow), update immediately
                            if (this.isTracking && !this.currentRun.dungeonHrid) {
                                this.currentRun.dungeonHrid = action.actionHrid;
                                this.currentRun.tier = action.difficultyTier;

                                const dungeonInfo = dungeonTrackerStorage.getDungeonInfo(action.actionHrid);
                                if (dungeonInfo) {
                                    this.currentRun.maxWaves = dungeonInfo.maxWaves;
                                    this.notifyUpdate();
                                }
                            }
                        } else if (action.isDone === true && this.isTracking && this.currentRun) {
                            // Dungeon action marked as done (completion or flee)

                            // If we don't have dungeon info yet, grab it from this action
                            if (!this.currentRun.dungeonHrid) {
                                this.currentRun.dungeonHrid = action.actionHrid;
                                this.currentRun.tier = action.difficultyTier;

                                const dungeonInfo = dungeonTrackerStorage.getDungeonInfo(action.actionHrid);
                                if (dungeonInfo) {
                                    this.currentRun.maxWaves = dungeonInfo.maxWaves;
                                    // Update UI with the name before resetting
                                    this.notifyUpdate();
                                }
                            }

                            // Check if this was a successful completion or early exit
                            const allWavesCompleted =
                                this.currentRun.maxWaves && this.currentRun.wavesCompleted >= this.currentRun.maxWaves;

                            if (!allWavesCompleted) {
                                // Early exit (fled, died, or failed)
                                this.resetTracking();
                            }
                            // If it was a successful completion, action_completed will handle it
                            return;
                        }
                    }
                }
            }
        }

        /**
         * Handle chat_message_received (parse Key counts messages, Battle started, and Party failed)
         * @param {Object} data - chat_message_received message data
         */
        onChatMessage(data) {
            // Extract message object
            const message = data.message;
            if (!message) {
                return;
            }

            // Only process party chat messages
            if (message.chan !== '/chat_channel_types/party') {
                return;
            }

            // Store ALL party messages in memory (for reliable timestamp capture)
            this.recentChatMessages.push(message);
            if (this.recentChatMessages.length > 100) {
                this.recentChatMessages.shift(); // Keep last 100 only
            }

            // Only process system messages
            if (!message.isSystemMessage) {
                return;
            }

            // Extract timestamp from message (convert to milliseconds)
            const timestamp = new Date(message.t).getTime();

            // Handle "Battle started" messages
            if (message.m === 'systemChatMessage.partyBattleStarted') {
                this.onBattleStarted(timestamp, message);
                return;
            }

            // Handle "Party failed" messages
            if (message.m === 'systemChatMessage.partyFailed') {
                this.onPartyFailed(timestamp, message);
                return;
            }

            // Handle "Key counts" messages
            if (message.m === 'systemChatMessage.partyKeyCount') {
                this.onKeyCountsMessage(timestamp, message);
            }
        }

        /**
         * Handle "Battle started" message
         * @param {number} timestamp - Message timestamp in milliseconds
         * @param {Object} message - Message object
         */
        onBattleStarted(timestamp, message) {
            // Store battle started timestamp
            this.battleStartedTimestamp = timestamp;

            // If tracking and dungeonHrid is set, check if this is a different dungeon
            if (this.isTracking && this.currentRun && this.currentRun.dungeonHrid) {
                // Parse dungeon name from message to detect dungeon switching
                try {
                    const metadata = JSON.parse(message.systemMetadata || '{}');
                    const battleName = metadata.name || '';

                    // Extract dungeon HRID from battle name (this is a heuristic)
                    const currentDungeonName =
                        dungeonTrackerStorage.getDungeonInfo(this.currentRun.dungeonHrid)?.name || '';

                    if (battleName && currentDungeonName && !battleName.includes(currentDungeonName)) {
                        this.resetTracking();
                    }
                } catch (error) {
                    console.error('[Dungeon Tracker] Error parsing battle started metadata:', error);
                }
            }
        }

        /**
         * Handle "Party failed" message
         * @param {number} _timestamp - Message timestamp in milliseconds
         * @param {Object} _message - Message object
         */
        onPartyFailed(_timestamp, _message) {
            if (!this.isTracking || !this.currentRun) {
                return;
            }

            // Mark run as failed and reset tracking
            this.resetTracking();
        }

        /**
         * Handle "Key counts" message
         * @param {number} timestamp - Message timestamp in milliseconds
         * @param {Object} message - Message object
         */
        onKeyCountsMessage(timestamp, message) {
            // Parse systemMetadata JSON to get keyCountString
            let keyCountString = '';
            try {
                const metadata = JSON.parse(message.systemMetadata);
                keyCountString = metadata.keyCountString || '';
            } catch (error) {
                console.error('[Dungeon Tracker] Failed to parse systemMetadata:', error);
                return;
            }

            // Parse key counts from the string
            const keyCountsMap = this.parseKeyCountsFromMessage(keyCountString);

            // If not tracking, ignore (probably from someone else's dungeon)
            if (!this.isTracking) {
                return;
            }

            // If we already have a lastKeyCountTimestamp, this is the COMPLETION message
            // (The first message sets both first and last to the same value)
            if (this.lastKeyCountTimestamp !== null && timestamp > this.lastKeyCountTimestamp) {
                // Check for midnight rollover
                timestamp - this.firstKeyCountTimestamp;

                // Update last timestamp for duration calculation
                this.lastKeyCountTimestamp = timestamp;

                // Update key counts
                if (this.currentRun) {
                    this.currentRun.keyCountsMap = keyCountsMap;
                }

                // Store completion message
                this.keyCountMessages.push({
                    timestamp,
                    keyCountsMap,
                    text: keyCountString,
                });

                // Complete the dungeon
                this.completeDungeon();
                return;
            }

            // First "Key counts" message = dungeon start
            if (this.firstKeyCountTimestamp === null) {
                // FALLBACK: If we're already tracking and have a currentRun.startTime,
                // this is probably the COMPLETION message, not the start!
                // This happens when state was restored but first message wasn't captured.
                if (this.currentRun && this.currentRun.startTime) {
                    // Use the currentRun.startTime as the first timestamp (best estimate)
                    this.firstKeyCountTimestamp = this.currentRun.startTime;
                    this.lastKeyCountTimestamp = timestamp; // Current message is completion

                    // Check for midnight rollover
                    timestamp - this.firstKeyCountTimestamp;

                    // Update key counts
                    if (this.currentRun) {
                        this.currentRun.keyCountsMap = keyCountsMap;
                    }

                    // Store completion message
                    this.keyCountMessages.push({
                        timestamp,
                        keyCountsMap,
                        text: keyCountString,
                    });

                    // Complete the dungeon
                    this.completeDungeon();
                    return;
                }

                // Normal case: This is actually the first message
                this.firstKeyCountTimestamp = timestamp;
                this.lastKeyCountTimestamp = timestamp; // Set both to same value initially
            }

            // Update current run with latest key counts
            if (this.currentRun) {
                this.currentRun.keyCountsMap = keyCountsMap;
                this.notifyUpdate(); // Trigger UI update with new key counts
                this.saveInProgressRun(); // Persist to IndexedDB
            }

            // Store message data for history
            this.keyCountMessages.push({
                timestamp,
                keyCountsMap,
                text: keyCountString,
            });
        }

        /**
         * Parse key counts from message text
         * @param {string} messageText - Message text containing key counts
         * @returns {Object} Map of player names to key counts
         */
        parseKeyCountsFromMessage(messageText) {
            const keyCountsMap = {};

            // Regex to match [PlayerName - KeyCount] pattern (with optional comma separators)
            const regex = /\[([^[\]-]+?)\s*-\s*([\d,]+)\]/g;
            let match;

            while ((match = regex.exec(messageText)) !== null) {
                const playerName = match[1].trim();
                // Remove commas before parsing
                const keyCount = parseInt(match[2].replace(/,/g, ''), 10);
                keyCountsMap[playerName] = keyCount;
            }

            return keyCountsMap;
        }

        /**
         * Calculate server-validated duration from party messages
         * @returns {number|null} Duration in milliseconds, or null if no messages
         */
        getPartyMessageDuration() {
            if (!this.firstKeyCountTimestamp || !this.lastKeyCountTimestamp) {
                return null;
            }

            // Duration = last message - first message
            return this.lastKeyCountTimestamp - this.firstKeyCountTimestamp;
        }

        /**
         * Handle new_battle message (wave start)
         * @param {Object} data - new_battle message data
         */
        async onNewBattle(data) {
            // Only track if we have wave data
            if (data.wave === undefined) {
                return;
            }

            // Capture battleId for persistence
            const battleId = data.battleId;

            // Wave 0 = first wave = dungeon start
            if (data.wave === 0) {
                // Clear any stale saved state first (in case previous run didn't clear properly)
                await this.clearInProgressRun();

                // Start fresh dungeon
                this.startDungeon(data);
            } else if (!this.isTracking) {
                // Mid-dungeon start - try to restore first
                const restored = await this.restoreInProgressRun(battleId);
                if (!restored) {
                    // No restore - initialize tracking anyway
                    this.startDungeon(data);
                }
            } else {
                // Subsequent wave (already tracking)
                // Update battleId in case user logged out and back in (new battle instance)
                this.currentBattleId = data.battleId;
                this.startWave(data);
            }
        }

        /**
         * Start tracking a new dungeon run
         * @param {Object} data - new_battle message data
         */
        startDungeon(data) {
            // Get dungeon info - prioritize pending info from actions_updated
            let dungeonHrid = null;
            let tier = null;
            let maxWaves = null;

            if (this.pendingDungeonInfo) {
                // Verify this is actually a dungeon action before starting tracking
                if (!this.isDungeonAction(this.pendingDungeonInfo.dungeonHrid)) {
                    console.warn(
                        '[Dungeon Tracker] Attempted to track non-dungeon action:',
                        this.pendingDungeonInfo.dungeonHrid
                    );
                    this.pendingDungeonInfo = null;
                    return; // Don't start tracking
                }

                // Use info from actions_updated message
                dungeonHrid = this.pendingDungeonInfo.dungeonHrid;
                tier = this.pendingDungeonInfo.tier;

                const dungeonInfo = dungeonTrackerStorage.getDungeonInfo(dungeonHrid);
                if (dungeonInfo) {
                    maxWaves = dungeonInfo.maxWaves;
                }

                // Clear pending info
                this.pendingDungeonInfo = null;
            } else {
                // FALLBACK: Check current actions from dataManager
                const currentActions = dataManager$1.getCurrentActions();
                const dungeonAction = currentActions.find((a) => this.isDungeonAction(a.actionHrid) && !a.isDone);

                if (dungeonAction) {
                    dungeonHrid = dungeonAction.actionHrid;
                    tier = dungeonAction.difficultyTier;

                    const dungeonInfo = dungeonTrackerStorage.getDungeonInfo(dungeonHrid);
                    if (dungeonInfo) {
                        maxWaves = dungeonInfo.maxWaves;
                    }
                }
            }

            // Don't start tracking if we don't have dungeon info (not a dungeon)
            if (!dungeonHrid) {
                return;
            }

            this.isTracking = true;
            this.currentBattleId = data.battleId; // Store battleId for persistence
            this.waveStartTime = new Date(data.combatStartTime);
            this.waveTimes = [];

            // Reset party message tracking
            this.firstKeyCountTimestamp = null;
            this.lastKeyCountTimestamp = null;
            this.keyCountMessages = [];

            // Reset hibernation detection for new run
            this.hibernationDetected = false;

            this.currentRun = {
                dungeonHrid: dungeonHrid,
                tier: tier,
                startTime: this.waveStartTime.getTime(),
                currentWave: data.wave, // Use actual wave number (1-indexed)
                maxWaves: maxWaves,
                wavesCompleted: 0, // No waves completed yet (will update as waves complete)
                hibernationDetected: false, // Track if computer sleep detected during this run
            };

            this.notifyUpdate();

            // Save initial state to IndexedDB
            this.saveInProgressRun();

            // Scan existing chat messages NOW that we're tracking (key counts message already in chat)
            const scanTimeout = setTimeout(() => this.scanExistingChatMessages(), 100);
            this.timerRegistry.registerTimeout(scanTimeout);
        }

        /**
         * Start tracking a new wave
         * @param {Object} data - new_battle message data
         */
        startWave(data) {
            if (!this.isTracking) {
                return;
            }

            // Update current wave
            this.waveStartTime = new Date(data.combatStartTime);
            this.currentRun.currentWave = data.wave;

            this.notifyUpdate();

            // Save state after each wave start
            this.saveInProgressRun();
        }

        /**
         * Handle action_completed message (wave complete)
         * @param {Object} data - action_completed message data
         */
        onActionCompleted(data) {
            const action = data.endCharacterAction;

            if (!this.isTracking) {
                return;
            }

            // Verify this is a dungeon action
            if (!this.isDungeonAction(action.actionHrid)) {
                return;
            }

            // Ignore non-dungeon combat (zones don't have maxCount or wave field)
            if (action.wave === undefined) {
                return;
            }

            // Set dungeon info if not already set (fallback for mid-dungeon starts)
            if (!this.currentRun.dungeonHrid) {
                this.currentRun.dungeonHrid = action.actionHrid;
                this.currentRun.tier = action.difficultyTier;

                const dungeonInfo = dungeonTrackerStorage.getDungeonInfo(action.actionHrid);
                if (dungeonInfo) {
                    this.currentRun.maxWaves = dungeonInfo.maxWaves;
                }

                // Notify update now that we have dungeon name
                this.notifyUpdate();
            }

            // Calculate wave time
            const waveEndTime = Date.now();
            const waveTime = waveEndTime - this.waveStartTime.getTime();
            this.waveTimes.push(waveTime);

            // Update waves completed
            // BUGFIX: Wave 50 completion sends wave: 0, so use currentWave instead
            const actualWaveNumber = action.wave === 0 ? this.currentRun.currentWave : action.wave;
            this.currentRun.wavesCompleted = actualWaveNumber;

            // Save state after wave completion
            this.saveInProgressRun();

            // Check if dungeon is complete
            if (action.isDone) {
                // Check if this was a successful completion (all waves done) or early exit
                const allWavesCompleted =
                    this.currentRun.maxWaves && this.currentRun.wavesCompleted >= this.currentRun.maxWaves;

                if (allWavesCompleted) {
                    // Successful completion
                    this.completeDungeon();
                } else {
                    // Early exit (fled, died, or failed)
                    this.resetTracking();
                }
            } else {
                this.notifyUpdate();
            }
        }

        /**
         * Complete the current dungeon run
         */
        async completeDungeon() {
            if (!this.currentRun || !this.isTracking) {
                return;
            }

            // Reset tracking immediately to prevent race condition with next dungeon
            this.isTracking = false;

            // Copy all state to local variables IMMEDIATELY so next dungeon can start clean
            const completedRunData = this.currentRun;
            const completedWaveTimes = [...this.waveTimes];
            const completedKeyCountMessages = [...this.keyCountMessages];
            const firstTimestamp = this.firstKeyCountTimestamp;
            const lastTimestamp = this.lastKeyCountTimestamp;

            // Clear ALL state immediately - next dungeon can now start without contamination
            this.currentRun = null;
            this.waveStartTime = null;
            this.waveTimes = [];
            this.firstKeyCountTimestamp = null;
            this.lastKeyCountTimestamp = null;
            this.keyCountMessages = [];
            this.currentBattleId = null;

            // Clear saved in-progress state immediately (before async saves)
            // This prevents race condition where next dungeon saves state, then we clear it
            await this.clearInProgressRun();

            const endTime = Date.now();
            const trackedTotalTime = endTime - completedRunData.startTime;

            // Get server-validated duration from party messages
            const partyMessageDuration = firstTimestamp && lastTimestamp ? lastTimestamp - firstTimestamp : null;
            const validated = partyMessageDuration !== null;

            // Use party message duration if available (authoritative), otherwise use tracked duration
            const totalTime = validated ? partyMessageDuration : trackedTotalTime;

            // Calculate statistics
            const avgWaveTime = completedWaveTimes.reduce((sum, time) => sum + time, 0) / completedWaveTimes.length;
            const fastestWave = Math.min(...completedWaveTimes);
            const slowestWave = Math.max(...completedWaveTimes);

            // Build complete run object
            const completedRun = {
                dungeonHrid: completedRunData.dungeonHrid,
                tier: completedRunData.tier,
                startTime: completedRunData.startTime,
                endTime,
                totalTime, // Authoritative duration (party message or tracked)
                trackedDuration: trackedTotalTime, // Wall-clock tracked duration
                partyMessageDuration, // Server-validated duration (null if solo)
                validated, // true if party messages available
                avgWaveTime,
                fastestWave,
                slowestWave,
                wavesCompleted: completedRunData.wavesCompleted,
                waveTimes: completedWaveTimes,
                keyCountMessages: completedKeyCountMessages, // Store key data for history
                keyCountsMap: completedRunData.keyCountsMap, // Include for backward compatibility
            };

            // Auto-save completed run to history if we have complete data
            // Only saves runs completed during live tracking (Option A)
            if (validated && completedRunData.keyCountsMap && completedRunData.dungeonHrid) {
                try {
                    // Extract team from keyCountsMap
                    const team = Object.keys(completedRunData.keyCountsMap).sort();
                    const teamKey = dungeonTrackerStorage.getTeamKey(team);

                    // Get dungeon name from HRID
                    const dungeonInfo = dungeonTrackerStorage.getDungeonInfo(completedRunData.dungeonHrid);
                    const dungeonName = dungeonInfo ? dungeonInfo.name : 'Unknown';

                    // Build run object in unified format
                    const runToSave = {
                        timestamp: new Date(firstTimestamp).toISOString(), // Use party message timestamp
                        duration: partyMessageDuration, // Server-validated duration
                        dungeonName: dungeonName,
                        keyCountsMap: completedRunData.keyCountsMap, // Include key counts
                    };

                    // Save to database (with duplicate detection)
                    await dungeonTrackerStorage.saveTeamRun(teamKey, runToSave);
                } catch (error) {
                    console.error('[Dungeon Tracker] Failed to auto-save run:', error);
                }
            }

            // Notify completion
            this.notifyCompletion(completedRun);

            this.notifyUpdate();
        }

        /**
         * Format time in milliseconds to MM:SS
         * @param {number} ms - Time in milliseconds
         * @returns {string} Formatted time
         */
        formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        /**
         * Reset tracking state (on completion, flee, or death)
         */
        async resetTracking() {
            this.isTracking = false;
            this.currentRun = null;
            this.waveStartTime = null;
            this.waveTimes = [];
            this.pendingDungeonInfo = null;
            this.currentBattleId = null;

            // Clear party message tracking
            this.firstKeyCountTimestamp = null;
            this.lastKeyCountTimestamp = null;
            this.keyCountMessages = [];
            this.battleStartedTimestamp = null;

            // Clear saved state (await to ensure it completes)
            await this.clearInProgressRun();

            this.notifyUpdate();
        }

        /**
         * Get current run state
         * @returns {Object|null} Current run state or null
         */
        getCurrentRun() {
            if (!this.isTracking || !this.currentRun) {
                return null;
            }

            // Calculate current elapsed time
            // Use firstKeyCountTimestamp (server-validated start) if available, otherwise use tracked start time
            const now = Date.now();
            const runStartTime = this.firstKeyCountTimestamp || this.currentRun.startTime;
            const totalElapsed = now - runStartTime;
            const currentWaveElapsed = now - this.waveStartTime.getTime();

            // Calculate average wave time so far
            const avgWaveTime =
                this.waveTimes.length > 0 ? this.waveTimes.reduce((sum, time) => sum + time, 0) / this.waveTimes.length : 0;

            // Calculate ETA
            const remainingWaves = this.currentRun.maxWaves - this.currentRun.wavesCompleted;
            const estimatedTimeRemaining = avgWaveTime > 0 ? avgWaveTime * remainingWaves : 0;

            // Calculate fastest/slowest wave times
            const fastestWave = this.waveTimes.length > 0 ? Math.min(...this.waveTimes) : 0;
            const slowestWave = this.waveTimes.length > 0 ? Math.max(...this.waveTimes) : 0;

            return {
                dungeonHrid: this.currentRun.dungeonHrid,
                dungeonName: this.currentRun.dungeonHrid
                    ? dungeonTrackerStorage.getDungeonInfo(this.currentRun.dungeonHrid)?.name
                    : 'Unknown',
                tier: this.currentRun.tier,
                currentWave: this.currentRun.currentWave, // Already 1-indexed from new_battle message
                maxWaves: this.currentRun.maxWaves,
                wavesCompleted: this.currentRun.wavesCompleted,
                totalElapsed,
                currentWaveElapsed,
                avgWaveTime,
                fastestWave,
                slowestWave,
                estimatedTimeRemaining,
                keyCountsMap: this.currentRun.keyCountsMap || {}, // Party member key counts
            };
        }

        /**
         * Register a callback for run updates
         * @param {Function} callback - Callback function
         */
        onUpdate(callback) {
            this.updateCallbacks.push(callback);
        }

        /**
         * Unregister a callback for run updates
         * @param {Function} callback - Callback function to remove
         */
        offUpdate(callback) {
            const index = this.updateCallbacks.indexOf(callback);
            if (index > -1) {
                this.updateCallbacks.splice(index, 1);
            }
        }

        /**
         * Notify all registered callbacks of an update
         */
        notifyUpdate() {
            for (const callback of this.updateCallbacks) {
                try {
                    callback(this.getCurrentRun());
                } catch (error) {
                    console.error('[Dungeon Tracker] Update callback error:', error);
                }
            }
        }

        /**
         * Notify all registered callbacks of completion
         * @param {Object} completedRun - Completed run data
         */
        notifyCompletion(completedRun) {
            for (const callback of this.updateCallbacks) {
                try {
                    callback(null, completedRun);
                } catch (error) {
                    console.error('[Dungeon Tracker] Completion callback error:', error);
                }
            }
        }

        /**
         * Check if currently tracking a dungeon
         * @returns {boolean} True if tracking
         */
        isTrackingDungeon() {
            return this.isTracking;
        }

        /**
         * Cleanup for character switching
         */
        async cleanup() {
            if (this.handlers.newBattle) {
                webSocketHook$1.off('new_battle', this.handlers.newBattle);
                this.handlers.newBattle = null;
            }
            if (this.handlers.actionCompleted) {
                webSocketHook$1.off('action_completed', this.handlers.actionCompleted);
                this.handlers.actionCompleted = null;
            }
            if (this.handlers.actionsUpdated) {
                webSocketHook$1.off('actions_updated', this.handlers.actionsUpdated);
                this.handlers.actionsUpdated = null;
            }
            if (this.handlers.chatMessage) {
                webSocketHook$1.off('chat_message_received', this.handlers.chatMessage);
                this.handlers.chatMessage = null;
            }

            // Reset all tracking state
            this.isTracking = false;
            this.currentRun = null;
            this.waveStartTime = null;
            this.waveTimes = [];
            this.pendingDungeonInfo = null;
            this.currentBattleId = null;

            // Clear party message tracking
            this.firstKeyCountTimestamp = null;
            this.lastKeyCountTimestamp = null;
            this.keyCountMessages = [];
            this.battleStartedTimestamp = null;
            this.recentChatMessages = [];

            // Reset hibernation detection
            this.hibernationDetected = false;

            if (this.visibilityHandler) {
                document.removeEventListener('visibilitychange', this.visibilityHandler);
                this.visibilityHandler = null;
            }

            // Clear character ID
            this.characterId = null;

            // Clear all callbacks
            this.updateCallbacks = [];

            this.timerRegistry.clearAll();

            // Clear saved in-progress run
            await this.clearInProgressRun();

            // Reset initialization flag
            this.isInitialized = false;
        }

        /**
         * Backfill team runs from party chat history
         * Scans all "Key counts:" messages and calculates run durations
         * @returns {Promise<{runsAdded: number, teams: Array<string>}>} Backfill results
         */
        async backfillFromChatHistory() {
            try {
                const messages = document.querySelectorAll('[class^="ChatMessage_chatMessage"]');
                const events = [];

                // Extract all relevant events: key counts, party failed, battle ended, battle started
                for (const msg of messages) {
                    const text = msg.textContent || '';

                    // FILTER: Skip player messages
                    // Check for username element (player messages have a username child element)
                    const hasUsername = msg.querySelector('[class*="ChatMessage_username"]') !== null;
                    if (hasUsername) {
                        continue; // Skip player messages
                    }

                    // FALLBACK: Check if text starts with non-timestamp text followed by colon
                    if (/^[^[]+:/.test(text)) {
                        continue; // Skip player messages
                    }

                    // Parse timestamp from message display format: [MM/DD HH:MM:SS AM/PM] or [DD-M HH:MM:SS]
                    const timestampMatch = text.match(
                        /\[(\d{1,2})([-/])(\d{1,2})\s+(\d{1,2}):(\d{2}):(\d{2})\s*([AP]M)?\]/
                    );
                    if (!timestampMatch) continue;

                    const part1 = parseInt(timestampMatch[1], 10);
                    const separator = timestampMatch[2];
                    const part2 = parseInt(timestampMatch[3], 10);
                    let hour = parseInt(timestampMatch[4], 10);
                    const min = parseInt(timestampMatch[5], 10);
                    const sec = parseInt(timestampMatch[6], 10);
                    const period = timestampMatch[7];

                    // Determine format based on separator
                    let month, day;
                    if (separator === '/') {
                        // MM/DD format
                        month = part1;
                        day = part2;
                    } else {
                        // DD-M format (dash separator)
                        day = part1;
                        month = part2;
                    }

                    // Handle AM/PM if present
                    if (period === 'PM' && hour < 12) hour += 12;
                    if (period === 'AM' && hour === 12) hour = 0;

                    // Create timestamp (assumes current year)
                    const now = new Date();
                    const timestamp = new Date(now.getFullYear(), month - 1, day, hour, min, sec, 0);

                    // Extract "Battle started:" messages
                    if (text.includes('Battle started:')) {
                        const dungeonName = text.split('Battle started:')[1]?.split(']')[0]?.trim();
                        if (dungeonName) {
                            events.push({
                                type: 'battle_start',
                                timestamp,
                                dungeonName,
                            });
                        }
                    }
                    // Extract "Key counts:" messages
                    else if (text.includes('Key counts:')) {
                        // Parse team composition from key counts
                        const keyCountsMap = this.parseKeyCountsFromMessage(text);
                        const playerNames = Object.keys(keyCountsMap).sort();

                        if (playerNames.length > 0) {
                            events.push({
                                type: 'key',
                                timestamp,
                                team: playerNames,
                                keyCountsMap,
                            });
                        }
                    }
                    // Extract "Party failed" messages
                    else if (text.match(/Party failed on wave \d+/)) {
                        events.push({
                            type: 'fail',
                            timestamp,
                        });
                    }
                    // Extract "Battle ended:" messages (fled/canceled)
                    else if (text.includes('Battle ended:')) {
                        const dungeonName = text.split('Battle ended:')[1]?.split(']')[0]?.trim();
                        events.push({
                            type: 'cancel',
                            timestamp,
                            dungeonName,
                        });
                    }
                }

                // Sort events by timestamp
                events.sort((a, b) => a.timestamp - b.timestamp);

                // Build runs from events - only count key→key pairs (skip key→fail and key→cancel)
                let runsAdded = 0;
                const teamsSet = new Set();

                for (let i = 0; i < events.length; i++) {
                    const event = events[i];
                    if (event.type !== 'key') continue; // Only process key count events

                    const next = events[i + 1];
                    if (!next) break; // No next event

                    // Only create run if next event is also a key count (successful completion)
                    if (next.type === 'key') {
                        // Calculate duration (handle midnight rollover)
                        let duration = next.timestamp - event.timestamp;
                        if (duration < 0) {
                            duration += 24 * 60 * 60 * 1000; // Add 24 hours
                        }

                        // Find nearest battle_ended or battle_start before this run
                        // Prioritize battle_ended (appears right before key count completion)
                        const battleEnded = events
                            .slice(0, i)
                            .reverse()
                            .find((e) => e.type === 'cancel' && e.dungeonName);

                        const battleStart = events
                            .slice(0, i)
                            .reverse()
                            .find((e) => e.type === 'battle_start');

                        // Use battle_ended if available, otherwise fall back to battle_start
                        const dungeonName = battleEnded?.dungeonName || battleStart?.dungeonName || 'Unknown';

                        // Get team key
                        const teamKey = dungeonTrackerStorage.getTeamKey(event.team);
                        teamsSet.add(teamKey);

                        // Save team run with dungeon name
                        const run = {
                            timestamp: event.timestamp.toISOString(),
                            duration: duration,
                            dungeonName: dungeonName,
                        };

                        const saved = await dungeonTrackerStorage.saveTeamRun(teamKey, run);
                        if (saved) {
                            runsAdded++;
                        }
                    }
                    // If next event is 'fail' or 'cancel', skip this key count (not a completed run)
                }

                return {
                    runsAdded,
                    teams: Array.from(teamsSet),
                };
            } catch (error) {
                console.error('[Dungeon Tracker] Backfill error:', error);
                return {
                    runsAdded: 0,
                    teams: [],
                };
            }
        }
    }

    const dungeonTracker = new DungeonTracker();

    /**
     * Dungeon Tracker Chat Annotations
     * Adds colored timer annotations to party chat messages
     * Handles both real-time (new messages) and batch (historical messages) processing
     */


    class DungeonTrackerChatAnnotations {
        constructor() {
            this.enabled = true;
            this.observer = null;
            this.lastSeenDungeonName = null; // Cache last known dungeon name
            this.cumulativeStatsByDungeon = {}; // Persistent cumulative counters for rolling averages
            this.processedMessages = new Map(); // Track processed messages to prevent duplicate counting
            this.initComplete = false; // Flag to ensure storage loads before annotation
            this.timerRegistry = createTimerRegistry();
            this.tabClickHandlers = new Map(); // Store tab click handlers for cleanup
        }

        /**
         * Initialize chat annotation monitor
         */
        async initialize() {
            // Load run counts from storage to sync with UI
            await this.loadRunCountsFromStorage();

            // Wait for chat to be available
            this.waitForChat();

            dataManager$1.on('character_switching', () => {
                this.cleanup();
            });
        }

        /**
         * Load run counts from storage to keep chat and UI in sync
         */
        async loadRunCountsFromStorage() {
            try {
                // Get all runs from unified storage
                const allRuns = await dungeonTrackerStorage.getAllRuns();

                // Extract unique dungeon names
                const uniqueDungeonNames = [...new Set(allRuns.map((run) => run.dungeonName))];

                // Load stats for each dungeon
                for (const dungeonName of uniqueDungeonNames) {
                    const stats = await dungeonTrackerStorage.getStatsByName(dungeonName);
                    if (stats && stats.totalRuns > 0) {
                        this.cumulativeStatsByDungeon[dungeonName] = {
                            runCount: stats.totalRuns,
                            totalTime: stats.avgTime * stats.totalRuns, // Reconstruct total time
                        };
                    }
                }

                this.initComplete = true;
            } catch (error) {
                console.error('[Dungeon Tracker] Failed to load run counts from storage:', error);
                this.initComplete = true; // Continue anyway
            }
        }

        /**
         * Refresh run counts after backfill operation
         */
        async refreshRunCounts() {
            this.cumulativeStatsByDungeon = {};
            this.processedMessages.clear();
            await this.loadRunCountsFromStorage();
            await this.annotateAllMessages();
        }

        /**
         * Wait for chat to be ready
         */
        waitForChat() {
            // Start monitoring immediately (doesn't need specific container)
            this.startMonitoring();

            // Initial annotation of existing messages (batch mode)
            const initialAnnotateTimeout = setTimeout(() => this.annotateAllMessages(), 1500);
            this.timerRegistry.registerTimeout(initialAnnotateTimeout);

            // Also trigger when switching to party chat
            this.observeTabSwitches();
        }

        /**
         * Observe chat tab switches to trigger batch annotation when user views party chat
         */
        observeTabSwitches() {
            // Find all chat tab buttons
            const tabButtons = document.querySelectorAll('.Chat_tabsComponentContainer__3ZoKe .MuiButtonBase-root');

            for (const button of tabButtons) {
                if (button.textContent.includes('Party')) {
                    // Remove old listener if exists
                    const oldHandler = this.tabClickHandlers.get(button);
                    if (oldHandler) {
                        button.removeEventListener('click', oldHandler);
                    }

                    // Create new handler
                    const handler = () => {
                        // Delay to let DOM update
                        const annotateTimeout = setTimeout(() => this.annotateAllMessages(), 300);
                        this.timerRegistry.registerTimeout(annotateTimeout);
                    };

                    // Store and add new listener
                    this.tabClickHandlers.set(button, handler);
                    button.addEventListener('click', handler);
                }
            }
        }

        /**
         * Start monitoring chat for new messages
         */
        startMonitoring() {
            // Stop existing observer if any
            if (this.observer) {
                this.observer();
            }

            // Create mutation observer to watch for new messages
            this.observer = createMutationWatcher(
                document.body,
                (mutations) => {
                    for (const mutation of mutations) {
                        for (const node of mutation.addedNodes) {
                            if (!(node instanceof HTMLElement)) continue;

                            const msg = node.matches?.('[class^="ChatMessage_chatMessage"]')
                                ? node
                                : node.querySelector?.('[class^="ChatMessage_chatMessage"]');

                            if (!msg) continue;

                            // Re-run batch annotation on any new message (matches working DRT script)
                            const annotateTimeout = setTimeout(() => this.annotateAllMessages(), 100);
                            this.timerRegistry.registerTimeout(annotateTimeout);
                        }
                    }
                },
                {
                    childList: true,
                    subtree: true,
                }
            );
        }

        /**
         * Batch process all chat messages (for historical messages)
         * Called on page load and when needed
         */
        async annotateAllMessages() {
            if (!this.enabled || !config$1.isFeatureEnabled('dungeonTracker')) {
                return;
            }

            // Wait for initialization to complete to ensure run counts are loaded
            if (!this.initComplete) {
                await new Promise((resolve) => {
                    const checkInterval = setInterval(() => {
                        if (this.initComplete) {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 50);

                    this.timerRegistry.registerInterval(checkInterval);

                    // Timeout after 5 seconds
                    const initTimeout = setTimeout(() => {
                        clearInterval(checkInterval);
                        resolve();
                    }, 5000);
                    this.timerRegistry.registerTimeout(initTimeout);
                });
            }

            const events = this.extractChatEvents();

            // NOTE: Run saving is done manually via the Backfill button
            // Chat annotations only add visual time labels to messages

            // Calculate in-memory stats from visible chat messages (for color thresholds only)
            const inMemoryStats = this.calculateStatsFromEvents(events);

            // Continue with visual annotations
            const runDurations = [];

            for (let i = 0; i < events.length; i++) {
                const e = events[i];
                if (e.type !== 'key') continue;

                const next = events[i + 1];
                let label = null;
                let diff = null;
                let color = null;

                // Get dungeon name with hybrid fallback (handles chat scrolling)
                const dungeonName = this.getDungeonNameWithFallback(events, i);

                if (next?.type === 'key') {
                    // Calculate duration between consecutive key counts
                    diff = next.timestamp - e.timestamp;
                    if (diff < 0) {
                        diff += 24 * 60 * 60 * 1000; // Handle midnight rollover
                    }

                    label = this.formatTime(diff);

                    // Determine color based on performance using dungeonName
                    // Check storage first, fall back to in-memory stats
                    if (dungeonName && dungeonName !== 'Unknown') {
                        const storageStats = await dungeonTrackerStorage.getStatsByName(dungeonName);
                        const stats = storageStats.totalRuns > 0 ? storageStats : inMemoryStats[dungeonName];

                        if (stats && stats.fastestTime > 0 && stats.slowestTime > 0) {
                            const fastestThreshold = stats.fastestTime * 1.1;
                            const slowestThreshold = stats.slowestTime * 0.9;

                            if (diff <= fastestThreshold) {
                                color = config$1.COLOR_PROFIT || '#5fda5f'; // Green
                            } else if (diff >= slowestThreshold) {
                                color = config$1.COLOR_LOSS || '#ff6b6b'; // Red
                            } else {
                                color = '#90ee90'; // Light green (normal)
                            }
                        } else {
                            color = '#90ee90'; // Light green (default)
                        }
                    } else {
                        color = '#90ee90'; // Light green (fallback)
                    }

                    // Track run durations for average calculation
                    runDurations.push({
                        msg: e.msg,
                        diff,
                        dungeonName,
                    });
                } else if (next?.type === 'fail') {
                    label = 'FAILED';
                    color = '#ff4c4c'; // Red
                } else if (next?.type === 'cancel') {
                    label = 'canceled';
                    color = '#ffd700'; // Gold
                }

                if (label) {
                    // Check if this is a successful run before inserting annotation
                    const nextNext = events[i + 2];
                    const nextRunWasCanceled = nextNext && (nextNext.type === 'fail' || nextNext.type === 'cancel');
                    const isSuccessfulRun = diff && dungeonName && dungeonName !== 'Unknown' && !nextRunWasCanceled;

                    if (isSuccessfulRun) {
                        // Create unique message ID to prevent duplicate counting on scroll
                        const messageId = `${e.timestamp.getTime()}_${dungeonName}`;

                        // Initialize dungeon tracking if needed
                        if (!this.cumulativeStatsByDungeon[dungeonName]) {
                            this.cumulativeStatsByDungeon[dungeonName] = {
                                runCount: 0,
                                totalTime: 0,
                            };
                        }

                        const dungeonStats = this.cumulativeStatsByDungeon[dungeonName];

                        // Check if this message was already counted
                        if (this.processedMessages.has(messageId)) {
                            // Already counted, use stored run number
                            const storedRunNumber = this.processedMessages.get(messageId);
                            label = `Run #${storedRunNumber}: ${label}`;
                        } else {
                            // New message, increment counter and store
                            dungeonStats.runCount++;
                            dungeonStats.totalTime += diff;
                            this.processedMessages.set(messageId, dungeonStats.runCount);
                            label = `Run #${dungeonStats.runCount}: ${label}`;
                        }
                    }

                    // Mark as processed BEFORE inserting (matches working DRT script)
                    e.msg.dataset.processed = '1';

                    this.insertAnnotation(label, color, e.msg, false);

                    // Add cumulative average if this is a successful run
                    if (isSuccessfulRun) {
                        const dungeonStats = this.cumulativeStatsByDungeon[dungeonName];

                        // Calculate cumulative average (average of all runs up to this point)
                        const cumulativeAvg = Math.floor(dungeonStats.totalTime / dungeonStats.runCount);

                        // Show cumulative average
                        const avgLabel = `Average: ${this.formatTime(cumulativeAvg)}`;
                        this.insertAnnotation(avgLabel, '#deb887', e.msg, true); // Tan color
                    }
                }
            }
        }

        /**
         * Save runs from chat events to storage (Phase 5: authoritative source)
         * @param {Array} events - Chat events array
         */
        async saveRunsFromEvents(events) {

            for (let i = 0; i < events.length; i++) {
                const event = events[i];
                if (event.type !== 'key') continue;

                const next = events[i + 1];
                if (!next || next.type !== 'key') continue; // Only key→key pairs

                // Calculate duration
                let duration = next.timestamp - event.timestamp;
                if (duration < 0) duration += 24 * 60 * 60 * 1000; // Midnight rollover

                // Get dungeon name with hybrid fallback (handles chat scrolling)
                const dungeonName = this.getDungeonNameWithFallback(events, i);

                // Get team key
                const teamKey = dungeonTrackerStorage.getTeamKey(event.team);

                // Create run object
                const run = {
                    timestamp: event.timestamp.toISOString(),
                    duration: duration,
                    dungeonName: dungeonName,
                };

                // Save team run (includes dungeon name from Phase 2)
                await dungeonTrackerStorage.saveTeamRun(teamKey, run);
            }
        }

        /**
         * Calculate stats from visible chat events (in-memory, no storage)
         * Used to show averages before backfill is done
         * @param {Array} events - Chat events array
         * @returns {Object} Stats by dungeon name { dungeonName: { totalRuns, avgTime, fastestTime, slowestTime } }
         */
        calculateStatsFromEvents(events) {
            const statsByDungeon = {};

            // Loop through events and collect all completed runs
            for (let i = 0; i < events.length; i++) {
                const event = events[i];
                if (event.type !== 'key') continue;

                const next = events[i + 1];
                if (!next || next.type !== 'key') continue; // Only key→key pairs (successful runs)

                // Calculate duration
                let duration = next.timestamp - event.timestamp;
                if (duration < 0) duration += 24 * 60 * 60 * 1000; // Midnight rollover

                // Get dungeon name
                const dungeonName = this.getDungeonNameWithFallback(events, i);
                if (!dungeonName || dungeonName === 'Unknown') continue;

                // Initialize dungeon stats if needed
                if (!statsByDungeon[dungeonName]) {
                    statsByDungeon[dungeonName] = {
                        durations: [],
                    };
                }

                // Add this run duration
                statsByDungeon[dungeonName].durations.push(duration);
            }

            // Calculate stats for each dungeon
            const result = {};
            for (const [dungeonName, data] of Object.entries(statsByDungeon)) {
                const durations = data.durations;
                if (durations.length === 0) continue;

                const total = durations.reduce((sum, d) => sum + d, 0);
                result[dungeonName] = {
                    totalRuns: durations.length,
                    avgTime: Math.floor(total / durations.length),
                    fastestTime: Math.min(...durations),
                    slowestTime: Math.max(...durations),
                };
            }

            return result;
        }

        /**
         * Extract chat events from DOM
         * @returns {Array} Array of chat events with timestamps and types
         */
        extractChatEvents() {
            // Query ALL chat messages (matches working DRT script - no tab filtering)
            const nodes = [...document.querySelectorAll('[class^="ChatMessage_chatMessage"]')];
            const events = [];

            for (const node of nodes) {
                if (node.dataset.processed === '1') continue;

                const text = node.textContent.trim();

                // Check message relevance FIRST before parsing timestamp
                // Battle started message
                if (text.includes('Battle started:')) {
                    const timestamp = this.getTimestampFromMessage(node);
                    if (!timestamp) {
                        console.warn('[Dungeon Tracker Debug] Battle started message has no timestamp:', text);
                        continue;
                    }

                    const dungeonName = text.split('Battle started:')[1]?.split(']')[0]?.trim();
                    if (dungeonName) {
                        // Cache the dungeon name (survives chat scrolling)
                        this.lastSeenDungeonName = dungeonName;

                        events.push({
                            type: 'battle_start',
                            timestamp,
                            dungeonName,
                            msg: node,
                        });
                    }
                    node.dataset.processed = '1';
                }
                // Key counts message (warn if timestamp fails - these should always have timestamps)
                else if (text.includes('Key counts:')) {
                    const timestamp = this.getTimestampFromMessage(node, true);
                    if (!timestamp) continue;

                    const team = this.getTeamFromMessage(node);
                    if (!team.length) continue;

                    events.push({
                        type: 'key',
                        timestamp,
                        team,
                        msg: node,
                    });
                }
                // Party failed message
                else if (text.match(/Party failed on wave \d+/)) {
                    const timestamp = this.getTimestampFromMessage(node);
                    if (!timestamp) continue;

                    events.push({
                        type: 'fail',
                        timestamp,
                        msg: node,
                    });
                    node.dataset.processed = '1';
                }
                // Battle ended (canceled/fled)
                else if (text.includes('Battle ended:')) {
                    const timestamp = this.getTimestampFromMessage(node);
                    if (!timestamp) continue;

                    events.push({
                        type: 'cancel',
                        timestamp,
                        msg: node,
                    });
                    node.dataset.processed = '1';
                }
            }

            return events;
        }

        /**
         * Get dungeon name with hybrid fallback strategy
         * Handles chat scrolling by using multiple sources
         * @param {Array} events - All chat events
         * @param {number} currentIndex - Current event index
         * @returns {string} Dungeon name or 'Unknown'
         */
        getDungeonNameWithFallback(events, currentIndex) {
            // 1st priority: Visible "Battle started:" message in chat
            const battleStart = events
                .slice(0, currentIndex)
                .reverse()
                .find((ev) => ev.type === 'battle_start');
            if (battleStart?.dungeonName) {
                return battleStart.dungeonName;
            }

            // 2nd priority: Currently active dungeon run
            const currentRun = dungeonTracker.getCurrentRun();
            if (currentRun?.dungeonName && currentRun.dungeonName !== 'Unknown') {
                return currentRun.dungeonName;
            }

            // 3rd priority: Cached last seen dungeon name
            if (this.lastSeenDungeonName) {
                return this.lastSeenDungeonName;
            }

            // Final fallback
            console.warn('[Dungeon Tracker Debug] ALL PRIORITIES FAILED for index', currentIndex, '-> Unknown');
            return 'Unknown';
        }

        /**
         * Check if party chat is currently selected
         * @returns {boolean} True if party chat is visible
         */
        isPartySelected() {
            const selectedTabEl = document.querySelector(
                `.Chat_tabsComponentContainer__3ZoKe .MuiButtonBase-root[aria-selected="true"]`
            );
            const tabsEl = document.querySelector(
                '.Chat_tabsComponentContainer__3ZoKe .TabsComponent_tabPanelsContainer__26mzo'
            );
            return (
                selectedTabEl &&
                tabsEl &&
                selectedTabEl.textContent.includes('Party') &&
                !tabsEl.classList.contains('TabsComponent_hidden__255ag')
            );
        }

        /**
         * Get timestamp from message DOM element
         * Handles both American (M/D HH:MM:SS AM/PM) and international (DD-M HH:MM:SS) formats
         * @param {HTMLElement} msg - Message element
         * @param {boolean} warnOnFailure - Whether to log warning if parsing fails (default: false)
         * @returns {Date|null} Parsed timestamp or null
         */
        getTimestampFromMessage(msg, warnOnFailure = false) {
            const text = msg.textContent.trim();

            // Try American format: [M/D HH:MM:SS AM/PM] or [M/D HH:MM:SS] (24-hour)
            // Use \s* to handle potential spacing variations
            let match = text.match(/\[(\d{1,2})\/(\d{1,2})\s*(\d{1,2}):(\d{2}):(\d{2})\s*([AP]M)?\]/);
            let isAmerican = true;

            if (!match) {
                // Try international format: [DD-M HH:MM:SS] (24-hour)
                // Use \s* to handle potential spacing variations in dungeon chat
                match = text.match(/\[(\d{1,2})-(\d{1,2})\s*(\d{1,2}):(\d{2}):(\d{2})\]/);
                isAmerican = false;
            }

            if (!match) {
                // Only warn if explicitly requested (for important messages like "Key counts:")
                if (warnOnFailure) {
                    console.warn(
                        '[Dungeon Tracker] Found key counts but could not parse timestamp from:',
                        text.match(/\[.*?\]/)?.[0]
                    );
                }
                return null;
            }

            let month, day, hour, min, sec, period;

            if (isAmerican) {
                // American format: M/D
                [, month, day, hour, min, sec, period] = match;
                month = parseInt(month, 10);
                day = parseInt(day, 10);
            } else {
                // International format: D-M
                [, day, month, hour, min, sec] = match;
                month = parseInt(month, 10);
                day = parseInt(day, 10);
            }

            hour = parseInt(hour, 10);
            min = parseInt(min, 10);
            sec = parseInt(sec, 10);

            // Handle AM/PM conversion (only for American format with AM/PM)
            if (period === 'PM' && hour < 12) hour += 12;
            if (period === 'AM' && hour === 12) hour = 0;

            const now = new Date();
            const dateObj = new Date(now.getFullYear(), month - 1, day, hour, min, sec, 0);
            return dateObj;
        }

        /**
         * Get team composition from message
         * @param {HTMLElement} msg - Message element
         * @returns {Array<string>} Sorted array of player names
         */
        getTeamFromMessage(msg) {
            const text = msg.textContent.trim();
            const matches = [...text.matchAll(/\[([^[\]-]+?)\s*-\s*[\d,]+\]/g)];
            return matches.map((m) => m[1].trim()).sort();
        }

        /**
         * Insert annotation into chat message
         * @param {string} label - Timer label text
         * @param {string} color - CSS color for the label
         * @param {HTMLElement} msg - Message DOM element
         * @param {boolean} isAverage - Whether this is an average annotation
         */
        insertAnnotation(label, color, msg, isAverage = false) {
            // Check using dataset attribute (matches working DRT script pattern)
            const datasetKey = isAverage ? 'avgAppended' : 'timerAppended';
            if (msg.dataset[datasetKey] === '1') {
                return;
            }

            const spans = msg.querySelectorAll('span');
            if (spans.length < 2) return;

            const messageSpan = spans[1];
            const timerSpan = document.createElement('span');
            timerSpan.textContent = ` [${label}]`;
            timerSpan.classList.add(isAverage ? 'dungeon-timer-average' : 'dungeon-timer-annotation');
            timerSpan.style.color = color;
            timerSpan.style.fontWeight = isAverage ? 'normal' : 'bold';
            timerSpan.style.fontStyle = 'italic';
            timerSpan.style.marginLeft = '4px';

            messageSpan.appendChild(timerSpan);

            // Mark as appended (matches working DRT script)
            msg.dataset[datasetKey] = '1';
        }

        /**
         * Format time in milliseconds to Mm Ss format
         * @param {number} ms - Time in milliseconds
         * @returns {string} Formatted time (e.g., "4m 32s")
         */
        formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}m ${seconds}s`;
        }

        /**
         * Enable chat annotations
         */
        enable() {
            this.enabled = true;
        }

        /**
         * Disable chat annotations
         */
        disable() {
            this.enabled = false;
        }

        /**
         * Cleanup for character switching
         */
        cleanup() {
            // Disconnect MutationObserver
            if (this.observer) {
                this.observer();
                this.observer = null;
            }

            // Remove tab click listeners
            for (const [button, handler] of this.tabClickHandlers) {
                button.removeEventListener('click', handler);
            }
            this.tabClickHandlers.clear();

            this.timerRegistry.clearAll();

            // Clear cached state
            this.lastSeenDungeonName = null;
            this.cumulativeStatsByDungeon = {}; // Reset cumulative counters
            this.processedMessages.clear(); // Clear message deduplication map
            this.initComplete = false; // Reset init flag
            this.enabled = true; // Reset to default enabled state

            // Remove all annotations from DOM
            const annotations = document.querySelectorAll('.dungeon-timer-annotation, .dungeon-timer-average');
            annotations.forEach((annotation) => annotation.remove());

            // Clear processed markers from chat messages
            const processedMessages = document.querySelectorAll('[class^="ChatMessage_chatMessage"][data-processed="1"]');
            processedMessages.forEach((msg) => {
                delete msg.dataset.processed;
                delete msg.dataset.timerAppended;
                delete msg.dataset.avgAppended;
            });
        }

        /**
         * Check if chat annotations are enabled
         * @returns {boolean} Enabled status
         */
        isEnabled() {
            return this.enabled;
        }
    }

    const dungeonTrackerChatAnnotations = new DungeonTrackerChatAnnotations();

    /**
     * Dungeon Tracker UI State Management
     * Handles loading, saving, and managing UI state
     */


    class DungeonTrackerUIState {
        constructor() {
            // Collapse/expand states
            this.isCollapsed = false;
            this.isKeysExpanded = false;
            this.isRunHistoryExpanded = false;
            this.isChartExpanded = true; // Default: expanded

            // Position state
            this.position = null; // { x, y } or null for default

            // Grouping and filtering state
            this.groupBy = 'team'; // 'team' or 'dungeon'
            this.filterDungeon = 'all'; // 'all' or specific dungeon name
            this.filterTeam = 'all'; // 'all' or specific team key

            // Track expanded groups to preserve state across refreshes
            this.expandedGroups = new Set();
        }

        /**
         * Load saved state from storage
         */
        async load() {
            const savedState = await storage$1.getJSON('dungeonTracker_uiState', 'settings', null);
            if (savedState) {
                this.isCollapsed = savedState.isCollapsed || false;
                this.isKeysExpanded = savedState.isKeysExpanded || false;
                this.isRunHistoryExpanded = savedState.isRunHistoryExpanded || false;
                this.position = savedState.position || null;

                // Load grouping/filtering state
                this.groupBy = savedState.groupBy || 'team';
                this.filterDungeon = savedState.filterDungeon || 'all';
                this.filterTeam = savedState.filterTeam || 'all';
            }
        }

        /**
         * Save current state to storage
         */
        async save() {
            await storage$1.setJSON(
                'dungeonTracker_uiState',
                {
                    isCollapsed: this.isCollapsed,
                    isKeysExpanded: this.isKeysExpanded,
                    isRunHistoryExpanded: this.isRunHistoryExpanded,
                    position: this.position,
                    groupBy: this.groupBy,
                    filterDungeon: this.filterDungeon,
                    filterTeam: this.filterTeam,
                },
                'settings',
                true
            );
        }

        /**
         * Update container position and styling
         * @param {HTMLElement} container - Container element
         */
        updatePosition(container) {
            const baseStyle = `
            position: fixed;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #4a9eff;
            border-radius: 8px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        `;

            if (this.position) {
                // Custom position (user dragged it)
                container.style.cssText = `
                ${baseStyle}
                top: ${this.position.y}px;
                left: ${this.position.x}px;
                min-width: ${this.isCollapsed ? '250px' : '480px'};
            `;
            } else if (this.isCollapsed) {
                // Collapsed: top-left (near action time display)
                container.style.cssText = `
                ${baseStyle}
                top: 10px;
                left: 10px;
                min-width: 250px;
            `;
            } else {
                // Expanded: top-center
                container.style.cssText = `
                ${baseStyle}
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                min-width: 480px;
            `;
            }
        }
    }

    const dungeonTrackerUIState = new DungeonTrackerUIState();

    /**
     * Dungeon Tracker UI Chart Integration
     * Handles Chart.js rendering for dungeon run statistics
     */


    class DungeonTrackerUIChart {
        constructor(state, formatTimeFunc) {
            this.state = state;
            this.formatTime = formatTimeFunc;
            this.chartInstance = null;
            this.modalChartInstance = null; // Store modal chart for cleanup
        }

        /**
         * Render chart with filtered run data
         * @param {HTMLElement} container - Main container element
         */
        async render(container) {
            const canvas = container.querySelector('#mwi-dt-chart-canvas');
            if (!canvas) return;

            // Get filtered runs based on current filters
            const allRuns = await dungeonTrackerStorage.getAllRuns();
            let filteredRuns = allRuns;

            if (this.state.filterDungeon !== 'all') {
                filteredRuns = filteredRuns.filter((r) => r.dungeonName === this.state.filterDungeon);
            }
            if (this.state.filterTeam !== 'all') {
                filteredRuns = filteredRuns.filter((r) => r.teamKey === this.state.filterTeam);
            }

            if (filteredRuns.length === 0) {
                // Destroy existing chart
                if (this.chartInstance) {
                    this.chartInstance.destroy();
                    this.chartInstance = null;
                }
                return;
            }

            // Sort by timestamp (oldest to newest)
            filteredRuns.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // Prepare data
            // Label runs in reverse chronological order to match list (newest = Run 1, oldest = Run N)
            const labels = filteredRuns.map((_, i) => `Run ${filteredRuns.length - i}`);
            const durations = filteredRuns.map((r) => (r.duration || r.totalTime || 0) / 60000); // Convert to minutes

            // Calculate stats
            const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
            const fastestDuration = Math.min(...durations);
            const slowestDuration = Math.max(...durations);

            // Create datasets
            const datasets = [
                {
                    label: 'Run Times',
                    data: durations,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderWidth: 2,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    tension: 0.1,
                    fill: false,
                },
                {
                    label: 'Average',
                    data: new Array(durations.length).fill(avgDuration),
                    borderColor: 'rgb(255, 159, 64)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    tension: 0,
                    fill: false,
                },
                {
                    label: 'Fastest',
                    data: new Array(durations.length).fill(fastestDuration),
                    borderColor: 'rgb(75, 192, 75)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    tension: 0,
                    fill: false,
                },
                {
                    label: 'Slowest',
                    data: new Array(durations.length).fill(slowestDuration),
                    borderColor: 'rgb(255, 99, 132)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    tension: 0,
                    fill: false,
                },
            ];

            // Destroy existing chart
            if (this.chartInstance) {
                this.chartInstance.destroy();
            }

            // Create new chart
            const ctx = canvas.getContext('2d');
            this.chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#ccc',
                                usePointStyle: true,
                                padding: 15,
                            },
                            onClick: (e, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const ci = legend.chart;
                                const meta = ci.getDatasetMeta(index);

                                // Toggle visibility
                                meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
                                ci.update();
                            },
                        },
                        title: {
                            display: false,
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    const minutes = Math.floor(value);
                                    const seconds = Math.floor((value - minutes) * 60);
                                    return `${label}: ${minutes}m ${seconds}s`;
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Run Number',
                                color: '#ccc',
                            },
                            ticks: {
                                color: '#999',
                            },
                            grid: {
                                color: '#333',
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Duration (minutes)',
                                color: '#ccc',
                            },
                            ticks: {
                                color: '#999',
                            },
                            grid: {
                                color: '#333',
                            },
                            beginAtZero: false,
                        },
                    },
                },
            });
        }

        /**
         * Create pop-out modal with larger chart
         */
        createPopoutModal() {
            // Remove existing modal if any
            const existingModal = document.getElementById('mwi-dt-chart-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // Create modal container
            const modal = document.createElement('div');
            modal.id = 'mwi-dt-chart-modal';
            modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 1200px;
            height: 80%;
            max-height: 700px;
            background: #1a1a1a;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 20px;
            z-index: 100000;
            display: flex;
            flex-direction: column;
        `;

            // Create header with close button
            const header = document.createElement('div');
            header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        `;

            const title = document.createElement('h3');
            title.textContent = '📊 Dungeon Run Chart';
            title.style.cssText = 'color: #ccc; margin: 0; font-size: 18px;';

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '✕';
            closeBtn.style.cssText = `
            background: #a33;
            color: #fff;
            border: none;
            cursor: pointer;
            font-size: 20px;
            padding: 4px 12px;
            border-radius: 4px;
            font-weight: bold;
        `;
            closeBtn.addEventListener('click', () => {
                // Destroy chart before removing modal
                if (this.modalChartInstance) {
                    this.modalChartInstance.destroy();
                    this.modalChartInstance = null;
                }
                modal.remove();
            });

            header.appendChild(title);
            header.appendChild(closeBtn);

            // Create canvas container
            const canvasContainer = document.createElement('div');
            canvasContainer.style.cssText = `
            flex: 1;
            position: relative;
            min-height: 0;
        `;

            const canvas = document.createElement('canvas');
            canvas.id = 'mwi-dt-chart-modal-canvas';
            canvasContainer.appendChild(canvas);

            modal.appendChild(header);
            modal.appendChild(canvasContainer);
            document.body.appendChild(modal);

            // Render chart in modal
            this.renderModalChart(canvas);

            // Close on ESC key
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    // Destroy chart before removing modal
                    if (this.modalChartInstance) {
                        this.modalChartInstance.destroy();
                        this.modalChartInstance = null;
                    }
                    modal.remove();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }

        /**
         * Render chart in pop-out modal
         * @param {HTMLElement} canvas - Canvas element
         */
        async renderModalChart(canvas) {
            // Get filtered runs (same as main chart)
            const allRuns = await dungeonTrackerStorage.getAllRuns();
            let filteredRuns = allRuns;

            if (this.state.filterDungeon !== 'all') {
                filteredRuns = filteredRuns.filter((r) => r.dungeonName === this.state.filterDungeon);
            }
            if (this.state.filterTeam !== 'all') {
                filteredRuns = filteredRuns.filter((r) => r.teamKey === this.state.filterTeam);
            }

            if (filteredRuns.length === 0) return;

            // Sort by timestamp
            filteredRuns.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // Prepare data (same as main chart)
            // Label runs in reverse chronological order to match list (newest = Run 1, oldest = Run N)
            const labels = filteredRuns.map((_, i) => `Run ${filteredRuns.length - i}`);
            const durations = filteredRuns.map((r) => (r.duration || r.totalTime || 0) / 60000);

            const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
            const fastestDuration = Math.min(...durations);
            const slowestDuration = Math.max(...durations);

            const datasets = [
                {
                    label: 'Run Times',
                    data: durations,
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderWidth: 2,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    tension: 0.1,
                    fill: false,
                },
                {
                    label: 'Average',
                    data: new Array(durations.length).fill(avgDuration),
                    borderColor: 'rgb(255, 159, 64)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    tension: 0,
                    fill: false,
                },
                {
                    label: 'Fastest',
                    data: new Array(durations.length).fill(fastestDuration),
                    borderColor: 'rgb(75, 192, 75)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    tension: 0,
                    fill: false,
                },
                {
                    label: 'Slowest',
                    data: new Array(durations.length).fill(slowestDuration),
                    borderColor: 'rgb(255, 99, 132)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    tension: 0,
                    fill: false,
                },
            ];

            // Create chart
            const ctx = canvas.getContext('2d');
            this.modalChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#ccc',
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 14,
                                },
                            },
                            onClick: (e, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const ci = legend.chart;
                                const meta = ci.getDatasetMeta(index);

                                meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
                                ci.update();
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    const minutes = Math.floor(value);
                                    const seconds = Math.floor((value - minutes) * 60);
                                    return `${label}: ${minutes}m ${seconds}s`;
                                },
                            },
                        },
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Run Number',
                                color: '#ccc',
                                font: {
                                    size: 14,
                                },
                            },
                            ticks: {
                                color: '#999',
                            },
                            grid: {
                                color: '#333',
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Duration (minutes)',
                                color: '#ccc',
                                font: {
                                    size: 14,
                                },
                            },
                            ticks: {
                                color: '#999',
                            },
                            grid: {
                                color: '#333',
                            },
                            beginAtZero: false,
                        },
                    },
                },
            });
        }
    }

    /**
     * Dungeon Tracker UI Run History Display
     * Handles grouping, filtering, and rendering of run history
     */


    class DungeonTrackerUIHistory {
        constructor(state, formatTimeFunc) {
            this.state = state;
            this.formatTime = formatTimeFunc;
        }

        /**
         * Group runs by team
         * @param {Array} runs - Array of runs
         * @returns {Array} Grouped runs with stats
         */
        groupByTeam(runs) {
            const groups = {};

            for (const run of runs) {
                const key = run.teamKey || 'Solo';
                if (!groups[key]) {
                    groups[key] = {
                        key: key,
                        label: key === 'Solo' ? 'Solo Runs' : key,
                        runs: [],
                    };
                }
                groups[key].runs.push(run);
            }

            // Convert to array and calculate stats
            return Object.values(groups).map((group) => ({
                ...group,
                stats: this.calculateStatsForRuns(group.runs),
            }));
        }

        /**
         * Group runs by dungeon
         * @param {Array} runs - Array of runs
         * @returns {Array} Grouped runs with stats
         */
        groupByDungeon(runs) {
            const groups = {};

            for (const run of runs) {
                const key = run.dungeonName || 'Unknown';
                if (!groups[key]) {
                    groups[key] = {
                        key: key,
                        label: key,
                        runs: [],
                    };
                }
                groups[key].runs.push(run);
            }

            // Convert to array and calculate stats
            return Object.values(groups).map((group) => ({
                ...group,
                stats: this.calculateStatsForRuns(group.runs),
            }));
        }

        /**
         * Calculate stats for a set of runs
         * @param {Array} runs - Array of runs
         * @returns {Object} Stats object
         */
        calculateStatsForRuns(runs) {
            if (!runs || runs.length === 0) {
                return {
                    totalRuns: 0,
                    avgTime: 0,
                    fastestTime: 0,
                    slowestTime: 0,
                };
            }

            const durations = runs.map((r) => r.duration);
            const total = durations.reduce((sum, d) => sum + d, 0);

            return {
                totalRuns: runs.length,
                avgTime: Math.floor(total / runs.length),
                fastestTime: Math.min(...durations),
                slowestTime: Math.max(...durations),
            };
        }

        /**
         * Update run history display with grouping and filtering
         * @param {HTMLElement} container - Main container element
         */
        async update(container) {
            const runList = container.querySelector('#mwi-dt-run-list');
            if (!runList) return;

            try {
                // Get all runs from unified storage
                const allRuns = await dungeonTrackerStorage.getAllRuns();

                if (allRuns.length === 0) {
                    runList.innerHTML =
                        '<div style="color: #888; font-style: italic; text-align: center; padding: 8px;">No runs yet</div>';
                    // Update filter dropdowns with empty options
                    this.updateFilterDropdowns(container, [], []);
                    return;
                }

                // Apply filters
                let filteredRuns = allRuns;
                if (this.state.filterDungeon !== 'all') {
                    filteredRuns = filteredRuns.filter((r) => r.dungeonName === this.state.filterDungeon);
                }
                if (this.state.filterTeam !== 'all') {
                    filteredRuns = filteredRuns.filter((r) => r.teamKey === this.state.filterTeam);
                }

                if (filteredRuns.length === 0) {
                    runList.innerHTML =
                        '<div style="color: #888; font-style: italic; text-align: center; padding: 8px;">No runs match filters</div>';
                    return;
                }

                // Group runs
                const groups =
                    this.state.groupBy === 'team' ? this.groupByTeam(filteredRuns) : this.groupByDungeon(filteredRuns);

                // Render grouped runs
                this.renderGroupedRuns(runList, groups);

                // Update filter dropdowns
                const dungeons = [...new Set(allRuns.map((r) => r.dungeonName).filter(Boolean))].sort();
                const teams = [...new Set(allRuns.map((r) => r.teamKey).filter(Boolean))].sort();
                this.updateFilterDropdowns(container, dungeons, teams);
            } catch (error) {
                console.error('[Dungeon Tracker UI History] Update error:', error);
                runList.innerHTML =
                    '<div style="color: #ff6b6b; text-align: center; padding: 8px;">Error loading run history</div>';
            }
        }

        /**
         * Update filter dropdown options
         * @param {HTMLElement} container - Main container element
         * @param {Array} dungeons - List of dungeon names
         * @param {Array} teams - List of team keys
         */
        updateFilterDropdowns(container, dungeons, teams) {
            // Update dungeon filter
            const dungeonFilter = container.querySelector('#mwi-dt-filter-dungeon');
            if (dungeonFilter) {
                const currentValue = dungeonFilter.value;
                dungeonFilter.innerHTML =
                    '<option value="all">All Dungeons</option>' +
                    dungeons.map((dungeon) => `<option value="${dungeon}">${dungeon}</option>`).join('');
                // Restore selection if still valid
                if (dungeons.includes(currentValue)) {
                    dungeonFilter.value = currentValue;
                } else {
                    this.state.filterDungeon = 'all';
                }
            }

            // Update team filter
            const teamFilter = container.querySelector('#mwi-dt-filter-team');
            if (teamFilter) {
                const currentValue = teamFilter.value;
                teamFilter.innerHTML =
                    '<option value="all">All Teams</option>' +
                    teams.map((team) => `<option value="${team}">${team}</option>`).join('');
                // Restore selection if still valid
                if (teams.includes(currentValue)) {
                    teamFilter.value = currentValue;
                } else {
                    this.state.filterTeam = 'all';
                }
            }
        }

        /**
         * Render grouped runs
         * @param {HTMLElement} runList - Run list container
         * @param {Array} groups - Grouped runs with stats
         */
        renderGroupedRuns(runList, groups) {
            let html = '';

            for (const group of groups) {
                const avgTime = this.formatTime(group.stats.avgTime);
                const bestTime = this.formatTime(group.stats.fastestTime);
                const worstTime = this.formatTime(group.stats.slowestTime);

                // Check if this group is expanded
                const isExpanded = this.state.expandedGroups.has(group.label);
                const displayStyle = isExpanded ? 'block' : 'none';
                const toggleIcon = isExpanded ? '▲' : '▼';

                html += `
                <div class="mwi-dt-group" style="
                    margin-bottom: 8px;
                    border: 1px solid #444;
                    border-radius: 4px;
                    padding: 8px;
                ">
                    <div style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 6px;
                        cursor: pointer;
                    " class="mwi-dt-group-header" data-group-label="${group.label}">
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #4a9eff; margin-bottom: 2px;">
                                ${group.label}
                            </div>
                            <div style="font-size: 10px; color: #aaa;">
                                Runs: ${group.stats.totalRuns} | Avg: ${avgTime} | Best: ${bestTime} | Worst: ${worstTime}
                            </div>
                        </div>
                        <span class="mwi-dt-group-toggle" style="color: #aaa; font-size: 10px;">${toggleIcon}</span>
                    </div>
                    <div class="mwi-dt-group-runs" style="
                        display: ${displayStyle};
                        border-top: 1px solid #444;
                        padding-top: 6px;
                        margin-top: 4px;
                    ">
                        ${this.renderRunList(group.runs)}
                    </div>
                </div>
            `;
            }

            runList.innerHTML = html;

            // Attach toggle handlers
            runList.querySelectorAll('.mwi-dt-group-header').forEach((header) => {
                header.addEventListener('click', () => {
                    const groupLabel = header.dataset.groupLabel;
                    const runsDiv = header.nextElementSibling;
                    const toggle = header.querySelector('.mwi-dt-group-toggle');

                    if (runsDiv.style.display === 'none') {
                        runsDiv.style.display = 'block';
                        toggle.textContent = '▲';
                        this.state.expandedGroups.add(groupLabel);
                    } else {
                        runsDiv.style.display = 'none';
                        toggle.textContent = '▼';
                        this.state.expandedGroups.delete(groupLabel);
                    }
                });
            });

            // Attach delete handlers
            runList.querySelectorAll('.mwi-dt-delete-run').forEach((btn) => {
                btn.addEventListener('click', async (e) => {
                    const runTimestamp = e.target.closest('[data-run-timestamp]').dataset.runTimestamp;

                    // Find and delete the run from unified storage
                    const allRuns = await dungeonTrackerStorage.getAllRuns();
                    const filteredRuns = allRuns.filter((r) => r.timestamp !== runTimestamp);
                    await storage$1.setJSON('allRuns', filteredRuns, 'unifiedRuns', true);

                    // Trigger refresh via callback
                    if (this.onDeleteCallback) {
                        this.onDeleteCallback();
                    }
                });
            });
        }

        /**
         * Render individual run list
         * @param {Array} runs - Array of runs
         * @returns {string} HTML for run list
         */
        renderRunList(runs) {
            let html = '';
            runs.forEach((run, index) => {
                const runNumber = runs.length - index;
                const timeStr = this.formatTime(run.duration);
                const dateObj = new Date(run.timestamp);
                const dateTime = dateObj.toLocaleString();
                const dungeonLabel = run.dungeonName || 'Unknown';

                html += `
                <div style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 4px 0;
                    border-bottom: 1px solid #333;
                    font-size: 10px;
                " data-run-timestamp="${run.timestamp}">
                    <span style="color: #aaa; min-width: 25px;">#${runNumber}</span>
                    <span style="color: #fff; flex: 1; text-align: center;">
                        ${timeStr} <span style="color: #888; font-size: 9px;">(${dateTime})</span>
                    </span>
                    <span style="color: #888; margin-right: 6px; font-size: 9px;">${dungeonLabel}</span>
                    <button class="mwi-dt-delete-run" style="
                        background: none;
                        border: 1px solid #ff6b6b;
                        color: #ff6b6b;
                        cursor: pointer;
                        font-size: 9px;
                        padding: 1px 4px;
                        border-radius: 2px;
                        font-weight: bold;
                    " title="Delete this run">✕</button>
                </div>
            `;
            });
            return html;
        }

        /**
         * Set callback for when a run is deleted
         * @param {Function} callback - Callback function
         */
        onDelete(callback) {
            this.onDeleteCallback = callback;
        }
    }

    /**
     * Dungeon Tracker UI Interactions
     * Handles all user interactions: dragging, toggles, button clicks
     */


    class DungeonTrackerUIInteractions {
        constructor(state, chartRef, historyRef) {
            this.state = state;
            this.chart = chartRef;
            this.history = historyRef;
            this.isDragging = false;
            this.dragOffset = { x: 0, y: 0 };
            this.timerRegistry = createTimerRegistry();
            // Store drag handlers for cleanup
            this.dragMoveHandler = null;
            this.dragUpHandler = null;
        }

        /**
         * Setup all interactions
         * @param {HTMLElement} container - Main container element
         * @param {Object} callbacks - Callback functions {onUpdate, onUpdateChart, onUpdateHistory}
         */
        setupAll(container, callbacks) {
            this.container = container;
            this.callbacks = callbacks;

            this.setupDragging();
            this.setupCollapseButton();
            this.setupKeysToggle();
            this.setupRunHistoryToggle();
            this.setupGroupingControls();
            this.setupBackfillButton();
            this.setupClearAll();
            this.setupChartToggle();
            this.setupChartPopout();
            this.setupKeyboardShortcut();
        }

        /**
         * Setup dragging functionality
         */
        setupDragging() {
            const header = this.container.querySelector('#mwi-dt-header');
            if (!header) return;

            header.addEventListener('mousedown', (e) => {
                // Don't drag if clicking collapse button
                if (e.target.id === 'mwi-dt-collapse-btn') return;

                this.isDragging = true;
                const rect = this.container.getBoundingClientRect();
                this.dragOffset = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                };
                header.style.cursor = 'grabbing';
            });

            // Remove old handlers if they exist
            if (this.dragMoveHandler) {
                document.removeEventListener('mousemove', this.dragMoveHandler);
            }
            if (this.dragUpHandler) {
                document.removeEventListener('mouseup', this.dragUpHandler);
            }

            // Create and store new handlers
            this.dragMoveHandler = (e) => {
                if (!this.isDragging) return;

                let x = e.clientX - this.dragOffset.x;
                let y = e.clientY - this.dragOffset.y;

                // Apply position boundaries to keep tracker visible
                const containerRect = this.container.getBoundingClientRect();
                const minVisiblePx = 100; // Keep at least 100px visible

                // Constrain Y: header must be visible at top
                y = Math.max(0, y);
                y = Math.min(y, window.innerHeight - minVisiblePx);

                // Constrain X: keep at least 100px visible on either edge
                x = Math.max(-containerRect.width + minVisiblePx, x);
                x = Math.min(x, window.innerWidth - minVisiblePx);

                // Save position (disables default centering)
                this.state.position = { x, y };

                // Apply position
                this.container.style.left = `${x}px`;
                this.container.style.top = `${y}px`;
                this.container.style.transform = 'none'; // Disable centering transform
            };

            this.dragUpHandler = () => {
                if (this.isDragging) {
                    this.isDragging = false;
                    const header = this.container.querySelector('#mwi-dt-header');
                    if (header) header.style.cursor = 'move';
                    this.state.save();
                }
            };

            document.addEventListener('mousemove', this.dragMoveHandler);
            document.addEventListener('mouseup', this.dragUpHandler);
        }

        /**
         * Setup collapse button
         */
        setupCollapseButton() {
            const collapseBtn = this.container.querySelector('#mwi-dt-collapse-btn');
            if (!collapseBtn) return;

            collapseBtn.addEventListener('click', () => {
                this.toggleCollapse();
            });
        }

        /**
         * Setup keys toggle
         */
        setupKeysToggle() {
            const keysHeader = this.container.querySelector('#mwi-dt-keys-header');
            if (!keysHeader) return;

            keysHeader.addEventListener('click', () => {
                this.toggleKeys();
            });
        }

        /**
         * Setup run history toggle
         */
        setupRunHistoryToggle() {
            const runHistoryHeader = this.container.querySelector('#mwi-dt-run-history-header');
            if (!runHistoryHeader) return;

            runHistoryHeader.addEventListener('click', (e) => {
                // Don't toggle if clicking the clear or backfill buttons
                if (e.target.id === 'mwi-dt-clear-all' || e.target.closest('#mwi-dt-clear-all')) return;
                if (e.target.id === 'mwi-dt-backfill-btn' || e.target.closest('#mwi-dt-backfill-btn')) return;
                this.toggleRunHistory();
            });
        }

        /**
         * Setup grouping and filtering controls
         */
        setupGroupingControls() {
            // Group by dropdown
            const groupBySelect = this.container.querySelector('#mwi-dt-group-by');
            if (groupBySelect) {
                groupBySelect.value = this.state.groupBy;
                groupBySelect.addEventListener('change', (e) => {
                    this.state.groupBy = e.target.value;
                    this.state.save();
                    // Clear expanded groups when grouping changes (different group labels)
                    this.state.expandedGroups.clear();
                    if (this.callbacks.onUpdateHistory) this.callbacks.onUpdateHistory();
                    if (this.callbacks.onUpdateChart) this.callbacks.onUpdateChart();
                });
            }

            // Filter dungeon dropdown
            const filterDungeonSelect = this.container.querySelector('#mwi-dt-filter-dungeon');
            if (filterDungeonSelect) {
                filterDungeonSelect.addEventListener('change', (e) => {
                    this.state.filterDungeon = e.target.value;
                    this.state.save();
                    if (this.callbacks.onUpdateHistory) this.callbacks.onUpdateHistory();
                    if (this.callbacks.onUpdateChart) this.callbacks.onUpdateChart();
                });
            }

            // Filter team dropdown
            const filterTeamSelect = this.container.querySelector('#mwi-dt-filter-team');
            if (filterTeamSelect) {
                filterTeamSelect.addEventListener('change', (e) => {
                    this.state.filterTeam = e.target.value;
                    this.state.save();
                    if (this.callbacks.onUpdateHistory) this.callbacks.onUpdateHistory();
                    if (this.callbacks.onUpdateChart) this.callbacks.onUpdateChart();
                });
            }
        }

        /**
         * Setup clear all button
         */
        setupClearAll() {
            const clearBtn = this.container.querySelector('#mwi-dt-clear-all');
            if (!clearBtn) return;

            clearBtn.addEventListener('click', async () => {
                if (confirm('Delete ALL run history data?\n\nThis cannot be undone!')) {
                    try {
                        // Clear unified storage completely
                        await storage$1.setJSON('allRuns', [], 'unifiedRuns', true);
                        alert('All run history cleared.');

                        // Refresh both history and chart display
                        if (this.callbacks.onUpdateHistory) await this.callbacks.onUpdateHistory();
                        if (this.callbacks.onUpdateChart) await this.callbacks.onUpdateChart();
                    } catch (error) {
                        console.error('[Dungeon Tracker UI Interactions] Clear all history error:', error);
                        alert('Failed to clear run history. Check console for details.');
                    }
                }
            });
        }

        /**
         * Setup chart toggle
         */
        setupChartToggle() {
            const chartHeader = this.container.querySelector('#mwi-dt-chart-header');
            if (!chartHeader) return;

            chartHeader.addEventListener('click', (e) => {
                // Don't toggle if clicking the pop-out button
                if (e.target.closest('#mwi-dt-chart-popout-btn')) return;

                this.toggleChart();
            });
        }

        /**
         * Setup chart pop-out button
         */
        setupChartPopout() {
            const popoutBtn = this.container.querySelector('#mwi-dt-chart-popout-btn');
            if (!popoutBtn) return;

            popoutBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent toggle
                this.chart.createPopoutModal();
            });
        }

        /**
         * Setup backfill button
         */
        setupBackfillButton() {
            const backfillBtn = this.container.querySelector('#mwi-dt-backfill-btn');
            if (!backfillBtn) return;

            backfillBtn.addEventListener('click', async () => {
                // Change button text to show loading
                backfillBtn.textContent = '⟳ Processing...';
                backfillBtn.disabled = true;

                try {
                    // Run backfill
                    const result = await dungeonTracker.backfillFromChatHistory();

                    // Show result message
                    if (result.runsAdded > 0) {
                        alert(`Backfill complete!\n\nRuns added: ${result.runsAdded}\nTeams: ${result.teams.length}`);
                    } else {
                        alert('No new runs found to backfill.');
                    }

                    // Refresh both history and chart display
                    if (this.callbacks.onUpdateHistory) await this.callbacks.onUpdateHistory();
                    if (this.callbacks.onUpdateChart) await this.callbacks.onUpdateChart();
                } catch (error) {
                    console.error('[Dungeon Tracker UI Interactions] Backfill error:', error);
                    alert('Backfill failed. Check console for details.');
                } finally {
                    // Reset button
                    backfillBtn.textContent = '⟳ Backfill';
                    backfillBtn.disabled = false;
                }
            });
        }

        /**
         * Toggle collapse state
         */
        toggleCollapse() {
            this.state.isCollapsed = !this.state.isCollapsed;

            if (this.state.isCollapsed) {
                this.applyCollapsedState();
            } else {
                this.applyExpandedState();
            }

            // If no custom position, update to new default position
            if (!this.state.position) {
                this.state.updatePosition(this.container);
            } else {
                // Just update width for custom positions
                this.container.style.minWidth = this.state.isCollapsed ? '250px' : '480px';
            }

            this.state.save();
        }

        /**
         * Apply collapsed state appearance
         */
        applyCollapsedState() {
            const content = this.container.querySelector('#mwi-dt-content');
            const collapseBtn = this.container.querySelector('#mwi-dt-collapse-btn');

            if (content) content.style.display = 'none';
            if (collapseBtn) collapseBtn.textContent = '▲';
        }

        /**
         * Apply expanded state appearance
         */
        applyExpandedState() {
            const content = this.container.querySelector('#mwi-dt-content');
            const collapseBtn = this.container.querySelector('#mwi-dt-collapse-btn');

            if (content) content.style.display = 'flex';
            if (collapseBtn) collapseBtn.textContent = '▼';
        }

        /**
         * Toggle keys expanded state
         */
        toggleKeys() {
            this.state.isKeysExpanded = !this.state.isKeysExpanded;

            if (this.state.isKeysExpanded) {
                this.applyKeysExpandedState();
            } else {
                this.applyKeysCollapsedState();
            }

            this.state.save();
        }

        /**
         * Apply keys expanded state
         */
        applyKeysExpandedState() {
            const keysList = this.container.querySelector('#mwi-dt-keys-list');
            const keysToggle = this.container.querySelector('#mwi-dt-keys-toggle');

            if (keysList) keysList.style.display = 'block';
            if (keysToggle) keysToggle.textContent = '▲';
        }

        /**
         * Apply keys collapsed state
         */
        applyKeysCollapsedState() {
            const keysList = this.container.querySelector('#mwi-dt-keys-list');
            const keysToggle = this.container.querySelector('#mwi-dt-keys-toggle');

            if (keysList) keysList.style.display = 'none';
            if (keysToggle) keysToggle.textContent = '▼';
        }

        /**
         * Toggle run history expanded state
         */
        toggleRunHistory() {
            this.state.isRunHistoryExpanded = !this.state.isRunHistoryExpanded;

            if (this.state.isRunHistoryExpanded) {
                this.applyRunHistoryExpandedState();
            } else {
                this.applyRunHistoryCollapsedState();
            }

            this.state.save();
        }

        /**
         * Apply run history expanded state
         */
        applyRunHistoryExpandedState() {
            const runList = this.container.querySelector('#mwi-dt-run-list');
            const runHistoryToggle = this.container.querySelector('#mwi-dt-run-history-toggle');
            const controls = this.container.querySelector('#mwi-dt-controls');

            if (runList) runList.style.display = 'block';
            if (runHistoryToggle) runHistoryToggle.textContent = '▲';
            if (controls) controls.style.display = 'block';
        }

        /**
         * Apply run history collapsed state
         */
        applyRunHistoryCollapsedState() {
            const runList = this.container.querySelector('#mwi-dt-run-list');
            const runHistoryToggle = this.container.querySelector('#mwi-dt-run-history-toggle');
            const controls = this.container.querySelector('#mwi-dt-controls');

            if (runList) runList.style.display = 'none';
            if (runHistoryToggle) runHistoryToggle.textContent = '▼';
            if (controls) controls.style.display = 'none';
        }

        /**
         * Toggle chart expanded/collapsed
         */
        toggleChart() {
            this.state.isChartExpanded = !this.state.isChartExpanded;

            if (this.state.isChartExpanded) {
                this.applyChartExpandedState();
            } else {
                this.applyChartCollapsedState();
            }

            this.state.save();
        }

        /**
         * Apply chart expanded state
         */
        applyChartExpandedState() {
            const chartContainer = this.container.querySelector('#mwi-dt-chart-container');
            const toggle = this.container.querySelector('#mwi-dt-chart-toggle');

            if (chartContainer) {
                chartContainer.style.display = 'block';
                // Render chart after becoming visible (longer delay for initial page load)
                if (this.callbacks.onUpdateChart) {
                    const chartTimeout = setTimeout(() => this.callbacks.onUpdateChart(), 300);
                    this.timerRegistry.registerTimeout(chartTimeout);
                }
            }
            if (toggle) toggle.textContent = '▼';
        }

        /**
         * Apply chart collapsed state
         */
        applyChartCollapsedState() {
            const chartContainer = this.container.querySelector('#mwi-dt-chart-container');
            const toggle = this.container.querySelector('#mwi-dt-chart-toggle');

            if (chartContainer) chartContainer.style.display = 'none';
            if (toggle) toggle.textContent = '▶';
        }

        /**
         * Apply initial states
         */
        applyInitialStates() {
            // Apply initial collapsed state
            if (this.state.isCollapsed) {
                this.applyCollapsedState();
            }

            // Apply initial keys expanded state
            if (this.state.isKeysExpanded) {
                this.applyKeysExpandedState();
            }

            // Apply initial run history expanded state
            if (this.state.isRunHistoryExpanded) {
                this.applyRunHistoryExpandedState();
            }

            // Apply initial chart expanded state
            if (this.state.isChartExpanded) {
                this.applyChartExpandedState();
            }
        }

        /**
         * Setup keyboard shortcut for resetting position
         * Ctrl+Shift+D to reset dungeon tracker to default position
         */
        setupKeyboardShortcut() {
            document.addEventListener('keydown', (e) => {
                // Ctrl+Shift+D - Reset dungeon tracker position
                if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                    e.preventDefault();
                    this.resetPosition();
                }
            });
        }

        /**
         * Reset dungeon tracker position to default (center)
         */
        resetPosition() {
            // Clear saved position (re-enables default centering)
            this.state.position = null;

            // Re-apply position styling
            this.state.updatePosition(this.container);

            // Save updated state
            this.state.save();

            // Show brief notification
            this.showNotification('Dungeon Tracker position reset');
        }

        /**
         * Show temporary notification message
         * @param {string} message - Notification text
         */
        showNotification(message) {
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(74, 158, 255, 0.95);
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            font-weight: bold;
            z-index: 99999;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        `;

            document.body.appendChild(notification);

            // Fade out and remove after 2 seconds
            const removeTimeout = setTimeout(() => {
                notification.style.transition = 'opacity 0.3s ease';
                notification.style.opacity = '0';
                const cleanupTimeout = setTimeout(() => notification.remove(), 300);
                this.timerRegistry.registerTimeout(cleanupTimeout);
            }, 2000);
            this.timerRegistry.registerTimeout(removeTimeout);
        }

        cleanup() {
            // Remove document-level drag listeners
            if (this.dragMoveHandler) {
                document.removeEventListener('mousemove', this.dragMoveHandler);
                this.dragMoveHandler = null;
            }
            if (this.dragUpHandler) {
                document.removeEventListener('mouseup', this.dragUpHandler);
                this.dragUpHandler = null;
            }

            this.timerRegistry.clearAll();
        }
    }

    /**
     * Dungeon Tracker UI Core
     * Main orchestrator for dungeon tracker UI display
     * Coordinates state, chart, history, and interaction modules
     */


    class DungeonTrackerUI {
        constructor() {
            this.container = null;
            this.updateInterval = null;
            this.isInitialized = false; // Guard against multiple initializations
            this.timerRegistry = createTimerRegistry();

            // Module references (initialized in initialize())
            this.state = dungeonTrackerUIState;
            this.chart = null;
            this.history = null;
            this.interactions = null;

            // Callback references for cleanup
            this.dungeonUpdateHandler = null;
            this.characterSwitchingHandler = null;
            this.characterSelectObserver = null;
        }

        /**
         * Initialize UI
         */
        async initialize() {
            // Prevent multiple initializations (memory leak protection)
            if (this.isInitialized) {
                console.warn('[Toolasha Dungeon Tracker UI] Already initialized, skipping duplicate initialization');
                return;
            }
            this.isInitialized = true;

            // Load saved state
            await this.state.load();

            // Initialize modules with formatTime function
            this.chart = new DungeonTrackerUIChart(this.state, this.formatTime.bind(this));
            this.history = new DungeonTrackerUIHistory(this.state, this.formatTime.bind(this));
            this.interactions = new DungeonTrackerUIInteractions(this.state, this.chart, this.history);

            // Set up history delete callback
            this.history.onDelete(() => this.updateRunHistory());

            // Create UI elements
            this.createUI();

            // Hide UI initially - only show when dungeon is active
            this.hide();

            // Store callback reference for cleanup
            this.dungeonUpdateHandler = (currentRun, completedRun) => {
                // Check if UI is enabled
                if (!config$1.isFeatureEnabled('dungeonTrackerUI')) {
                    this.hide();
                    return;
                }

                if (completedRun) {
                    // Dungeon completed - trigger chat annotation update and hide UI
                    const annotateTimeout = setTimeout(() => dungeonTrackerChatAnnotations.annotateAllMessages(), 200);
                    this.timerRegistry.registerTimeout(annotateTimeout);
                    this.hide();
                } else if (currentRun) {
                    // Dungeon in progress
                    this.show();
                    this.update(currentRun);
                } else {
                    // No active dungeon
                    this.hide();
                }
            };

            // Register for dungeon tracker updates
            dungeonTracker.onUpdate(this.dungeonUpdateHandler);

            // Start update loop (updates current wave time every second)
            this.startUpdateLoop();

            // Store listener reference for cleanup
            this.characterSwitchingHandler = () => {
                this.cleanup();
            };

            dataManager$1.on('character_switching', this.characterSwitchingHandler);

            // Watch for character selection screen appearing (when user clicks "Switch Character")
            if (document.body) {
                this.characterSelectObserver = createMutationWatcher(
                    document.body,
                    () => {
                        // Check if character selection screen is visible
                        const headings = document.querySelectorAll('h1, h2, h3');
                        for (const heading of headings) {
                            if (heading.textContent?.includes('Select Character')) {
                                this.hide();
                                break;
                            }
                        }
                    },
                    {
                        childList: true,
                        subtree: true,
                    }
                );
            }
        }

        /**
         * Create UI elements
         */
        createUI() {
            // Create container
            this.container = document.createElement('div');
            this.container.id = 'mwi-dungeon-tracker';

            // Apply saved position or default
            this.state.updatePosition(this.container);

            // Add HTML structure
            this.container.innerHTML = `
            <div id="mwi-dt-header" style="
                background: #2d3748;
                border-radius: 6px 6px 0 0;
                cursor: move;
                user-select: none;
            ">
                <!-- Header Line 1: Dungeon Name + Current Time + Wave -->
                <div style="
                    display: flex;
                    align-items: center;
                    padding: 6px 10px;
                ">
                    <div style="flex: 1;">
                        <span id="mwi-dt-dungeon-name" style="font-weight: bold; font-size: 14px; color: #4a9eff;">
                            Loading...
                        </span>
                    </div>
                    <div style="flex: 0; padding: 0 10px; white-space: nowrap;">
                        <span id="mwi-dt-time-label" style="font-size: 12px; color: #aaa;" title="Time since dungeon started">Elapsed: </span>
                        <span id="mwi-dt-current-time" style="font-size: 13px; color: #fff; font-weight: bold;">
                            00:00
                        </span>
                    </div>
                    <div style="flex: 1; display: flex; gap: 8px; align-items: center; justify-content: flex-end;">
                        <span id="mwi-dt-wave-counter" style="font-size: 13px; color: #aaa;">
                            Wave 1/50
                        </span>
                        <button id="mwi-dt-collapse-btn" style="
                            background: none;
                            border: none;
                            color: #aaa;
                            cursor: pointer;
                            font-size: 16px;
                            padding: 0 4px;
                            line-height: 1;
                        " title="Collapse/Expand">▼</button>
                    </div>
                </div>

                <!-- Header Line 2: Stats (always visible) -->
                <div id="mwi-dt-header-stats" style="
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    padding: 4px 10px 6px 10px;
                    font-size: 12px;
                    color: #ccc;
                    gap: 12px;
                ">
                    <span>Last Run: <span id="mwi-dt-header-last" style="color: #fff; font-weight: bold;">--:--</span></span>
                    <span>|</span>
                    <span>Avg Run: <span id="mwi-dt-header-avg" style="color: #fff; font-weight: bold;">--:--</span></span>
                    <span>|</span>
                    <span>Runs: <span id="mwi-dt-header-runs" style="color: #fff; font-weight: bold;">0</span></span>
                    <span>|</span>
                    <span>Keys: <span id="mwi-dt-header-keys" style="color: #fff; font-weight: bold;">0</span></span>
                </div>
            </div>

            <div id="mwi-dt-content" style="padding: 12px 20px; display: flex; flex-direction: column; gap: 12px;">
                <!-- Progress bar -->
                <div>
                    <div style="background: #333; border-radius: 4px; height: 20px; position: relative; overflow: hidden;">
                        <div id="mwi-dt-progress-bar" style="
                            background: linear-gradient(90deg, #4a9eff 0%, #6eb5ff 100%);
                            height: 100%;
                            width: 0%;
                            transition: width 0.3s ease;
                        "></div>
                        <div style="
                            position: absolute;
                            top: 0;
                            left: 0;
                            right: 0;
                            bottom: 0;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 11px;
                            font-weight: bold;
                            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
                        " id="mwi-dt-progress-text">0%</div>
                    </div>
                </div>

                <!-- Run-level stats (2x2 grid) -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; font-size: 11px; color: #ccc; padding-top: 4px; border-top: 1px solid #444;">
                    <div style="text-align: center;">
                        <div style="color: #aaa; font-size: 10px;">Avg Run</div>
                        <div id="mwi-dt-avg-time" style="color: #fff; font-weight: bold;">--:--</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: #aaa; font-size: 10px;">Last Run</div>
                        <div id="mwi-dt-last-time" style="color: #fff; font-weight: bold;">--:--</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: #aaa; font-size: 10px;">Fastest Run</div>
                        <div id="mwi-dt-fastest-time" style="color: #5fda5f; font-weight: bold;">--:--</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="color: #aaa; font-size: 10px;">Slowest Run</div>
                        <div id="mwi-dt-slowest-time" style="color: #ff6b6b; font-weight: bold;">--:--</div>
                    </div>
                </div>

                <!-- Keys section (collapsible placeholder) -->
                <div id="mwi-dt-keys-section" style="padding-top: 8px; border-top: 1px solid #444;">
                    <div id="mwi-dt-keys-header" style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        cursor: pointer;
                        padding: 4px 0;
                        font-size: 12px;
                        color: #ccc;
                    ">
                        <span>Keys: <span id="mwi-dt-character-name">Loading...</span> (<span id="mwi-dt-self-keys">0</span>)</span>
                        <span id="mwi-dt-keys-toggle" style="font-size: 10px;">▼</span>
                    </div>
                    <div id="mwi-dt-keys-list" style="
                        display: none;
                        padding: 8px 0;
                        font-size: 11px;
                        color: #ccc;
                    ">
                        <!-- Keys will be populated dynamically -->
                    </div>
                </div>

                <!-- Run history section (unified with grouping/filtering) -->
                <div style="padding-top: 8px; border-top: 1px solid #444;">
                    <div id="mwi-dt-run-history-header" style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        cursor: pointer;
                        padding: 4px 0;
                        margin-bottom: 8px;
                    ">
                        <span style="font-size: 12px; font-weight: bold; color: #ccc;">Run History <span id="mwi-dt-run-history-toggle" style="font-size: 10px;">▼</span></span>
                        <div style="display: flex; gap: 4px;">
                            <button id="mwi-dt-backfill-btn" style="
                                background: none;
                                border: 1px solid #4a9eff;
                                color: #4a9eff;
                                cursor: pointer;
                                font-size: 11px;
                                padding: 2px 8px;
                                border-radius: 3px;
                                font-weight: bold;
                            " title="Scan party chat and import historical runs">⟳ Backfill</button>
                            <button id="mwi-dt-clear-all" style="
                                background: none;
                                border: 1px solid #ff6b6b;
                                color: #ff6b6b;
                                cursor: pointer;
                                font-size: 11px;
                                padding: 2px 8px;
                                border-radius: 3px;
                                font-weight: bold;
                            " title="Clear all runs">✕ Clear</button>
                        </div>
                    </div>

                    <!-- Grouping and filtering controls -->
                    <div id="mwi-dt-controls" style="
                        display: none;
                        padding: 8px 0;
                        font-size: 11px;
                        color: #ccc;
                        border-bottom: 1px solid #444;
                        margin-bottom: 8px;
                    ">
                        <div style="margin-bottom: 6px;">
                            <label style="margin-right: 6px;">Group by:</label>
                            <select id="mwi-dt-group-by" style="
                                background: #333;
                                color: #fff;
                                border: 1px solid #555;
                                border-radius: 3px;
                                padding: 2px 4px;
                                font-size: 11px;
                            ">
                                <option value="team">Team</option>
                                <option value="dungeon">Dungeon</option>
                            </select>
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <div>
                                <label style="margin-right: 6px;">Dungeon:</label>
                                <select id="mwi-dt-filter-dungeon" style="
                                    background: #333;
                                    color: #fff;
                                    border: 1px solid #555;
                                    border-radius: 3px;
                                    padding: 2px 4px;
                                    font-size: 11px;
                                    min-width: 100px;
                                ">
                                    <option value="all">All Dungeons</option>
                                </select>
                            </div>
                            <div>
                                <label style="margin-right: 6px;">Team:</label>
                                <select id="mwi-dt-filter-team" style="
                                    background: #333;
                                    color: #fff;
                                    border: 1px solid #555;
                                    border-radius: 3px;
                                    padding: 2px 4px;
                                    font-size: 11px;
                                    min-width: 100px;
                                ">
                                    <option value="all">All Teams</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div id="mwi-dt-run-list" style="
                        display: none;
                        max-height: 200px;
                        overflow-y: auto;
                        font-size: 11px;
                        color: #ccc;
                    ">
                        <!-- Run list populated dynamically -->
                        <div style="color: #888; font-style: italic; text-align: center; padding: 8px;">No runs yet</div>
                    </div>
                </div>

                <!-- Run Chart section (collapsible) -->
                <div style="padding-top: 8px; border-top: 1px solid #444;">
                    <div id="mwi-dt-chart-header" style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        cursor: pointer;
                        padding: 4px 0;
                        margin-bottom: 8px;
                    ">
                        <span style="font-size: 12px; font-weight: bold; color: #ccc;">📊 Run Chart <span id="mwi-dt-chart-toggle" style="font-size: 10px;">▼</span></span>
                        <button id="mwi-dt-chart-popout-btn" style="
                            background: none;
                            border: 1px solid #4a9eff;
                            color: #4a9eff;
                            cursor: pointer;
                            font-size: 11px;
                            padding: 2px 8px;
                            border-radius: 3px;
                            font-weight: bold;
                        " title="Pop out chart">⇱ Pop-out</button>
                    </div>
                    <div id="mwi-dt-chart-container" style="
                        display: block;
                        height: 300px;
                        position: relative;
                    ">
                        <canvas id="mwi-dt-chart-canvas"></canvas>
                    </div>
                </div>
            </div>
        `;

            // Add to page
            document.body.appendChild(this.container);

            // Setup all interactions with callbacks
            this.interactions.setupAll(this.container, {
                onUpdate: () => {
                    const currentRun = dungeonTracker.getCurrentRun();
                    if (currentRun) this.update(currentRun);
                },
                onUpdateChart: () => this.updateChart(),
                onUpdateHistory: () => this.updateRunHistory(),
            });

            // Apply initial states
            this.interactions.applyInitialStates();
        }

        /**
         * Update UI with current run data
         * @param {Object} run - Current run state
         */
        async update(run) {
            if (!run || !this.container) {
                return;
            }

            // Update dungeon name and tier
            const dungeonName = this.container.querySelector('#mwi-dt-dungeon-name');
            if (dungeonName) {
                if (run.dungeonName && run.tier !== null) {
                    dungeonName.textContent = `${run.dungeonName} (T${run.tier})`;
                } else {
                    dungeonName.textContent = 'Dungeon Loading...';
                }
            }

            // Update wave counter
            const waveCounter = this.container.querySelector('#mwi-dt-wave-counter');
            if (waveCounter && run.maxWaves) {
                waveCounter.textContent = `Wave ${run.currentWave}/${run.maxWaves}`;
            }

            // Update current elapsed time
            const currentTime = this.container.querySelector('#mwi-dt-current-time');
            if (currentTime && run.totalElapsed !== undefined) {
                currentTime.textContent = this.formatTime(run.totalElapsed);
            }

            // Update time label based on hibernation detection
            const timeLabel = this.container.querySelector('#mwi-dt-time-label');
            if (timeLabel) {
                if (run.hibernationDetected) {
                    timeLabel.textContent = 'Chat: ';
                    timeLabel.title = 'Using party chat timestamps (computer sleep detected)';
                } else {
                    timeLabel.textContent = 'Elapsed: ';
                    timeLabel.title = 'Time since dungeon started';
                }
            }

            // Update progress bar
            const progressBar = this.container.querySelector('#mwi-dt-progress-bar');
            const progressText = this.container.querySelector('#mwi-dt-progress-text');
            if (progressBar && progressText && run.maxWaves) {
                const percent = Math.round((run.currentWave / run.maxWaves) * 100);
                progressBar.style.width = `${percent}%`;
                progressText.textContent = `${percent}%`;
            }

            // Fetch run statistics - respect ALL filters to match chart exactly
            let stats, runHistory, lastRunTime;

            // Get all runs and apply filters (EXACT SAME LOGIC as chart)
            const allRuns = await storage$1.getJSON('allRuns', 'unifiedRuns', []);
            runHistory = allRuns;

            // Apply dungeon filter
            if (this.state.filterDungeon !== 'all') {
                runHistory = runHistory.filter((r) => r.dungeonName === this.state.filterDungeon);
            }

            // Apply team filter
            if (this.state.filterTeam !== 'all') {
                runHistory = runHistory.filter((r) => r.teamKey === this.state.filterTeam);
            }

            // Calculate stats from filtered runs
            if (runHistory.length > 0) {
                // Sort by timestamp (descending for most recent first)
                runHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                const durations = runHistory.map((r) => r.duration || r.totalTime || 0);
                const total = durations.reduce((sum, d) => sum + d, 0);

                stats = {
                    totalRuns: runHistory.length,
                    avgTime: Math.floor(total / runHistory.length),
                    fastestTime: Math.min(...durations),
                    slowestTime: Math.max(...durations),
                };

                lastRunTime = durations[0]; // First run after sorting (most recent)
            } else {
                // No runs match filters
                stats = { totalRuns: 0, avgTime: 0, fastestTime: 0, slowestTime: 0 };
                lastRunTime = 0;
            }

            // Get character name from dataManager
            let characterName = dataManager$1.characterData?.character?.name;

            if (!characterName && run.keyCountsMap) {
                // Fallback: use first player name from key counts
                const playerNames = Object.keys(run.keyCountsMap);
                if (playerNames.length > 0) {
                    characterName = playerNames[0];
                }
            }

            if (!characterName) {
                characterName = 'You'; // Final fallback
            }

            // Update character name in Keys section
            const characterNameElement = this.container.querySelector('#mwi-dt-character-name');
            if (characterNameElement) {
                characterNameElement.textContent = characterName;
            }

            // Update header stats (always visible)
            const headerLast = this.container.querySelector('#mwi-dt-header-last');
            if (headerLast) {
                headerLast.textContent = lastRunTime > 0 ? this.formatTime(lastRunTime) : '--:--';
            }

            const headerAvg = this.container.querySelector('#mwi-dt-header-avg');
            if (headerAvg) {
                headerAvg.textContent = stats.avgTime > 0 ? this.formatTime(stats.avgTime) : '--:--';
            }

            const headerRuns = this.container.querySelector('#mwi-dt-header-runs');
            if (headerRuns) {
                headerRuns.textContent = stats.totalRuns.toString();
            }

            // Update header keys (always visible) - show current key count from current run
            const headerKeys = this.container.querySelector('#mwi-dt-header-keys');
            if (headerKeys) {
                const currentKeys = (run.keyCountsMap && run.keyCountsMap[characterName]) || 0;
                headerKeys.textContent = currentKeys.toLocaleString();
            }

            // Update run-level stats in content area (2x2 grid)
            const avgTime = this.container.querySelector('#mwi-dt-avg-time');
            if (avgTime) {
                avgTime.textContent = stats.avgTime > 0 ? this.formatTime(stats.avgTime) : '--:--';
            }

            const lastTime = this.container.querySelector('#mwi-dt-last-time');
            if (lastTime) {
                lastTime.textContent = lastRunTime > 0 ? this.formatTime(lastRunTime) : '--:--';
            }

            const fastestTime = this.container.querySelector('#mwi-dt-fastest-time');
            if (fastestTime) {
                fastestTime.textContent = stats.fastestTime > 0 ? this.formatTime(stats.fastestTime) : '--:--';
            }

            const slowestTime = this.container.querySelector('#mwi-dt-slowest-time');
            if (slowestTime) {
                slowestTime.textContent = stats.slowestTime > 0 ? this.formatTime(stats.slowestTime) : '--:--';
            }

            // Update Keys section with party member key counts
            this.updateKeysDisplay(run.keyCountsMap || {}, characterName);

            // Update run history list
            await this.updateRunHistory();
        }

        /**
         * Update Keys section display
         * @param {Object} keyCountsMap - Map of player names to key counts
         * @param {string} characterName - Current character name
         */
        updateKeysDisplay(keyCountsMap, characterName) {
            // Update self key count in header
            const selfKeyCount = keyCountsMap[characterName] || 0;
            const selfKeysElement = this.container.querySelector('#mwi-dt-self-keys');
            if (selfKeysElement) {
                selfKeysElement.textContent = selfKeyCount.toString();
            }

            // Update expanded keys list
            const keysList = this.container.querySelector('#mwi-dt-keys-list');
            if (!keysList) return;

            // Clear existing content
            keysList.innerHTML = '';

            // Get all players sorted (current character first, then alphabetically)
            const playerNames = Object.keys(keyCountsMap).sort((a, b) => {
                if (a === characterName) return -1;
                if (b === characterName) return 1;
                return a.localeCompare(b);
            });

            if (playerNames.length === 0) {
                keysList.innerHTML =
                    '<div style="color: #888; font-style: italic; text-align: center; padding: 8px;">No key data yet</div>';
                return;
            }

            // Build player list HTML
            playerNames.forEach((playerName) => {
                const keyCount = keyCountsMap[playerName];
                const isCurrentPlayer = playerName === characterName;

                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.justifyContent = 'space-between';
                row.style.alignItems = 'center';
                row.style.padding = '4px 8px';
                row.style.borderBottom = '1px solid #333';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = playerName;
                nameSpan.style.color = isCurrentPlayer ? '#4a9eff' : '#ccc';
                nameSpan.style.fontWeight = isCurrentPlayer ? 'bold' : 'normal';

                const keyCountSpan = document.createElement('span');
                keyCountSpan.textContent = keyCount.toLocaleString();
                keyCountSpan.style.color = '#fff';
                keyCountSpan.style.fontWeight = 'bold';

                row.appendChild(nameSpan);
                row.appendChild(keyCountSpan);
                keysList.appendChild(row);
            });
        }

        /**
         * Update run history display
         */
        async updateRunHistory() {
            await this.history.update(this.container);
        }

        /**
         * Update chart display
         */
        async updateChart() {
            if (this.state.isChartExpanded) {
                await this.chart.render(this.container);
            }
        }

        /**
         * Show the UI
         */
        show() {
            if (this.container) {
                this.container.style.display = 'block';
            }
        }

        /**
         * Hide the UI
         */
        hide() {
            if (this.container) {
                this.container.style.display = 'none';
            }
        }

        /**
         * Start the update loop (updates current wave time every second)
         */
        startUpdateLoop() {
            // Clear existing interval
            if (this.updateInterval) {
                clearInterval(this.updateInterval);
            }

            // Update every second
            this.updateInterval = setInterval(() => {
                const currentRun = dungeonTracker.getCurrentRun();
                if (currentRun) {
                    this.update(currentRun);
                }
            }, 1000);

            this.timerRegistry.registerInterval(this.updateInterval);
        }

        /**
         * Cleanup for character switching
         */
        cleanup() {
            // Immediately hide UI to prevent visual artifacts during character switch
            this.hide();

            if (this.dungeonUpdateHandler) {
                dungeonTracker.offUpdate(this.dungeonUpdateHandler);
                this.dungeonUpdateHandler = null;
            }

            if (this.characterSwitchingHandler) {
                dataManager$1.off('character_switching', this.characterSwitchingHandler);
                this.characterSwitchingHandler = null;
            }

            // Disconnect character selection screen observer
            if (this.characterSelectObserver) {
                this.characterSelectObserver();
                this.characterSelectObserver = null;
            }

            // Clear update interval
            if (this.updateInterval) {
                clearInterval(this.updateInterval);
                this.updateInterval = null;
            }

            this.timerRegistry.clearAll();

            // Force remove ALL dungeon tracker containers (handles duplicates from memory leak)
            const allContainers = document.querySelectorAll('#mwi-dungeon-tracker');
            if (allContainers.length > 1) {
                console.warn(
                    `[Toolasha Dungeon Tracker UI] Found ${allContainers.length} UI containers, removing all (memory leak detected)`
                );
            }
            allContainers.forEach((container) => container.remove());

            if (this.interactions && this.interactions.cleanup) {
                this.interactions.cleanup();
            }

            // Clear instance reference
            this.container = null;

            // Clean up module references
            if (this.chart) {
                this.chart = null;
            }
            if (this.history) {
                this.history = null;
            }
            if (this.interactions) {
                this.interactions = null;
            }

            // Reset initialization flag
            this.isInitialized = false;
        }

        /**
         * Format time in milliseconds to MM:SS
         * @param {number} ms - Time in milliseconds
         * @returns {string} Formatted time
         */
        formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    const dungeonTrackerUI = new DungeonTrackerUI();

    /**
     * Combat Summary Module
     * Shows detailed statistics when returning from combat
     */


    /**
     * CombatSummary class manages combat completion statistics display
     */
    class CombatSummary {
        constructor() {
            this.isActive = false;
            this.isInitialized = false;
            this.battleUnitFetchedHandler = null; // Store handler reference for cleanup
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Initialize combat summary feature
         */
        initialize() {
            // Guard FIRST (before feature check)
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('combatSummary')) {
                return;
            }

            this.isInitialized = true;

            this.battleUnitFetchedHandler = (data) => {
                this.handleBattleSummary(data);
            };

            // Listen for battle_unit_fetched WebSocket message
            webSocketHook$1.on('battle_unit_fetched', this.battleUnitFetchedHandler);

            this.isActive = true;
        }

        /**
         * Handle battle completion and display summary
         * @param {Object} message - WebSocket message data
         */
        async handleBattleSummary(message) {
            // Validate message structure
            if (!message || !message.unit) {
                console.warn('[Combat Summary] Invalid message structure:', message);
                return;
            }

            // Ensure market data is loaded
            if (!marketAPI.isLoaded()) {
                const marketData = await marketAPI.fetch();
                if (!marketData) {
                    console.error('[Combat Summary] Market data not available');
                    return;
                }
            }

            // Calculate total revenue from loot (with null check)
            let totalPriceAsk = 0;
            let totalPriceBid = 0;

            if (message.unit.totalLootMap) {
                for (const loot of Object.values(message.unit.totalLootMap)) {
                    const itemCount = loot.count;

                    // Coins are revenue at face value (1 coin = 1 gold)
                    if (loot.itemHrid === '/items/coin') {
                        totalPriceAsk += itemCount;
                        totalPriceBid += itemCount;
                    } else {
                        // Other items: get market price
                        const prices = marketAPI.getPrice(loot.itemHrid);
                        if (prices) {
                            totalPriceAsk += prices.ask * itemCount;
                            totalPriceBid += prices.bid * itemCount;
                        }
                    }
                }
            } else {
                console.warn('[Combat Summary] No totalLootMap in message');
            }

            // Calculate total experience (with null check)
            let totalSkillsExp = 0;
            if (message.unit.totalSkillExperienceMap) {
                for (const exp of Object.values(message.unit.totalSkillExperienceMap)) {
                    totalSkillsExp += exp;
                }
            } else {
                console.warn('[Combat Summary] No totalSkillExperienceMap in message');
            }

            // Wait for battle panel to appear and inject summary
            const tryTimes = 0;
            this.findAndInjectSummary(message, totalPriceAsk, totalPriceBid, totalSkillsExp, tryTimes);
        }

        /**
         * Find battle panel and inject summary stats
         * @param {Object} message - WebSocket message data
         * @param {number} totalPriceAsk - Total loot value at ask price
         * @param {number} totalPriceBid - Total loot value at bid price
         * @param {number} totalSkillsExp - Total experience gained
         * @param {number} tryTimes - Retry counter
         */
        findAndInjectSummary(message, totalPriceAsk, totalPriceBid, totalSkillsExp, tryTimes) {
            tryTimes++;

            // Find the experience section parent
            const elem = document.querySelector('[class*="BattlePanel_gainedExp"]')?.parentElement;

            if (elem) {
                // Get primary text color from settings
                const textColor = config$1.getSetting('color_text_primary') || config$1.COLOR_TEXT_PRIMARY;

                // Parse combat duration and battle count
                let battleDurationSec = null;
                const combatInfoElement = document.querySelector('[class*="BattlePanel_combatInfo"]');

                if (combatInfoElement) {
                    const matches = combatInfoElement.innerHTML.match(
                        /Combat Duration: (?:(\d+)d\s*)?(?:(\d+)h\s*)?(?:(\d+)m\s*)?(?:(\d+)s).*?Battles: (\d+).*?Deaths: (\d+)/
                    );

                    if (matches) {
                        const days = parseInt(matches[1], 10) || 0;
                        const hours = parseInt(matches[2], 10) || 0;
                        const minutes = parseInt(matches[3], 10) || 0;
                        const seconds = parseInt(matches[4], 10) || 0;
                        const battles = parseInt(matches[5], 10) - 1; // Exclude current battle

                        battleDurationSec = days * 86400 + hours * 3600 + minutes * 60 + seconds;

                        // Calculate encounters per hour
                        const encountersPerHour = ((battles / battleDurationSec) * 3600).toFixed(1);

                        elem.insertAdjacentHTML(
                            'beforeend',
                            `<div id="mwi-combat-encounters" style="color: ${textColor};">Encounters/hour: ${encountersPerHour}</div>`
                        );
                    }
                }

                // Total revenue
                document
                    .querySelector('div#mwi-combat-encounters')
                    ?.insertAdjacentHTML(
                        'afterend',
                        `<div id="mwi-combat-revenue" style="color: ${textColor};">Total revenue: ${formatLargeNumber(Math.round(totalPriceAsk))} / ${formatLargeNumber(Math.round(totalPriceBid))}</div>`
                    );

                // Per-hour revenue
                if (battleDurationSec) {
                    const revenuePerHourAsk = totalPriceAsk / (battleDurationSec / 3600);
                    const revenuePerHourBid = totalPriceBid / (battleDurationSec / 3600);

                    document
                        .querySelector('div#mwi-combat-revenue')
                        ?.insertAdjacentHTML(
                            'afterend',
                            `<div id="mwi-combat-revenue-hour" style="color: ${textColor};">Revenue/hour: ${formatLargeNumber(Math.round(revenuePerHourAsk))} / ${formatLargeNumber(Math.round(revenuePerHourBid))}</div>`
                        );

                    // Per-day revenue
                    document
                        .querySelector('div#mwi-combat-revenue-hour')
                        ?.insertAdjacentHTML(
                            'afterend',
                            `<div id="mwi-combat-revenue-day" style="color: ${textColor};">Revenue/day: ${formatLargeNumber(Math.round(revenuePerHourAsk * 24))} / ${formatLargeNumber(Math.round(revenuePerHourBid * 24))}</div>`
                        );
                }

                // Total experience
                document
                    .querySelector('div#mwi-combat-revenue-day')
                    ?.insertAdjacentHTML(
                        'afterend',
                        `<div id="mwi-combat-total-exp" style="color: ${textColor};">Total exp: ${formatLargeNumber(Math.round(totalSkillsExp))}</div>`
                    );

                // Per-hour experience breakdowns
                if (battleDurationSec) {
                    const totalExpPerHour = totalSkillsExp / (battleDurationSec / 3600);

                    // Insert total exp/hour first
                    document
                        .querySelector('div#mwi-combat-total-exp')
                        ?.insertAdjacentHTML(
                            'afterend',
                            `<div id="mwi-combat-total-exp-hour" style="color: ${textColor};">Total exp/hour: ${formatLargeNumber(Math.round(totalExpPerHour))}</div>`
                        );

                    // Individual skill exp/hour
                    const skills = [
                        { skillHrid: '/skills/attack', name: 'Attack' },
                        { skillHrid: '/skills/magic', name: 'Magic' },
                        { skillHrid: '/skills/ranged', name: 'Ranged' },
                        { skillHrid: '/skills/defense', name: 'Defense' },
                        { skillHrid: '/skills/melee', name: 'Melee' },
                        { skillHrid: '/skills/intelligence', name: 'Intelligence' },
                        { skillHrid: '/skills/stamina', name: 'Stamina' },
                    ];

                    let lastElement = document.querySelector('div#mwi-combat-total-exp-hour');

                    // Only show individual skill exp if we have the data
                    if (message.unit.totalSkillExperienceMap) {
                        for (const skill of skills) {
                            const expGained = message.unit.totalSkillExperienceMap[skill.skillHrid];
                            if (expGained && lastElement) {
                                const expPerHour = expGained / (battleDurationSec / 3600);
                                lastElement.insertAdjacentHTML(
                                    'afterend',
                                    `<div style="color: ${textColor};">${skill.name} exp/hour: ${formatLargeNumber(Math.round(expPerHour))}</div>`
                                );
                                // Update lastElement to the newly inserted div
                                lastElement = lastElement.nextElementSibling;
                            }
                        }
                    }
                } else {
                    console.warn('[Combat Summary] Unable to display hourly stats due to null battleDurationSec');
                }
            } else if (tryTimes <= 10) {
                // Retry if element not found
                const retryTimeout = setTimeout(() => {
                    this.findAndInjectSummary(message, totalPriceAsk, totalPriceBid, totalSkillsExp, tryTimes);
                }, 200);
                this.timerRegistry.registerTimeout(retryTimeout);
            } else {
                console.error('[Combat Summary] Battle panel not found after 10 tries');
            }
        }

        /**
         * Disable the combat summary feature
         */
        disable() {
            if (this.battleUnitFetchedHandler) {
                webSocketHook$1.off('battle_unit_fetched', this.battleUnitFetchedHandler);
                this.battleUnitFetchedHandler = null;
            }

            this.timerRegistry.clearAll();
            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const combatSummary = new CombatSummary();

    /**
     * Combat Simulator Export Module
     * Constructs player data in Shykai Combat Simulator format
     *
     * Exports character data for solo or party simulation testing
     */


    // Detect if we're running on Tampermonkey or Steam
    const hasScriptManager$1 = typeof GM_info !== 'undefined';

    /**
     * Get saved character data from storage
     * @returns {Promise<Object|null>} Parsed character data or null
     */
    async function getCharacterData$1() {
        try {
            // Tampermonkey: Use GM storage (cross-domain, persisted)
            if (hasScriptManager$1) {
                const data = await webSocketHook$1.loadFromStorage('toolasha_init_character_data', null);
                if (!data) {
                    console.error('[Combat Sim Export] No character data found. Please refresh game page.');
                    return null;
                }
                return JSON.parse(data);
            }

            // Steam: Use dataManager (which has its own fallback handling)
            const characterData = dataManager$1.characterData;

            if (!characterData) {
                console.error('[Combat Sim Export] No character data found. Please refresh game page.');
                return null;
            }
            return characterData;
        } catch (error) {
            console.error('[Combat Sim Export] Failed to get character data:', error);
            return null;
        }
    }

    /**
     * Get saved battle data from storage
     * @returns {Promise<Object|null>} Parsed battle data or null
     */
    async function getBattleData() {
        try {
            // Tampermonkey: Use GM storage
            if (hasScriptManager$1) {
                const data = await webSocketHook$1.loadFromStorage('toolasha_new_battle', null);
                if (!data) {
                    return null; // No battle data (not in combat or solo)
                }
                return JSON.parse(data);
            }

            // Steam: Use dataManager (RAM only, no GM storage available)
            const battleData = dataManager$1.battleData;
            if (!battleData) {
                return null; // No battle data (not in combat or solo)
            }
            return battleData;
        } catch (error) {
            console.error('[Combat Sim Export] Failed to get battle data:', error);
            return null;
        }
    }

    /**
     * Get init_client_data from storage
     * @returns {Promise<Object|null>} Parsed client data or null
     */
    async function getClientData() {
        try {
            // Tampermonkey: Use GM storage (cross-domain, persisted)
            if (hasScriptManager$1) {
                const data = await webSocketHook$1.loadFromStorage('toolasha_init_client_data', null);
                if (!data) {
                    console.warn('[Combat Sim Export] No client data found');
                    return null;
                }
                return JSON.parse(data);
            }

            // Steam: Use dataManager (RAM only, no GM storage available)
            const clientData = dataManager$1.getInitClientData();
            if (!clientData) {
                console.warn('[Combat Sim Export] No client data found');
                return null;
            }
            return clientData;
        } catch (error) {
            console.error('[Combat Sim Export] Failed to get client data:', error);
            return null;
        }
    }

    /**
     * Get profile export list from storage
     * @returns {Promise<Array>} List of saved profiles
     */
    async function getProfileList() {
        try {
            // Read from GM storage (cross-origin accessible, matches pattern of other combat sim data)
            const profileListJson = await webSocketHook$1.loadFromStorage('toolasha_profile_list', '[]');
            return JSON.parse(profileListJson);
        } catch (error) {
            console.error('[Combat Sim Export] Failed to get profile list:', error);
            return [];
        }
    }

    /**
     * Construct player export object from own character data
     * @param {Object} characterObj - Character data from init_character_data
     * @param {Object} clientObj - Client data (optional)
     * @returns {Object} Player export object
     */
    function constructSelfPlayer(characterObj, clientObj) {
        const playerObj = {
            player: {
                attackLevel: 1,
                magicLevel: 1,
                meleeLevel: 1,
                rangedLevel: 1,
                defenseLevel: 1,
                staminaLevel: 1,
                intelligenceLevel: 1,
                equipment: [],
            },
            food: { '/action_types/combat': [] },
            drinks: { '/action_types/combat': [] },
            abilities: [],
            triggerMap: {},
            houseRooms: {},
        };

        // Extract combat skill levels
        for (const skill of characterObj.characterSkills || []) {
            const skillName = skill.skillHrid.split('/').pop();
            if (skillName && playerObj.player[skillName + 'Level'] !== undefined) {
                playerObj.player[skillName + 'Level'] = skill.level;
            }
        }

        // Extract equipped items - handle both formats
        if (Array.isArray(characterObj.characterItems)) {
            // Array format (full inventory list)
            for (const item of characterObj.characterItems) {
                if (item.itemLocationHrid && !item.itemLocationHrid.includes('/item_locations/inventory')) {
                    playerObj.player.equipment.push({
                        itemLocationHrid: item.itemLocationHrid,
                        itemHrid: item.itemHrid,
                        enhancementLevel: item.enhancementLevel || 0,
                    });
                }
            }
        } else if (characterObj.characterEquipment) {
            // Object format (just equipped items)
            for (const key in characterObj.characterEquipment) {
                const item = characterObj.characterEquipment[key];
                playerObj.player.equipment.push({
                    itemLocationHrid: item.itemLocationHrid,
                    itemHrid: item.itemHrid,
                    enhancementLevel: item.enhancementLevel || 0,
                });
            }
        }

        // Initialize food and drink slots
        for (let i = 0; i < 3; i++) {
            playerObj.food['/action_types/combat'][i] = { itemHrid: '' };
            playerObj.drinks['/action_types/combat'][i] = { itemHrid: '' };
        }

        // Extract food slots
        const foodSlots = characterObj.actionTypeFoodSlotsMap?.['/action_types/combat'];
        if (Array.isArray(foodSlots)) {
            foodSlots.forEach((item, i) => {
                if (i < 3 && item?.itemHrid) {
                    playerObj.food['/action_types/combat'][i] = { itemHrid: item.itemHrid };
                }
            });
        }

        // Extract drink slots
        const drinkSlots = characterObj.actionTypeDrinkSlotsMap?.['/action_types/combat'];
        if (Array.isArray(drinkSlots)) {
            drinkSlots.forEach((item, i) => {
                if (i < 3 && item?.itemHrid) {
                    playerObj.drinks['/action_types/combat'][i] = { itemHrid: item.itemHrid };
                }
            });
        }

        // Initialize abilities (5 slots)
        for (let i = 0; i < 5; i++) {
            playerObj.abilities[i] = { abilityHrid: '', level: 1 };
        }

        // Extract equipped abilities
        let normalAbilityIndex = 1;
        const equippedAbilities = characterObj.combatUnit?.combatAbilities || [];
        for (const ability of equippedAbilities) {
            if (!ability || !ability.abilityHrid) continue;

            // Check if special ability
            const isSpecial = clientObj?.abilityDetailMap?.[ability.abilityHrid]?.isSpecialAbility || false;

            if (isSpecial) {
                // Special ability goes in slot 0
                playerObj.abilities[0] = {
                    abilityHrid: ability.abilityHrid,
                    level: ability.level || 1,
                };
            } else if (normalAbilityIndex < 5) {
                // Normal abilities go in slots 1-4
                playerObj.abilities[normalAbilityIndex++] = {
                    abilityHrid: ability.abilityHrid,
                    level: ability.level || 1,
                };
            }
        }

        // Extract trigger maps
        playerObj.triggerMap = {
            ...(characterObj.abilityCombatTriggersMap || {}),
            ...(characterObj.consumableCombatTriggersMap || {}),
        };

        // Extract house room levels
        for (const house of Object.values(characterObj.characterHouseRoomMap || {})) {
            playerObj.houseRooms[house.houseRoomHrid] = house.level;
        }

        // Extract completed achievements
        playerObj.achievements = {};
        if (characterObj.characterAchievements) {
            for (const achievement of characterObj.characterAchievements) {
                if (achievement.achievementHrid && achievement.isCompleted) {
                    playerObj.achievements[achievement.achievementHrid] = true;
                }
            }
        }

        return playerObj;
    }

    /**
     * Construct party member data from profile share
     * @param {Object} profile - Profile data from profile_shared message
     * @param {Object} clientObj - Client data (optional)
     * @param {Object} battleObj - Battle data (optional, for consumables)
     * @returns {Object} Player export object
     */
    function constructPartyPlayer(profile, clientObj, battleObj) {
        const playerObj = {
            player: {
                attackLevel: 1,
                magicLevel: 1,
                meleeLevel: 1,
                rangedLevel: 1,
                defenseLevel: 1,
                staminaLevel: 1,
                intelligenceLevel: 1,
                equipment: [],
            },
            food: { '/action_types/combat': [] },
            drinks: { '/action_types/combat': [] },
            abilities: [],
            triggerMap: {},
            houseRooms: {},
        };

        // Extract skill levels from profile
        for (const skill of profile.profile?.characterSkills || []) {
            const skillName = skill.skillHrid?.split('/').pop();
            if (skillName && playerObj.player[skillName + 'Level'] !== undefined) {
                playerObj.player[skillName + 'Level'] = skill.level || 1;
            }
        }

        // Extract equipment from profile
        if (profile.profile?.wearableItemMap) {
            for (const key in profile.profile.wearableItemMap) {
                const item = profile.profile.wearableItemMap[key];
                playerObj.player.equipment.push({
                    itemLocationHrid: item.itemLocationHrid,
                    itemHrid: item.itemHrid,
                    enhancementLevel: item.enhancementLevel || 0,
                });
            }
        }

        // Initialize food and drink slots
        for (let i = 0; i < 3; i++) {
            playerObj.food['/action_types/combat'][i] = { itemHrid: '' };
            playerObj.drinks['/action_types/combat'][i] = { itemHrid: '' };
        }

        // Get consumables from battle data if available
        let battlePlayer = null;
        if (battleObj?.players) {
            battlePlayer = battleObj.players.find((p) => p.character?.id === profile.characterID);
        }

        if (battlePlayer?.combatConsumables) {
            let foodIndex = 0;
            let drinkIndex = 0;

            // Intelligently separate food and drinks
            battlePlayer.combatConsumables.forEach((consumable) => {
                const itemHrid = consumable.itemHrid;

                // Check if it's a drink
                const isDrink =
                    itemHrid.includes('/drinks/') ||
                    itemHrid.includes('coffee') ||
                    clientObj?.itemDetailMap?.[itemHrid]?.type === 'drink';

                if (isDrink && drinkIndex < 3) {
                    playerObj.drinks['/action_types/combat'][drinkIndex++] = { itemHrid: itemHrid };
                } else if (!isDrink && foodIndex < 3) {
                    playerObj.food['/action_types/combat'][foodIndex++] = { itemHrid: itemHrid };
                }
            });
        }

        // Initialize abilities (5 slots)
        for (let i = 0; i < 5; i++) {
            playerObj.abilities[i] = { abilityHrid: '', level: 1 };
        }

        // Extract equipped abilities from profile
        let normalAbilityIndex = 1;
        const equippedAbilities = profile.profile?.equippedAbilities || [];
        for (const ability of equippedAbilities) {
            if (!ability || !ability.abilityHrid) continue;

            // Check if special ability
            const isSpecial = clientObj?.abilityDetailMap?.[ability.abilityHrid]?.isSpecialAbility || false;

            if (isSpecial) {
                // Special ability goes in slot 0
                playerObj.abilities[0] = {
                    abilityHrid: ability.abilityHrid,
                    level: ability.level || 1,
                };
            } else if (normalAbilityIndex < 5) {
                // Normal abilities go in slots 1-4
                playerObj.abilities[normalAbilityIndex++] = {
                    abilityHrid: ability.abilityHrid,
                    level: ability.level || 1,
                };
            }
        }

        // Extract trigger maps (prefer battle data, fallback to profile)
        playerObj.triggerMap = {
            ...(battlePlayer?.abilityCombatTriggersMap || profile.profile?.abilityCombatTriggersMap || {}),
            ...(battlePlayer?.consumableCombatTriggersMap || profile.profile?.consumableCombatTriggersMap || {}),
        };

        // Extract house room levels from profile
        if (profile.profile?.characterHouseRoomMap) {
            for (const house of Object.values(profile.profile.characterHouseRoomMap)) {
                playerObj.houseRooms[house.houseRoomHrid] = house.level;
            }
        }

        // Extract completed achievements from profile
        playerObj.achievements = {};
        if (profile.profile?.characterAchievements) {
            for (const achievement of profile.profile.characterAchievements) {
                if (achievement.achievementHrid && achievement.isCompleted) {
                    playerObj.achievements[achievement.achievementHrid] = true;
                }
            }
        }

        return playerObj;
    }

    /**
     * Construct full export object (solo or party)
     * @param {string|null} externalProfileId - Optional profile ID (for viewing other players' profiles)
     * @param {boolean} singlePlayerFormat - If true, returns player object instead of multi-player format
     * @returns {Object} Export object with player data, IDs, positions, and zone info
     */
    async function constructExportObject(externalProfileId = null, singlePlayerFormat = false) {
        const characterObj = await getCharacterData$1();
        if (!characterObj) {
            return null;
        }

        const clientObj = await getClientData();
        const battleObj = await getBattleData();
        const profileList = await getProfileList();

        // Blank player template (as string, like MCS)
        const BLANK =
            '{"player":{"attackLevel":1,"magicLevel":1,"meleeLevel":1,"rangedLevel":1,"defenseLevel":1,"staminaLevel":1,"intelligenceLevel":1,"equipment":[]},"food":{"/action_types/combat":[{"itemHrid":""},{"itemHrid":""},{"itemHrid":""}]},"drinks":{"/action_types/combat":[{"itemHrid":""},{"itemHrid":""},{"itemHrid":""}]},"abilities":[{"abilityHrid":"","level":1},{"abilityHrid":"","level":1},{"abilityHrid":"","level":1},{"abilityHrid":"","level":1},{"abilityHrid":"","level":1}],"triggerMap":{},"zone":"/actions/combat/fly","simulationTime":"100","houseRooms":{"/house_rooms/dairy_barn":0,"/house_rooms/garden":0,"/house_rooms/log_shed":0,"/house_rooms/forge":0,"/house_rooms/workshop":0,"/house_rooms/sewing_parlor":0,"/house_rooms/kitchen":0,"/house_rooms/brewery":0,"/house_rooms/laboratory":0,"/house_rooms/observatory":0,"/house_rooms/dining_room":0,"/house_rooms/library":0,"/house_rooms/dojo":0,"/house_rooms/gym":0,"/house_rooms/armory":0,"/house_rooms/archery_range":0,"/house_rooms/mystical_study":0},"achievements":{}}';

        // Check if exporting another player's profile
        if (externalProfileId && externalProfileId !== characterObj.character.id) {
            // Try to find profile in GM storage first, then fall back to memory cache
            let profile = profileList.find((p) => p.characterID === externalProfileId);

            // If not found in GM storage, check memory cache (works on Steam)
            const cachedProfile = getCurrentProfile();
            if (!profile && cachedProfile && cachedProfile.characterID === externalProfileId) {
                profile = cachedProfile;
            }

            if (!profile) {
                console.error('[Combat Sim Export] Profile not found for:', externalProfileId);
                return null; // Profile not in cache
            }

            // Construct the player object
            const playerObj = constructPartyPlayer(profile, clientObj, battleObj);

            // If single-player format requested, return player object directly
            if (singlePlayerFormat) {
                // Add name field and remove zone/simulationTime for single-player format
                playerObj.name = profile.characterName;
                delete playerObj.zone;
                delete playerObj.simulationTime;

                return {
                    exportObj: playerObj,
                    playerIDs: [profile.characterName, 'Player 2', 'Player 3', 'Player 4', 'Player 5'],
                    importedPlayerPositions: [true, false, false, false, false],
                    zone: '/actions/combat/fly',
                    isZoneDungeon: false,
                    difficultyTier: 0,
                    isParty: false,
                };
            }

            // Multi-player format (for auto-import storage)
            const exportObj = {};
            exportObj[1] = JSON.stringify(playerObj);

            // Fill other slots with blanks
            for (let i = 2; i <= 5; i++) {
                exportObj[i] = BLANK;
            }

            return {
                exportObj,
                playerIDs: [profile.characterName, 'Player 2', 'Player 3', 'Player 4', 'Player 5'],
                importedPlayerPositions: [true, false, false, false, false],
                zone: '/actions/combat/fly',
                isZoneDungeon: false,
                difficultyTier: 0,
                isParty: false,
            };
        }

        // Export YOUR data (solo or party) - existing logic below
        const exportObj = {};
        for (let i = 1; i <= 5; i++) {
            exportObj[i] = BLANK;
        }

        const playerIDs = ['Player 1', 'Player 2', 'Player 3', 'Player 4', 'Player 5'];
        const importedPlayerPositions = [false, false, false, false, false];
        let zone = '/actions/combat/fly';
        let isZoneDungeon = false;
        let difficultyTier = 0;
        let isParty = false;
        let yourSlotIndex = 1; // Track which slot contains YOUR data (for party mode)

        // Check if in party
        const hasParty = characterObj.partyInfo?.partySlotMap;

        if (!hasParty) {
            exportObj[1] = JSON.stringify(constructSelfPlayer(characterObj, clientObj));
            playerIDs[0] = characterObj.character?.name || 'Player 1';
            importedPlayerPositions[0] = true;

            // Get current combat zone and tier
            for (const action of characterObj.characterActions || []) {
                if (action && action.actionHrid.includes('/actions/combat/')) {
                    zone = action.actionHrid;
                    difficultyTier = action.difficultyTier || 0;
                    isZoneDungeon = clientObj?.actionDetailMap?.[action.actionHrid]?.combatZoneInfo?.isDungeon || false;
                    break;
                }
            }
        } else {
            isParty = true;

            let slotIndex = 1;
            for (const member of Object.values(characterObj.partyInfo.partySlotMap)) {
                if (member.characterID) {
                    if (member.characterID === characterObj.character.id) {
                        // This is you
                        yourSlotIndex = slotIndex; // Remember your slot
                        exportObj[slotIndex] = JSON.stringify(constructSelfPlayer(characterObj, clientObj));
                        playerIDs[slotIndex - 1] = characterObj.character.name;
                        importedPlayerPositions[slotIndex - 1] = true;
                    } else {
                        // Party member - try to get from profile list
                        const profile = profileList.find((p) => p.characterID === member.characterID);
                        if (profile) {
                            exportObj[slotIndex] = JSON.stringify(constructPartyPlayer(profile, clientObj, battleObj));
                            playerIDs[slotIndex - 1] = profile.characterName;
                            importedPlayerPositions[slotIndex - 1] = true;
                        } else {
                            console.warn(
                                '[Combat Sim Export] No profile found for party member',
                                member.characterID,
                                '- profiles have:',
                                profileList.map((p) => p.characterID)
                            );
                            playerIDs[slotIndex - 1] = 'Open profile in game';
                        }
                    }
                    slotIndex++;
                }
            }

            // Get party zone and tier
            zone = characterObj.partyInfo?.party?.actionHrid || '/actions/combat/fly';
            difficultyTier = characterObj.partyInfo?.party?.difficultyTier || 0;
            isZoneDungeon = clientObj?.actionDetailMap?.[zone]?.combatZoneInfo?.isDungeon || false;
        }

        // If single-player format requested, return just the player object
        if (singlePlayerFormat && exportObj[1]) {
            // In party mode, export YOUR data (not necessarily slot 1)
            const slotToExport = isParty ? yourSlotIndex : 1;

            // Parse the player JSON string back to an object
            const playerObj = JSON.parse(exportObj[slotToExport]);

            // Add name field and remove zone/simulationTime for single-player format
            playerObj.name = playerIDs[slotToExport - 1];
            delete playerObj.zone;
            delete playerObj.simulationTime;

            return {
                exportObj: playerObj, // Single player object instead of multi-player format
                playerIDs,
                importedPlayerPositions,
                zone,
                isZoneDungeon,
                difficultyTier,
                isParty: false, // Single player export is never party format
            };
        }

        return {
            exportObj,
            playerIDs,
            importedPlayerPositions,
            zone,
            isZoneDungeon,
            difficultyTier,
            isParty,
        };
    }

    /**
     * Combat Simulator Integration Module
     * Injects import button on Shykai Combat Simulator page
     *
     * Automatically fills character/party data from game into simulator
     */


    /**
     * Check if running on Steam client (no extension manager)
     * @returns {boolean} True if on Steam client
     */
    function isSteamClient() {
        return typeof GM === 'undefined' && typeof GM_setValue === 'undefined';
    }

    const timerRegistry = createTimerRegistry();
    const IMPORT_CONTAINER_ID = 'toolasha-import-container';

    /**
     * Initialize combat sim integration (runs on sim page only)
     */
    function initialize$1() {
        // Don't inject import button on Steam client (no cross-domain storage)
        if (isSteamClient()) {
            return;
        }

        disable();

        // Wait for simulator UI to load
        waitForSimulatorUI();
    }

    /**
     * Disable combat sim integration and cleanup injected UI
     */
    function disable() {
        timerRegistry.clearAll();

        const container = document.getElementById(IMPORT_CONTAINER_ID);
        if (container) {
            container.remove();
        }
    }

    /**
     * Wait for simulator's import/export button to appear
     */
    function waitForSimulatorUI() {
        const checkInterval = setInterval(() => {
            const exportButton = document.querySelector('button#buttonImportExport');
            if (exportButton) {
                clearInterval(checkInterval);
                injectImportButton(exportButton);
            }
        }, 200);

        timerRegistry.registerInterval(checkInterval);

        // Stop checking after 10 seconds
        const stopTimeout = setTimeout(() => clearInterval(checkInterval), 10000);
        timerRegistry.registerTimeout(stopTimeout);
    }

    /**
     * Inject "Import from Toolasha" button
     * @param {Element} exportButton - Reference element to insert after
     */
    function injectImportButton(exportButton) {
        // Check if button already exists
        if (document.getElementById('toolasha-import-button')) {
            return;
        }

        // Create container div
        const container = document.createElement('div');
        container.id = IMPORT_CONTAINER_ID;
        container.style.marginTop = '10px';

        // Create import button
        const button = document.createElement('button');
        button.id = 'toolasha-import-button';
        // Include hidden text for JIGS compatibility (JIGS searches for "Import solo/group")
        button.innerHTML = 'Import from Toolasha<span style="display:none;">Import solo/group</span>';
        button.style.backgroundColor = config$1.COLOR_ACCENT;
        button.style.color = 'white';
        button.style.padding = '10px 20px';
        button.style.border = 'none';
        button.style.borderRadius = '4px';
        button.style.cursor = 'pointer';
        button.style.fontWeight = 'bold';
        button.style.width = '100%';

        // Add hover effect
        button.addEventListener('mouseenter', () => {
            button.style.opacity = '0.8';
        });
        button.addEventListener('mouseleave', () => {
            button.style.opacity = '1';
        });

        // Add click handler
        button.addEventListener('click', () => {
            importDataToSimulator(button);
        });

        container.appendChild(button);

        // Insert after export button's parent container
        exportButton.parentElement.parentElement.insertAdjacentElement('afterend', container);
    }

    /**
     * Import character/party data into simulator
     * @param {Element} button - Button element to update status
     */
    async function importDataToSimulator(button) {
        try {
            // Get export data from storage
            const exportData = await constructExportObject();

            if (!exportData) {
                button.textContent = 'Error: No character data';
                button.style.backgroundColor = '#dc3545'; // Red
                const resetTimeout = setTimeout(() => {
                    button.innerHTML = 'Import from Toolasha<span style="display:none;">Import solo/group</span>';
                    button.style.backgroundColor = config$1.COLOR_ACCENT;
                }, 3000);
                timerRegistry.registerTimeout(resetTimeout);
                console.error('[Toolasha Combat Sim] No export data available');
                alert(
                    'No character data found. Please:\n1. Refresh the game page\n2. Wait for it to fully load\n3. Try again'
                );
                return;
            }

            const { exportObj, playerIDs, importedPlayerPositions, zone, isZoneDungeon, difficultyTier, _isParty } =
                exportData;

            // Step 1: Switch to Group Combat tab
            const groupTab = document.querySelector('a#group-combat-tab');
            if (groupTab) {
                groupTab.click();
            } else {
                console.warn('[Toolasha Combat Sim] Group combat tab not found');
            }

            // Small delay to let tab switch complete
            const importTimeout = setTimeout(() => {
                // Step 2: Fill import field with JSON data
                const importInput = document.querySelector('input#inputSetGroupCombatAll');
                if (importInput) {
                    // exportObj already has JSON strings for each slot, just stringify once
                    setReactInputValue(importInput, JSON.stringify(exportObj), { focus: false });
                } else {
                    console.error('[Toolasha Combat Sim] Import input field not found');
                }

                // Step 3: Click import button
                const importButton = document.querySelector('button#buttonImportSet');
                if (importButton) {
                    importButton.click();
                } else {
                    console.error('[Toolasha Combat Sim] Import button not found');
                }

                // Step 4: Set player names in tabs
                for (let i = 0; i < 5; i++) {
                    const tab = document.querySelector(`a#player${i + 1}-tab`);
                    if (tab) {
                        tab.textContent = playerIDs[i];
                    }
                }

                // Step 5: Select zone or dungeon
                if (zone) {
                    selectZone(zone, isZoneDungeon);
                }

                // Step 5.5: Set difficulty tier
                const difficultyTimeout = setTimeout(() => {
                    // Try both input and select elements
                    const difficultyElement =
                        document.querySelector('input#inputDifficulty') ||
                        document.querySelector('select#inputDifficulty') ||
                        document.querySelector('[id*="ifficulty"]');

                    if (difficultyElement) {
                        const tierValue = 'T' + difficultyTier;

                        // Handle select dropdown (set by value)
                        if (difficultyElement.tagName === 'SELECT') {
                            // Try to find option by value or text
                            for (let i = 0; i < difficultyElement.options.length; i++) {
                                const option = difficultyElement.options[i];
                                if (
                                    option.value === tierValue ||
                                    option.value === String(difficultyTier) ||
                                    option.text === tierValue ||
                                    option.text.includes('T' + difficultyTier)
                                ) {
                                    difficultyElement.selectedIndex = i;
                                    break;
                                }
                            }
                        } else {
                            // Handle text input
                            difficultyElement.value = tierValue;
                        }

                        difficultyElement.dispatchEvent(new Event('change'));
                        difficultyElement.dispatchEvent(new Event('input'));
                    } else {
                        console.warn('[Toolasha Combat Sim] Difficulty element not found');
                    }
                }, 250); // Increased delay to ensure zone loads first
                timerRegistry.registerTimeout(difficultyTimeout);

                // Step 6: Enable/disable player checkboxes
                for (let i = 0; i < 5; i++) {
                    const checkbox = document.querySelector(`input#player${i + 1}.form-check-input.player-checkbox`);
                    if (checkbox) {
                        checkbox.checked = importedPlayerPositions[i];
                        checkbox.dispatchEvent(new Event('change'));
                    }
                }

                // Step 7: Set simulation time to 24 hours (standard)
                const simTimeInput = document.querySelector('input#inputSimulationTime');
                if (simTimeInput) {
                    setReactInputValue(simTimeInput, '24', { focus: false });
                }

                // Step 8: Get prices (refresh market data)
                const getPriceButton = document.querySelector('button#buttonGetPrices');
                if (getPriceButton) {
                    getPriceButton.click();
                }

                // Update button status
                button.textContent = '✓ Imported';
                button.style.backgroundColor = '#28a745'; // Green
                const successResetTimeout = setTimeout(() => {
                    button.innerHTML = 'Import from Toolasha<span style="display:none;">Import solo/group</span>';
                    button.style.backgroundColor = config$1.COLOR_ACCENT;
                }, 3000);
                timerRegistry.registerTimeout(successResetTimeout);
            }, 100);
            timerRegistry.registerTimeout(importTimeout);
        } catch (error) {
            console.error('[Toolasha Combat Sim] Import failed:', error);
            button.textContent = 'Import Failed';
            button.style.backgroundColor = '#dc3545'; // Red
            const failResetTimeout = setTimeout(() => {
                button.innerHTML = 'Import from Toolasha<span style="display:none;">Import solo/group</span>';
                button.style.backgroundColor = config$1.COLOR_ACCENT;
            }, 3000);
            timerRegistry.registerTimeout(failResetTimeout);
        }
    }

    /**
     * Select zone or dungeon in simulator
     * @param {string} zoneHrid - Zone action HRID
     * @param {boolean} isDungeon - Whether it's a dungeon
     */
    function selectZone(zoneHrid, isDungeon) {
        const dungeonToggle = document.querySelector('input#simDungeonToggle');

        if (isDungeon) {
            // Dungeon mode
            if (dungeonToggle) {
                dungeonToggle.checked = true;
                dungeonToggle.dispatchEvent(new Event('change'));
            }

            const dungeonTimeout = setTimeout(() => {
                const selectDungeon = document.querySelector('select#selectDungeon');
                if (selectDungeon) {
                    for (let i = 0; i < selectDungeon.options.length; i++) {
                        if (selectDungeon.options[i].value === zoneHrid) {
                            selectDungeon.options[i].selected = true;
                            selectDungeon.dispatchEvent(new Event('change'));
                            break;
                        }
                    }
                }
            }, 100);
            timerRegistry.registerTimeout(dungeonTimeout);
        } else {
            // Zone mode
            if (dungeonToggle) {
                dungeonToggle.checked = false;
                dungeonToggle.dispatchEvent(new Event('change'));
            }

            const zoneTimeout = setTimeout(() => {
                const selectZone = document.querySelector('select#selectZone');
                if (selectZone) {
                    for (let i = 0; i < selectZone.options.length; i++) {
                        if (selectZone.options[i].value === zoneHrid) {
                            selectZone.options[i].selected = true;
                            selectZone.dispatchEvent(new Event('change'));
                            break;
                        }
                    }
                }
            }, 100);
            timerRegistry.registerTimeout(zoneTimeout);
        }
    }

    var combatSimIntegration = /*#__PURE__*/Object.freeze({
        __proto__: null,
        disable: disable,
        initialize: initialize$1
    });

    /**
     * Milkonomy Export Module
     * Constructs player data in Milkonomy format for external tools
     */


    // Detect if we're running on Tampermonkey or Steam
    const hasScriptManager = typeof GM_info !== 'undefined';

    /**
     * Get character data from storage
     * @returns {Promise<Object|null>} Character data or null
     */
    async function getCharacterData() {
        try {
            // Tampermonkey: Use GM storage (cross-domain, persisted)
            if (hasScriptManager) {
                const data = await webSocketHook$1.loadFromStorage('toolasha_init_character_data', null);
                if (!data) {
                    console.error('[Milkonomy Export] No character data found');
                    return null;
                }
                return JSON.parse(data);
            }

            // Steam: Use dataManager (RAM only, no GM storage available)
            const characterData = dataManager$1.characterData;
            if (!characterData) {
                console.error('[Milkonomy Export] No character data found');
                return null;
            }
            return characterData;
        } catch (error) {
            console.error('[Milkonomy Export] Failed to get character data:', error);
            return null;
        }
    }

    /**
     * Map equipment slot types to Milkonomy format
     * @param {string} slotType - Game slot type
     * @returns {string} Milkonomy slot name
     */
    function mapSlotType(slotType) {
        const mapping = {
            '/equipment_types/milking_tool': 'milking_tool',
            '/equipment_types/foraging_tool': 'foraging_tool',
            '/equipment_types/woodcutting_tool': 'woodcutting_tool',
            '/equipment_types/cheesesmithing_tool': 'cheesesmithing_tool',
            '/equipment_types/crafting_tool': 'crafting_tool',
            '/equipment_types/tailoring_tool': 'tailoring_tool',
            '/equipment_types/cooking_tool': 'cooking_tool',
            '/equipment_types/brewing_tool': 'brewing_tool',
            '/equipment_types/alchemy_tool': 'alchemy_tool',
            '/equipment_types/enhancing_tool': 'enhancing_tool',
            '/equipment_types/legs': 'legs',
            '/equipment_types/body': 'body',
            '/equipment_types/charm': 'charm',
            '/equipment_types/off_hand': 'off_hand',
            '/equipment_types/head': 'head',
            '/equipment_types/hands': 'hands',
            '/equipment_types/feet': 'feet',
            '/equipment_types/neck': 'neck',
            '/equipment_types/earrings': 'earrings',
            '/equipment_types/ring': 'ring',
            '/equipment_types/pouch': 'pouch',
        };
        return mapping[slotType] || slotType;
    }

    /**
     * Get skill level by action type
     * @param {Array} skills - Character skills array
     * @param {string} actionType - Action type HRID (e.g., '/action_types/milking')
     * @returns {number} Skill level
     */
    function getSkillLevel(skills, actionType) {
        const skillHrid = actionType.replace('/action_types/', '/skills/');
        const skill = skills.find((s) => s.skillHrid === skillHrid);
        return skill?.level || 1;
    }

    /**
     * Map item location HRID to equipment slot type HRID
     * @param {string} locationHrid - Item location HRID (e.g., '/item_locations/brewing_tool')
     * @returns {string|null} Equipment slot type HRID or null
     */
    function locationToSlotType(locationHrid) {
        // Map item locations to equipment slot types
        // Location format: /item_locations/X
        // Slot type format: /equipment_types/X
        if (!locationHrid || !locationHrid.startsWith('/item_locations/')) {
            return null;
        }

        const slotName = locationHrid.replace('/item_locations/', '');
        return `/equipment_types/${slotName}`;
    }

    /**
     * Check if an item has stats for a specific skill
     * @param {Object} itemDetail - Item detail from game data
     * @param {string} skillName - Skill name (e.g., 'brewing', 'enhancing')
     * @returns {boolean} True if item has stats for this skill
     */
    function itemHasSkillStats(itemDetail, skillName) {
        if (!itemDetail || !itemDetail.equipmentDetail || !itemDetail.equipmentDetail.noncombatStats) {
            return false;
        }

        const stats = itemDetail.equipmentDetail.noncombatStats;

        // Check if any stat key contains the skill name (e.g., brewingSpeed, brewingEfficiency, brewingRareFind)
        for (const statKey of Object.keys(stats)) {
            if (statKey.toLowerCase().startsWith(skillName.toLowerCase())) {
                return true;
            }
        }

        return false;
    }

    /**
     * Get best equipment for a specific skill and slot from entire inventory
     * @param {Array} inventory - Full inventory array from dataManager
     * @param {Object} gameData - Game data (initClientData)
     * @param {string} skillName - Skill name (e.g., 'brewing', 'enhancing')
     * @param {string} slotType - Equipment slot type (e.g., '/equipment_types/brewing_tool')
     * @returns {Object} Equipment object or empty object with just type
     */
    function getBestEquipmentForSkill(inventory, gameData, skillName, slotType) {
        if (!inventory || !gameData || !gameData.itemDetailMap) {
            return { type: mapSlotType(slotType) };
        }

        // Filter inventory for matching items
        const matchingItems = [];

        for (const invItem of inventory) {
            // Skip items without HRID
            if (!invItem.itemHrid) {
                continue;
            }

            const itemDetail = gameData.itemDetailMap[invItem.itemHrid];

            // Skip non-equipment items (resources, consumables, etc.)
            if (!itemDetail || !itemDetail.equipmentDetail) {
                continue;
            }

            // Check if item matches the slot type
            const itemSlotType = itemDetail.equipmentDetail.type;
            if (itemSlotType !== slotType) {
                continue;
            }

            // Check if item has stats for this skill
            if (!itemHasSkillStats(itemDetail, skillName)) {
                continue;
            }

            // Item matches! Add to candidates
            matchingItems.push({
                hrid: invItem.itemHrid,
                enhancementLevel: invItem.enhancementLevel || 0,
                name: itemDetail.name,
            });
        }

        // Sort by enhancement level (descending) and pick the best
        if (matchingItems.length > 0) {
            matchingItems.sort((a, b) => b.enhancementLevel - a.enhancementLevel);
            const best = matchingItems[0];

            const equipment = {
                type: mapSlotType(slotType),
                hrid: best.hrid,
            };

            // Only include enhanceLevel if the item can be enhanced (has the field)
            if (typeof best.enhancementLevel === 'number') {
                equipment.enhanceLevel = best.enhancementLevel > 0 ? best.enhancementLevel : null;
            }

            return equipment;
        }

        // No matching equipment found
        return { type: mapSlotType(slotType) };
    }

    /**
     * Get house room level for action type
     * @param {string} actionType - Action type HRID
     * @returns {number} House room level
     */
    function getHouseLevel(actionType) {
        const roomMapping = {
            '/action_types/milking': '/house_rooms/dairy_barn',
            '/action_types/foraging': '/house_rooms/garden',
            '/action_types/woodcutting': '/house_rooms/log_shed',
            '/action_types/cheesesmithing': '/house_rooms/forge',
            '/action_types/crafting': '/house_rooms/workshop',
            '/action_types/tailoring': '/house_rooms/sewing_parlor',
            '/action_types/cooking': '/house_rooms/kitchen',
            '/action_types/brewing': '/house_rooms/brewery',
            '/action_types/alchemy': '/house_rooms/laboratory',
            '/action_types/enhancing': '/house_rooms/observatory',
        };

        const roomHrid = roomMapping[actionType];
        if (!roomHrid) return 0;

        return dataManager$1.getHouseRoomLevel(roomHrid) || 0;
    }

    /**
     * Get active teas for action type
     * @param {string} actionType - Action type HRID
     * @returns {Array} Array of tea item HRIDs
     */
    function getActiveTeas(actionType) {
        const drinkSlots = dataManager$1.getActionDrinkSlots(actionType);
        if (!drinkSlots || drinkSlots.length === 0) return [];

        return drinkSlots.filter((slot) => slot && slot.itemHrid).map((slot) => slot.itemHrid);
    }

    /**
     * Construct action config for a skill
     * @param {string} skillName - Skill name (e.g., 'milking')
     * @param {Object} skills - Character skills array
     * @param {Array} inventory - Full inventory array
     * @param {Object} gameData - Game data (initClientData)
     * @returns {Object} Action config object
     */
    function constructActionConfig(skillName, skills, inventory, gameData) {
        const actionType = `/action_types/${skillName}`;
        const toolType = `/equipment_types/${skillName}_tool`;
        const legsType = '/equipment_types/legs';
        const bodyType = '/equipment_types/body';
        const charmType = '/equipment_types/charm';

        return {
            action: skillName,
            playerLevel: getSkillLevel(skills, actionType),
            tool: getBestEquipmentForSkill(inventory, gameData, skillName, toolType),
            legs: getBestEquipmentForSkill(inventory, gameData, skillName, legsType),
            body: getBestEquipmentForSkill(inventory, gameData, skillName, bodyType),
            charm: getBestEquipmentForSkill(inventory, gameData, skillName, charmType),
            houseLevel: getHouseLevel(actionType),
            tea: getActiveTeas(actionType),
        };
    }

    /**
     * Get equipment from currently equipped items (for special slots)
     * Only includes items that have noncombat (skilling) stats
     * @param {Map} equipmentMap - Currently equipped items map
     * @param {Object} gameData - Game data (initClientData)
     * @param {string} slotType - Equipment slot type (e.g., '/equipment_types/off_hand')
     * @returns {Object} Equipment object or empty object with just type
     */
    function getEquippedItem(equipmentMap, gameData, slotType) {
        for (const [locationHrid, item] of equipmentMap) {
            // Derive the slot type from the location HRID
            const itemSlotType = locationToSlotType(locationHrid);

            if (itemSlotType === slotType) {
                // Check if item has any noncombat (skilling) stats
                const itemDetail = gameData.itemDetailMap[item.itemHrid];
                if (!itemDetail || !itemDetail.equipmentDetail) {
                    // Skip items we can't look up
                    continue;
                }

                const noncombatStats = itemDetail.equipmentDetail.noncombatStats;
                if (!noncombatStats || Object.keys(noncombatStats).length === 0) {
                    // Item has no skilling stats (combat-only like Cheese Buckler) - skip it
                    continue;
                }

                // Item has skilling stats - include it
                const equipment = {
                    type: mapSlotType(slotType),
                    hrid: item.itemHrid,
                };

                // Only include enhanceLevel if the item has an enhancement level field
                if (typeof item.enhancementLevel === 'number') {
                    equipment.enhanceLevel = item.enhancementLevel > 0 ? item.enhancementLevel : null;
                }

                return equipment;
            }
        }

        // No equipment in this slot (or only combat-only items)
        return { type: mapSlotType(slotType) };
    }

    /**
     * Construct Milkonomy export object
     * @param {string|null} externalProfileId - Optional profile ID (for viewing other players' profiles)
     * @returns {Object|null} Milkonomy export data or null
     */
    async function constructMilkonomyExport(externalProfileId = null) {
        try {
            const characterData = await getCharacterData();
            if (!characterData) {
                console.error('[Milkonomy Export] No character data available');
                return null;
            }

            // Milkonomy export is only for your own character (no external profiles)
            if (externalProfileId) {
                console.error('[Milkonomy Export] External profile export not supported');
                alert(
                    'Milkonomy export is only available for your own profile.\n\nTo export another player:\n1. Use Combat Sim Export instead\n2. Or copy their profile link and open it separately'
                );
                return null;
            }

            const skills = characterData.characterSkills || [];
            const inventory = dataManager$1.getInventory();
            const equipmentMap = dataManager$1.getEquipment();
            const gameData = dataManager$1.getInitClientData();

            if (!inventory) {
                console.error('[Milkonomy Export] No inventory data available');
                return null;
            }

            if (!gameData) {
                console.error('[Milkonomy Export] No game data available');
                return null;
            }

            // Character name and color
            const name = characterData.name || 'Player';
            const color = '#90ee90'; // Default color (light green)

            // Build action config map for all 10 skills
            const skillNames = [
                'milking',
                'foraging',
                'woodcutting',
                'cheesesmithing',
                'crafting',
                'tailoring',
                'cooking',
                'brewing',
                'alchemy',
                'enhancing',
            ];

            const actionConfigMap = {};
            for (const skillName of skillNames) {
                actionConfigMap[skillName] = constructActionConfig(skillName, skills, inventory, gameData);
            }

            // Build special equipment map (non-skill-specific equipment)
            // Use currently equipped items for these slots
            const specialEquipmentMap = {};
            const specialSlots = [
                '/equipment_types/off_hand',
                '/equipment_types/head',
                '/equipment_types/hands',
                '/equipment_types/feet',
                '/equipment_types/neck',
                '/equipment_types/earrings',
                '/equipment_types/ring',
                '/equipment_types/pouch',
            ];

            for (const slotType of specialSlots) {
                const slotName = mapSlotType(slotType);
                const equipment = getEquippedItem(equipmentMap, gameData, slotType);
                if (equipment.hrid) {
                    specialEquipmentMap[slotName] = equipment;
                } else {
                    specialEquipmentMap[slotName] = { type: slotName };
                }
            }

            // Build community buff map
            const communityBuffMap = {};
            const buffTypes = ['experience', 'gathering_quantity', 'production_efficiency', 'enhancing_speed'];

            for (const buffType of buffTypes) {
                const buffHrid = `/community_buff_types/${buffType}`;
                const level = dataManager$1.getCommunityBuffLevel(buffHrid) || 0;
                communityBuffMap[buffType] = {
                    type: buffType,
                    hrid: buffHrid,
                    level: level,
                };
            }

            // Construct final export object
            return {
                name,
                color,
                actionConfigMap,
                specialEquimentMap: specialEquipmentMap,
                communityBuffMap,
            };
        } catch (error) {
            console.error('[Milkonomy Export] Export construction failed:', error);
            return null;
        }
    }

    /**
     * Combat Statistics Data Collector
     * Listens for new_battle WebSocket messages and stores combat data
     */


    class CombatStatsDataCollector {
        constructor() {
            this.isInitialized = false;
            this.newBattleHandler = null;
            this.consumableEventHandler = null; // NEW: for battle_consumable_ability_updated
            this.latestCombatData = null;
            this.currentBattleId = null;
            this.consumableActualConsumed = {}; // { characterId: { itemHrid: count } } - from consumption events
            this.trackingStartTime = {}; // { characterId: timestamp } - when we started tracking
        }

        /**
         * Initialize the data collector
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            this.isInitialized = true;

            // Store handler references for cleanup
            this.newBattleHandler = (data) => this.onNewBattle(data);
            this.consumableEventHandler = (data) => this.onConsumableUsed(data);

            // Listen for new_battle messages (fires during combat, continuously updated)
            webSocketHook$1.on('new_battle', this.newBattleHandler);

            // Listen for battle_consumable_ability_updated (fires on each consumable use)
            webSocketHook$1.on('battle_consumable_ability_updated', this.consumableEventHandler);
        }

        /**
         * Handle battle_consumable_ability_updated event (fires on each consumption)
         * NOTE: This event only fires for the CURRENT PLAYER (solo tracking)
         * @param {Object} data - Consumable update data
         */
        onConsumableUsed(data) {
            try {
                if (!data || !data.consumable || !data.consumable.itemHrid) {
                    return;
                }

                // Use 'current' key for solo player tracking (event only fires for current player)
                const characterId = 'current';

                // Initialize tracking for current player if needed
                if (!this.consumableActualConsumed[characterId]) {
                    this.consumableActualConsumed[characterId] = {};
                    this.trackingStartTime[characterId] = Date.now();
                }

                const itemHrid = data.consumable.itemHrid;

                // Initialize count for this item if first time seen
                if (!this.consumableActualConsumed[characterId][itemHrid]) {
                    this.consumableActualConsumed[characterId][itemHrid] = 0;
                }

                // Increment consumption count (this event fires once per use)
                this.consumableActualConsumed[characterId][itemHrid]++;
            } catch (error) {
                console.error('[Combat Stats] Error processing consumable event:', error);
            }
        }

        /**
         * Handle new_battle message (fires during combat)
         * @param {Object} data - new_battle message data
         */
        async onNewBattle(data) {
            try {
                // Only process if we have players data
                if (!data.players || data.players.length === 0) {
                    return;
                }

                // Detect new combat run (new battleId)
                const battleId = data.battleId || 0;

                // Only reset if we haven't initialized yet (first run after script load)
                // Don't reset on every battleId change since that happens every wave!

                // Calculate duration from combat start time
                const combatStartTime = new Date(data.combatStartTime).getTime() / 1000;
                const currentTime = Date.now() / 1000;
                const durationSeconds = currentTime - combatStartTime;

                // Extract combat data
                const combatData = {
                    timestamp: Date.now(),
                    battleId: battleId,
                    combatStartTime: data.combatStartTime,
                    durationSeconds: durationSeconds,
                    players: data.players.map((player, index) => {
                        const characterId = player.character.id;

                        // For the first player (current player), use event-based consumption tracking
                        // For other players (party members), we'd need snapshot-based tracking (TODO)
                        const trackingKey = index === 0 ? 'current' : characterId;

                        // Initialize tracking for this character if needed
                        if (!this.consumableActualConsumed[trackingKey]) {
                            this.consumableActualConsumed[trackingKey] = {};
                            this.trackingStartTime[trackingKey] = Date.now();
                        }

                        // Calculate time elapsed since we started tracking
                        const trackingStartTime = this.trackingStartTime[trackingKey] || Date.now();
                        const elapsedSeconds = (Date.now() - trackingStartTime) / 1000;

                        // Process consumables using event-based consumption data
                        const consumablesWithConsumed = [];
                        const seenItems = new Set(); // Deduplicate by itemHrid (game allows 1 of each type)

                        if (player.combatConsumables) {
                            for (const consumable of player.combatConsumables) {
                                // Skip duplicate entries (game UI enforces 1 per type, but WS data may have dupes)
                                if (seenItems.has(consumable.itemHrid)) {
                                    continue;
                                }
                                seenItems.add(consumable.itemHrid);

                                // Get actual consumed count from consumption events
                                const totalActualConsumed =
                                    this.consumableActualConsumed[trackingKey]?.[consumable.itemHrid] || 0;

                                // MCS-style baseline: fixed item counts (not rates)
                                // Baseline assumes 2 drinks or 10 foods consumed in DEFAULT_TIME (600s)
                                const itemName = consumable.itemHrid.toLowerCase();
                                const isDrink = itemName.includes('coffee') || itemName.includes('drink');
                                const isFood =
                                    itemName.includes('donut') ||
                                    itemName.includes('cupcake') ||
                                    itemName.includes('cake') ||
                                    itemName.includes('gummy') ||
                                    itemName.includes('yogurt');

                                const defaultConsumed = isDrink ? 2 : isFood ? 10 : 0;

                                // MCS-style weighted average with DEFAULT_TIME constant
                                // Adds 10 minutes (600s) of baseline data to make estimates stable from start
                                const DEFAULT_TIME = 10 * 60; // 600 seconds
                                const baselineRate = defaultConsumed / DEFAULT_TIME;

                                let consumptionRate;
                                if (totalActualConsumed === 0) {
                                    // No consumption detected yet — use pure baseline rate
                                    consumptionRate = baselineRate;
                                } else {
                                    // Blend actual data with baseline for stability
                                    const actualRate = totalActualConsumed / elapsedSeconds;
                                    const combinedTotal = defaultConsumed + totalActualConsumed;
                                    const combinedTime = DEFAULT_TIME + elapsedSeconds;
                                    const combinedRate = combinedTotal / combinedTime;
                                    // 90% actual rate + 10% combined (baseline+actual) rate
                                    consumptionRate = actualRate * 0.9 + combinedRate * 0.1;
                                }

                                // Estimate total consumed for the entire combat duration
                                const estimatedConsumed = consumptionRate * durationSeconds;

                                consumablesWithConsumed.push({
                                    itemHrid: consumable.itemHrid,
                                    currentCount: consumable.count,
                                    actualConsumed: totalActualConsumed,
                                    consumed: estimatedConsumed,
                                    consumptionRate: consumptionRate,
                                    elapsedSeconds: elapsedSeconds,
                                });
                            }
                        }

                        return {
                            name: player.character.name,
                            characterId: characterId,
                            loot: player.totalLootMap || {},
                            experience: player.totalSkillExperienceMap || {},
                            deathCount: player.deathCount || 0,
                            consumables: consumablesWithConsumed,
                            combatStats: {
                                combatDropQuantity: player.combatDetails?.combatStats?.combatDropQuantity || 0,
                                combatDropRate: player.combatDetails?.combatStats?.combatDropRate || 0,
                                combatRareFind: player.combatDetails?.combatStats?.combatRareFind || 0,
                                drinkConcentration: player.combatDetails?.combatStats?.drinkConcentration || 0,
                            },
                        };
                    }),
                };

                // Store in memory
                this.latestCombatData = combatData;

                // Store in IndexedDB (debounced - will update continuously during combat)
                await storage$1.setJSON('latestCombatRun', combatData, 'combatStats');
            } catch (error) {
                console.error('[Combat Stats] Error collecting combat data:', error);
            }
        }

        /**
         * Get the latest combat data
         * @returns {Object|null} Latest combat data
         */
        getLatestData() {
            return this.latestCombatData;
        }

        /**
         * Load latest combat data from storage
         * @returns {Promise<Object|null>} Latest combat data
         */
        async loadLatestData() {
            const data = await storage$1.getJSON('latestCombatRun', 'combatStats', null);
            if (data) {
                this.latestCombatData = data;
            }
            return data;
        }

        /**
         * Cleanup
         */
        cleanup() {
            if (this.newBattleHandler) {
                webSocketHook$1.off('new_battle', this.newBattleHandler);
                this.newBattleHandler = null;
            }

            if (this.consumableEventHandler) {
                webSocketHook$1.off('battle_consumable_ability_updated', this.consumableEventHandler);
                this.consumableEventHandler = null;
            }

            this.isInitialized = false;
            this.latestCombatData = null;
            this.currentBattleId = null;
            this.consumableActualConsumed = {};
            this.trackingStartTime = {};
        }
    }

    const combatStatsDataCollector = new CombatStatsDataCollector();

    /**
     * Combat Statistics Calculator
     * Calculates income, profit, consumable costs, and other statistics
     */


    /**
     * Calculate total income from loot
     * @param {Object} lootMap - totalLootMap from player data
     * @returns {Object} { ask: number, bid: number }
     */
    function calculateIncome(lootMap) {
        let totalAsk = 0;
        let totalBid = 0;

        if (!lootMap) {
            return { ask: 0, bid: 0 };
        }

        for (const loot of Object.values(lootMap)) {
            const itemCount = loot.count;

            // Coins are revenue at face value (1 coin = 1 gold)
            if (loot.itemHrid === '/items/coin') {
                totalAsk += itemCount;
                totalBid += itemCount;
            } else {
                // Other items: get market price
                const prices = marketAPI.getPrice(loot.itemHrid);
                if (prices) {
                    totalAsk += prices.ask * itemCount;
                    totalBid += prices.bid * itemCount;
                }
            }
        }

        return { ask: totalAsk, bid: totalBid };
    }

    /**
     * Calculate consumable costs based on actual consumption with baseline estimates
     * Uses weighted average: 90% actual data + 10% baseline estimate (like MCS)
     * @param {Array} consumables - combatConsumables array from player data (with consumed field)
     * @param {number} durationSeconds - Combat duration in seconds
     * @returns {Object} { total: number, breakdown: Array } Total cost and per-item breakdown
     */
    function calculateConsumableCosts(consumables, durationSeconds) {
        if (!consumables || consumables.length === 0 || !durationSeconds || durationSeconds <= 0) {
            return { total: 0, breakdown: [] };
        }

        let totalCost = 0;
        const breakdown = [];

        for (const consumable of consumables) {
            const consumed = consumable.consumed || 0;
            const actualConsumed = consumable.actualConsumed || 0;
            consumable.elapsedSeconds || 0;

            // Skip if no consumption (even estimated)
            if (consumed <= 0) {
                continue;
            }

            const prices = marketAPI.getPrice(consumable.itemHrid);
            const itemPrice = prices ? prices.ask : 500;
            const itemCost = itemPrice * consumed;

            totalCost += itemCost;

            // Get item name from data manager
            const itemDetails = dataManager$1.getItemDetails(consumable.itemHrid);
            const itemName = itemDetails?.name || consumable.itemHrid;

            breakdown.push({
                itemHrid: consumable.itemHrid,
                itemName: itemName,
                count: consumed, // Use estimated consumption
                pricePerItem: itemPrice,
                totalCost: itemCost,
                startingCount: consumable.startingCount,
                currentCount: consumable.currentCount,
                actualConsumed: actualConsumed,
                consumptionRate: consumable.consumptionRate,
                elapsedSeconds: consumable.elapsedSeconds || 0,
            });
        }

        return { total: totalCost, breakdown };
    }

    /**
     * Calculate total experience
     * @param {Object} experienceMap - totalSkillExperienceMap from player data
     * @returns {number} Total experience
     */
    function calculateTotalExperience(experienceMap) {
        if (!experienceMap) {
            return 0;
        }

        let total = 0;
        for (const exp of Object.values(experienceMap)) {
            total += exp;
        }

        return total;
    }

    /**
     * Calculate daily rate
     * @param {number} total - Total value
     * @param {number} durationSeconds - Duration in seconds
     * @returns {number} Value per day
     */
    function calculateDailyRate(total, durationSeconds) {
        if (durationSeconds <= 0) {
            return 0;
        }

        const durationDays = durationSeconds / 86400; // 86400 seconds in a day
        return total / durationDays;
    }

    /**
     * Format loot items for display
     * @param {Object} lootMap - totalLootMap from player data
     * @returns {Array} Array of { count, itemHrid, itemName, rarity }
     */
    function formatLootList(lootMap) {
        if (!lootMap) {
            return [];
        }

        const items = [];

        for (const loot of Object.values(lootMap)) {
            const itemDetails = dataManager$1.getItemDetails(loot.itemHrid);
            items.push({
                count: loot.count,
                itemHrid: loot.itemHrid,
                itemName: itemDetails?.name || 'Unknown',
                rarity: itemDetails?.rarity || 0,
            });
        }

        // Sort by rarity (descending), then by name
        items.sort((a, b) => {
            if (a.rarity !== b.rarity) {
                return b.rarity - a.rarity;
            }
            return a.itemName.localeCompare(b.itemName);
        });

        return items;
    }

    /**
     * Calculate all statistics for a player
     * @param {Object} playerData - Player data from combat data
     * @param {number|null} durationSeconds - Combat duration in seconds (from DOM or null)
     * @returns {Object} Calculated statistics
     */
    function calculatePlayerStats(playerData, durationSeconds = null) {
        // Calculate income
        const income = calculateIncome(playerData.loot);

        // Use provided duration or default to 0 (will show 0 for rates if no duration)
        const duration = durationSeconds || 0;

        // Calculate daily income
        const dailyIncomeAsk = duration > 0 ? calculateDailyRate(income.ask, duration) : 0;
        const dailyIncomeBid = duration > 0 ? calculateDailyRate(income.bid, duration) : 0;

        // Calculate consumable costs based on ACTUAL consumption
        const consumableData = calculateConsumableCosts(playerData.consumables, duration);
        const consumableCosts = consumableData.total;
        const consumableBreakdown = consumableData.breakdown;

        // Calculate daily consumable costs
        const dailyConsumableCosts = duration > 0 ? calculateDailyRate(consumableCosts, duration) : 0;

        // Calculate daily profit
        const dailyProfitAsk = dailyIncomeAsk - dailyConsumableCosts;
        const dailyProfitBid = dailyIncomeBid - dailyConsumableCosts;

        // Calculate total experience
        const totalExp = calculateTotalExperience(playerData.experience);

        // Calculate experience per hour
        const expPerHour = duration > 0 ? (totalExp / duration) * 3600 : 0;

        // Format loot list
        const lootList = formatLootList(playerData.loot);

        return {
            name: playerData.name,
            income: {
                ask: income.ask,
                bid: income.bid,
            },
            dailyIncome: {
                ask: dailyIncomeAsk,
                bid: dailyIncomeBid,
            },
            consumableCosts,
            consumableBreakdown,
            dailyConsumableCosts,
            dailyProfit: {
                ask: dailyProfitAsk,
                bid: dailyProfitBid,
            },
            totalExp,
            expPerHour,
            deathCount: playerData.deathCount,
            lootList,
            duration,
        };
    }

    /**
     * Calculate statistics for all players
     * @param {Object} combatData - Combat data from data collector
     * @param {number|null} durationSeconds - Combat duration in seconds (from DOM or null)
     * @returns {Array} Array of player statistics
     */
    function calculateAllPlayerStats(combatData, durationSeconds = null) {
        if (!combatData || !combatData.players) {
            return [];
        }

        // Calculate encounters per hour (EPH)
        const duration = durationSeconds || combatData.durationSeconds || 0;
        const battleId = combatData.battleId || 1;
        const encountersPerHour = duration > 0 ? (3600 * (battleId - 1)) / duration : 0;

        return combatData.players.map((player) => {
            const stats = calculatePlayerStats(player, durationSeconds);
            // Add EPH and formatted duration to each player's stats
            stats.encountersPerHour = encountersPerHour;
            stats.durationFormatted = formatDuration(duration);
            return stats;
        });
    }

    /**
     * Format duration in seconds to human-readable format
     * @param {number} seconds - Duration in seconds
     * @returns {string} Formatted duration (e.g., "1h 23m", "3d 12h", "2mo 15d")
     */
    function formatDuration(seconds) {
        if (!seconds || seconds <= 0) {
            return '0s';
        }

        if (seconds < 60) return `${Math.floor(seconds)}s`;
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
        if (seconds < 86400) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            return m > 0 ? `${h}h ${m}m` : `${h}h`;
        }

        // Days
        const d = Math.floor(seconds / 86400);
        const h = Math.floor((seconds % 86400) / 3600);
        if (d >= 365) {
            const years = Math.floor(d / 365);
            const days = d % 365;
            if (days >= 30) {
                const months = Math.floor(days / 30);
                return `${years}y ${months}mo`;
            }
            return days > 0 ? `${years}y ${days}d` : `${years}y`;
        }
        if (d >= 30) {
            const months = Math.floor(d / 30);
            const days = d % 30;
            return days > 0 ? `${months}mo ${days}d` : `${months}mo`;
        }
        return h > 0 ? `${d}d ${h}h` : `${d}d`;
    }

    /**
     * Combat Statistics UI
     * Injects button and displays statistics popup
     */


    class CombatStatsUI {
        constructor() {
            this.isInitialized = false;
            this.observer = null;
            this.popup = null;
        }

        /**
         * Initialize the UI
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            this.isInitialized = true;

            // Start observing for Combat panel
            this.startObserver();
        }

        /**
         * Start MutationObserver to watch for Combat panel
         */
        startObserver() {
            this.observer = new MutationObserver((mutations) => {
                for (const mutation of mutations) {
                    for (const addedNode of mutation.addedNodes) {
                        if (addedNode.nodeType !== Node.ELEMENT_NODE) continue;

                        // Check for Combat Panel appearing
                        if (addedNode.classList?.contains('MainPanel_subPanelContainer__1i-H9')) {
                            const combatPanel = addedNode.querySelector('[class*="CombatPanel_combatPanel"]');
                            if (combatPanel) {
                                this.injectButton();
                            }
                        }

                        // Check for initial page load
                        if (addedNode.classList?.contains('GamePage_contentPanel__Zx4FH')) {
                            const combatPanel = addedNode.querySelector('[class*="CombatPanel_combatPanel"]');
                            if (combatPanel) {
                                this.injectButton();
                            }
                        }
                    }
                }
            });

            this.observer.observe(document.body, { childList: true, subtree: true });

            // Try to inject button immediately if Combat panel is already visible
            setTimeout(() => this.injectButton(), 1000);
        }

        /**
         * Inject Statistics button into Combat panel tabs
         */
        injectButton() {
            // Find the tabs container
            const tabsContainer = document.querySelector(
                'div.GamePage_mainPanel__2njyb > div > div:nth-child(1) > div > div > div > div[class*="TabsComponent_tabsContainer"] > div > div > div'
            );

            if (!tabsContainer) {
                return;
            }

            // Verify we're in a Combat panel, not Marketplace or other panels
            const combatPanel = tabsContainer.closest('[class*="CombatPanel_combatPanel"]');
            if (!combatPanel) {
                return;
            }

            // Check if button already exists
            if (tabsContainer.querySelector('.toolasha-combat-stats-btn')) {
                return;
            }

            // Create button
            const button = document.createElement('div');
            button.className =
                'MuiButtonBase-root MuiTab-root MuiTab-textColorPrimary css-1q2h7u5 toolasha-combat-stats-btn';
            button.textContent = 'Statistics';
            button.style.cursor = 'pointer';

            button.onclick = () => this.showPopup();

            // Insert button at the end
            const lastTab = tabsContainer.children[tabsContainer.children.length - 1];
            tabsContainer.insertBefore(button, lastTab.nextSibling);
        }

        /**
         * Share statistics to chat (triggered by Ctrl+Click on player card)
         * @param {Object} stats - Player statistics
         */
        shareStatsToChat(stats) {
            // Get chat message format from config (use getSettingValue for template type)
            const messageTemplate = config$1.getSettingValue('combatStatsChatMessage');

            // Convert array format to string if needed
            let message = '';
            if (Array.isArray(messageTemplate)) {
                // Format numbers
                const useKMB = config$1.getSetting('formatting_useKMBFormat');
                const formatNum = (num) => (useKMB ? coinFormatter(Math.round(num)) : formatWithSeparator(Math.round(num)));

                // Build message from array
                message = messageTemplate
                    .map((item) => {
                        if (item.type === 'variable') {
                            // Replace variable with actual value
                            switch (item.key) {
                                case '{income}':
                                    return formatNum(stats.income.bid);
                                case '{dailyIncome}':
                                    return formatNum(stats.dailyIncome.bid);
                                case '{dailyConsumableCosts}':
                                    return formatNum(stats.dailyConsumableCosts);
                                case '{dailyProfit}':
                                    return formatNum(stats.dailyProfit.bid);
                                case '{exp}':
                                    return formatNum(stats.expPerHour);
                                case '{deathCount}':
                                    return stats.deathCount.toString();
                                case '{encountersPerHour}':
                                    return formatNum(stats.encountersPerHour);
                                case '{duration}':
                                    return stats.durationFormatted || '0s';
                                default:
                                    return item.key;
                            }
                        } else {
                            // Plain text
                            return item.value;
                        }
                    })
                    .join('');
            } else {
                // Legacy string format (shouldn't happen, but handle it)
                const useKMB = config$1.getSetting('formatting_useKMBFormat');
                const formatNum = (num) => (useKMB ? coinFormatter(Math.round(num)) : formatWithSeparator(Math.round(num)));

                message = (messageTemplate || 'Combat Stats: {income} income | {dailyProfit} profit/d | {exp} exp/h')
                    .replace('{income}', formatNum(stats.income.bid))
                    .replace('{dailyIncome}', formatNum(stats.dailyIncome.bid))
                    .replace('{dailyProfit}', formatNum(stats.dailyProfit.bid))
                    .replace('{dailyConsumableCosts}', formatNum(stats.dailyConsumableCosts))
                    .replace('{exp}', formatNum(stats.expPerHour))
                    .replace('{deathCount}', stats.deathCount.toString());
            }

            // Insert into chat
            this.insertToChat(message);
        }

        /**
         * Insert text into chat input
         * @param {string} text - Text to insert
         */
        insertToChat(text) {
            const chatSelector =
                '#root > div > div > div.GamePage_gamePanel__3uNKN > div.GamePage_contentPanel__Zx4FH > div.GamePage_middlePanel__uDts7 > div.GamePage_chatPanel__mVaVt > div > div.Chat_chatInputContainer__2euR8 > form > input';
            const chatInput = document.querySelector(chatSelector);

            if (!chatInput) {
                console.error('[Combat Stats] Chat input not found');
                return;
            }

            // Use native value setter for React compatibility
            const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;
            const start = chatInput.selectionStart || 0;
            const end = chatInput.selectionEnd || 0;

            // Insert text at cursor position
            const newValue = chatInput.value.substring(0, start) + text + chatInput.value.substring(end);
            nativeInputValueSetter.call(chatInput, newValue);

            // Dispatch input event for React
            const event = new Event('input', {
                bubbles: true,
                cancelable: true,
            });
            chatInput.dispatchEvent(event);

            // Set cursor position after inserted text
            chatInput.selectionStart = chatInput.selectionEnd = start + text.length;
            chatInput.focus();
        }

        /**
         * Show statistics popup
         */
        async showPopup() {
            // Ensure market data is loaded
            if (!marketAPI.isLoaded()) {
                const marketData = await marketAPI.fetch();
                if (!marketData) {
                    console.error('[Combat Stats] Market data not available');
                    alert('Market data not available. Please try again.');
                    return;
                }
            }

            // Get latest combat data
            let combatData = combatStatsDataCollector.getLatestData();

            if (!combatData) {
                // Try to load from storage
                combatData = await combatStatsDataCollector.loadLatestData();
            }

            if (!combatData || !combatData.players || combatData.players.length === 0) {
                alert('No combat data available. Start a combat run first.');
                return;
            }

            // Recalculate duration from combat start time (updates in real-time during combat)
            let durationSeconds = null;
            if (combatData.combatStartTime) {
                const combatStartTime = new Date(combatData.combatStartTime).getTime() / 1000;
                const currentTime = Date.now() / 1000;
                durationSeconds = currentTime - combatStartTime;
            } else if (combatData.durationSeconds) {
                // Fallback to stored duration if no start time
                durationSeconds = combatData.durationSeconds;
            }

            if (!durationSeconds) {
                console.warn('[Combat Stats] No duration data available');
            }

            // Calculate statistics
            const playerStats = calculateAllPlayerStats(combatData, durationSeconds);

            // Create and show popup
            this.createPopup(playerStats);
        }

        /**
         * Create and display the statistics popup
         * @param {Array} playerStats - Array of player statistics
         */
        createPopup(playerStats) {
            // Remove existing popup if any
            if (this.popup) {
                this.closePopup();
            }

            // Get text color from config
            const textColor = config$1.getSetting('color_text_primary') || config$1.COLOR_TEXT_PRIMARY;

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'toolasha-combat-stats-overlay';
            overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        `;

            // Create popup container
            const popup = document.createElement('div');
            popup.className = 'toolasha-combat-stats-popup';
            popup.style.cssText = `
            background: #1a1a1a;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            color: ${textColor};
        `;

            // Create header
            const header = document.createElement('div');
            header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #3a3a3a;
            padding-bottom: 10px;
        `;

            const title = document.createElement('h2');
            title.textContent = 'Combat Statistics';
            title.style.cssText = `
            margin: 0;
            color: ${textColor};
            font-size: 24px;
        `;

            const closeButton = document.createElement('button');
            closeButton.textContent = '×';
            closeButton.style.cssText = `
            background: none;
            border: none;
            color: ${textColor};
            font-size: 32px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        `;
            closeButton.onclick = () => this.closePopup();

            header.appendChild(title);
            header.appendChild(closeButton);

            // Create player cards container
            const cardsContainer = document.createElement('div');
            cardsContainer.style.cssText = `
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        `;

            // Create a card for each player
            for (const stats of playerStats) {
                const card = this.createPlayerCard(stats, textColor);
                cardsContainer.appendChild(card);
            }

            // Assemble popup
            popup.appendChild(header);
            popup.appendChild(cardsContainer);
            overlay.appendChild(popup);

            // Add to page
            document.body.appendChild(overlay);

            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    this.closePopup();
                }
            };

            this.popup = overlay;
        }

        /**
         * Get the current items sprite URL from the DOM
         * Extracts the sprite URL with webpack hash from an existing item icon
         * @returns {string|null} Items sprite URL or null if not found
         */
        getItemsSpriteUrl() {
            // Find any existing item icon in the DOM
            const itemIcon = document.querySelector('use[href*="items_sprite"]');
            if (!itemIcon) {
                return null;
            }

            const href = itemIcon.getAttribute('href');
            // Extract just the sprite URL without the #symbol part
            // e.g., "/static/media/items_sprite.53ef17dc.svg#coin" → "/static/media/items_sprite.53ef17dc.svg"
            return href ? href.split('#')[0] : null;
        }

        /**
         * Clone a symbol from the document into a defs element
         * @param {string} symbolId - Symbol ID to clone
         * @param {SVGDefsElement} defsElement - Defs element to append to
         * @returns {boolean} True if successful
         */
        cloneSymbolToDefs(symbolId, defsElement) {
            // Check if already cloned
            if (defsElement.querySelector(`symbol[id="${symbolId}"]`)) {
                return true;
            }

            // Find symbol in document
            const symbol = document.querySelector(`symbol[id="${symbolId}"]`);
            if (!symbol) {
                console.warn('[Combat Stats] Symbol not found:', symbolId);
                return false;
            }

            // Clone and append
            const clonedSymbol = symbol.cloneNode(true);
            defsElement.appendChild(clonedSymbol);
            return true;
        }

        /**
         * Create a player statistics card
         * @param {Object} stats - Player statistics
         * @param {string} textColor - Text color
         * @returns {HTMLElement} Card element
         */
        createPlayerCard(stats, textColor) {
            const card = document.createElement('div');
            card.style.cssText = `
            background: #2a2a2a;
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            padding: 15px;
            min-width: 300px;
            max-width: 400px;
            cursor: pointer;
        `;

            // Add Ctrl+Click handler to share to chat
            card.onclick = (e) => {
                if (e.ctrlKey || e.metaKey) {
                    this.shareStatsToChat(stats);
                    e.stopPropagation();
                }
            };

            // Player name
            const nameHeader = document.createElement('div');
            nameHeader.textContent = stats.name;
            nameHeader.style.cssText = `
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: ${textColor};
            border-bottom: 1px solid #4a4a4a;
            padding-bottom: 8px;
        `;

            // Statistics rows
            // Use K/M/B formatting if enabled, otherwise use separators
            const useKMB = config$1.getSetting('formatting_useKMBFormat');
            const formatNum = (num) => (useKMB ? coinFormatter(Math.round(num)) : formatWithSeparator(Math.round(num)));

            const statsRows = [
                { label: 'Duration', value: stats.durationFormatted || '0s' },
                { label: 'Encounters/Hour', value: formatNum(stats.encountersPerHour) },
                { label: 'Income', value: formatNum(stats.income.bid) },
                { label: 'Daily Income', value: `${formatNum(stats.dailyIncome.bid)}/d` },
                {
                    label: 'Consumable Costs',
                    value: formatNum(stats.consumableCosts),
                    color: '#ff6b6b',
                    expandable: true,
                    breakdown: stats.consumableBreakdown,
                },
                {
                    label: 'Daily Consumable Costs',
                    value: `${formatNum(stats.dailyConsumableCosts)}/d`,
                    color: '#ff6b6b',
                    expandable: true,
                    breakdown: stats.consumableBreakdown,
                    isDaily: true,
                },
                {
                    label: 'Daily Profit',
                    value: `${formatNum(stats.dailyProfit.bid)}/d`,
                    color: stats.dailyProfit.bid >= 0 ? '#51cf66' : '#ff6b6b',
                },
                { label: 'Total EXP', value: formatNum(stats.totalExp) },
                { label: 'EXP/hour', value: `${formatNum(stats.expPerHour)}/h` },
                { label: 'Death Count', value: `${stats.deathCount}` },
            ];

            const statsContainer = document.createElement('div');
            statsContainer.style.cssText = 'margin-bottom: 15px;';

            for (const row of statsRows) {
                const rowDiv = document.createElement('div');
                rowDiv.style.cssText = `
                display: flex;
                justify-content: space-between;
                margin-bottom: 5px;
                font-size: 14px;
            `;

                const label = document.createElement('span');
                label.textContent = row.label + ':';
                label.style.color = textColor;

                const value = document.createElement('span');
                value.textContent = row.value;
                value.style.color = row.color || textColor;

                // Add expandable indicator if applicable
                if (row.expandable) {
                    rowDiv.style.cursor = 'pointer';
                    rowDiv.style.userSelect = 'none';
                    label.textContent = '▶ ' + row.label + ':';

                    let isExpanded = false;
                    let breakdownDiv = null;

                    rowDiv.onclick = () => {
                        isExpanded = !isExpanded;
                        label.textContent = (isExpanded ? '▼ ' : '▶ ') + row.label + ':';

                        if (isExpanded) {
                            // Create breakdown
                            breakdownDiv = document.createElement('div');
                            breakdownDiv.style.cssText = `
                            margin-left: 20px;
                            margin-top: 5px;
                            margin-bottom: 10px;
                            padding: 10px;
                            background: #1a1a1a;
                            border-left: 2px solid #4a4a4a;
                            font-size: 13px;
                        `;

                            if (row.breakdown && row.breakdown.length > 0) {
                                // Add header
                                const header = document.createElement('div');
                                header.style.cssText = `
                                display: grid;
                                grid-template-columns: 2fr 1fr 1fr 1fr;
                                gap: 10px;
                                font-weight: bold;
                                margin-bottom: 5px;
                                padding-bottom: 5px;
                                border-bottom: 1px solid #4a4a4a;
                                color: ${textColor};
                            `;
                                header.innerHTML = `
                                <span>Item</span>
                                <span style="text-align: right;">Consumed</span>
                                <span style="text-align: right;">Price</span>
                                <span style="text-align: right;">Cost</span>
                            `;
                                breakdownDiv.appendChild(header);

                                // Add each item
                                for (const item of row.breakdown) {
                                    const itemRow = document.createElement('div');
                                    itemRow.style.cssText = `
                                    display: grid;
                                    grid-template-columns: 2fr 1fr 1fr 1fr;
                                    gap: 10px;
                                    margin-bottom: 3px;
                                    color: ${textColor};
                                `;

                                    // For daily: show per-day quantities at same price
                                    // For total: show actual quantities and costs
                                    const displayQty = row.isDaily ? (item.count / stats.duration) * 86400 : item.count;

                                    const displayPrice = item.pricePerItem; // Price stays the same

                                    const displayCost = row.isDaily
                                        ? (item.totalCost / stats.duration) * 86400
                                        : item.totalCost;

                                    itemRow.innerHTML = `
                                    <span>${item.itemName}</span>
                                    <span style="text-align: right;">${formatNum(displayQty)}</span>
                                    <span style="text-align: right;">${formatNum(displayPrice)}</span>
                                    <span style="text-align: right; color: #ff6b6b;">${formatNum(displayCost)}</span>
                                `;
                                    breakdownDiv.appendChild(itemRow);
                                }

                                // Add total row
                                const totalRow = document.createElement('div');
                                totalRow.style.cssText = `
                                display: grid;
                                grid-template-columns: 2fr 1fr 1fr 1fr;
                                gap: 10px;
                                margin-top: 5px;
                                padding-top: 5px;
                                border-top: 1px solid #4a4a4a;
                                font-weight: bold;
                                color: ${textColor};
                            `;
                                totalRow.innerHTML = `
                                <span>Total</span>
                                <span></span>
                                <span></span>
                                <span style="text-align: right; color: #ff6b6b;">${row.value}</span>
                            `;
                                breakdownDiv.appendChild(totalRow);

                                // Add tracking info note
                                if (row.breakdown.length > 0) {
                                    const trackingNote = document.createElement('div');
                                    trackingNote.style.cssText = `
                                    margin-top: 8px;
                                    padding-top: 8px;
                                    border-top: 1px solid #3a3a3a;
                                    font-size: 11px;
                                    color: #888;
                                    font-style: italic;
                                `;

                                    // Format tracking duration
                                    const formatTrackingDuration = (seconds) => {
                                        if (seconds < 60) return `${seconds}s`;
                                        if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
                                        if (seconds < 86400) {
                                            const h = Math.floor(seconds / 3600);
                                            const m = Math.floor((seconds % 3600) / 60);
                                            return m > 0 ? `${h}h ${m}m` : `${h}h`;
                                        }
                                        // Days
                                        const d = Math.floor(seconds / 86400);
                                        const h = Math.floor((seconds % 86400) / 3600);
                                        if (d >= 30) {
                                            const months = Math.floor(d / 30);
                                            const days = d % 30;
                                            return days > 0 ? `${months}mo ${days}d` : `${months}mo`;
                                        }
                                        return h > 0 ? `${d}d ${h}h` : `${d}d`;
                                    };

                                    // Display tracking info with MCS-style calculation note
                                    const firstItem = row.breakdown[0];
                                    const trackingDuration = Math.floor(firstItem.elapsedSeconds || 0);
                                    const hasActualData = firstItem.actualConsumed > 0;

                                    if (!hasActualData) {
                                        trackingNote.textContent = `📊 Tracked ${formatTrackingDuration(trackingDuration)} - Using baseline rates (no consumption detected yet)`;
                                    } else {
                                        trackingNote.textContent = `📊 Tracked ${formatTrackingDuration(trackingDuration)} - Using 90% actual + 10% combined (baseline+actual)`;
                                    }

                                    breakdownDiv.appendChild(trackingNote);
                                }
                            } else if (breakdownDiv) {
                                breakdownDiv.textContent = 'No consumables used';
                                breakdownDiv.style.color = '#888';
                            }

                            rowDiv.after(breakdownDiv);
                        } else if (breakdownDiv) {
                            // Collapse - remove breakdown
                            breakdownDiv.remove();
                            breakdownDiv = null;
                        }
                    };
                }

                rowDiv.appendChild(label);
                rowDiv.appendChild(value);
                statsContainer.appendChild(rowDiv);
            }

            // Drop list
            if (stats.lootList && stats.lootList.length > 0) {
                const dropHeader = document.createElement('div');
                dropHeader.textContent = 'Drops';
                dropHeader.style.cssText = `
                font-weight: bold;
                margin-top: 10px;
                margin-bottom: 5px;
                color: ${textColor};
                border-top: 1px solid #4a4a4a;
                padding-top: 8px;
            `;

                const dropList = document.createElement('div');
                dropList.style.cssText = `
                font-size: 13px;
                max-height: 200px;
                overflow-y: auto;
                padding-right: 5px;
            `;

                // Get current items sprite URL from DOM (to handle webpack hash changes)
                const itemsSpriteUrl = this.getItemsSpriteUrl();

                // Show ALL items with icons
                for (const item of stats.lootList) {
                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = `
                    margin-bottom: 3px;
                    display: flex;
                    align-items: center;
                    gap: 5px;
                `;

                    // Create item icon
                    if (item.itemHrid && itemsSpriteUrl) {
                        const iconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        iconSvg.setAttribute('width', '16');
                        iconSvg.setAttribute('height', '16');
                        iconSvg.style.flexShrink = '0';

                        // Determine icon name based on HRID type
                        let iconName;
                        if (item.itemHrid.startsWith('/items/')) {
                            // Regular items: /items/cheese → cheese
                            iconName = item.itemHrid.split('/').pop();
                        } else if (item.itemHrid.startsWith('/ability_books/')) {
                            // Ability books: /ability_books/fireball → ability_book
                            iconName = 'ability_book';
                        } else if (item.itemHrid === '/consumables/coin') {
                            // Coins: /consumables/coin → coin
                            iconName = 'coin';
                        } else {
                            // Other types: extract last part of HRID
                            iconName = item.itemHrid.split('/').pop();
                        }

                        const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                        use.setAttribute('href', `${itemsSpriteUrl}#${iconName}`);
                        iconSvg.appendChild(use);

                        itemDiv.appendChild(iconSvg);
                    }

                    // Create text content with KMB formatting
                    const textSpan = document.createElement('span');
                    const rarityColor = this.getRarityColor(item.rarity);
                    textSpan.innerHTML = `<span style="color: ${textColor};">${formatNum(item.count)}</span> <span style="color: ${rarityColor};">× ${item.itemName}</span>`;
                    itemDiv.appendChild(textSpan);

                    dropList.appendChild(itemDiv);
                }

                statsContainer.appendChild(dropHeader);
                statsContainer.appendChild(dropList);
            }

            // Assemble card
            card.appendChild(nameHeader);
            card.appendChild(statsContainer);

            return card;
        }

        /**
         * Get color for item rarity
         * @param {number} rarity - Item rarity
         * @returns {string} Color hex code
         */
        getRarityColor(rarity) {
            switch (rarity) {
                case 6:
                    return '#64dbff'; // Mythic
                case 5:
                    return '#ff8888'; // Legendary
                case 4:
                    return '#ffa844'; // Epic
                case 3:
                    return '#e586ff'; // Rare
                case 2:
                    return '#a9d5ff'; // Uncommon
                case 1:
                    return '#b9f1be'; // Common
                default:
                    return '#b4b4b4'; // Normal
            }
        }

        /**
         * Close the popup
         */
        closePopup() {
            if (this.popup) {
                this.popup.remove();
                this.popup = null;
            }
        }

        /**
         * Cleanup
         */
        cleanup() {
            if (this.observer) {
                this.observer.disconnect();
                this.observer = null;
            }

            this.closePopup();

            // Remove injected buttons
            const buttons = document.querySelectorAll('.toolasha-combat-stats-btn');
            for (const button of buttons) {
                button.remove();
            }

            this.isInitialized = false;
        }
    }

    const combatStatsUI = new CombatStatsUI();

    /**
     * Combat Statistics Feature
     * Main entry point for combat statistics tracking and display
     */


    /**
     * Initialize combat statistics feature
     */
    async function initialize() {
        // Initialize data collector (WebSocket listener)
        combatStatsDataCollector.initialize();

        // Initialize UI (button injection and popup)
        combatStatsUI.initialize();
    }

    /**
     * Cleanup combat statistics feature
     */
    function cleanup() {
        combatStatsDataCollector.cleanup();
        combatStatsUI.cleanup();
    }

    var combatStats = {
        name: 'Combat Statistics',
        initialize,
        cleanup,
    };

    /**
     * Ability Book Calculator
     * Shows number of books needed to reach target ability level
     * Appears in Item Dictionary when viewing ability books
     */


    /**
     * AbilityBookCalculator class handles ability book calculations in Item Dictionary
     */
    class AbilityBookCalculator {
        constructor() {
            this.unregisterObserver = null; // Unregister function from centralized observer
            this.isActive = false;
            this.isInitialized = false;
        }

        /**
         * Setup settings listeners for feature toggle and color changes
         */
        setupSettingListener() {
            config$1.onSettingChange('skillbook', (value) => {
                if (value) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('color_accent', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize the ability book calculator
         */
        initialize() {
            // Guard FIRST (before feature check)
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('skillbook')) {
                return;
            }

            this.isInitialized = true;

            // Register with centralized observer to watch for Item Dictionary modal
            this.unregisterObserver = domObserver$1.onClass(
                'AbilityBookCalculator',
                'ItemDictionary_modalContent__WvEBY',
                (dictContent) => {
                    this.handleItemDictionary(dictContent);
                }
            );

            this.isActive = true;
        }

        /**
         * Handle Item Dictionary modal
         * @param {Element} panel - Item Dictionary content element
         */
        async handleItemDictionary(panel) {
            try {
                // Extract ability HRID from modal title
                const abilityHrid = this.extractAbilityHrid(panel);
                if (!abilityHrid) {
                    return; // Not an ability book
                }

                // Get ability book data
                const itemHrid = abilityHrid.replace('/abilities/', '/items/');
                const gameData = dataManager$1.getInitClientData();
                if (!gameData) return;

                const itemDetails = gameData.itemDetailMap[itemHrid];
                if (!itemDetails?.abilityBookDetail) {
                    return; // Not an ability book
                }

                const xpPerBook = itemDetails.abilityBookDetail.experienceGain;

                // Get current ability level and XP
                const abilityData = this.getCurrentAbilityData(abilityHrid);

                // Inject calculator UI
                this.injectCalculator(panel, abilityData, xpPerBook, itemHrid);
            } catch (error) {
                console.error('[AbilityBookCalculator] Error handling dictionary:', error);
            }
        }

        /**
         * Extract ability HRID from modal title
         * @param {Element} panel - Item Dictionary content element
         * @returns {string|null} Ability HRID or null
         */
        extractAbilityHrid(panel) {
            const titleElement = panel.querySelector('h1.ItemDictionary_title__27cTd');
            if (!titleElement) return null;

            // Get the item name from title
            const itemName = titleElement.textContent.trim().toLowerCase().replaceAll(' ', '_').replaceAll("'", '');

            // Look up ability HRID from name
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) return null;

            for (const abilityHrid of Object.keys(gameData.abilityDetailMap)) {
                if (abilityHrid.includes('/' + itemName)) {
                    return abilityHrid;
                }
            }

            return null;
        }

        /**
         * Get current ability level and XP from character data
         * @param {string} abilityHrid - Ability HRID
         * @returns {Object} {level, xp}
         */
        getCurrentAbilityData(abilityHrid) {
            // Get character abilities from live character data (NOT static game data)
            const characterData = dataManager$1.characterData;
            if (!characterData?.characterAbilities) {
                return { level: 0, xp: 0 };
            }

            // characterAbilities is an ARRAY of ability objects
            const ability = characterData.characterAbilities.find((a) => a.abilityHrid === abilityHrid);
            if (ability) {
                return {
                    level: ability.level || 0,
                    xp: ability.experience || 0,
                };
            }

            return { level: 0, xp: 0 };
        }

        /**
         * Calculate books needed to reach target level
         * @param {number} currentLevel - Current ability level
         * @param {number} currentXp - Current ability XP
         * @param {number} targetLevel - Target ability level
         * @param {number} xpPerBook - XP gained per book
         * @returns {number} Number of books needed
         */
        calculateBooksNeeded(currentLevel, currentXp, targetLevel, xpPerBook) {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) return 0;

            const levelXpTable = gameData.levelExperienceTable;
            if (!levelXpTable) return 0;

            // Calculate XP needed to reach target level
            const targetXp = levelXpTable[targetLevel];
            const xpNeeded = targetXp - currentXp;

            // Calculate books needed
            let booksNeeded = xpNeeded / xpPerBook;

            // If starting from level 0, need +1 book to learn the ability initially
            if (currentLevel === 0) {
                booksNeeded += 1;
            }

            return booksNeeded;
        }

        /**
         * Inject calculator UI into Item Dictionary modal
         * @param {Element} panel - Item Dictionary content element
         * @param {Object} abilityData - {level, xp}
         * @param {number} xpPerBook - XP per book
         * @param {string} itemHrid - Item HRID for market prices
         */
        async injectCalculator(panel, abilityData, xpPerBook, itemHrid) {
            // Check if already injected
            if (panel.querySelector('.tillLevel')) {
                return;
            }

            const { level: currentLevel, xp: currentXp } = abilityData;
            const targetLevel = currentLevel + 1;

            // Calculate initial books needed
            const booksNeeded = this.calculateBooksNeeded(currentLevel, currentXp, targetLevel, xpPerBook);

            // Get market prices
            const prices = marketAPI.getPrice(itemHrid, 0);
            const ask = prices?.ask || 0;
            const bid = prices?.bid || 0;

            // Create calculator HTML
            const calculatorDiv = dom.createStyledDiv(
                {
                    color: config$1.COLOR_ACCENT,
                    textAlign: 'left',
                    marginTop: '16px',
                    padding: '12px',
                    border: '1px solid rgba(255,255,255,0.2)',
                    borderRadius: '4px',
                },
                '',
                'tillLevel'
            );

            calculatorDiv.innerHTML = `
            <div style="margin-bottom: 8px; font-size: 0.95em;">
                <strong>Current level:</strong> ${currentLevel}
            </div>
            <div style="margin-bottom: 8px;">
                <label for="tillLevelInput">To level: </label>
                <input
                    id="tillLevelInput"
                    type="number"
                    value="${targetLevel}"
                    min="${currentLevel + 1}"
                    max="200"
                    style="width: 60px; padding: 4px; background: #2a2a2a; color: white; border: 1px solid #555; border-radius: 3px;"
                >
            </div>
            <div id="tillLevelNumber" style="font-size: 0.95em;">
                Books needed: <strong>${numberFormatter(booksNeeded)}</strong>
                <br>
                Cost: ${numberFormatter(Math.ceil(booksNeeded * ask))} / ${numberFormatter(Math.ceil(booksNeeded * bid))} (ask / bid)
            </div>
            <div style="font-size: 0.85em; color: #999; margin-top: 8px; font-style: italic;">
                Refresh page to update current level
            </div>
        `;

            // Add event listeners for input changes
            const input = calculatorDiv.querySelector('#tillLevelInput');
            const display = calculatorDiv.querySelector('#tillLevelNumber');

            const updateDisplay = () => {
                const target = parseInt(input.value);

                if (target > currentLevel && target <= 200) {
                    const books = this.calculateBooksNeeded(currentLevel, currentXp, target, xpPerBook);
                    display.innerHTML = `
                    Books needed: <strong>${numberFormatter(books)}</strong>
                    <br>
                    Cost: ${numberFormatter(Math.ceil(books * ask))} / ${numberFormatter(Math.ceil(books * bid))} (ask / bid)
                `;
                } else {
                    display.innerHTML = '<span style="color: ${config.COLOR_LOSS};">Invalid target level</span>';
                }
            };

            input.addEventListener('change', updateDisplay);
            input.addEventListener('keyup', updateDisplay);

            // Try to find the left column by looking for the modal's main content structure
            // The Item Dictionary modal typically has its content in direct children of the panel
            const directChildren = Array.from(panel.children);

            // Look for a container that has exactly 2 children (two-column layout)
            for (const child of directChildren) {
                const grandchildren = Array.from(child.children).filter((c) => {
                    // Filter for visible elements that look like content columns
                    const style = window.getComputedStyle(c);
                    return style.display !== 'none' && c.offsetHeight > 50; // At least 50px tall
                });

                if (grandchildren.length === 2) {
                    // Found the two-column container! Use the left column (first child)
                    const leftColumn = grandchildren[0];
                    leftColumn.appendChild(calculatorDiv);
                    return;
                }
            }

            // Fallback: append to panel bottom (original behavior)
            panel.appendChild(calculatorDiv);
        }

        /**
         * Refresh colors on existing calculator displays
         */
        refresh() {
            // Update all .tillLevel elements
            document.querySelectorAll('.tillLevel').forEach((calc) => {
                calc.style.color = config$1.COLOR_ACCENT;
            });
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }
            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const abilityBookCalculator = new AbilityBookCalculator();
    abilityBookCalculator.setupSettingListener();

    /**
     * Combat Score Calculator
     * Calculates player gear score based on:
     * - House Score: Cost of battle houses
     * - Ability Score: Cost to reach current ability levels
     * - Equipment Score: Cost to enhance equipped items
     */


    /**
     * Token-based item data for untradeable back slot items (capes/cloaks/quivers)
     * These items are purchased with dungeon tokens and have no market data
     */
    const CAPE_ITEM_TOKEN_DATA = {
        '/items/chimerical_quiver': {
            tokenCost: 35000,
            tokenShopItems: [
                { hrid: '/items/griffin_leather', cost: 600 },
                { hrid: '/items/manticore_sting', cost: 1000 },
                { hrid: '/items/jackalope_antler', cost: 1200 },
                { hrid: '/items/dodocamel_plume', cost: 3000 },
                { hrid: '/items/griffin_talon', cost: 3000 },
            ],
        },
        '/items/sinister_cape': {
            tokenCost: 27000,
            tokenShopItems: [
                { hrid: '/items/acrobats_ribbon', cost: 2000 },
                { hrid: '/items/magicians_cloth', cost: 2000 },
                { hrid: '/items/chaotic_chain', cost: 3000 },
                { hrid: '/items/cursed_ball', cost: 3000 },
            ],
        },
        '/items/enchanted_cloak': {
            tokenCost: 27000,
            tokenShopItems: [
                { hrid: '/items/royal_cloth', cost: 2000 },
                { hrid: '/items/knights_ingot', cost: 2000 },
                { hrid: '/items/bishops_scroll', cost: 2000 },
                { hrid: '/items/regal_jewel', cost: 3000 },
                { hrid: '/items/sundering_jewel', cost: 3000 },
            ],
        },
    };

    /**
     * Skill classification for equipment categorization
     */
    const COMBAT_SKILLS = ['attack', 'melee', 'defense', 'ranged', 'magic', 'prayer'];
    const SKILLING_SKILLS = [
        'milking',
        'foraging',
        'woodcutting',
        'cheesesmithing',
        'crafting',
        'tailoring',
        'brewing',
        'cooking',
        'alchemy',
        'enhancing',
    ];

    /**
     * Categorize equipment item by skill requirements
     * @param {string} slot - Item slot HRID (e.g., "/item_locations/neck")
     * @param {Object} equipmentDetail - Equipment detail from item data
     * @returns {Object} {combat: boolean, skiller: boolean}
     */
    function categorizeEquipmentItem(slot, equipmentDetail) {
        // Tools always go to skiller only (regardless of requirements)
        if (slot.endsWith('_tool')) {
            return { combat: false, skiller: true };
        }

        const requirements = equipmentDetail?.levelRequirements || [];

        // No requirements → both scores
        if (requirements.length === 0) {
            return { combat: true, skiller: true };
        }

        // Check for combat vs skilling requirements
        const hasCombat = requirements.some((req) => COMBAT_SKILLS.some((skill) => req.skillHrid.includes(skill)));
        const hasSkilling = requirements.some((req) => SKILLING_SKILLS.some((skill) => req.skillHrid.includes(skill)));

        return { combat: hasCombat, skiller: hasSkilling };
    }

    /**
     * Calculate combat score from profile data
     * @param {Object} profileData - Profile data from game
     * @returns {Promise<Object>} {total, house, ability, equipment, breakdown}
     */
    async function calculateCombatScore(profileData) {
        try {
            // 1. Calculate House Score
            const houseResult = calculateHouseScore(profileData);

            // 2. Calculate Ability Score
            const abilityResult = calculateAbilityScore(profileData);

            // 3. Calculate Combat Equipment Score
            const combatEquipmentResult = calculateEquipmentScore(profileData, 'combat');

            // 4. Calculate Skiller Equipment Score
            const skillerEquipmentResult = calculateEquipmentScore(profileData, 'skiller');

            const combatTotalScore = houseResult.score + abilityResult.score + combatEquipmentResult.score;
            const skillerTotalScore = skillerEquipmentResult.score;

            return {
                // Combat score (house + ability + combat equipment)
                total: combatTotalScore,
                house: houseResult.score,
                ability: abilityResult.score,
                equipment: combatEquipmentResult.score,
                equipmentHidden: profileData.profile?.hideWearableItems || false,
                hasEquipmentData: combatEquipmentResult.hasEquipmentData,
                breakdown: {
                    houses: houseResult.breakdown,
                    abilities: abilityResult.breakdown,
                    equipment: combatEquipmentResult.breakdown,
                },
                // Skiller score (skilling equipment only)
                skillerTotal: skillerTotalScore,
                skillerEquipment: skillerEquipmentResult.score,
                skillerBreakdown: {
                    equipment: skillerEquipmentResult.breakdown,
                },
            };
        } catch (error) {
            console.error('[CombatScore] Error calculating score:', error);
            return {
                total: 0,
                house: 0,
                ability: 0,
                equipment: 0,
                equipmentHidden: false,
                hasEquipmentData: false,
                breakdown: { houses: [], abilities: [], equipment: [] },
                skillerTotal: 0,
                skillerEquipment: 0,
                skillerBreakdown: { equipment: [] },
            };
        }
    }

    /**
     * Get market price for an item with crafting cost fallback
     * @param {string} itemHrid - Item HRID
     * @param {number} enhancementLevel - Enhancement level
     * @returns {number} Price per item (always uses ask price, falls back to crafting cost)
     */
    function getMarketPriceWithFallback(itemHrid, enhancementLevel = 0) {
        const gameData = dataManager$1.getInitClientData();

        // Try ask price first
        const askPrice = getItemPrice(itemHrid, { enhancementLevel, mode: 'ask' });

        if (askPrice && askPrice > 0) {
            return askPrice;
        }

        // For base items (enhancement 0), try crafting cost fallback
        if (enhancementLevel === 0 && gameData) {
            // Find the action that produces this item
            for (const action of Object.values(gameData.actionDetailMap || {})) {
                if (action.outputItems) {
                    for (const output of action.outputItems) {
                        if (output.itemHrid === itemHrid) {
                            // Found the crafting action, calculate material costs
                            let inputCost = 0;

                            // Add input items
                            if (action.inputItems && action.inputItems.length > 0) {
                                for (const input of action.inputItems) {
                                    const inputPrice = getMarketPriceWithFallback(input.itemHrid, 0);
                                    inputCost += inputPrice * input.count;
                                }
                            }

                            // Apply Artisan Tea reduction (0.9x) to input materials
                            inputCost *= 0.9;

                            // Add upgrade item cost (not affected by Artisan Tea)
                            let upgradeCost = 0;
                            if (action.upgradeItemHrid) {
                                const upgradePrice = getMarketPriceWithFallback(action.upgradeItemHrid, 0);
                                upgradeCost = upgradePrice;
                            }

                            const totalCost = inputCost + upgradeCost;

                            // Divide by output count to get per-item cost
                            const perItemCost = totalCost / (output.count || 1);

                            if (perItemCost > 0) {
                                return perItemCost;
                            }
                        }
                    }
                }
            }

            // Try shop cost as final fallback (for shop-only items)
            const shopCost = getShopCost(itemHrid, gameData);
            if (shopCost > 0) {
                return shopCost;
            }
        }

        return 0;
    }

    /**
     * Get shop cost for an item (if purchaseable with coins)
     * @param {string} itemHrid - Item HRID
     * @param {Object} gameData - Game data object
     * @returns {number} Coin cost, or 0 if not in shop or not purchaseable with coins
     */
    function getShopCost(itemHrid, gameData) {
        if (!gameData) return 0;

        // Find shop item for this itemHrid
        for (const shopItem of Object.values(gameData.shopItemDetailMap || {})) {
            if (shopItem.itemHrid === itemHrid) {
                // Check if purchaseable with coins
                if (shopItem.costs && shopItem.costs.length > 0) {
                    const coinCost = shopItem.costs.find((cost) => cost.itemHrid === '/items/coin');
                    if (coinCost) {
                        return coinCost.count;
                    }
                }
            }
        }

        return 0;
    }

    /**
     * Calculate house score from battle houses
     * @param {Object} profileData - Profile data
     * @returns {Object} {score, breakdown}
     */
    function calculateHouseScore(profileData) {
        const characterHouseRooms = profileData.profile?.characterHouseRoomMap || {};

        const { totalCost, breakdown } = calculateBattleHousesCost(characterHouseRooms);

        // Convert to score (cost / 1 million)
        const score = totalCost / 1_000_000;

        // Format breakdown for display
        const formattedBreakdown = breakdown.map((house) => ({
            name: `${house.name} ${house.level}`,
            value: (house.cost / 1_000_000).toFixed(1),
        }));

        return { score, breakdown: formattedBreakdown };
    }

    /**
     * Calculate ability score from equipped abilities
     * @param {Object} profileData - Profile data
     * @returns {Object} {score, breakdown}
     */
    function calculateAbilityScore(profileData) {
        // Use equippedAbilities (not characterAbilities) to match MCS behavior
        const equippedAbilities = profileData.profile?.equippedAbilities || [];

        let totalCost = 0;
        const breakdown = [];

        for (const ability of equippedAbilities) {
            if (!ability.abilityHrid || ability.level === 0) continue;

            const cost = calculateAbilityCost(ability.abilityHrid, ability.level);
            totalCost += cost;

            // Format ability name for display
            const abilityName = ability.abilityHrid
                .replace('/abilities/', '')
                .split('_')
                .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');

            breakdown.push({
                name: `${abilityName} ${ability.level}`,
                value: (cost / 1_000_000).toFixed(1),
            });
        }

        // Convert to score (cost / 1 million)
        const score = totalCost / 1_000_000;

        // Sort by value descending
        breakdown.sort((a, b) => parseFloat(b.value) - parseFloat(a.value));

        return { score, breakdown };
    }

    /**
     * Calculate token-based item value for untradeable back slot items
     * @param {string} itemHrid - Item HRID
     * @returns {number} Item value in coins (0 if not a token-based item)
     */
    function calculateTokenBasedItemValue(itemHrid) {
        const capeData = CAPE_ITEM_TOKEN_DATA[itemHrid];
        if (!capeData) {
            return 0; // Not a token-based item
        }

        // Find the best value per token from shop items
        let bestValuePerToken = 0;
        for (const shopItem of capeData.tokenShopItems) {
            // Use ask price for shop items (instant buy cost)
            const shopItemPrice = getItemPrice(shopItem.hrid, { mode: 'ask' }) || 0;
            if (shopItemPrice > 0) {
                const valuePerToken = shopItemPrice / shopItem.cost;
                if (valuePerToken > bestValuePerToken) {
                    bestValuePerToken = valuePerToken;
                }
            }
        }

        // Calculate total item value: best value per token × token cost
        return bestValuePerToken * capeData.tokenCost;
    }

    /**
     * Calculate equipment score from equipped items
     * @param {Object} profileData - Profile data
     * @param {string} scoreType - 'combat' or 'skiller'
     * @returns {Object} {score, breakdown, hasEquipmentData}
     */
    function calculateEquipmentScore(profileData, scoreType = 'combat') {
        const equippedItems = profileData.profile?.wearableItemMap || {};
        const hideEquipment = profileData.profile?.hideWearableItems || false;

        // Check if equipment data is actually available
        // If wearableItemMap is populated, calculate score even if hideEquipment is true
        // (This happens when viewing party members - game sends equipment data despite privacy setting)
        const hasEquipmentData = Object.keys(equippedItems).length > 0;

        // If equipment is hidden AND no data available, return 0
        if (hideEquipment && !hasEquipmentData) {
            return { score: 0, breakdown: [], hasEquipmentData: false };
        }

        const gameData = dataManager$1.getInitClientData();
        if (!gameData) return { score: 0, breakdown: [], hasEquipmentData: false };

        let totalValue = 0;
        const breakdown = [];

        for (const [slot, itemData] of Object.entries(equippedItems)) {
            if (!itemData?.itemHrid) continue;

            const itemHrid = itemData.itemHrid;
            const itemDetails = gameData.itemDetailMap[itemHrid];
            if (!itemDetails) continue;

            // Categorize item by skill requirements
            const category = categorizeEquipmentItem(slot, itemDetails.equipmentDetail);

            // Filter by score type
            if (scoreType === 'combat' && !category.combat) {
                continue; // Skip non-combat items for combat score
            }
            if (scoreType === 'skiller' && !category.skiller) {
                continue; // Skip non-skilling items for skiller score
            }

            // Get enhancement level from itemData (separate field, not in HRID)
            const enhancementLevel = itemData.enhancementLevel || 0;

            let itemCost = 0;

            // First, check if this is a token-based back slot item (cape/cloak/quiver)
            const tokenValue = calculateTokenBasedItemValue(itemHrid);
            if (tokenValue > 0) {
                itemCost = tokenValue;
            } else {
                // Check if high enhancement cost mode is enabled
                const useHighEnhancementCost = config$1.getSetting('networth_highEnhancementUseCost');
                const minLevel = config$1.getSetting('networth_highEnhancementMinLevel') || 13;

                // For high enhancement levels, use cost instead of market price (if enabled)
                if (enhancementLevel >= 1 && useHighEnhancementCost && enhancementLevel >= minLevel) {
                    // Calculate enhancement cost (ignore market price)
                    const enhancementParams = getEnhancingParams();
                    const enhancementPath = calculateEnhancementPath(itemHrid, enhancementLevel, enhancementParams);

                    if (enhancementPath && enhancementPath.optimalStrategy) {
                        itemCost = enhancementPath.optimalStrategy.totalCost;
                    } else {
                        // Enhancement calculation failed, fallback to base item price
                        console.warn(
                            '[Combat Score] Enhancement calculation failed for:',
                            itemHrid,
                            '+' + enhancementLevel
                        );
                        const basePrice = getMarketPriceWithFallback(itemHrid, 0);
                        itemCost = basePrice;
                    }
                } else {
                    // Try market price first (ask price with crafting cost fallback)
                    const marketPrice = getMarketPriceWithFallback(itemHrid, enhancementLevel);

                    if (marketPrice && marketPrice > 0) {
                        itemCost = marketPrice;
                    } else if (enhancementLevel > 1) {
                        // No market data - calculate enhancement cost
                        const enhancementParams = getEnhancingParams();
                        const enhancementPath = calculateEnhancementPath(itemHrid, enhancementLevel, enhancementParams);

                        if (enhancementPath && enhancementPath.optimalStrategy) {
                            itemCost = enhancementPath.optimalStrategy.totalCost;
                        } else {
                            // Fallback to base market price if enhancement calculation fails
                            const basePrice = getMarketPriceWithFallback(itemHrid, 0);
                            itemCost = basePrice;
                        }
                    } else {
                        // Enhancement level 0 or 1, just use base market price with fallback
                        const basePrice = getMarketPriceWithFallback(itemHrid, 0);
                        itemCost = basePrice;
                    }
                }
            }

            totalValue += itemCost;

            // Format item name for display
            const itemName = itemDetails.name || itemHrid.replace('/items/', '');
            const displayName = enhancementLevel > 0 ? `${itemName} +${enhancementLevel}` : itemName;

            // Only add to breakdown if formatted value is not "0.0"
            // (items worth less than 50k coins round to 0.0 and clutter the display)
            const formattedValue = (itemCost / 1_000_000).toFixed(1);
            if (formattedValue !== '0.0') {
                breakdown.push({
                    name: displayName,
                    value: formattedValue,
                });
            }
        }

        // Convert to score (value / 1 million)
        const score = totalValue / 1_000_000;

        // Sort by value descending
        breakdown.sort((a, b) => parseFloat(b.value) - parseFloat(a.value));

        return { score, breakdown, hasEquipmentData };
    }

    /**
     * Utilities to parse the MWI character share modal into a urpt string
     * for https://tib-san.gitlab.io/mwi-character-sheet/. Food is not present in the modal, so it is
     * emitted as empty entries.
     *
     * Usage:
     *   import { buildCharacterSheetLink } from './character-sheet.js';
     *   const url = buildCharacterSheetLink(); // assumes modal is open in DOM
     */


    /**
     * Build character sheet segments from cached character data
     * @param {Object} characterData - Character data from dataManager or profile cache
     * @param {Object} clientData - Init client data for lookups
     * @param {Object} consumablesData - Optional character data containing consumables (for profile_shared data)
     * @returns {Object} Character sheet segments
     */
    function buildSegmentsFromCharacterData(characterData, clientData, consumablesData = null) {
        if (!characterData) {
            throw new Error('Character data is required');
        }

        // Use consumablesData if provided, otherwise try characterData
        const dataForConsumables = consumablesData || characterData;

        // Extract general info
        const character = characterData.sharableCharacter || characterData;
        const name = character.name || 'Player';

        // Avatar/outfit/icon - extract from sharableCharacter first, then fall back to items
        let avatar = 'person_default';
        let outfit = 'tshirt_default';
        let nameIcon = '';
        let nameColor = '';

        // Extract from sharableCharacter object (profile_shared data)
        if (character.avatarHrid) {
            avatar = character.avatarHrid.replace('/avatars/', '');
        }
        if (character.avatarOutfitHrid) {
            outfit = character.avatarOutfitHrid.replace('/avatar_outfits/', '');
        }
        if (character.chatIconHrid) {
            nameIcon = character.chatIconHrid.replace('/chat_icons/', '');
        }

        // Try to get avatar/outfit from character items
        if (characterData.characterItems) {
            for (const item of characterData.characterItems) {
                if (item.itemLocationHrid === '/item_locations/avatar') {
                    avatar = item.itemHrid.replace('/items/', '');
                } else if (item.itemLocationHrid === '/item_locations/outfit') {
                    outfit = item.itemHrid.replace('/items/', '');
                } else if (item.itemLocationHrid === '/item_locations/chat_icon') {
                    nameIcon = item.itemHrid.replace('/items/', '');
                }
            }
        }
        // Check wearableItemMap (for profile_shared data)
        else if (characterData.wearableItemMap) {
            if (characterData.wearableItemMap['/item_locations/avatar']) {
                avatar = characterData.wearableItemMap['/item_locations/avatar'].itemHrid.replace('/items/', '');
            }
            if (characterData.wearableItemMap['/item_locations/outfit']) {
                outfit = characterData.wearableItemMap['/item_locations/outfit'].itemHrid.replace('/items/', '');
            }
            if (characterData.wearableItemMap['/item_locations/chat_icon']) {
                nameIcon = characterData.wearableItemMap['/item_locations/chat_icon'].itemHrid.replace('/items/', '');
            }
        }

        // Name color - try to extract from character data
        if (character.chatBorderColorHrid) {
            nameColor = character.chatBorderColorHrid.replace('/chat_border_colors/', '');
        }

        const general = [name, avatar, outfit, nameIcon, nameColor].join(',');

        // Extract skills
        const skillMap = {};
        if (characterData.characterSkills) {
            for (const skill of characterData.characterSkills) {
                const skillName = skill.skillHrid.replace('/skills/', '');
                skillMap[skillName] = skill.level || 0;
            }
        }

        const skills = [
            skillMap.combat || '',
            skillMap.stamina || '',
            skillMap.intelligence || '',
            skillMap.attack || '',
            skillMap.defense || '',
            skillMap.melee || '',
            skillMap.ranged || '',
            skillMap.magic || '',
        ].join(',');

        // Extract equipment
        const equipmentSlots = {
            back: '',
            head: '',
            trinket: '',
            main_hand: '',
            body: '',
            off_hand: '',
            hands: '',
            legs: '',
            pouch: '',
            shoes: '',
            necklace: '',
            earrings: '',
            ring: '',
            charm: '',
        };

        const slotMapping = {
            // For characterItems (own character data)
            '/equipment_types/back': 'back',
            '/equipment_types/head': 'head',
            '/equipment_types/trinket': 'trinket',
            '/equipment_types/main_hand': 'main_hand',
            '/equipment_types/two_hand': 'main_hand',
            '/equipment_types/body': 'body',
            '/equipment_types/off_hand': 'off_hand',
            '/equipment_types/hands': 'hands',
            '/equipment_types/legs': 'legs',
            '/equipment_types/pouch': 'pouch',
            '/equipment_types/feet': 'shoes',
            '/equipment_types/neck': 'necklace',
            '/equipment_types/earrings': 'earrings',
            '/equipment_types/ring': 'ring',
            '/equipment_types/charm': 'charm',
            // For wearableItemMap (profile_shared data)
            '/item_locations/back': 'back',
            '/item_locations/head': 'head',
            '/item_locations/trinket': 'trinket',
            '/item_locations/main_hand': 'main_hand',
            '/item_locations/two_hand': 'main_hand',
            '/item_locations/body': 'body',
            '/item_locations/off_hand': 'off_hand',
            '/item_locations/hands': 'hands',
            '/item_locations/legs': 'legs',
            '/item_locations/pouch': 'pouch',
            '/item_locations/feet': 'shoes',
            '/item_locations/neck': 'necklace',
            '/item_locations/earrings': 'earrings',
            '/item_locations/ring': 'ring',
            '/item_locations/charm': 'charm',
        };

        if (characterData.characterItems) {
            for (const item of characterData.characterItems) {
                if (item.itemLocationHrid && item.itemLocationHrid.startsWith('/equipment_types/')) {
                    const slot = slotMapping[item.itemLocationHrid];
                    if (slot) {
                        const itemId = item.itemHrid.replace('/items/', '');
                        const enhancement = item.enhancementLevel || 0;
                        equipmentSlots[slot] = enhancement > 0 ? `${itemId}.${enhancement}` : `${itemId}.`;
                    }
                }
            }
        }
        // Check for wearableItemMap (profile data from other players)
        else if (characterData.wearableItemMap) {
            for (const key in characterData.wearableItemMap) {
                const item = characterData.wearableItemMap[key];
                const slot = slotMapping[item.itemLocationHrid];
                if (slot) {
                    const itemId = item.itemHrid.replace('/items/', '');
                    const enhancement = item.enhancementLevel || 0;
                    equipmentSlots[slot] = enhancement > 0 ? `${itemId}.${enhancement}` : `${itemId}.`;
                }
            }
        }

        const equipment = [
            equipmentSlots.back,
            equipmentSlots.head,
            equipmentSlots.trinket,
            equipmentSlots.main_hand,
            equipmentSlots.body,
            equipmentSlots.off_hand,
            equipmentSlots.hands,
            equipmentSlots.legs,
            equipmentSlots.pouch,
            equipmentSlots.shoes,
            equipmentSlots.necklace,
            equipmentSlots.earrings,
            equipmentSlots.ring,
            equipmentSlots.charm,
        ].join(',');

        // Extract abilities
        const abilitySlots = new Array(8).fill('');

        if (characterData.combatUnit?.combatAbilities || characterData.equippedAbilities) {
            // equippedAbilities (profile data) or combatUnit.combatAbilities (own character)
            const abilities = characterData.equippedAbilities || characterData.combatUnit?.combatAbilities || [];

            // Separate special and normal abilities
            let specialAbility = null;
            const normalAbilities = [];

            for (const ability of abilities) {
                if (!ability || !ability.abilityHrid) continue;

                const isSpecial = clientData?.abilityDetailMap?.[ability.abilityHrid]?.isSpecialAbility || false;

                if (isSpecial) {
                    specialAbility = ability;
                } else {
                    normalAbilities.push(ability);
                }
            }

            // Format abilities: slots 2-5 are normal abilities, slot 1 is special
            // But render-map expects them in order 1-8, so we need to rotate
            const orderedAbilities = [...normalAbilities.slice(0, 4)];
            if (specialAbility) {
                orderedAbilities.push(specialAbility);
            }

            orderedAbilities.forEach((ability, i) => {
                const abilityId = ability.abilityHrid.replace('/abilities/', '');
                const level = ability.level || 1;
                abilitySlots[i] = `${abilityId}.${level}`;
            });
        }

        const abilitiesStr = abilitySlots.join(',');

        // Extract food and drinks (consumables)
        // Use dataForConsumables (from parameter) instead of characterData
        const foodSlots = dataForConsumables.actionTypeFoodSlotsMap?.['/action_types/combat'];
        const drinkSlots = dataForConsumables.actionTypeDrinkSlotsMap?.['/action_types/combat'];
        const food = formatFoodData(foodSlots, drinkSlots);

        // Extract housing
        const housingLevels = {
            dining_room: '',
            library: '',
            dojo: '',
            armory: '',
            gym: '',
            archery_range: '',
            mystical_study: '',
        };

        const houseMapping = {
            '/house_rooms/dining_room': 'dining_room',
            '/house_rooms/library': 'library',
            '/house_rooms/dojo': 'dojo',
            '/house_rooms/armory': 'armory',
            '/house_rooms/gym': 'gym',
            '/house_rooms/archery_range': 'archery_range',
            '/house_rooms/mystical_study': 'mystical_study',
        };

        if (characterData.characterHouseRoomMap) {
            for (const [hrid, room] of Object.entries(characterData.characterHouseRoomMap)) {
                const key = houseMapping[hrid];
                if (key) {
                    housingLevels[key] = room.level || '';
                }
            }
        }

        const housing = [
            housingLevels.dining_room,
            housingLevels.library,
            housingLevels.dojo,
            housingLevels.armory,
            housingLevels.gym,
            housingLevels.archery_range,
            housingLevels.mystical_study,
        ].join(',');

        // Extract achievements (6 tiers: Beginner, Novice, Adept, Veteran, Elite, Champion)
        const achievementTiers = ['Beginner', 'Novice', 'Adept', 'Veteran', 'Elite', 'Champion'];
        const achievementFlags = new Array(6).fill('0');

        if (characterData.characterAchievements && clientData?.achievementDetailMap) {
            const tierCounts = {};

            // Count completed achievements by tier
            // characterAchievements only has achievementHrid and isCompleted
            // Need to look up tierHrid from achievementDetailMap
            for (const achievement of characterData.characterAchievements) {
                // Only count completed achievements
                if (!achievement.isCompleted || !achievement.achievementHrid) {
                    continue;
                }

                // Look up achievement details to get tier
                const achDetails = clientData.achievementDetailMap[achievement.achievementHrid];
                if (achDetails?.tierHrid) {
                    // Extract tier name from HRID: /achievement_tiers/veteran -> Veteran
                    const tierName = achDetails.tierHrid.replace('/achievement_tiers/', '');
                    const tierNameCapitalized = tierName.charAt(0).toUpperCase() + tierName.slice(1);
                    tierCounts[tierNameCapitalized] = (tierCounts[tierNameCapitalized] || 0) + 1;
                }
            }

            // Count total achievements per tier from achievementDetailMap
            const tierTotals = {};
            for (const achData of Object.values(clientData.achievementDetailMap)) {
                if (achData.tierHrid) {
                    // Extract tier name from HRID: /achievement_tiers/veteran -> Veteran
                    const tierName = achData.tierHrid.replace('/achievement_tiers/', '');
                    const tierNameCapitalized = tierName.charAt(0).toUpperCase() + tierName.slice(1);
                    tierTotals[tierNameCapitalized] = (tierTotals[tierNameCapitalized] || 0) + 1;
                }
            }

            // Set flags: 1 if tier is complete (have === total), 0 otherwise
            achievementTiers.forEach((tier, i) => {
                const have = tierCounts[tier] || 0;
                const total = tierTotals[tier] || 0;
                achievementFlags[i] = have > 0 && have === total ? '1' : '0';
            });
        }

        const achievements = achievementFlags.join('');

        return {
            general,
            skills,
            equipment,
            abilities: abilitiesStr,
            food,
            housing,
            achievements,
        };
    }

    function buildUrptString(segments) {
        if (!segments) throw new Error('Segments are required to build urpt');
        const { general, skills, equipment, abilities, food, housing, achievements } = segments;
        return [general, skills, equipment, abilities, food, housing, achievements].join(';');
    }

    /**
     * Format food and drink data for character sheet
     * @param {Array} foodSlots - Array of food items from actionTypeFoodSlotsMap
     * @param {Array} drinkSlots - Array of drink items from actionTypeDrinkSlotsMap
     * @returns {string} Comma-separated list of 6 item IDs (food 1-3, drink 1-3)
     */
    function formatFoodData(foodSlots, drinkSlots) {
        const slots = new Array(6).fill('');

        // Fill food slots (1-3)
        if (Array.isArray(foodSlots)) {
            foodSlots.slice(0, 3).forEach((item, i) => {
                if (item && item.itemHrid) {
                    // Strip '/items/' prefix
                    slots[i] = item.itemHrid.replace('/items/', '');
                }
            });
        }

        // Fill drink slots (4-6)
        if (Array.isArray(drinkSlots)) {
            drinkSlots.slice(0, 3).forEach((item, i) => {
                if (item && item.itemHrid) {
                    // Strip '/items/' prefix
                    slots[i + 3] = item.itemHrid.replace('/items/', '');
                }
            });
        }

        return slots.join(',');
    }

    /**
     * Extracts character data from the share modal and builds a render URL.
     * @param {Element} modal - Profile modal element (optional, for DOM fallback)
     * @param {string} baseUrl - Base URL for character sheet
     * @param {Object} characterData - Character data from cache (preferred)
     * @param {Object} clientData - Init client data for lookups
     * @param {Object} consumablesData - Optional character data containing consumables (for profile_shared data)
     * @returns {string} Character sheet URL
     */
    function buildCharacterSheetLink(
        _modal = document.querySelector('.SharableProfile_modal__2OmCQ'),
        baseUrl = 'https://tib-san.gitlab.io/mwi-character-sheet/',
        characterData = null,
        clientData = null,
        consumablesData = null
    ) {
        let segments;

        // Prefer cached character data over DOM parsing
        if (characterData && clientData) {
            segments = buildSegmentsFromCharacterData(characterData, clientData, consumablesData);
        } else {
            // DOM parsing fallback not yet implemented
            throw new Error('Character data and client data are required (DOM parsing not implemented)');
        }

        const urpt = buildUrptString(segments);
        const base = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;
        return `${base}?urpt=${urpt}`;
    }

    /**
     * Character Card Button
     * Provides View Card functionality that opens character sheet in new tab.
     * The button itself is rendered in the combat score panel template (combat-score.js).
     */


    /**
     * Convert combatConsumables array to actionTypeFoodSlotsMap/actionTypeDrinkSlotsMap format
     * @param {Array} combatConsumables - Array of consumable items from profile data
     * @param {Object} clientData - Init client data for item type lookups
     * @returns {Object} Object with actionTypeFoodSlotsMap and actionTypeDrinkSlotsMap
     */
    function convertCombatConsumablesToSlots(combatConsumables, clientData) {
        const foodSlots = [];
        const drinkSlots = [];

        // Separate food and drinks (matching combat sim logic)
        combatConsumables.forEach((consumable) => {
            const itemHrid = consumable.itemHrid;

            // Check if it's a drink
            const isDrink =
                itemHrid.includes('coffee') ||
                itemHrid.includes('tea') ||
                clientData?.itemDetailMap?.[itemHrid]?.tags?.includes('drink');

            if (isDrink && drinkSlots.length < 3) {
                drinkSlots.push({ itemHrid });
            } else if (!isDrink && foodSlots.length < 3) {
                foodSlots.push({ itemHrid });
            }
        });

        // Pad to 4 slots (3 used + 1 null)
        while (foodSlots.length < 4) foodSlots.push(null);
        while (drinkSlots.length < 4) drinkSlots.push(null);

        return {
            actionTypeFoodSlotsMap: {
                '/action_types/combat': foodSlots,
            },
            actionTypeDrinkSlotsMap: {
                '/action_types/combat': drinkSlots,
            },
        };
    }

    /**
     * Handle View Card button click - opens character sheet in new tab
     * @param {Object} profileData - Profile data from WebSocket (profile_shared event)
     */
    function handleViewCardClick(profileData) {
        try {
            const clientData = dataManager$1.getInitClientData();

            // Determine if viewing own profile or someone else's
            let characterData = null;

            // If we have profile data from profile_shared event, use it (other player)
            if (profileData?.profile) {
                characterData = profileData.profile;
            }
            // Otherwise use own character data from dataManager
            else {
                characterData = dataManager$1.characterData;
            }

            if (!characterData) {
                console.error('[CharacterCardButton] No character data available');
                return;
            }

            // Determine consumables data source
            let consumablesData = null;

            // If viewing own profile, use own character data (has actionTypeFoodSlotsMap/actionTypeDrinkSlotsMap)
            if (!profileData?.profile) {
                consumablesData = dataManager$1.characterData;
            }
            // If viewing other player, check if they have combatConsumables (only visible in party)
            else if (characterData.combatConsumables && characterData.combatConsumables.length > 0) {
                // Convert combatConsumables array to expected format
                consumablesData = convertCombatConsumablesToSlots(characterData.combatConsumables, clientData);
            }
            // Otherwise leave consumables empty (can't see other player's consumables outside party)

            // Find the profile modal for fallback
            const _modal = document.querySelector('.SharableProfile_modal__2OmCQ');

            // Build character sheet link using cached data (preferred) or DOM fallback
            const url = buildCharacterSheetLink(
                _modal,
                'https://tib-san.gitlab.io/mwi-character-sheet/',
                characterData,
                clientData,
                consumablesData
            );

            // Open in new tab
            window.open(url, '_blank');
        } catch (error) {
            console.error('[CharacterCardButton] Failed to open character card:', error);
        }
    }

    /**
     * CharacterCardButton class - minimal feature registry interface.
     * The View Card button is now rendered directly in the combat score panel template.
     */
    class CharacterCardButton {
        constructor() {
            this.isActive = false;
            this.isInitialized = false;
        }

        /**
         * Setup settings listeners for color changes
         */
        setupSettingListener() {
            config$1.onSettingChange('characterCard', (value) => {
                if (value) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('color_accent', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize character card button feature
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('characterCard')) {
                return;
            }

            this.isInitialized = true;
            this.isActive = true;
        }

        /**
         * Refresh colors on existing button
         */
        refresh() {
            const button = document.getElementById('mwi-character-card-btn');
            if (button) {
                button.style.background = config$1.COLOR_ACCENT;
            }
        }

        /**
         * Disable the feature
         */
        disable() {
            // Remove button from DOM if present
            const button = document.getElementById('mwi-character-card-btn');
            if (button) {
                button.remove();
            }

            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const characterCardButton = new CharacterCardButton();
    characterCardButton.setupSettingListener();

    /**
     * Combat Score Display
     * Shows player gear score in a floating panel next to profile modal
     */


    /**
     * CombatScore class manages combat score display on profiles
     */
    class CombatScore {
        constructor() {
            this.isActive = false;
            this.currentPanel = null;
            this.currentAbilitiesPanel = null;
            this.isInitialized = false;
            this.profileSharedHandler = null; // Store handler reference for cleanup
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Setup settings listeners for feature toggle and color changes
         */
        setupSettingListener() {
            config$1.onSettingChange('combatScore', (value) => {
                if (value) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('abilitiesTriggers', (value) => {
                if (!value && this.currentAbilitiesPanel) {
                    this.currentAbilitiesPanel.remove();
                    this.currentAbilitiesPanel = null;
                }
            });

            config$1.onSettingChange('color_accent', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize combat score feature
         */
        initialize() {
            // Guard FIRST (before feature check)
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('combatScore')) {
                return;
            }

            this.isInitialized = true;

            this.profileSharedHandler = (data) => {
                this.handleProfileShared(data);
            };

            // Listen for profile_shared WebSocket messages
            webSocketHook$1.on('profile_shared', this.profileSharedHandler);

            this.isActive = true;
        }

        /**
         * Handle profile_shared WebSocket message
         * @param {Object} profileData - Profile data from WebSocket
         */
        async handleProfileShared(profileData) {
            // Extract character ID from profile data
            const characterId =
                profileData.profile.sharableCharacter?.id ||
                profileData.profile.characterSkills?.[0]?.characterID ||
                profileData.profile.character?.id;

            // Store the profile ID so export button can find it
            await storage$1.set('currentProfileId', characterId, 'combatExport', true);

            // Note: Memory cache is handled by websocket.js listener (don't duplicate here)

            // Wait for profile panel to appear in DOM
            const profilePanel = await this.waitForProfilePanel();
            if (!profilePanel) {
                console.error('[CombatScore] Could not find profile panel');
                return;
            }

            // Find the modal container
            const modalContainer =
                profilePanel.closest('.Modal_modalContent__Iw0Yv') ||
                profilePanel.closest('[class*="Modal"]') ||
                profilePanel.parentElement;

            if (modalContainer) {
                await this.handleProfileOpen(profileData, modalContainer);
            }
        }

        /**
         * Wait for profile panel to appear in DOM
         * @returns {Promise<Element|null>} Profile panel element or null if timeout
         */
        async waitForProfilePanel() {
            for (let i = 0; i < 20; i++) {
                const panel = document.querySelector('div.SharableProfile_overviewTab__W4dCV');
                if (panel) {
                    return panel;
                }
                await new Promise((resolve) => setTimeout(resolve, 100));
            }
            return null;
        }

        /**
         * Handle profile modal opening
         * @param {Object} profileData - Profile data from WebSocket
         * @param {Element} modalContainer - Modal container element
         */
        async handleProfileOpen(profileData, modalContainer) {
            try {
                // Calculate combat score
                const scoreData = await calculateCombatScore(profileData);

                // Display score panel
                this.showScorePanel(profileData, scoreData, modalContainer);

                // Display abilities & triggers panel below profile (if enabled)
                if (config$1.getSetting('abilitiesTriggers')) {
                    this.showAbilitiesTriggersPanel(profileData, modalContainer);
                }
            } catch (error) {
                console.error('[CombatScore] Error handling profile:', error);
            }
        }

        /**
         * Show combat score panel next to profile
         * @param {Object} profileData - Profile data
         * @param {Object} scoreData - Calculated score data
         * @param {Element} modalContainer - Modal container element
         */
        showScorePanel(profileData, scoreData, modalContainer) {
            // Remove existing panel if any
            if (this.currentPanel) {
                this.currentPanel.remove();
                this.currentPanel = null;
            }

            const playerName = profileData.profile?.sharableCharacter?.name || 'Player';
            const equipmentHiddenText =
                scoreData.equipmentHidden && !scoreData.hasEquipmentData ? ' (Equipment hidden)' : '';

            // Create panel element
            const panel = document.createElement('div');
            panel.id = 'mwi-combat-score-panel';
            panel.style.cssText = `
            position: fixed;
            background: rgba(30, 30, 30, 0.98);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            min-width: 180px;
            max-width: 280px;
            font-size: 0.875rem;
            z-index: 10001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        `;

            // Build house breakdown HTML
            const houseBreakdownHTML = scoreData.breakdown.houses
                .map(
                    (item) =>
                        `<div style="margin-left: 10px; font-size: 0.8rem; color: ${config$1.COLOR_TEXT_SECONDARY};">${item.name}: ${item.value}</div>`
                )
                .join('');

            // Build ability breakdown HTML
            const abilityBreakdownHTML = scoreData.breakdown.abilities
                .map(
                    (item) =>
                        `<div style="margin-left: 10px; font-size: 0.8rem; color: ${config$1.COLOR_TEXT_SECONDARY};">${item.name}: ${item.value}</div>`
                )
                .join('');

            // Build equipment breakdown HTML
            const equipmentBreakdownHTML = scoreData.breakdown.equipment
                .map(
                    (item) =>
                        `<div style="margin-left: 10px; font-size: 0.8rem; color: ${config$1.COLOR_TEXT_SECONDARY};">${item.name}: ${item.value}</div>`
                )
                .join('');

            // Build skiller equipment breakdown HTML
            const skillerEquipmentBreakdownHTML = scoreData.skillerBreakdown.equipment
                .map(
                    (item) =>
                        `<div style="margin-left: 10px; font-size: 0.8rem; color: ${config$1.COLOR_TEXT_SECONDARY};">${item.name}: ${item.value}</div>`
                )
                .join('');

            // Build View Card button HTML (only if characterCard setting is enabled)
            const viewCardButtonHTML = config$1.getSetting('characterCard')
                ? `<button id="mwi-character-card-btn" style="
                    padding: 8px 12px;
                    background: ${config$1.COLOR_ACCENT};
                    color: black;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 0.85rem;
                    width: 100%;
                ">View Card</button>`
                : '';

            // Create panel HTML
            panel.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                <div style="font-weight: bold; color: ${config$1.COLOR_ACCENT}; font-size: 0.9rem;">${playerName}</div>
                <span id="mwi-score-close-btn" style="
                    cursor: pointer;
                    font-size: 18px;
                    color: #aaa;
                    padding: 0 5px;
                    line-height: 1;
                " title="Close">×</span>
            </div>
            <div style="cursor: pointer; font-weight: bold; margin-bottom: 8px; color: ${config$1.COLOR_PROFIT};" id="mwi-score-toggle">
                + Combat Score: ${numberFormatter(scoreData.total.toFixed(1))}${equipmentHiddenText}
            </div>
            <div id="mwi-score-details" style="display: none; margin-left: 10px; color: ${config$1.COLOR_TEXT_PRIMARY};">
                <div style="cursor: pointer; margin-bottom: 4px;" id="mwi-house-toggle">
                    + House: ${numberFormatter(scoreData.house.toFixed(1))}
                </div>
                <div id="mwi-house-breakdown" style="display: none; margin-bottom: 6px;">
                    ${houseBreakdownHTML}
                </div>

                <div style="cursor: pointer; margin-bottom: 4px;" id="mwi-ability-toggle">
                    + Ability: ${numberFormatter(scoreData.ability.toFixed(1))}
                </div>
                <div id="mwi-ability-breakdown" style="display: none; margin-bottom: 6px;">
                    ${abilityBreakdownHTML}
                </div>

                <div style="cursor: pointer; margin-bottom: 4px;" id="mwi-equipment-toggle">
                    + Equipment: ${numberFormatter(scoreData.equipment.toFixed(1))}
                </div>
                <div id="mwi-equipment-breakdown" style="display: none;">
                    ${equipmentBreakdownHTML}
                </div>
            </div>

            <div style="cursor: pointer; font-weight: bold; margin-top: 12px; margin-bottom: 8px; color: ${config$1.COLOR_PROFIT};" id="mwi-skiller-score-toggle">
                + Skiller Score: ${numberFormatter(scoreData.skillerTotal.toFixed(1))}
            </div>
            <div id="mwi-skiller-score-details" style="display: none; margin-left: 10px; color: ${config$1.COLOR_TEXT_PRIMARY};">
                <div style="cursor: pointer; margin-bottom: 4px;" id="mwi-skiller-equipment-toggle">
                    + Equipment: ${numberFormatter(scoreData.skillerEquipment.toFixed(1))}
                </div>
                <div id="mwi-skiller-equipment-breakdown" style="display: none;">
                    ${skillerEquipmentBreakdownHTML}
                </div>
            </div>

            <div id="mwi-button-container" style="margin-top: 12px; display: flex; flex-direction: column; gap: 6px;">
                <button id="mwi-combat-sim-export-btn" style="
                    padding: 8px 12px;
                    background: ${config$1.COLOR_ACCENT};
                    color: black;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 0.85rem;
                    width: 100%;
                ">Combat Sim Export</button>
                <button id="mwi-milkonomy-export-btn" style="
                    padding: 8px 12px;
                    background: ${config$1.COLOR_ACCENT};
                    color: black;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 0.85rem;
                    width: 100%;
                ">Milkonomy Export</button>
                ${viewCardButtonHTML}
            </div>
        `;

            document.body.appendChild(panel);
            this.currentPanel = panel;

            // Position panel next to modal
            this.positionPanel(panel, modalContainer);

            // Set up event listeners
            this.setupPanelEvents(panel, modalContainer, scoreData, equipmentHiddenText, profileData);

            // Set up cleanup observer
            this.setupCleanupObserver(panel, modalContainer);
        }

        /**
         * Position panel next to the modal
         * @param {Element} panel - Score panel element
         * @param {Element} modal - Modal container element
         */
        positionPanel(panel, modal) {
            const modalRect = modal.getBoundingClientRect();
            const panelWidth = 220;
            const gap = 8;

            // Try left side first
            if (modalRect.left - gap - panelWidth >= 10) {
                panel.style.left = modalRect.left - panelWidth - gap + 'px';
            } else {
                // Fall back to right side
                panel.style.left = modalRect.right + gap + 'px';
            }

            panel.style.top = modalRect.top + 'px';
        }

        /**
         * Set up panel event listeners
         * @param {Element} panel - Score panel element
         * @param {Element} modal - Modal container element
         * @param {Object} scoreData - Score data
         * @param {string} equipmentHiddenText - Equipment hidden text
         * @param {Object} profileData - Profile data from WebSocket
         */
        setupPanelEvents(panel, modal, scoreData, equipmentHiddenText, profileData) {
            // Close button
            const closeBtn = panel.querySelector('#mwi-score-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    panel.remove();
                    this.currentPanel = null;
                });
                closeBtn.addEventListener('mouseover', () => {
                    closeBtn.style.color = '#fff';
                });
                closeBtn.addEventListener('mouseout', () => {
                    closeBtn.style.color = '#aaa';
                });
            }

            // Toggle main score details
            const toggleBtn = panel.querySelector('#mwi-score-toggle');
            const details = panel.querySelector('#mwi-score-details');
            if (toggleBtn && details) {
                toggleBtn.addEventListener('click', () => {
                    const isCollapsed = details.style.display === 'none';
                    details.style.display = isCollapsed ? 'block' : 'none';
                    toggleBtn.textContent =
                        (isCollapsed ? '- ' : '+ ') +
                        `Combat Score: ${numberFormatter(scoreData.total.toFixed(1))}${equipmentHiddenText}`;
                });
            }

            // Toggle house breakdown
            const houseToggle = panel.querySelector('#mwi-house-toggle');
            const houseBreakdown = panel.querySelector('#mwi-house-breakdown');
            if (houseToggle && houseBreakdown) {
                houseToggle.addEventListener('click', () => {
                    const isCollapsed = houseBreakdown.style.display === 'none';
                    houseBreakdown.style.display = isCollapsed ? 'block' : 'none';
                    houseToggle.textContent =
                        (isCollapsed ? '- ' : '+ ') + `House: ${numberFormatter(scoreData.house.toFixed(1))}`;
                });
            }

            // Toggle ability breakdown
            const abilityToggle = panel.querySelector('#mwi-ability-toggle');
            const abilityBreakdown = panel.querySelector('#mwi-ability-breakdown');
            if (abilityToggle && abilityBreakdown) {
                abilityToggle.addEventListener('click', () => {
                    const isCollapsed = abilityBreakdown.style.display === 'none';
                    abilityBreakdown.style.display = isCollapsed ? 'block' : 'none';
                    abilityToggle.textContent =
                        (isCollapsed ? '- ' : '+ ') + `Ability: ${numberFormatter(scoreData.ability.toFixed(1))}`;
                });
            }

            // Toggle equipment breakdown
            const equipmentToggle = panel.querySelector('#mwi-equipment-toggle');
            const equipmentBreakdown = panel.querySelector('#mwi-equipment-breakdown');
            if (equipmentToggle && equipmentBreakdown) {
                equipmentToggle.addEventListener('click', () => {
                    const isCollapsed = equipmentBreakdown.style.display === 'none';
                    equipmentBreakdown.style.display = isCollapsed ? 'block' : 'none';
                    equipmentToggle.textContent =
                        (isCollapsed ? '- ' : '+ ') + `Equipment: ${numberFormatter(scoreData.equipment.toFixed(1))}`;
                });
            }

            // Toggle skiller score details
            const skillerScoreToggle = panel.querySelector('#mwi-skiller-score-toggle');
            const skillerScoreDetails = panel.querySelector('#mwi-skiller-score-details');
            if (skillerScoreToggle && skillerScoreDetails) {
                skillerScoreToggle.addEventListener('click', () => {
                    const isCollapsed = skillerScoreDetails.style.display === 'none';
                    skillerScoreDetails.style.display = isCollapsed ? 'block' : 'none';
                    skillerScoreToggle.textContent =
                        (isCollapsed ? '- ' : '+ ') +
                        `Skiller Score: ${numberFormatter(scoreData.skillerTotal.toFixed(1))}`;
                });
            }

            // Toggle skiller equipment breakdown
            const skillerEquipmentToggle = panel.querySelector('#mwi-skiller-equipment-toggle');
            const skillerEquipmentBreakdown = panel.querySelector('#mwi-skiller-equipment-breakdown');
            if (skillerEquipmentToggle && skillerEquipmentBreakdown) {
                skillerEquipmentToggle.addEventListener('click', () => {
                    const isCollapsed = skillerEquipmentBreakdown.style.display === 'none';
                    skillerEquipmentBreakdown.style.display = isCollapsed ? 'block' : 'none';
                    skillerEquipmentToggle.textContent =
                        (isCollapsed ? '- ' : '+ ') +
                        `Equipment: ${numberFormatter(scoreData.skillerEquipment.toFixed(1))}`;
                });
            }

            // Combat Sim Export button
            const combatSimBtn = panel.querySelector('#mwi-combat-sim-export-btn');
            if (combatSimBtn) {
                combatSimBtn.addEventListener('click', async () => {
                    await this.handleCombatSimExport(combatSimBtn);
                });
                combatSimBtn.addEventListener('mouseenter', () => {
                    combatSimBtn.style.opacity = '0.8';
                });
                combatSimBtn.addEventListener('mouseleave', () => {
                    combatSimBtn.style.opacity = '1';
                });
            }

            // Milkonomy Export button
            const milkonomyBtn = panel.querySelector('#mwi-milkonomy-export-btn');
            if (milkonomyBtn) {
                milkonomyBtn.addEventListener('click', async () => {
                    await this.handleMilkonomyExport(milkonomyBtn);
                });
                milkonomyBtn.addEventListener('mouseenter', () => {
                    milkonomyBtn.style.opacity = '0.8';
                });
                milkonomyBtn.addEventListener('mouseleave', () => {
                    milkonomyBtn.style.opacity = '1';
                });
            }

            // View Card button
            const viewCardBtn = panel.querySelector('#mwi-character-card-btn');
            if (viewCardBtn) {
                viewCardBtn.addEventListener('click', () => {
                    handleViewCardClick(profileData);
                });
                viewCardBtn.addEventListener('mouseenter', () => {
                    viewCardBtn.style.opacity = '0.8';
                });
                viewCardBtn.addEventListener('mouseleave', () => {
                    viewCardBtn.style.opacity = '1';
                });
            }
        }

        /**
         * Show abilities & triggers panel below profile
         * @param {Object} profileData - Profile data
         * @param {Element} modalContainer - Modal container element
         */
        showAbilitiesTriggersPanel(profileData, modalContainer) {
            // Remove existing abilities panel if any
            if (this.currentAbilitiesPanel) {
                this.currentAbilitiesPanel.remove();
                this.currentAbilitiesPanel = null;
            }

            // Build abilities and triggers HTML
            const abilitiesTriggersHTML = this.buildAbilitiesTriggersHTML(profileData);

            // Don't show panel if no data
            if (!abilitiesTriggersHTML) {
                return;
            }

            const playerName = profileData.profile?.sharableCharacter?.name || 'Player';

            // Create panel element
            const panel = document.createElement('div');
            panel.id = 'mwi-abilities-triggers-panel';
            panel.style.cssText = `
            position: fixed;
            background: rgba(30, 30, 30, 0.98);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            min-width: 300px;
            max-width: 400px;
            max-height: 200px;
            font-size: 0.875rem;
            z-index: 10001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        `;

            // Create panel HTML
            panel.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; flex-shrink: 0;">
                <div style="font-weight: bold; color: ${config$1.COLOR_ACCENT}; font-size: 0.9rem;">${playerName} - Abilities & Triggers</div>
                <span id="mwi-abilities-close-btn" style="
                    cursor: pointer;
                    font-size: 18px;
                    color: #aaa;
                    padding: 0 5px;
                    line-height: 1;
                " title="Close">×</span>
            </div>
            <div style="cursor: pointer; font-weight: bold; margin-bottom: 8px; color: ${config$1.COLOR_ACCENT}; flex-shrink: 0;" id="mwi-abilities-toggle">
                + Show Details
            </div>
            <div id="mwi-abilities-details" style="display: none; overflow-y: auto; flex: 1; min-height: 0;">
                ${abilitiesTriggersHTML}
            </div>
        `;

            document.body.appendChild(panel);
            this.currentAbilitiesPanel = panel;

            // Position panel below modal
            this.positionAbilitiesPanel(panel, modalContainer);

            // Set up event listeners
            this.setupAbilitiesPanelEvents(panel);

            // Set up cleanup observer
            this.setupAbilitiesCleanupObserver(panel, modalContainer);
        }

        /**
         * Position abilities panel below the modal
         * @param {Element} panel - Abilities panel element
         * @param {Element} modal - Modal container element
         */
        positionAbilitiesPanel(panel, modal) {
            const modalRect = modal.getBoundingClientRect();
            const gap = 8;

            // Center panel horizontally under modal
            const panelWidth = panel.offsetWidth || 300;
            const modalCenter = modalRect.left + modalRect.width / 2;
            const panelLeft = modalCenter - panelWidth / 2;

            panel.style.left = Math.max(10, panelLeft) + 'px';

            // Position below modal, but ensure it doesn't go off screen
            const topPosition = modalRect.bottom + gap;
            const viewportHeight = window.innerHeight;
            const panelHeight = panel.offsetHeight || 300;

            // If panel would go off bottom of screen, adjust position or reduce height
            if (topPosition + panelHeight > viewportHeight - 10) {
                const availableHeight = viewportHeight - topPosition - 10;
                if (availableHeight < 200) {
                    // Not enough space below - position above modal instead
                    panel.style.top = Math.max(10, modalRect.top - panelHeight - gap) + 'px';
                } else {
                    // Limit height to fit available space
                    panel.style.top = topPosition + 'px';
                    panel.style.maxHeight = availableHeight + 'px';
                }
            } else {
                panel.style.top = topPosition + 'px';
            }
        }

        /**
         * Set up abilities panel event listeners
         * @param {Element} panel - Abilities panel element
         */
        setupAbilitiesPanelEvents(panel) {
            // Close button
            const closeBtn = panel.querySelector('#mwi-abilities-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    panel.remove();
                    this.currentAbilitiesPanel = null;
                });
                closeBtn.addEventListener('mouseover', () => {
                    closeBtn.style.color = '#fff';
                });
                closeBtn.addEventListener('mouseout', () => {
                    closeBtn.style.color = '#aaa';
                });
            }

            // Toggle details
            const toggleBtn = panel.querySelector('#mwi-abilities-toggle');
            const details = panel.querySelector('#mwi-abilities-details');
            if (toggleBtn && details) {
                toggleBtn.addEventListener('click', () => {
                    const isCollapsed = details.style.display === 'none';
                    details.style.display = isCollapsed ? 'block' : 'none';
                    toggleBtn.textContent = (isCollapsed ? '- ' : '+ ') + (isCollapsed ? 'Hide Details' : 'Show Details');
                });
            }
        }

        /**
         * Set up cleanup observer for abilities panel
         * @param {Element} panel - Abilities panel element
         * @param {Element} modal - Modal container element
         */
        setupAbilitiesCleanupObserver(panel, modal) {
            // Defensive check for document.body
            if (!document.body) {
                console.warn('[Combat Score] document.body not available for abilities cleanup observer');
                return;
            }

            const cleanupObserver = createMutationWatcher(
                document.body,
                () => {
                    if (
                        !document.body.contains(modal) ||
                        !document.querySelector('div.SharableProfile_overviewTab__W4dCV')
                    ) {
                        panel.remove();
                        this.currentAbilitiesPanel = null;
                        cleanupObserver();
                    }
                },
                {
                    childList: true,
                    subtree: true,
                }
            );
        }

        /**
         * Set up cleanup observer to remove panel when modal closes
         * @param {Element} panel - Score panel element
         * @param {Element} modal - Modal container element
         */
        setupCleanupObserver(panel, modal) {
            // Defensive check for document.body
            if (!document.body) {
                console.warn('[Combat Score] document.body not available for cleanup observer');
                return;
            }

            const cleanupObserver = createMutationWatcher(
                document.body,
                () => {
                    if (
                        !document.body.contains(modal) ||
                        !document.querySelector('div.SharableProfile_overviewTab__W4dCV')
                    ) {
                        panel.remove();
                        this.currentPanel = null;
                        cleanupObserver();
                    }
                },
                {
                    childList: true,
                    subtree: true,
                }
            );
        }

        /**
         * Handle Combat Sim Export button click
         * @param {Element} button - Button element
         */
        async handleCombatSimExport(button) {
            const originalText = button.textContent;
            const originalBg = button.style.background;

            try {
                // Get current profile ID (if viewing someone else's profile)
                const currentProfileId = await storage$1.get('currentProfileId', 'combatExport', null);

                // Get export data in single-player format (for pasting into "Player 1 import" field)
                const exportData = await constructExportObject(currentProfileId, true);
                if (!exportData) {
                    button.textContent = '✗ No Data';
                    button.style.background = '${config.COLOR_LOSS}';
                    const resetTimeout = setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = originalBg;
                    }, 3000);
                    this.timerRegistry.registerTimeout(resetTimeout);
                    return;
                }

                const exportString = JSON.stringify(exportData.exportObj);
                await navigator.clipboard.writeText(exportString);

                button.textContent = '✓ Copied';
                button.style.background = '${config.COLOR_PROFIT}';
                const resetTimeout = setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = originalBg;
                }, 3000);
                this.timerRegistry.registerTimeout(resetTimeout);
            } catch (error) {
                console.error('[Combat Score] Combat Sim export failed:', error);
                button.textContent = '✗ Failed';
                button.style.background = '${config.COLOR_LOSS}';
                const resetTimeout = setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = originalBg;
                }, 3000);
                this.timerRegistry.registerTimeout(resetTimeout);
            }
        }

        /**
         * Handle Milkonomy Export button click
         * @param {Element} button - Button element
         */
        async handleMilkonomyExport(button) {
            const originalText = button.textContent;
            const originalBg = button.style.background;

            try {
                // Defensive: ensure currentProfileId is null when exporting own profile
                // This prevents stale data from blocking export
                await storage$1.set('currentProfileId', null, 'combatExport', true);
                clearCurrentProfile();

                // Get current profile ID (should be null for own profile)
                const currentProfileId = await storage$1.get('currentProfileId', 'combatExport', null);

                // Get export data (pass profile ID if viewing external profile)
                const exportData = await constructMilkonomyExport(currentProfileId);
                if (!exportData) {
                    button.textContent = '✗ No Data';
                    button.style.background = '${config.COLOR_LOSS}';
                    const resetTimeout = setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = originalBg;
                    }, 3000);
                    this.timerRegistry.registerTimeout(resetTimeout);
                    return;
                }

                const exportString = JSON.stringify(exportData);
                await navigator.clipboard.writeText(exportString);

                button.textContent = '✓ Copied';
                button.style.background = '${config.COLOR_PROFIT}';
                const resetTimeout = setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = originalBg;
                }, 3000);
                this.timerRegistry.registerTimeout(resetTimeout);
            } catch (error) {
                console.error('[Combat Score] Milkonomy export failed:', error);
                button.textContent = '✗ Failed';
                button.style.background = '${config.COLOR_LOSS}';
                const resetTimeout = setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = originalBg;
                }, 3000);
                this.timerRegistry.registerTimeout(resetTimeout);
            }
        }

        /**
         * Refresh colors on existing panel
         */
        refresh() {
            if (!this.currentPanel) return;

            // Update title color
            const titleElem = this.currentPanel.querySelector('div[style*="font-weight: bold"]');
            if (titleElem) {
                titleElem.style.color = config$1.COLOR_ACCENT;
            }

            // Update all panel buttons
            const buttons = this.currentPanel.querySelectorAll('#mwi-button-container button');
            buttons.forEach((button) => {
                button.style.background = config$1.COLOR_ACCENT;
            });
        }

        /**
         * Format trigger dependency to readable text
         * @param {string} dependencyHrid - Dependency HRID
         * @returns {string} Readable dependency
         */
        formatDependency(dependencyHrid) {
            const map = {
                '/combat_trigger_dependencies/self': 'Self',
                '/combat_trigger_dependencies/targeted_enemy': 'Target',
                '/combat_trigger_dependencies/all_enemies': 'All Enemies',
                '/combat_trigger_dependencies/all_allies': 'All Allies',
            };
            return map[dependencyHrid] || dependencyHrid.split('/').pop().replace(/_/g, ' ');
        }

        /**
         * Format trigger condition to readable text
         * @param {string} conditionHrid - Condition HRID
         * @returns {string} Readable condition
         */
        formatCondition(conditionHrid) {
            const map = {
                '/combat_trigger_conditions/current_hp': 'HP',
                '/combat_trigger_conditions/missing_hp': 'Missing HP',
                '/combat_trigger_conditions/current_mp': 'MP',
                '/combat_trigger_conditions/missing_mp': 'Missing MP',
                '/combat_trigger_conditions/number_of_active_units': 'Active Units',
            };
            if (map[conditionHrid]) return map[conditionHrid];

            // Fallback: extract name from HRID and title case
            const name = conditionHrid.split('/').pop().replace(/_/g, ' ');
            return name
                .split(' ')
                .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
                .join(' ');
        }

        /**
         * Format trigger comparator to symbol
         * @param {string} comparatorHrid - Comparator HRID
         * @returns {string} Symbol or text
         */
        formatComparator(comparatorHrid) {
            const map = {
                '/combat_trigger_comparators/greater_than_equal': '≥',
                '/combat_trigger_comparators/less_than_equal': '≤',
                '/combat_trigger_comparators/greater_than': '>',
                '/combat_trigger_comparators/less_than': '<',
                '/combat_trigger_comparators/equal': '=',
                '/combat_trigger_comparators/is_active': 'is active',
                '/combat_trigger_comparators/is_inactive': 'is inactive',
            };
            return map[comparatorHrid] || comparatorHrid.split('/').pop().replace(/_/g, ' ');
        }

        /**
         * Format a single trigger condition
         * @param {Object} condition - Trigger condition object
         * @returns {string} Formatted condition string
         */
        formatTriggerCondition(condition) {
            const dependency = this.formatDependency(condition.dependencyHrid);
            const conditionName = this.formatCondition(condition.conditionHrid);
            const comparator = this.formatComparator(condition.comparatorHrid);

            // Handle is_active/is_inactive specially
            if (comparator === 'is active' || comparator === 'is inactive') {
                return `${dependency}: ${conditionName} ${comparator}`;
            }

            return `${dependency}: ${conditionName} ${comparator} ${condition.value}`;
        }

        /**
         * Format array of trigger conditions (AND logic)
         * @param {Array} conditions - Array of trigger conditions
         * @returns {string} Formatted trigger string
         */
        formatTriggers(conditions) {
            if (!conditions || conditions.length === 0) return 'No trigger';

            return conditions.map((c) => this.formatTriggerCondition(c)).join(' AND ');
        }

        /**
         * Get the current abilities sprite URL from the DOM
         * @returns {string|null} Abilities sprite URL or null if not found
         */
        getAbilitiesSpriteUrl() {
            const abilityIcon = document.querySelector('use[href*="abilities_sprite"]');
            if (!abilityIcon) {
                return null;
            }
            const href = abilityIcon.getAttribute('href');
            return href ? href.split('#')[0] : null;
        }

        /**
         * Get the current items sprite URL from the DOM
         * @returns {string|null} Items sprite URL or null if not found
         */
        getItemsSpriteUrl() {
            const itemIcon = document.querySelector('use[href*="items_sprite"]');
            if (!itemIcon) {
                return null;
            }
            const href = itemIcon.getAttribute('href');
            return href ? href.split('#')[0] : null;
        }

        /**
         * Build abilities and triggers HTML
         * @param {Object} profileData - Profile data from WebSocket
         * @returns {string} HTML string for abilities/triggers section
         */
        buildAbilitiesTriggersHTML(profileData) {
            const abilities = profileData.profile?.equippedAbilities || [];
            const abilityTriggers = profileData.profile?.abilityCombatTriggersMap || {};
            const consumableTriggers = profileData.profile?.consumableCombatTriggersMap || {};

            if (
                abilities.length === 0 &&
                Object.keys(abilityTriggers).length === 0 &&
                Object.keys(consumableTriggers).length === 0
            ) {
                return ''; // Don't show section if no data
            }

            // Get sprite URLs
            const abilitiesSpriteUrl = this.getAbilitiesSpriteUrl();
            const itemsSpriteUrl = this.getItemsSpriteUrl();

            let html = '';

            // Build abilities section
            if (abilities.length > 0 && abilitiesSpriteUrl) {
                for (const ability of abilities) {
                    const abilityIconId = ability.abilityHrid.split('/').pop();
                    const triggers = abilityTriggers[ability.abilityHrid];
                    const triggerText = triggers ? this.formatTriggers(triggers) : 'No trigger';

                    html += `
                    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 6px;">
                        <svg role="img" aria-label="Ability" style="width: 24px; height: 24px; flex-shrink: 0;">
                            <use href="${abilitiesSpriteUrl}#${abilityIconId}"></use>
                        </svg>
                        <span style="font-size: 0.75rem; color: #999; line-height: 1.3;">${triggerText}</span>
                    </div>
                `;
                }
            }

            // Build consumables section
            const consumableKeys = Object.keys(consumableTriggers);
            if (consumableKeys.length > 0 && itemsSpriteUrl) {
                if (abilities.length > 0) {
                    html += `<div style="margin-top: 6px; margin-bottom: 6px; font-weight: 600; color: ${config$1.COLOR_TEXT_SECONDARY}; font-size: 0.85rem;">Food & Drinks</div>`;
                }

                for (const itemHrid of consumableKeys) {
                    const itemIconId = itemHrid.split('/').pop();
                    const triggers = consumableTriggers[itemHrid];
                    const triggerText = triggers ? this.formatTriggers(triggers) : 'No trigger';

                    html += `
                    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 6px;">
                        <svg role="img" aria-label="Item" style="width: 24px; height: 24px; flex-shrink: 0;">
                            <use href="${itemsSpriteUrl}#${itemIconId}"></use>
                        </svg>
                        <span style="font-size: 0.75rem; color: #999; line-height: 1.3;">${triggerText}</span>
                    </div>
                `;
                }
            }

            return html;
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.profileSharedHandler) {
                webSocketHook$1.off('profile_shared', this.profileSharedHandler);
                this.profileSharedHandler = null;
            }

            this.timerRegistry.clearAll();

            if (this.currentPanel) {
                this.currentPanel.remove();
                this.currentPanel = null;
            }

            if (this.currentAbilitiesPanel) {
                this.currentAbilitiesPanel.remove();
                this.currentAbilitiesPanel = null;
            }

            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const combatScore = new CombatScore();
    combatScore.setupSettingListener();

    /**
     * Combat Library
     * Combat, abilities, and combat stats features
     *
     * Exports to: window.Toolasha.Combat
     */


    // Export to global namespace
    const toolashaRoot$1 = window.Toolasha || {};
    window.Toolasha = toolashaRoot$1;

    if (typeof unsafeWindow !== 'undefined') {
        unsafeWindow.Toolasha = toolashaRoot$1;
    }

    toolashaRoot$1.Combat = {
        zoneIndices,
        dungeonTracker,
        dungeonTrackerUI,
        dungeonTrackerChatAnnotations,
        combatSummary,
        combatSimIntegration,
        combatSimExport: {
            constructExportObject,
            constructMilkonomyExport,
        },
        combatStats,
        abilityBookCalculator,
        combatScore,
        characterCardButton,
    };

    console.log('[Toolasha] Combat library loaded');

    /**
     * Equipment Level Display
     * Shows item level in top right corner of equipment icons
     * Based on original MWI Tools implementation
     */


    /**
     * EquipmentLevelDisplay class adds level overlays to equipment icons
     */
    class EquipmentLevelDisplay {
        constructor() {
            this.unregisterHandler = null;
            this.isActive = false;
            this.processedDivs = new WeakSet(); // Track already-processed divs
            this.isInitialized = false;
        }

        /**
         * Setup setting change listener (always active, even when feature is disabled)
         */
        setupSettingListener() {
            // Listen for main toggle changes
            config$1.onSettingChange('itemIconLevel', (enabled) => {
                if (enabled) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            // Listen for key info toggle
            config$1.onSettingChange('showsKeyInfoInIcon', () => {
                if (this.isInitialized) {
                    // Clear processed set and re-render
                    this.processedDivs = new WeakSet();
                    this.addItemLevels();
                }
            });

            config$1.onSettingChange('color_accent', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize the equipment level display
         */
        initialize() {
            if (!config$1.getSetting('itemIconLevel')) {
                return;
            }

            if (this.isInitialized) {
                return;
            }

            // Register with centralized DOM observer with debouncing
            this.unregisterHandler = domObserver$1.register(
                'EquipmentLevelDisplay',
                () => {
                    this.addItemLevels();
                },
                { debounce: true, debounceDelay: 150 } // 150ms debounce to reduce update frequency
            );

            // Process any existing items on page
            this.addItemLevels();

            this.isActive = true;
            this.isInitialized = true;
        }

        /**
         * Clean up
         */
        cleanup() {
            if (this.unregisterHandler) {
                this.unregisterHandler();
                this.unregisterHandler = null;
            }
            this.isActive = false;
        }

        /**
         * Add item levels to all equipment icons
         * Matches original MWI Tools logic with dungeon key zone info
         */
        addItemLevels() {
            // Find all item icon divs (the clickable containers)
            const iconDivs = document.querySelectorAll(
                'div.Item_itemContainer__x7kH1 div.Item_item__2De2O.Item_clickable__3viV6'
            );

            for (const div of iconDivs) {
                if (this.processedDivs.has(div)) {
                    continue;
                }

                // Skip if already has a name element (tooltip is open)
                if (div.querySelector('div.Item_name__2C42x')) {
                    continue;
                }

                // Get the use element inside this div
                const useElement = div.querySelector('use');
                if (!useElement) {
                    continue;
                }

                const href = useElement.getAttribute('href');
                if (!href) {
                    continue;
                }

                // Extract item HRID (e.g., "#cheese_sword" -> "/items/cheese_sword")
                const hrefName = href.split('#')[1];
                const itemHrid = `/items/${hrefName}`;

                // Get item details
                const itemDetails = dataManager$1.getItemDetails(itemHrid);
                if (!itemDetails) {
                    continue;
                }

                // For equipment, show the level requirement (not itemLevel)
                // For ability books, show the ability level requirement
                // For dungeon entry keys, show zone index
                let displayText = null;

                if (itemDetails.equipmentDetail) {
                    // Equipment: Use levelRequirements from equipmentDetail
                    const levelReq = itemDetails.equipmentDetail.levelRequirements;
                    if (levelReq && levelReq.length > 0 && levelReq[0].level > 0) {
                        displayText = levelReq[0].level.toString();
                    }
                } else if (itemDetails.abilityBookDetail) {
                    // Ability book: Use level requirement from abilityBookDetail
                    const abilityLevelReq = itemDetails.abilityBookDetail.levelRequirements;
                    if (abilityLevelReq && abilityLevelReq.length > 0 && abilityLevelReq[0].level > 0) {
                        displayText = abilityLevelReq[0].level.toString();
                    }
                } else if (config$1.getSetting('showsKeyInfoInIcon') && this.isKeyOrFragment(itemHrid)) {
                    // Keys and fragments: Show zone/dungeon info
                    displayText = this.getKeyDisplayText(itemHrid);
                }

                // Add overlay if we have valid text to display
                if (displayText && !div.querySelector('div.script_itemLevel')) {
                    div.style.position = 'relative';

                    // Position: bottom left for all items (matches market value style)
                    const position = 'bottom: 2px; left: 2px; text-align: left;';

                    div.insertAdjacentHTML(
                        'beforeend',
                        `<div class="script_itemLevel" style="z-index: 1; position: absolute; ${position} color: ${config$1.SCRIPT_COLOR_MAIN}; text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 3px #000;">${displayText}</div>`
                    );
                    // Mark as processed
                    this.processedDivs.add(div);
                } else {
                    // No valid text or already has overlay, mark as processed
                    this.processedDivs.add(div);
                }
            }
        }

        /**
         * Check if item is a key or fragment
         * @param {string} itemHrid - Item HRID
         * @returns {boolean} True if item is a key or fragment
         */
        isKeyOrFragment(itemHrid) {
            return itemHrid.includes('_key') || itemHrid.includes('_fragment');
        }

        /**
         * Get display text for keys and fragments
         * Uses hardcoded mapping like MWI Tools
         * @param {string} itemHrid - Key/fragment HRID
         * @returns {string|null} Display text (e.g., "D1", "Z3", "3.4.5.6") or null
         */
        getKeyDisplayText(itemHrid) {
            const keyMap = new Map([
                // Key fragments (zones where they drop)
                ['/items/blue_key_fragment', 'Z3'],
                ['/items/green_key_fragment', 'Z4'],
                ['/items/purple_key_fragment', 'Z5'],
                ['/items/white_key_fragment', 'Z6'],
                ['/items/orange_key_fragment', 'Z7'],
                ['/items/brown_key_fragment', 'Z8'],
                ['/items/stone_key_fragment', 'Z9'],
                ['/items/dark_key_fragment', 'Z10'],
                ['/items/burning_key_fragment', 'Z11'],

                // Entry keys (dungeon identifiers)
                ['/items/chimerical_entry_key', 'D1'],
                ['/items/sinister_entry_key', 'D2'],
                ['/items/enchanted_entry_key', 'D3'],
                ['/items/pirate_entry_key', 'D4'],

                // Chest keys (zones where they drop)
                ['/items/chimerical_chest_key', '3.4.5.6'],
                ['/items/sinister_chest_key', '5.7.8.10'],
                ['/items/enchanted_chest_key', '7.8.9.11'],
                ['/items/pirate_chest_key', '6.9.10.11'],
            ]);

            return keyMap.get(itemHrid) || null;
        }

        /**
         * Refresh colors (called when settings change)
         */
        refresh() {
            // Update color for all level overlays
            const overlays = document.querySelectorAll('div.script_itemLevel');
            overlays.forEach((overlay) => {
                overlay.style.color = config$1.COLOR_ACCENT;
            });
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.unregisterHandler) {
                this.unregisterHandler();
                this.unregisterHandler = null;
            }

            // Remove all level overlays
            const overlays = document.querySelectorAll('div.script_itemLevel');
            for (const overlay of overlays) {
                overlay.remove();
            }

            // Clear processed tracking
            this.processedDivs = new WeakSet();

            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const equipmentLevelDisplay = new EquipmentLevelDisplay();

    equipmentLevelDisplay.setupSettingListener();

    /**
     * Alchemy Item Dimming
     * Dims items in alchemy panel that require higher level than player has
     * Player must have Alchemy level >= itemLevel to perform alchemy actions
     */


    /**
     * AlchemyItemDimming class dims items based on level requirements
     */
    class AlchemyItemDimming {
        constructor() {
            this.unregisterObserver = null; // Unregister function from centralized observer
            this.isActive = false;
            this.processedDivs = new WeakSet(); // Track already-processed divs
            this.isInitialized = false;
        }

        /**
         * Initialize the alchemy item dimming
         */
        initialize() {
            // Guard FIRST (before feature check)
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('alchemyItemDimming')) {
                return;
            }

            this.isInitialized = true;

            // Register with centralized observer to watch for alchemy panel
            this.unregisterObserver = domObserver$1.onClass('AlchemyItemDimming', 'ItemSelector_menu__12sEM', () => {
                this.processAlchemyItems();
            });

            // Process any existing items on page
            this.processAlchemyItems();

            this.isActive = true;
        }

        /**
         * Process all items in the alchemy panel
         */
        processAlchemyItems() {
            // Check if alchemy panel is open
            const alchemyPanel = this.findAlchemyPanel();
            if (!alchemyPanel) {
                return;
            }

            // Get player's Alchemy level
            const skills = dataManager$1.getSkills();
            if (!skills) {
                return;
            }

            const alchemySkill = skills.find((s) => s.skillHrid === '/skills/alchemy');
            const playerAlchemyLevel = alchemySkill?.level || 1;

            // Find all item icon divs within the alchemy panel
            const iconDivs = alchemyPanel.querySelectorAll(
                'div.Item_itemContainer__x7kH1 div.Item_item__2De2O.Item_clickable__3viV6'
            );

            for (const div of iconDivs) {
                if (this.processedDivs.has(div)) {
                    continue;
                }

                // Get the use element inside this div
                const useElement = div.querySelector('use');
                if (!useElement) {
                    continue;
                }

                const href = useElement.getAttribute('href');
                if (!href) {
                    continue;
                }

                // Extract item HRID (e.g., "#cheese_sword" -> "/items/cheese_sword")
                const hrefName = href.split('#')[1];
                const itemHrid = `/items/${hrefName}`;

                // Get item details
                const itemDetails = dataManager$1.getItemDetails(itemHrid);
                if (!itemDetails) {
                    continue;
                }

                // Get item's alchemy level requirement
                const itemLevel = itemDetails.itemLevel || 0;

                // Apply dimming if player level is too low
                if (playerAlchemyLevel < itemLevel) {
                    div.style.opacity = '0.5';
                    div.style.pointerEvents = 'auto'; // Still clickable
                    div.classList.add('mwi-alchemy-dimmed');
                } else {
                    // Remove dimming if level is now sufficient (player leveled up)
                    div.style.opacity = '1';
                    div.classList.remove('mwi-alchemy-dimmed');
                }

                // Mark as processed
                this.processedDivs.add(div);
            }
        }

        /**
         * Find the alchemy panel in the DOM
         * @returns {Element|null} Alchemy panel element or null
         */
        findAlchemyPanel() {
            // The alchemy item selector is a MuiTooltip dropdown with ItemSelector_menu class
            // It appears when clicking in the "Alchemize Item" box
            const itemSelectorMenus = document.querySelectorAll('div.ItemSelector_menu__12sEM');

            // Check each menu to find the one with "Alchemize Item" label
            for (const menu of itemSelectorMenus) {
                // Look for the ItemSelector_label element in the document
                // (It's not a direct sibling, it's part of the button that opens this menu)
                const alchemyLabels = document.querySelectorAll('div.ItemSelector_label__22ds9');

                for (const label of alchemyLabels) {
                    if (label.textContent.trim() === 'Alchemize Item') {
                        // Found the alchemy label, this menu is likely the alchemy selector
                        return menu;
                    }
                }
            }

            return null;
        }

        /**
         * Disable the feature
         */
        disable() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            // Remove all dimming effects
            const dimmedItems = document.querySelectorAll('.mwi-alchemy-dimmed');
            for (const item of dimmedItems) {
                item.style.opacity = '1';
                item.classList.remove('mwi-alchemy-dimmed');
            }

            // Clear processed tracking
            this.processedDivs = new WeakSet();

            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const alchemyItemDimming = new AlchemyItemDimming();

    /**
     * Skill Experience Percentage Display
     * Shows XP progress percentage in the left sidebar skill list
     */


    class SkillExperiencePercentage {
        constructor() {
            this.isActive = false;
            this.unregisterHandlers = [];
            this.processedBars = new Set();
            this.isInitialized = false;
            this.updateInterval = null;
            this.timerRegistry = createTimerRegistry();
            this.progressBarObservers = new Map(); // Track MutationObservers for each progress bar
        }

        /**
         * Setup setting change listener (always active, even when feature is disabled)
         */
        setupSettingListener() {
            // Listen for main toggle changes
            config$1.onSettingChange('skillExperiencePercentage', (enabled) => {
                if (enabled) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('color_accent', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize the display system
         */
        initialize() {
            if (!config$1.isFeatureEnabled('skillExperiencePercentage')) {
                return;
            }

            if (this.isInitialized) {
                return;
            }

            this.isActive = true;
            this.registerObservers();

            // Setup observers for any existing progress bars
            const existingProgressBars = document.querySelectorAll('[class*="NavigationBar_currentExperience"]');
            existingProgressBars.forEach((progressBar) => {
                this.setupProgressBarObserver(progressBar);
            });

            this.isInitialized = true;
        }

        /**
         * Register DOM observers
         */
        registerObservers() {
            // Watch for progress bars appearing
            const unregister = domObserver$1.onClass(
                'SkillExpPercentage',
                'NavigationBar_currentExperience',
                (progressBar) => {
                    this.setupProgressBarObserver(progressBar);
                }
            );
            this.unregisterHandlers.push(unregister);
        }

        /**
         * Setup MutationObserver for a progress bar to watch for style changes
         * @param {HTMLElement} progressBar - The progress bar element
         */
        setupProgressBarObserver(progressBar) {
            // Skip if we're already observing this progress bar
            if (this.progressBarObservers.has(progressBar)) {
                return;
            }

            // Initial update
            this.updateSkillPercentage(progressBar);

            // Watch for style attribute changes (width percentage updates)
            const unwatch = createMutationWatcher(
                progressBar,
                () => {
                    this.updateSkillPercentage(progressBar);
                },
                {
                    attributes: true,
                    attributeFilter: ['style'],
                }
            );

            // Store the observer so we can clean it up later
            this.progressBarObservers.set(progressBar, unwatch);
        }

        /**
         * Update a single skill's percentage display
         * @param {Element} progressBar - The progress bar element
         */
        updateSkillPercentage(progressBar) {
            // Get the skill container
            const skillContainer = progressBar.parentNode?.parentNode;
            if (!skillContainer) return;

            // Get the level display container (first child of skill container)
            const levelContainer = skillContainer.children[0];
            if (!levelContainer) return;

            // Find the NavigationBar_level span to set its width
            const levelSpan = skillContainer.querySelector('[class*="NavigationBar_level"]');
            if (levelSpan) {
                levelSpan.style.width = 'auto';
            }

            // Extract percentage from progress bar width
            const widthStyle = progressBar.style.width;
            if (!widthStyle) return;

            const percentage = parseFloat(widthStyle.replace('%', ''));
            if (isNaN(percentage)) return;

            // Format with 1 decimal place (convert from percentage to decimal first)
            const formattedPercentage = formatPercentage(percentage / 100, 1);

            // Check if we already have a percentage span
            let percentageSpan = levelContainer.querySelector('.mwi-exp-percentage');

            if (percentageSpan) {
                // Update existing span
                if (percentageSpan.textContent !== formattedPercentage) {
                    percentageSpan.textContent = formattedPercentage;
                }
            } else {
                // Create new span
                percentageSpan = document.createElement('span');
                percentageSpan.className = 'mwi-exp-percentage';
                percentageSpan.textContent = formattedPercentage;
                percentageSpan.style.fontSize = '0.875rem';
                percentageSpan.style.color = config$1.SCRIPT_COLOR_MAIN;

                // Insert percentage before children[1] (same as original)
                levelContainer.insertBefore(percentageSpan, levelContainer.children[1]);
            }
        }

        /**
         * Refresh colors (called when settings change)
         */
        refresh() {
            // Update all existing percentage spans with new color
            const percentageSpans = document.querySelectorAll('.mwi-exp-percentage');
            percentageSpans.forEach((span) => {
                span.style.color = config$1.COLOR_ACCENT;
            });
        }

        /**
         * Disable the feature
         */
        disable() {
            this.timerRegistry.clearAll();
            this.updateInterval = null;

            // Disconnect all progress bar observers
            this.progressBarObservers.forEach((unwatch) => {
                unwatch();
            });
            this.progressBarObservers.clear();

            // Remove all percentage spans
            document.querySelectorAll('.mwi-exp-percentage').forEach((span) => span.remove());

            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];

            this.processedBars.clear();
            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const skillExperiencePercentage = new SkillExperiencePercentage();

    skillExperiencePercentage.setupSettingListener();

    /**
     * External Links
     * Adds links to external MWI tools in the left sidebar navigation
     */


    class ExternalLinks {
        constructor() {
            this.unregisterObserver = null;
            this.addedContainers = new WeakSet(); // Track which specific containers have links
            this.isInitialized = false;
        }

        /**
         * Initialize external links feature
         */
        initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('ui_externalLinks')) {
                return;
            }

            this.isInitialized = true;
            this.setupObserver();
        }

        /**
         * Setup DOM observer to watch for navigation bar
         */
        setupObserver() {
            // Wait for the minor navigation links container
            this.unregisterObserver = domObserver$1.onClass(
                'ExternalLinks',
                'NavigationBar_minorNavigationLinks',
                (container) => {
                    if (!this.addedContainers.has(container)) {
                        this.addLinks(container);
                        this.addedContainers.add(container);
                    }
                }
            );

            // Check for existing container immediately
            const existingContainer = document.querySelector('[class*="NavigationBar_minorNavigationLinks"]');
            if (existingContainer && !this.addedContainers.has(existingContainer)) {
                this.addLinks(existingContainer);
                this.addedContainers.add(existingContainer);
            }
        }

        /**
         * Add external tool links to navigation bar
         * @param {HTMLElement} container - Navigation links container
         */
        addLinks(container) {
            const links = [
                {
                    label: 'Combat Sim',
                    url: 'https://shykai.github.io/MWICombatSimulatorTest/dist/',
                },
                {
                    label: 'Milkyway Market',
                    url: 'https://milkyway.market/',
                },
                {
                    label: 'Enhancelator',
                    url: 'https://doh-nuts.github.io/Enhancelator/',
                },
                {
                    label: 'Milkonomy',
                    url: 'https://milkonomy.pages.dev/#/dashboard',
                },
            ];

            // Add each link (in reverse order so they appear in correct order when prepended)
            for (let i = links.length - 1; i >= 0; i--) {
                const link = links[i];
                this.addLink(container, link.label, link.url);
            }
        }

        /**
         * Add a single external link to the navigation
         * @param {HTMLElement} container - Navigation links container
         * @param {string} label - Link label
         * @param {string} url - External URL
         */
        addLink(container, label, url) {
            const div = document.createElement('div');
            div.setAttribute('class', 'NavigationBar_minorNavigationLink__31K7Y');
            div.style.color = config$1.COLOR_ACCENT;
            div.style.cursor = 'pointer';
            div.textContent = label;

            div.addEventListener('click', () => {
                window.open(url, '_blank');
            });

            // Insert at the beginning (after Settings if it exists)
            container.insertAdjacentElement('afterbegin', div);
        }

        /**
         * Disable the external links feature
         */
        disable() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            // Remove added links
            const container = document.querySelector('[class*="NavigationBar_minorNavigationLinks"]');
            if (container) {
                const linksToRemove = container.querySelectorAll('[style*="cursor: pointer"]');
                linksToRemove.forEach((link) => {
                    // Only remove links we added (check if they have our color)
                    if (link.style.color === config$1.COLOR_ACCENT) {
                        link.remove();
                    }
                });
            }

            // Clear the WeakSet (create new instance)
            this.addedContainers = new WeakSet();
            this.isInitialized = false;
        }
    }

    const externalLinks = new ExternalLinks();

    /**
     * Task Profit Display
     * Shows profit calculation on task cards
     * Expandable breakdown on click
     */


    // Compiled regex pattern (created once, reused for performance)
    const REGEX_TASK_PROGRESS = /(\d+)\s*\/\s*(\d+)/;
    const RATING_MODE_TOKENS = 'tokens';
    const RATING_MODE_GOLD = 'gold';

    /**
     * Calculate task completion time in seconds based on task progress and action rates
     * @param {Object} profitData - Profit calculation result
     * @returns {number|null} Completion time in seconds or null if unavailable
     */
    function calculateTaskCompletionSeconds(profitData) {
        const actionsPerHour = profitData?.action?.details?.actionsPerHour;
        const totalQuantity = profitData?.taskInfo?.quantity;

        if (!actionsPerHour || !totalQuantity) {
            return null;
        }

        const currentProgress = profitData.taskInfo.currentProgress || 0;
        const remainingActions = Math.max(totalQuantity - currentProgress, 0);
        if (remainingActions <= 0) {
            return 0;
        }

        const efficiencyMultiplier = profitData.action.details.efficiencyMultiplier || 1;
        const baseActionsNeeded = efficiencyMultiplier > 0 ? remainingActions / efficiencyMultiplier : remainingActions;

        return calculateSecondsForActions(baseActionsNeeded, actionsPerHour);
    }

    /**
     * Calculate task efficiency rating data
     * @param {Object} profitData - Profit calculation result
     * @param {string} ratingMode - Rating mode (tokens or gold)
     * @returns {Object|null} Rating data or null if unavailable
     */
    function calculateTaskEfficiencyRating(profitData, ratingMode) {
        const completionSeconds = calculateTaskCompletionSeconds(profitData);
        if (!completionSeconds || completionSeconds <= 0) {
            return null;
        }

        const hours = completionSeconds / 3600;

        if (ratingMode === RATING_MODE_GOLD) {
            if (profitData.rewards?.error || profitData.totalProfit === null || profitData.totalProfit === undefined) {
                return {
                    value: null,
                    unitLabel: 'gold/hr',
                    error: profitData.rewards?.error || 'Missing price data',
                };
            }

            return {
                value: profitData.totalProfit / hours,
                unitLabel: 'gold/hr',
                error: null,
            };
        }

        const tokensReceived = profitData.rewards?.breakdown?.tokensReceived ?? 0;
        return {
            value: tokensReceived / hours,
            unitLabel: 'tokens/hr',
            error: null,
        };
    }

    const HEX_COLOR_PATTERN = /^#?[0-9a-f]{6}$/i;

    /**
     * Convert a hex color to RGB
     * @param {string} hex - Hex color string
     * @returns {Object|null} RGB values or null when invalid
     */
    function parseHexColor(hex) {
        if (!hex || !HEX_COLOR_PATTERN.test(hex)) {
            return null;
        }

        const normalized = hex.startsWith('#') ? hex.slice(1) : hex;
        return {
            r: Number.parseInt(normalized.slice(0, 2), 16),
            g: Number.parseInt(normalized.slice(2, 4), 16),
            b: Number.parseInt(normalized.slice(4, 6), 16),
        };
    }

    /**
     * Convert RGB values to a CSS color string
     * @param {Object} rgb - RGB values
     * @returns {string} CSS rgb color string
     */
    function formatRgbColor({ r, g, b }) {
        return `rgb(${r}, ${g}, ${b})`;
    }

    /**
     * Interpolate between two RGB colors
     * @param {Object} startColor - RGB start color
     * @param {Object} endColor - RGB end color
     * @param {number} ratio - Interpolation ratio
     * @returns {Object} RGB color
     */
    function interpolateRgbColor(startColor, endColor, ratio) {
        return {
            r: Math.round(startColor.r + (endColor.r - startColor.r) * ratio),
            g: Math.round(startColor.g + (endColor.g - startColor.g) * ratio),
            b: Math.round(startColor.b + (endColor.b - startColor.b) * ratio),
        };
    }

    /**
     * Convert a rating value into a relative gradient color
     * @param {number} value - Rating value
     * @param {number} minValue - Minimum rating value
     * @param {number} maxValue - Maximum rating value
     * @param {string} minColor - CSS color for lowest value
     * @param {string} maxColor - CSS color for highest value
     * @param {string} fallbackColor - Color to use when value is invalid
     * @returns {string} CSS color value
     */
    function getRelativeEfficiencyGradientColor(value, minValue, maxValue, minColor, maxColor, fallbackColor) {
        if (!Number.isFinite(value) || !Number.isFinite(minValue) || !Number.isFinite(maxValue) || maxValue <= minValue) {
            return fallbackColor;
        }

        const startColor = parseHexColor(minColor);
        const endColor = parseHexColor(maxColor);
        if (!startColor || !endColor) {
            return fallbackColor;
        }

        const normalized = (value - minValue) / (maxValue - minValue);
        const clamped = Math.min(Math.max(normalized, 0), 1);
        const blendedColor = interpolateRgbColor(startColor, endColor, clamped);
        return formatRgbColor(blendedColor);
    }

    /**
     * TaskProfitDisplay class manages task profit UI
     */
    class TaskProfitDisplay {
        constructor() {
            this.isActive = false;
            this.unregisterHandlers = []; // Store unregister functions
            this.retryHandler = null; // Retry handler reference for cleanup
            this.marketDataRetryHandler = null; // Market data retry handler
            this.pendingTaskNodes = new Set(); // Track task nodes waiting for data
            this.eventListeners = new WeakMap(); // Store listeners for cleanup
            this.isInitialized = false;
            this.timerRegistry = createTimerRegistry();
            this.marketDataInitPromise = null; // Guard against duplicate market data inits
        }

        /**
         * Setup settings listeners for feature toggle and color changes
         */
        setupSettingListener() {
            config$1.onSettingChange('taskProfitCalculator', (value) => {
                if (value) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('taskEfficiencyRating', () => {
                if (this.isInitialized) {
                    this.updateTaskProfits(true);
                }
            });

            config$1.onSettingChange('taskEfficiencyRatingMode', () => {
                if (this.isInitialized) {
                    this.updateTaskProfits(true);
                }
            });

            config$1.onSettingChange('taskEfficiencyGradient', () => {
                if (this.isInitialized) {
                    this.updateEfficiencyGradientColors();
                }
            });

            config$1.onSettingChange('color_accent', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize task profit display
         */
        initialize() {
            // Guard FIRST (before feature check)
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('taskProfitCalculator')) {
                return;
            }

            // Set up retry handler for when game data loads
            if (!dataManager$1.getInitClientData()) {
                if (!this.retryHandler) {
                    this.retryHandler = () => {
                        // Retry all pending task nodes
                        this.retryPendingTasks();
                    };
                    dataManager$1.on('character_initialized', this.retryHandler);
                }
            }

            // Set up retry handler for when market data loads
            if (!this.marketDataRetryHandler) {
                this.marketDataRetryHandler = () => {
                    // Retry all pending task nodes when market data becomes available
                    this.retryPendingTasks();
                };
                dataManager$1.on('expected_value_initialized', this.marketDataRetryHandler);
            }

            // Register WebSocket listener for task updates
            this.registerWebSocketListeners();

            // Register DOM observers for task panel appearance
            this.registerDOMObservers();

            // Initial update
            this.updateTaskProfits();

            this.isActive = true;
            this.isInitialized = true;
        }

        /**
         * Register WebSocket message listeners
         */
        registerWebSocketListeners() {
            const questsHandler = (data) => {
                if (!data.endCharacterQuests) return;

                // Wait for game to update DOM before recalculating profits
                const updateTimeout = setTimeout(() => {
                    this.updateTaskProfits();
                }, 250);
                this.timerRegistry.registerTimeout(updateTimeout);
            };

            webSocketHook$1.on('quests_updated', questsHandler);

            this.unregisterHandlers.push(() => {
                webSocketHook$1.off('quests_updated', questsHandler);
            });
        }

        /**
         * Register DOM observers
         */
        registerDOMObservers() {
            // Watch for task list appearing
            const unregisterTaskList = domObserver$1.onClass('TaskProfitDisplay-TaskList', 'TasksPanel_taskList', () => {
                this.updateTaskProfits();
            });
            this.unregisterHandlers.push(unregisterTaskList);

            // Watch for individual tasks appearing
            const unregisterTask = domObserver$1.onClass('TaskProfitDisplay-Task', 'RandomTask_randomTask', () => {
                // Small delay to let task data settle
                const taskTimeout = setTimeout(() => this.updateTaskProfits(), 100);
                this.timerRegistry.registerTimeout(taskTimeout);
            });
            this.unregisterHandlers.push(unregisterTask);
        }

        /**
         * Update all task profit displays
         */
        updateTaskProfits(forceRefresh = false) {
            if (!config$1.getSetting('taskProfitCalculator')) {
                return;
            }

            const taskListNode = document.querySelector(GAME.TASK_LIST);
            if (!taskListNode) return;

            const taskNodes = taskListNode.querySelectorAll(GAME.TASK_INFO);
            for (const taskNode of taskNodes) {
                // Get current task description to detect changes
                const taskData = this.parseTaskData(taskNode);
                if (!taskData) continue;

                const currentTaskKey = `${taskData.description}|${taskData.quantity}`;

                // Check if already processed
                const existingProfit = taskNode.querySelector(TOOLASHA.TASK_PROFIT);
                if (existingProfit) {
                    // Check if task has changed (rerolled)
                    const savedTaskKey = existingProfit.dataset.taskKey;
                    if (!forceRefresh && savedTaskKey === currentTaskKey) {
                        continue; // Same task, skip
                    }

                    // Task changed - clean up event listeners before removing
                    const listeners = this.eventListeners.get(existingProfit);
                    if (listeners) {
                        listeners.forEach((listener, element) => {
                            element.removeEventListener('click', listener);
                        });
                        this.eventListeners.delete(existingProfit);
                    }

                    // Remove ALL old profit displays (visible + hidden markers)
                    taskNode.querySelectorAll(TOOLASHA.TASK_PROFIT).forEach((el) => el.remove());
                }

                this.addProfitToTask(taskNode);
            }
        }

        /**
         * Retry processing pending task nodes after data becomes available
         */
        retryPendingTasks() {
            if (!dataManager$1.getInitClientData()) {
                return; // Data still not ready
            }

            // Remove retry handler - we're ready now
            if (this.retryHandler) {
                dataManager$1.off('character_initialized', this.retryHandler);
                this.retryHandler = null;
            }

            // Process all pending tasks
            const pendingNodes = Array.from(this.pendingTaskNodes);
            this.pendingTaskNodes.clear();

            this.timerRegistry.clearAll();

            for (const taskNode of pendingNodes) {
                // Check if node still exists in DOM
                if (document.contains(taskNode)) {
                    this.addProfitToTask(taskNode);
                }
            }
        }

        /**
         * Ensure expected value calculator is initialized when task profits need market data
         * @returns {Promise<boolean>} True if initialization completed
         */
        async ensureMarketDataInitialized() {
            if (expectedValueCalculator.isInitialized) {
                return true;
            }

            if (!this.marketDataInitPromise) {
                this.marketDataInitPromise = (async () => {
                    try {
                        return await expectedValueCalculator.initialize();
                    } catch (error) {
                        console.error('[Task Profit Display] Market data initialization failed:', error);
                        return false;
                    } finally {
                        this.marketDataInitPromise = null;
                    }
                })();
            }

            return this.marketDataInitPromise;
        }

        /**
         * Add profit display to a task card
         * @param {Element} taskNode - Task card DOM element
         */
        async addProfitToTask(taskNode) {
            try {
                // Check if game data is ready
                if (!dataManager$1.getInitClientData()) {
                    // Game data not ready - add to pending queue
                    this.pendingTaskNodes.add(taskNode);
                    return;
                }

                // Double-check we haven't already processed this task
                // (check again in case another async call beat us to it)
                if (taskNode.querySelector(TOOLASHA.TASK_PROFIT)) {
                    return;
                }

                // Parse task data from DOM
                const taskData = this.parseTaskData(taskNode);
                if (!taskData) {
                    return;
                }

                if (!expectedValueCalculator.isInitialized) {
                    const initialized = await this.ensureMarketDataInitialized();
                    if (!initialized || !expectedValueCalculator.isInitialized) {
                        this.pendingTaskNodes.add(taskNode);
                        this.displayLoadingState(taskNode, taskData);
                        return;
                    }
                }

                // Calculate profit
                const profitData = await calculateTaskProfit(taskData);

                // Don't show anything for combat tasks, but mark them so we detect rerolls
                if (profitData === null) {
                    // Add hidden marker for combat tasks to enable reroll detection
                    const combatMarker = document.createElement('div');
                    combatMarker.className = 'mwi-task-profit';
                    combatMarker.style.display = 'none';
                    combatMarker.dataset.taskKey = `${taskData.description}|${taskData.quantity}`;

                    const actionNode = taskNode.querySelector(GAME.TASK_ACTION);
                    if (actionNode) {
                        actionNode.appendChild(combatMarker);
                    }
                    return;
                }

                // Handle market data not loaded - add to pending queue
                if (
                    profitData.error === 'Market data not loaded' ||
                    (profitData.rewards && profitData.rewards.error === 'Market data not loaded')
                ) {
                    // Add to pending queue
                    this.pendingTaskNodes.add(taskNode);

                    // Show loading state instead of error
                    this.displayLoadingState(taskNode, taskData);
                    return;
                }

                // Check one more time before adding (another async call might have added it)
                if (taskNode.querySelector(TOOLASHA.TASK_PROFIT)) {
                    return;
                }

                // Display profit
                this.displayTaskProfit(taskNode, profitData);
            } catch (error) {
                console.error('[Task Profit Display] Failed to calculate profit:', error);

                // Display error state in UI
                this.displayErrorState(taskNode, 'Unable to calculate profit');

                // Remove from pending queue if present
                this.pendingTaskNodes.delete(taskNode);
            }
        }

        /**
         * Parse task data from DOM
         * @param {Element} taskNode - Task card DOM element
         * @returns {Object|null} {description, coinReward, taskTokenReward, quantity}
         */
        parseTaskData(taskNode) {
            // Get task description
            const nameNode = taskNode.querySelector(GAME.TASK_NAME_DIV);
            if (!nameNode) return null;

            const description = nameNode.textContent.trim();

            // Get quantity from progress (plain div with text "Progress: 0 / 1562")
            // Find all divs in taskInfo and look for the one containing "Progress:"
            let quantity = 0;
            let currentProgress = 0;
            const taskInfoDivs = taskNode.querySelectorAll('div');
            for (const div of taskInfoDivs) {
                const text = div.textContent.trim();
                if (text.startsWith('Progress:')) {
                    const match = text.match(REGEX_TASK_PROGRESS);
                    if (match) {
                        currentProgress = parseInt(match[1]); // Current progress
                        quantity = parseInt(match[2]); // Total quantity
                    }
                    break;
                }
            }

            // Get rewards
            const rewardsNode = taskNode.querySelector(GAME.TASK_REWARDS);
            if (!rewardsNode) return null;

            let coinReward = 0;
            let taskTokenReward = 0;

            const itemContainers = rewardsNode.querySelectorAll(GAME.ITEM_CONTAINER);

            for (const container of itemContainers) {
                const useElement = container.querySelector('use');
                if (!useElement) continue;

                const href = useElement.href.baseVal;

                if (href.includes('coin')) {
                    const countNode = container.querySelector(GAME.ITEM_COUNT);
                    if (countNode) {
                        coinReward = this.parseItemCount(countNode.textContent);
                    }
                } else if (href.includes('task_token')) {
                    const countNode = container.querySelector(GAME.ITEM_COUNT);
                    if (countNode) {
                        taskTokenReward = this.parseItemCount(countNode.textContent);
                    }
                }
            }

            const taskData = {
                description,
                coinReward,
                taskTokenReward,
                quantity,
                currentProgress,
            };

            return taskData;
        }

        /**
         * Parse item count from text (handles K/M suffixes)
         * @param {string} text - Count text (e.g., "1.5K")
         * @returns {number} Parsed count
         */
        parseItemCount(text) {
            text = text.trim();

            if (text.includes('K')) {
                return parseFloat(text.replace('K', '')) * 1000;
            } else if (text.includes('M')) {
                return parseFloat(text.replace('M', '')) * 1000000;
            }

            return parseFloat(text) || 0;
        }

        /**
         * Display profit on task card
         * @param {Element} taskNode - Task card DOM element
         * @param {Object} profitData - Profit calculation result
         */
        displayTaskProfit(taskNode, profitData) {
            const actionNode = taskNode.querySelector(GAME.TASK_ACTION);
            if (!actionNode) return;

            // Create profit container
            const profitContainer = document.createElement('div');
            profitContainer.className = 'mwi-task-profit';
            profitContainer.style.cssText = `
            margin-top: 4px;
            font-size: 0.75rem;
        `;

            // Store task key for reroll detection
            if (profitData.taskInfo) {
                const taskKey = `${profitData.taskInfo.description}|${profitData.taskInfo.quantity}`;
                profitContainer.dataset.taskKey = taskKey;
            }

            // Check for error state
            if (profitData.error) {
                profitContainer.innerHTML = `
                <div style="color: ${config$1.SCRIPT_COLOR_ALERT};">
                    Unable to calculate profit
                </div>
            `;
                actionNode.appendChild(profitContainer);
                return;
            }

            // Calculate time estimate for task completion
            const completionSeconds = calculateTaskCompletionSeconds(profitData);
            const timeEstimate = completionSeconds !== null ? timeReadable(completionSeconds) : '???';

            // Create main profit display (Option B format: compact with time)
            const profitLine = document.createElement('div');
            profitLine.style.cssText = `
            color: ${config$1.COLOR_ACCENT};
            cursor: pointer;
            user-select: none;
        `;
            const totalProfitLabel = profitData.hasMissingPrices ? '-- ⚠' : numberFormatter(profitData.totalProfit);
            profitLine.innerHTML = `💰 ${totalProfitLabel} | <span style="display: inline-block; margin-right: 0.25em;">⏱</span> ${timeEstimate} ▸`;

            // Create breakdown section (hidden by default)
            const breakdownSection = document.createElement('div');
            breakdownSection.className = 'mwi-task-profit-breakdown';
            breakdownSection.style.cssText = `
            display: none;
            margin-top: 6px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: #ddd;
        `;

            // Build breakdown HTML
            breakdownSection.innerHTML = this.buildBreakdownHTML(profitData);

            // Store listener references for cleanup
            const listeners = new Map();

            // Add click handlers for expandable sections
            breakdownSection.querySelectorAll('.mwi-expandable-header').forEach((header) => {
                const listener = (e) => {
                    e.stopPropagation();
                    const section = header.getAttribute('data-section');
                    const detailSection = breakdownSection.querySelector(
                        `.mwi-expandable-section[data-section="${section}"]`
                    );

                    if (detailSection) {
                        const isHidden = detailSection.style.display === 'none';
                        detailSection.style.display = isHidden ? 'block' : 'none';

                        // Update arrow
                        const currentText = header.textContent;
                        header.textContent = currentText.replace(isHidden ? '▸' : '▾', isHidden ? '▾' : '▸');
                    }
                };

                header.addEventListener('click', listener);
                listeners.set(header, listener);
            });

            // Toggle breakdown on click
            const profitLineListener = (e) => {
                e.stopPropagation();
                const isHidden = breakdownSection.style.display === 'none';
                breakdownSection.style.display = isHidden ? 'block' : 'none';
                const updatedProfitLabel = profitData.hasMissingPrices ? '-- ⚠' : numberFormatter(profitData.totalProfit);
                profitLine.innerHTML = `💰 ${updatedProfitLabel} | <span style="display: inline-block; margin-right: 0.25em;">⏱</span> ${timeEstimate} ${isHidden ? '▾' : '▸'}`;
            };

            profitLine.addEventListener('click', profitLineListener);
            listeners.set(profitLine, profitLineListener);

            // Store all listeners for cleanup
            this.eventListeners.set(profitContainer, listeners);

            profitContainer.appendChild(profitLine);

            profitContainer.appendChild(breakdownSection);

            if (config$1.getSetting('taskEfficiencyRating')) {
                const ratingMode = config$1.getSettingValue('taskEfficiencyRatingMode', RATING_MODE_TOKENS);
                const ratingData = calculateTaskEfficiencyRating(profitData, ratingMode);
                const ratingLine = document.createElement('div');
                ratingLine.className = 'mwi-task-profit-rating';
                ratingLine.style.cssText = 'margin-top: 2px; font-size: 0.7rem;';

                if (!ratingData || ratingData.value === null) {
                    const warningText = ratingData?.error ? ' ⚠' : '';
                    ratingLine.style.color = config$1.COLOR_WARNING;
                    ratingLine.textContent = `⚡ --${warningText} ${ratingData?.unitLabel || ''}`.trim();
                } else {
                    const ratingValue = numberFormatter(ratingData.value, 2);
                    ratingLine.dataset.ratingValue = `${ratingData.value}`;
                    ratingLine.dataset.ratingMode = ratingMode;
                    ratingLine.style.color = config$1.COLOR_ACCENT;
                    ratingLine.textContent = `⚡ ${ratingValue} ${ratingData.unitLabel}`;
                }

                profitContainer.appendChild(ratingLine);
            }
            actionNode.appendChild(profitContainer);

            this.updateEfficiencyGradientColors();
        }

        /**
         * Update efficiency rating colors based on relative performance
         */
        updateEfficiencyGradientColors() {
            const ratingMode = config$1.getSettingValue('taskEfficiencyRatingMode', RATING_MODE_TOKENS);
            const ratingLines = Array.from(document.querySelectorAll('.mwi-task-profit-rating')).filter((line) => {
                return line.dataset.ratingMode === ratingMode && line.dataset.ratingValue;
            });

            if (ratingLines.length === 0) {
                return;
            }

            const ratingValues = ratingLines
                .map((line) => Number.parseFloat(line.dataset.ratingValue))
                .filter((value) => Number.isFinite(value));

            if (ratingValues.length === 0) {
                return;
            }

            if (!config$1.getSetting('taskEfficiencyGradient')) {
                ratingLines.forEach((line) => {
                    line.style.color = config$1.COLOR_ACCENT;
                });
                return;
            }

            if (ratingValues.length === 1) {
                ratingLines.forEach((line) => {
                    line.style.color = config$1.COLOR_ACCENT;
                });
                return;
            }

            const sortedValues = [...ratingValues].sort((a, b) => a - b);
            const lastIndex = sortedValues.length - 1;
            const percentileLookup = new Map();
            const resolvedPercentile = (value) => {
                if (percentileLookup.has(value)) {
                    return percentileLookup.get(value);
                }

                const firstIndex = sortedValues.indexOf(value);
                const lastValueIndex = sortedValues.lastIndexOf(value);
                const averageRank = (firstIndex + lastValueIndex) / 2;
                const percentile = lastIndex > 0 ? averageRank / lastIndex : 1;
                percentileLookup.set(value, percentile);
                return percentile;
            };

            ratingLines.forEach((line) => {
                const value = Number.parseFloat(line.dataset.ratingValue);
                const percentile = resolvedPercentile(value);
                line.style.color = getRelativeEfficiencyGradientColor(
                    percentile,
                    0,
                    1,
                    config$1.COLOR_LOSS,
                    config$1.COLOR_ACCENT,
                    config$1.COLOR_ACCENT
                );
            });
        }

        /**
         * Build breakdown HTML
         * @param {Object} profitData - Profit calculation result
         * @returns {string} HTML string
         */
        buildBreakdownHTML(profitData) {
            const lines = [];
            const showTotals = !profitData.hasMissingPrices;
            const formatTotalValue = (value) => (showTotals ? numberFormatter(value) : '-- ⚠');
            const formatPerActionValue = (value) => (showTotals ? numberFormatter(value.toFixed(0)) : '-- ⚠');

            lines.push('<div style="font-weight: bold; margin-bottom: 4px;">Task Profit Breakdown</div>');
            lines.push('<div style="border-bottom: 1px solid #555; margin-bottom: 4px;"></div>');

            // Show warning if market data unavailable
            if (profitData.rewards.error) {
                lines.push(
                    `<div style="color: ${config$1.SCRIPT_COLOR_ALERT}; margin-bottom: 6px; font-style: italic;">⚠ ${profitData.rewards.error} - Token values unavailable</div>`
                );
            }

            // Task Rewards section
            lines.push('<div style="margin-bottom: 4px; color: #aaa;">Task Rewards:</div>');
            lines.push(`<div style="margin-left: 10px;">Coins: ${numberFormatter(profitData.rewards.coins)}</div>`);

            if (!profitData.rewards.error) {
                lines.push(
                    `<div style="margin-left: 10px;">Task Tokens: ${numberFormatter(profitData.rewards.taskTokens)}</div>`
                );
                lines.push(
                    `<div style="margin-left: 20px; font-size: 0.65rem; color: #888;">(${profitData.rewards.breakdown.tokensReceived} tokens @ ${numberFormatter(profitData.rewards.breakdown.tokenValue.toFixed(0))} each)</div>`
                );
                lines.push(
                    `<div style="margin-left: 10px;">Purple's Gift: ${numberFormatter(profitData.rewards.purpleGift)}</div>`
                );
                lines.push(
                    `<div style="margin-left: 20px; font-size: 0.65rem; color: #888;">(${numberFormatter(profitData.rewards.breakdown.giftPerTask.toFixed(0))} per task)</div>`
                );
            } else {
                lines.push(
                    `<div style="margin-left: 10px; color: #888; font-style: italic;">Task Tokens: Loading...</div>`
                );
                lines.push(
                    `<div style="margin-left: 10px; color: #888; font-style: italic;">Purple's Gift: Loading...</div>`
                );
            }
            // Action profit section
            lines.push('<div style="margin-top: 6px; margin-bottom: 4px; color: #aaa;">Action Profit:</div>');

            if (profitData.type === 'gathering') {
                // Gathering Value (expandable)
                lines.push(
                    `<div class="mwi-expandable-header" data-section="gathering" style="margin-left: 10px; cursor: pointer; user-select: none;">Gathering Value: ${formatTotalValue(profitData.action.totalValue)} ▸</div>`
                );
                lines.push(
                    `<div class="mwi-expandable-section" data-section="gathering" style="display: none; margin-left: 20px; font-size: 0.65rem; color: #888; margin-top: 2px;">`
                );

                if (profitData.action.details) {
                    const details = profitData.action.details;
                    const quantity = profitData.action.breakdown.quantity;
                    const actionsPerHour = details.actionsPerHour;

                    // Primary output (base + gourmet + processing)
                    if (details.baseOutputs && details.baseOutputs.length > 0) {
                        const baseRevenueTotal = details.baseOutputs.reduce((sum, output) => {
                            const revenuePerAction = output.revenuePerAction ?? output.revenuePerHour / actionsPerHour;
                            return sum + revenuePerAction * quantity;
                        }, 0);
                        const gourmetRevenueTotal = (details.gourmetRevenueBonusPerAction || 0) * quantity;
                        const processingRevenueTotal = (details.processingRevenueBonusPerAction || 0) * quantity;
                        const primaryOutputTotal = baseRevenueTotal + gourmetRevenueTotal + processingRevenueTotal;
                        lines.push(
                            `<div style="margin-top: 2px; color: #aaa;">Primary Outputs: ${formatTotalValue(Math.round(primaryOutputTotal))}</div>`
                        );
                        for (const output of details.baseOutputs) {
                            const itemsPerAction = output.itemsPerAction ?? output.itemsPerHour / actionsPerHour;
                            const revenuePerAction = output.revenuePerAction ?? output.revenuePerHour / actionsPerHour;
                            const itemsForTask = itemsPerAction * quantity;
                            const revenueForTask = revenuePerAction * quantity;
                            const dropRateText =
                                output.dropRate < 1.0 ? ` (${formatPercentage(output.dropRate, 1)} drop)` : '';
                            const missingPriceNote = output.missingPrice ? ' ⚠' : '';
                            lines.push(
                                `<div>• ${output.name} (Base): ${itemsForTask.toFixed(1)} items @ ${numberFormatter(Math.round(output.priceEach))}${missingPriceNote} = ${numberFormatter(Math.round(revenueForTask))}${dropRateText}</div>`
                            );
                        }
                    }

                    if (details.gourmetBonuses && details.gourmetBonuses.length > 0) {
                        for (const output of details.gourmetBonuses) {
                            const itemsPerAction = output.itemsPerAction ?? output.itemsPerHour / actionsPerHour;
                            const revenuePerAction = output.revenuePerAction ?? output.revenuePerHour / actionsPerHour;
                            const itemsForTask = itemsPerAction * quantity;
                            const revenueForTask = revenuePerAction * quantity;
                            const missingPriceNote = output.missingPrice ? ' ⚠' : '';
                            lines.push(
                                `<div>• ${output.name} (Gourmet ${formatPercentage(details.gourmetBonus || 0, 1)}): ${itemsForTask.toFixed(1)} items @ ${numberFormatter(Math.round(output.priceEach))}${missingPriceNote} = ${numberFormatter(Math.round(revenueForTask))}</div>`
                            );
                        }
                    }

                    if (details.processingConversions && details.processingConversions.length > 0) {
                        const processingBonusTotal = (details.processingRevenueBonusPerAction || 0) * quantity;
                        const processingLabel = `${processingBonusTotal >= 0 ? '+' : '-'}${numberFormatter(Math.abs(Math.round(processingBonusTotal)))}`;
                        lines.push(
                            `<div>• Processing (${formatPercentage(details.processingBonus || 0, 1)} proc): Net ${processingLabel}</div>`
                        );

                        for (const conversion of details.processingConversions) {
                            const conversionsPerAction =
                                conversion.conversionsPerAction ?? conversion.conversionsPerHour / actionsPerHour;
                            const rawConsumedPerAction =
                                conversion.rawConsumedPerAction ?? conversion.rawConsumedPerHour / actionsPerHour;
                            const totalConsumed = rawConsumedPerAction * quantity;
                            const totalProduced = conversionsPerAction * quantity;
                            const consumedRevenue = totalConsumed * conversion.rawPriceEach;
                            const producedRevenue = totalProduced * conversion.processedPriceEach;
                            const missingPriceNote = conversion.missingPrice ? ' ⚠' : '';
                            lines.push(
                                `<div style="margin-left: 10px;">• ${conversion.rawItem} consumed: -${totalConsumed.toFixed(1)} items @ ${numberFormatter(Math.round(conversion.rawPriceEach))}${missingPriceNote} = -${numberFormatter(Math.round(consumedRevenue))}</div>`
                            );
                            lines.push(
                                `<div style="margin-left: 10px;">• ${conversion.processedItem} produced: ${totalProduced.toFixed(1)} items @ ${numberFormatter(Math.round(conversion.processedPriceEach))}${missingPriceNote} = ${numberFormatter(Math.round(producedRevenue))}</div>`
                            );
                        }
                    }

                    // Bonus Revenue (essence and rare finds)
                    if (
                        details.bonusRevenue &&
                        details.bonusRevenue.bonusDrops &&
                        details.bonusRevenue.bonusDrops.length > 0
                    ) {
                        const bonusRevenue = details.bonusRevenue;
                        const essenceDrops = bonusRevenue.bonusDrops.filter((d) => d.type === 'essence');
                        const rareFindDrops = bonusRevenue.bonusDrops.filter((d) => d.type === 'rare_find');

                        if (essenceDrops.length > 0) {
                            const totalEssenceRevenue = essenceDrops.reduce(
                                (sum, drop) => sum + (drop.revenuePerAction || 0) * quantity,
                                0
                            );
                            lines.push(
                                `<div style="margin-top: 4px; color: #aaa;">Essence Drops: ${formatTotalValue(Math.round(totalEssenceRevenue))}</div>`
                            );
                            for (const drop of essenceDrops) {
                                const dropsForTask = (drop.dropsPerAction || 0) * quantity;
                                const revenueForTask = (drop.revenuePerAction || 0) * quantity;
                                const missingPriceNote = drop.missingPrice ? ' ⚠' : '';
                                lines.push(
                                    `<div>• ${drop.itemName}: ${dropsForTask.toFixed(2)} drops @ ${numberFormatter(Math.round(drop.priceEach))}${missingPriceNote} = ${numberFormatter(Math.round(revenueForTask))}</div>`
                                );
                            }
                        }

                        if (rareFindDrops.length > 0) {
                            const totalRareRevenue = rareFindDrops.reduce(
                                (sum, drop) => sum + (drop.revenuePerAction || 0) * quantity,
                                0
                            );
                            lines.push(
                                `<div style="margin-top: 4px; color: #aaa;">Rare Finds: ${formatTotalValue(Math.round(totalRareRevenue))}</div>`
                            );
                            for (const drop of rareFindDrops) {
                                const dropsForTask = (drop.dropsPerAction || 0) * quantity;
                                const revenueForTask = (drop.revenuePerAction || 0) * quantity;
                                const missingPriceNote = drop.missingPrice ? ' ⚠' : '';
                                lines.push(
                                    `<div>• ${drop.itemName}: ${dropsForTask.toFixed(2)} drops @ ${numberFormatter(Math.round(drop.priceEach))}${missingPriceNote} = ${numberFormatter(Math.round(revenueForTask))}</div>`
                                );
                            }
                        }
                    }
                }

                lines.push(`</div>`);
                lines.push(
                    `<div style="margin-left: 20px; font-size: 0.65rem; color: #888;">(${profitData.action.breakdown.quantity}× @ ${formatPerActionValue(profitData.action.breakdown.perAction)} each)</div>`
                );
            } else if (profitData.type === 'production') {
                const details = profitData.action.details;
                const bonusDrops = details?.bonusRevenue?.bonusDrops || [];
                const netProductionValue = profitData.action.totalProfit;

                // Net Production (expandable)
                lines.push(
                    `<div class="mwi-expandable-header" data-section="production" style="margin-left: 10px; cursor: pointer; user-select: none;">Net Production: ${formatTotalValue(netProductionValue)} ▸</div>`
                );
                lines.push(
                    `<div class="mwi-expandable-section" data-section="production" style="display: none; margin-left: 20px; font-size: 0.65rem; color: #888; margin-top: 2px;">`
                );

                if (details) {
                    const outputAmount = details.outputAmount || 1;
                    const totalItems = outputAmount * profitData.action.breakdown.quantity;
                    const outputPriceNote = details.outputPriceMissing ? ' ⚠' : '';
                    const baseRevenueTotal = totalItems * details.priceEach;
                    const gourmetRevenueTotal = details.gourmetBonus
                        ? outputAmount * details.gourmetBonus * profitData.action.breakdown.quantity * details.priceEach
                        : 0;
                    const primaryOutputTotal = baseRevenueTotal + gourmetRevenueTotal;

                    lines.push(
                        `<div style="margin-top: 2px; color: #aaa;">Primary Outputs: ${formatTotalValue(Math.round(primaryOutputTotal))}</div>`
                    );

                    lines.push(
                        `<div>• ${details.itemName} (Base): ${totalItems.toFixed(1)} items @ ${numberFormatter(details.priceEach)}${outputPriceNote} = ${numberFormatter(Math.round(totalItems * details.priceEach))}</div>`
                    );

                    if (details.gourmetBonus > 0) {
                        const bonusItems = outputAmount * details.gourmetBonus * profitData.action.breakdown.quantity;
                        lines.push(
                            `<div>• ${details.itemName} (Gourmet +${formatPercentage(details.gourmetBonus, 1)}): ${bonusItems.toFixed(1)} items @ ${numberFormatter(details.priceEach)}${outputPriceNote} = ${numberFormatter(Math.round(bonusItems * details.priceEach))}</div>`
                        );
                    }
                }

                if (bonusDrops.length > 0) {
                    const essenceDrops = bonusDrops.filter((d) => d.type === 'essence');
                    const rareFindDrops = bonusDrops.filter((d) => d.type === 'rare_find');

                    if (essenceDrops.length > 0) {
                        const totalEssenceRevenue = essenceDrops.reduce(
                            (sum, drop) => sum + (drop.revenuePerAction || 0) * profitData.action.breakdown.quantity,
                            0
                        );
                        lines.push(
                            `<div style="margin-top: 4px; color: #aaa;">Essence Drops: ${formatTotalValue(Math.round(totalEssenceRevenue))}</div>`
                        );
                        for (const drop of essenceDrops) {
                            const dropsForTask = (drop.dropsPerAction || 0) * profitData.action.breakdown.quantity;
                            const revenueForTask = (drop.revenuePerAction || 0) * profitData.action.breakdown.quantity;
                            const missingPriceNote = drop.missingPrice ? ' ⚠' : '';
                            lines.push(
                                `<div>• ${drop.itemName}: ${dropsForTask.toFixed(2)} drops @ ${numberFormatter(Math.round(drop.priceEach))}${missingPriceNote} = ${numberFormatter(Math.round(revenueForTask))}</div>`
                            );
                        }
                    }

                    if (rareFindDrops.length > 0) {
                        const totalRareRevenue = rareFindDrops.reduce(
                            (sum, drop) => sum + (drop.revenuePerAction || 0) * profitData.action.breakdown.quantity,
                            0
                        );
                        lines.push(
                            `<div style="margin-top: 4px; color: #aaa;">Rare Finds: ${formatTotalValue(Math.round(totalRareRevenue))}</div>`
                        );
                        for (const drop of rareFindDrops) {
                            const dropsForTask = (drop.dropsPerAction || 0) * profitData.action.breakdown.quantity;
                            const revenueForTask = (drop.revenuePerAction || 0) * profitData.action.breakdown.quantity;
                            const missingPriceNote = drop.missingPrice ? ' ⚠' : '';
                            lines.push(
                                `<div>• ${drop.itemName}: ${dropsForTask.toFixed(2)} drops @ ${numberFormatter(Math.round(drop.priceEach))}${missingPriceNote} = ${numberFormatter(Math.round(revenueForTask))}</div>`
                            );
                        }
                    }
                }

                if (details?.materialCosts) {
                    const actionsNeeded = profitData.action.breakdown.quantity;
                    const hoursNeeded = actionsNeeded / (details.actionsPerHour * (details.efficiencyMultiplier || 1));
                    lines.push(
                        `<div style="margin-top: 4px; color: #aaa;">Material Costs: ${formatTotalValue(profitData.action.breakdown.materialCost)}</div>`
                    );

                    for (const mat of details.materialCosts) {
                        const totalAmount = mat.amount * actionsNeeded;
                        const totalCost = mat.totalCost * actionsNeeded;
                        const missingPriceNote = mat.missingPrice ? ' ⚠' : '';
                        lines.push(
                            `<div>• ${mat.itemName}: ${totalAmount.toFixed(1)} @ ${numberFormatter(Math.round(mat.askPrice))}${missingPriceNote} = ${numberFormatter(Math.round(totalCost))}</div>`
                        );
                    }

                    if (details.teaCosts && details.teaCosts.length > 0) {
                        for (const tea of details.teaCosts) {
                            const drinksNeeded = tea.drinksPerHour * hoursNeeded;
                            const totalCost = tea.totalCost * hoursNeeded;
                            const missingPriceNote = tea.missingPrice ? ' ⚠' : '';
                            lines.push(
                                `<div>• ${tea.itemName}: ${drinksNeeded.toFixed(1)} drinks @ ${numberFormatter(Math.round(tea.pricePerDrink))}${missingPriceNote} = ${numberFormatter(Math.round(totalCost))}</div>`
                            );
                        }
                    }
                }

                lines.push(`</div>`);

                // Net Production now shown in header
                lines.push(
                    `<div style="margin-left: 20px; font-size: 0.65rem; color: #888;">(${profitData.action.breakdown.quantity}× @ ${formatPerActionValue(profitData.action.breakdown.perAction)} each)</div>`
                );
            }

            // Total
            lines.push('<div style="border-top: 1px solid #555; margin-top: 6px; padding-top: 4px;"></div>');
            lines.push(
                `<div style="font-weight: bold; color: ${config$1.COLOR_ACCENT};">Total Profit: ${formatTotalValue(profitData.totalProfit)}</div>`
            );

            return lines.join('');
        }

        /**
         * Display error state when profit calculation fails
         * @param {Element} taskNode - Task card DOM element
         * @param {string} message - Error message to display
         */
        displayErrorState(taskNode, message) {
            const actionNode = taskNode.querySelector(GAME.TASK_ACTION);
            if (!actionNode) return;

            // Create error container
            const errorContainer = document.createElement('div');
            errorContainer.className = 'mwi-task-profit mwi-task-profit-error';
            errorContainer.style.cssText = `
            margin-top: 4px;
            font-size: 0.75rem;
            color: ${config$1.SCRIPT_COLOR_ALERT};
            font-style: italic;
        `;
            errorContainer.textContent = `⚠ ${message}`;

            actionNode.appendChild(errorContainer);
        }

        /**
         * Display loading state while waiting for market data
         * @param {Element} taskNode - Task card DOM element
         * @param {Object} taskData - Task data for reroll detection
         */
        displayLoadingState(taskNode, taskData) {
            const actionNode = taskNode.querySelector(GAME.TASK_ACTION);
            if (!actionNode) return;

            // Create loading container
            const loadingContainer = document.createElement('div');
            loadingContainer.className = 'mwi-task-profit mwi-task-profit-loading';
            loadingContainer.style.cssText = `
            margin-top: 4px;
            font-size: 0.75rem;
            color: #888;
            font-style: italic;
        `;
            loadingContainer.textContent = '⏳ Loading market data...';

            // Store task key for reroll detection
            const taskKey = `${taskData.description}|${taskData.quantity}`;
            loadingContainer.dataset.taskKey = taskKey;

            actionNode.appendChild(loadingContainer);
        }

        /**
         * Refresh colors on existing task profit displays
         */
        refresh() {
            // Update all profit line colors
            const profitLines = document.querySelectorAll('.mwi-task-profit > div:first-child');
            profitLines.forEach((line) => {
                line.style.color = config$1.COLOR_ACCENT;
            });

            // Update all total profit colors in breakdowns
            const totalProfits = document.querySelectorAll('.mwi-task-profit-breakdown > div:last-child');
            totalProfits.forEach((total) => {
                total.style.color = config$1.COLOR_ACCENT;
            });
        }

        /**
         * Disable the feature
         */
        disable() {
            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];

            if (this.retryHandler) {
                dataManager$1.off('character_initialized', this.retryHandler);
                this.retryHandler = null;
            }

            if (this.marketDataRetryHandler) {
                dataManager$1.off('expected_value_initialized', this.marketDataRetryHandler);
                this.marketDataRetryHandler = null;
            }

            // Clear pending tasks
            this.pendingTaskNodes.clear();

            // Clean up event listeners before removing profit displays
            document.querySelectorAll(TOOLASHA.TASK_PROFIT).forEach((el) => {
                const listeners = this.eventListeners.get(el);
                if (listeners) {
                    listeners.forEach((listener, element) => {
                        element.removeEventListener('click', listener);
                    });
                    this.eventListeners.delete(el);
                }
                el.remove();
            });

            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const taskProfitDisplay = new TaskProfitDisplay();
    taskProfitDisplay.setupSettingListener();

    /**
     * Task Reroll Cost Tracker
     * Tracks and displays reroll costs for tasks using WebSocket messages
     */


    class TaskRerollTracker {
        constructor() {
            this.taskRerollData = new Map(); // key: taskId, value: { coinRerollCount, cowbellRerollCount }
            this.unregisterHandlers = [];
            this.isInitialized = false;
            this.storeName = 'rerollSpending';
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Initialize the tracker
         */
        async initialize() {
            if (this.isInitialized) return;

            // Load saved data from IndexedDB
            await this.loadFromStorage();

            // Register WebSocket listener
            this.registerWebSocketListeners();

            // Register DOM observer for display updates
            this.registerDOMObservers();

            this.isInitialized = true;
        }

        /**
         * Load task reroll data from IndexedDB
         */
        async loadFromStorage() {
            try {
                const savedData = await storage$1.getJSON('taskRerollData', this.storeName, {});

                // Convert saved object back to Map
                for (const [taskId, data] of Object.entries(savedData)) {
                    this.taskRerollData.set(parseInt(taskId), data);
                }
            } catch (error) {
                console.error('[Task Reroll Tracker] Failed to load from storage:', error);
            }
        }

        /**
         * Save task reroll data to IndexedDB
         */
        async saveToStorage() {
            try {
                // Convert Map to plain object for storage
                const dataToSave = {};
                for (const [taskId, data] of this.taskRerollData.entries()) {
                    dataToSave[taskId] = data;
                }

                await storage$1.setJSON('taskRerollData', dataToSave, this.storeName, true);
            } catch (error) {
                console.error('[Task Reroll Tracker] Failed to save to storage:', error);
            }
        }

        /**
         * Clean up observers and handlers
         */
        cleanup() {
            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];
            this.timerRegistry.clearAll();
            this.isInitialized = false;
        }

        disable() {
            this.cleanup();
        }

        /**
         * Clean up old task data that's no longer active
         * Keeps only tasks that are currently in characterQuests
         */
        cleanupOldTasks() {
            if (!dataManager$1.characterData || !dataManager$1.characterData.characterQuests) {
                return;
            }

            const activeTaskIds = new Set(dataManager$1.characterData.characterQuests.map((quest) => quest.id));

            let hasChanges = false;

            // Remove tasks that are no longer active
            for (const taskId of this.taskRerollData.keys()) {
                if (!activeTaskIds.has(taskId)) {
                    this.taskRerollData.delete(taskId);
                    hasChanges = true;
                }
            }

            if (hasChanges) {
                this.saveToStorage();
            }
        }

        /**
         * Register WebSocket message listeners
         */
        registerWebSocketListeners() {
            const questsHandler = (data) => {
                if (!data.endCharacterQuests) {
                    return;
                }

                let hasChanges = false;

                // Update our task reroll data from server data
                for (const quest of data.endCharacterQuests) {
                    const existingData = this.taskRerollData.get(quest.id);
                    const newCoinCount = quest.coinRerollCount || 0;
                    const newCowbellCount = quest.cowbellRerollCount || 0;

                    // Only update if counts increased or task is new
                    if (
                        !existingData ||
                        newCoinCount > existingData.coinRerollCount ||
                        newCowbellCount > existingData.cowbellRerollCount
                    ) {
                        this.taskRerollData.set(quest.id, {
                            coinRerollCount: Math.max(existingData?.coinRerollCount || 0, newCoinCount),
                            cowbellRerollCount: Math.max(existingData?.cowbellRerollCount || 0, newCowbellCount),
                            monsterHrid: quest.monsterHrid || '',
                            actionHrid: quest.actionHrid || '',
                            goalCount: quest.goalCount || 0,
                        });
                        hasChanges = true;
                    }
                }

                // Save to storage if data changed
                if (hasChanges) {
                    this.saveToStorage();
                }

                // Clean up old tasks periodically (every 10th update)
                if (Math.random() < 0.1) {
                    this.cleanupOldTasks();
                }

                // Wait for game to update DOM before updating displays
                const updateTimeout = setTimeout(() => {
                    this.updateAllTaskDisplays();
                }, 250);
                this.timerRegistry.registerTimeout(updateTimeout);
            };

            webSocketHook$1.on('quests_updated', questsHandler);

            this.unregisterHandlers.push(() => {
                webSocketHook$1.off('quests_updated', questsHandler);
            });

            // Load existing quest data from DataManager (which receives init_character_data early)
            const initHandler = (data) => {
                if (!data.characterQuests) {
                    return;
                }

                let hasChanges = false;

                // Load all quest data into the map
                for (const quest of data.characterQuests) {
                    const existingData = this.taskRerollData.get(quest.id);
                    const newCoinCount = quest.coinRerollCount || 0;
                    const newCowbellCount = quest.cowbellRerollCount || 0;

                    // Only update if counts increased or task is new
                    if (
                        !existingData ||
                        newCoinCount > existingData.coinRerollCount ||
                        newCowbellCount > existingData.cowbellRerollCount
                    ) {
                        this.taskRerollData.set(quest.id, {
                            coinRerollCount: Math.max(existingData?.coinRerollCount || 0, newCoinCount),
                            cowbellRerollCount: Math.max(existingData?.cowbellRerollCount || 0, newCowbellCount),
                            monsterHrid: quest.monsterHrid || '',
                            actionHrid: quest.actionHrid || '',
                            goalCount: quest.goalCount || 0,
                        });
                        hasChanges = true;
                    }
                }

                // Save to storage if data changed
                if (hasChanges) {
                    this.saveToStorage();
                }

                // Clean up old tasks after loading character data
                this.cleanupOldTasks();

                // Wait for DOM to be ready before updating displays
                const initTimeout = setTimeout(() => {
                    this.updateAllTaskDisplays();
                }, 500);
                this.timerRegistry.registerTimeout(initTimeout);
            };

            dataManager$1.on('character_initialized', initHandler);

            // Check if character data already loaded (in case we missed the event)
            if (dataManager$1.characterData && dataManager$1.characterData.characterQuests) {
                initHandler(dataManager$1.characterData);
            }

            this.unregisterHandlers.push(() => {
                dataManager$1.off('character_initialized', initHandler);
            });
        }

        /**
         * Register DOM observers for display updates
         */
        registerDOMObservers() {
            // Watch for task list appearing
            const unregisterTaskList = domObserver$1.onClass('TaskRerollTracker-TaskList', 'TasksPanel_taskList', () => {
                this.updateAllTaskDisplays();
            });
            this.unregisterHandlers.push(unregisterTaskList);

            // Watch for individual tasks appearing
            const unregisterTask = domObserver$1.onClass('TaskRerollTracker-Task', 'RandomTask_randomTask', () => {
                // Small delay to let task data settle
                const taskTimeout = setTimeout(() => this.updateAllTaskDisplays(), 100);
                this.timerRegistry.registerTimeout(taskTimeout);
            });
            this.unregisterHandlers.push(unregisterTask);
        }

        /**
         * Calculate cumulative gold spent from coin reroll count
         * Formula: 10K, 20K, 40K, 80K, 160K, 320K (doubles, caps at 320K)
         * @param {number} rerollCount - Number of gold rerolls
         * @returns {number} Total gold spent
         */
        calculateGoldSpent(rerollCount) {
            if (rerollCount === 0) return 0;

            let total = 0;
            let cost = 10000; // Start at 10K

            for (let i = 0; i < rerollCount; i++) {
                total += cost;
                // Double the cost, but cap at 320K
                cost = Math.min(cost * 2, 320000);
            }

            return total;
        }

        /**
         * Calculate cumulative cowbells spent from cowbell reroll count
         * Formula: 1, 2, 4, 8, 16, 32 (doubles, caps at 32)
         * @param {number} rerollCount - Number of cowbell rerolls
         * @returns {number} Total cowbells spent
         */
        calculateCowbellSpent(rerollCount) {
            if (rerollCount === 0) return 0;

            let total = 0;
            let cost = 1; // Start at 1

            for (let i = 0; i < rerollCount; i++) {
                total += cost;
                // Double the cost, but cap at 32
                cost = Math.min(cost * 2, 32);
            }

            return total;
        }

        /**
         * Get task ID from DOM element by matching task description
         * @param {Element} taskElement - Task DOM element
         * @returns {number|null} Task ID or null if not found
         */
        getTaskIdFromElement(taskElement) {
            // Get task description and goal count from DOM
            const nameEl = taskElement.querySelector(GAME.TASK_NAME);
            const description = nameEl ? nameEl.textContent.trim() : '';

            if (!description) {
                return null;
            }

            // Get quantity from progress text
            const progressDivs = taskElement.querySelectorAll('div');
            let goalCount = 0;
            for (const div of progressDivs) {
                const text = div.textContent.trim();
                if (text.startsWith('Progress:')) {
                    const match = text.match(/Progress:\s*\d+\s*\/\s*(\d+)/);
                    if (match) {
                        goalCount = parseInt(match[1]);
                        break;
                    }
                }
            }

            // Match against stored task data
            for (const [taskId, taskData] of this.taskRerollData.entries()) {
                // Check if goal count matches
                if (taskData.goalCount !== goalCount) continue;

                // Extract monster/action name from description
                // Description format: "Kill X" or "Do action X times"
                const descLower = description.toLowerCase();

                // For monster tasks, check monsterHrid
                if (taskData.monsterHrid) {
                    const monsterName = taskData.monsterHrid.replace('/monsters/', '').replace(/_/g, ' ');
                    if (descLower.includes(monsterName.toLowerCase())) {
                        return taskId;
                    }
                }

                // For action tasks, check actionHrid
                if (taskData.actionHrid) {
                    const actionParts = taskData.actionHrid.split('/');
                    const actionName = actionParts[actionParts.length - 1].replace(/_/g, ' ');
                    if (descLower.includes(actionName.toLowerCase())) {
                        return taskId;
                    }
                }
            }

            return null;
        }

        /**
         * Update display for a specific task
         * @param {Element} taskElement - Task DOM element
         */
        updateTaskDisplay(taskElement) {
            const taskId = this.getTaskIdFromElement(taskElement);
            if (!taskId) {
                // Remove display if task not found in our data
                const existingDisplay = taskElement.querySelector('.mwi-reroll-cost-display');
                if (existingDisplay) {
                    existingDisplay.remove();
                }
                return;
            }

            const taskData = this.taskRerollData.get(taskId);
            if (!taskData) {
                return;
            }

            // Calculate totals
            const goldSpent = this.calculateGoldSpent(taskData.coinRerollCount);
            const cowbellSpent = this.calculateCowbellSpent(taskData.cowbellRerollCount);

            // Find or create display element
            let displayElement = taskElement.querySelector(TOOLASHA.REROLL_COST_DISPLAY);

            if (!displayElement) {
                displayElement = document.createElement('div');
                displayElement.className = 'mwi-reroll-cost-display';
                displayElement.style.cssText = `
                color: ${config$1.SCRIPT_COLOR_SECONDARY};
                font-size: 0.75rem;
                margin-top: 4px;
                padding: 2px 4px;
                border-radius: 3px;
                background: rgba(0, 0, 0, 0.3);
            `;

                // Insert at top of task card
                const taskContent = taskElement.querySelector(GAME.TASK_CONTENT);
                if (taskContent) {
                    taskContent.insertBefore(displayElement, taskContent.firstChild);
                } else {
                    taskElement.insertBefore(displayElement, taskElement.firstChild);
                }
            }

            // Format display text
            const parts = [];
            if (cowbellSpent > 0) {
                parts.push(`${cowbellSpent}🔔`);
            }
            if (goldSpent > 0) {
                parts.push(`${numberFormatter(goldSpent)}💰`);
            }

            if (parts.length > 0) {
                displayElement.textContent = `Reroll spent: ${parts.join(' + ')}`;
                displayElement.style.display = 'block';
            } else {
                displayElement.style.display = 'none';
            }
        }

        /**
         * Update all task displays
         */
        updateAllTaskDisplays() {
            const taskList = document.querySelector(GAME.TASK_LIST);
            if (!taskList) {
                return;
            }

            const allTasks = taskList.querySelectorAll(GAME.TASK_CARD);
            allTasks.forEach((task) => {
                this.updateTaskDisplay(task);
            });
        }
    }

    const taskRerollTracker = new TaskRerollTracker();

    /**
     * Task Icon Filters
     *
     * Adds clickable filter icons to the task panel header for controlling
     * which task icons are displayed. Based on MWI Task Manager implementation.
     *
     * Features:
     * - Battle icon toggle (shows/hides all combat task icons)
     * - Individual dungeon toggles (4 dungeons)
     * - Visual state indication (opacity 1.0 = active, 0.3 = inactive)
     * - Task count badges on each icon
     * - Persistent filter state across sessions
     * - Event-driven updates when filters change
     */


    const STORAGE_KEYS = {
        migration: 'taskIconsFiltersMigratedV1',
        battle: 'taskIconsFilterBattle',
        dungeonPrefix: 'taskIconsFilterDungeon:',
    };

    // Hardcoded sprite URLs (like MWI Task Manager)
    // These may need updating when the game rebuilds with new webpack hashes
    const SPRITE_URLS = {
        actions: '/static/media/actions_sprite.e6388cbc.svg',
        misc: '/static/media/misc_sprite.354aafcf.svg',
    };

    class TaskIconFilters {
        constructor() {
            this.filterIcons = new Map(); // Map of filter ID -> DOM element
            this.currentCounts = new Map(); // Map of filter ID -> task count
            this.taskListObserver = null;
            this.filterBar = null; // Reference to filter bar DOM element
            this.settingChangeHandler = null; // Handler for setting changes
            this.stateLoadPromise = null;
            this.isStateLoaded = false;
            this.state = {
                battle: true,
                dungeons: {},
            };

            // Dungeon configuration matching game data
            this.dungeonConfig = {
                '/actions/combat/chimerical_den': {
                    id: 'chimerical_den',
                    name: 'Chimerical Den',
                    spriteId: 'chimerical_den',
                },
                '/actions/combat/sinister_circus': {
                    id: 'sinister_circus',
                    name: 'Sinister Circus',
                    spriteId: 'sinister_circus',
                },
                '/actions/combat/enchanted_fortress': {
                    id: 'enchanted_fortress',
                    name: 'Enchanted Fortress',
                    spriteId: 'enchanted_fortress',
                },
                '/actions/combat/pirate_cove': {
                    id: 'pirate_cove',
                    name: 'Pirate Cove',
                    spriteId: 'pirate_cove',
                },
            };
        }

        /**
         * Initialize the task icon filters feature
         */
        initialize() {
            // Note: Filter bar is added by task-sorter.js when task panel appears

            this.loadState();

            // Listen for taskIconsDungeons setting changes
            this.settingChangeHandler = (enabled) => {
                if (this.filterBar) {
                    this.filterBar.style.display = enabled ? 'flex' : 'none';
                }
            };
            config$1.onSettingChange('taskIconsDungeons', this.settingChangeHandler);
        }

        async loadState() {
            if (this.stateLoadPromise) {
                return this.stateLoadPromise;
            }

            this.stateLoadPromise = this.loadStateInternal();
            return this.stateLoadPromise;
        }

        async loadStateInternal() {
            try {
                const migrated = await storage$1.get(STORAGE_KEYS.migration, 'settings', false);

                if (migrated) {
                    await this.loadStateFromStorage();
                } else {
                    this.loadStateFromLocalStorage();
                    const migrated = await this.persistStateToStorage();
                    if (migrated) {
                        await storage$1.set(STORAGE_KEYS.migration, true, 'settings', true);
                        this.clearLocalStorageState();
                    }
                }
            } catch (error) {
                console.error('[TaskIconFilters] Failed to load filter state:', error);
            } finally {
                this.isStateLoaded = true;
                this.updateAllIconStates();
                this.dispatchFilterChange('init');
            }
        }

        loadStateFromLocalStorage() {
            const storedBattle = localStorage.getItem('mwi-taskIconsFilterBattle');
            this.state.battle = storedBattle === null || storedBattle === 'true';

            Object.values(this.dungeonConfig).forEach((dungeon) => {
                const stored = localStorage.getItem(`mwi-taskIconsFilter-${dungeon.id}`);
                this.state.dungeons[dungeon.id] = stored === 'true';
            });
        }

        async loadStateFromStorage() {
            const storedBattle = await storage$1.get(STORAGE_KEYS.battle, 'settings', true);
            this.state.battle = storedBattle === true;

            const dungeonEntries = Object.values(this.dungeonConfig).map(async (dungeon) => {
                const key = `${STORAGE_KEYS.dungeonPrefix}${dungeon.id}`;
                const enabled = await storage$1.get(key, 'settings', false);
                return { id: dungeon.id, enabled: enabled === true };
            });

            const results = await Promise.all(dungeonEntries);
            results.forEach(({ id, enabled }) => {
                this.state.dungeons[id] = enabled;
            });
        }

        async persistStateToStorage() {
            const battleSaved = await storage$1.set(STORAGE_KEYS.battle, this.state.battle, 'settings', true);

            const dungeonWrites = Object.values(this.dungeonConfig).map((dungeon) => {
                const key = `${STORAGE_KEYS.dungeonPrefix}${dungeon.id}`;
                return storage$1.set(key, this.state.dungeons[dungeon.id] === true, 'settings', true);
            });

            const dungeonResults = await Promise.all(dungeonWrites);
            return battleSaved && dungeonResults.every(Boolean);
        }

        clearLocalStorageState() {
            localStorage.removeItem('mwi-taskIconsFilterBattle');
            Object.values(this.dungeonConfig).forEach((dungeon) => {
                localStorage.removeItem(`mwi-taskIconsFilter-${dungeon.id}`);
            });
        }

        /**
         * Cleanup when feature is disabled
         */
        cleanup() {
            // Remove setting change listener
            if (this.settingChangeHandler) {
                config$1.offSettingChange('taskIconsDungeons', this.settingChangeHandler);
                this.settingChangeHandler = null;
            }

            // Disconnect task list observer
            if (this.taskListObserver) {
                this.taskListObserver();
                this.taskListObserver = null;
            }

            // Remove filter bar from DOM
            if (this.filterBar) {
                this.filterBar.remove();
                this.filterBar = null;
            }

            // Clear maps
            this.filterIcons.clear();
            this.currentCounts.clear();
        }

        /**
         * Add filter icon bar to task panel header
         * Called by task-sorter.js when task panel appears
         * @param {HTMLElement} headerElement - Task panel header element
         */
        addFilterBar(headerElement) {
            // Check if we already added filters to this header
            if (headerElement.querySelector('[data-mwi-task-filters]')) {
                return;
            }

            // Find the task panel container to observe task list
            // DOM structure: Grandparent > TaskBoardInfo (parent) > TaskSlotCount (header)
            //                Grandparent > TaskList (sibling to TaskBoardInfo)
            // So we need to go up two levels to find the common container
            const panel = headerElement.parentElement?.parentElement;
            if (!panel) {
                console.warn('[TaskIconFilters] Could not find task panel grandparent');
                return;
            }

            // Create container for filter icons
            this.filterBar = document.createElement('div');
            this.filterBar.setAttribute('data-mwi-task-filters', 'true');
            this.filterBar.style.gap = '8px';
            this.filterBar.style.alignItems = 'center';
            this.filterBar.style.marginLeft = '8px';

            // Check if taskIconsDungeons setting is enabled
            const isEnabled = config$1.isFeatureEnabled('taskIconsDungeons');
            this.filterBar.style.display = isEnabled ? 'flex' : 'none';

            // Create battle icon (combat icon is in misc_sprite)
            const battleIcon = this.createFilterIcon(
                'battle',
                'Battle',
                'combat',
                () => this.getBattleFilterEnabled(),
                'misc'
            );
            this.filterBar.appendChild(battleIcon);
            this.filterIcons.set('battle', battleIcon);

            // Create dungeon icons (dungeon icons are in actions_sprite)
            Object.entries(this.dungeonConfig).forEach(([hrid, dungeon]) => {
                const dungeonIcon = this.createFilterIcon(
                    dungeon.id,
                    dungeon.name,
                    dungeon.spriteId,
                    () => this.getDungeonFilterEnabled(hrid),
                    'actions'
                );
                this.filterBar.appendChild(dungeonIcon);
                this.filterIcons.set(dungeon.id, dungeonIcon);
            });

            // Insert filter bar after the task sort button (if it exists)
            const sortButton = headerElement.querySelector('[data-mwi-task-sort]');
            if (sortButton) {
                sortButton.parentNode.insertBefore(this.filterBar, sortButton.nextSibling);
            } else {
                headerElement.appendChild(this.filterBar);
            }

            // Initial count update
            this.updateCounts(panel);

            // Start observing task list for count updates
            this.observeTaskList(panel);
        }

        /**
         * Get the current items sprite URL from the DOM
         * @returns {string|null} Items sprite URL or null if not found
         */
        getItemsSpriteUrl() {
            const itemIcon = document.querySelector('use[href*="items_sprite"]');
            if (!itemIcon) {
                return null;
            }
            const href = itemIcon.getAttribute('href');
            return href ? href.split('#')[0] : null;
        }

        /**
         * Get the current misc sprite URL from the DOM (for combat icons)
         * @returns {string|null} Misc sprite URL or null if not found
         */
        getMiscSpriteUrl() {
            const miscIcon = document.querySelector('use[href*="misc_sprite"]');
            if (!miscIcon) {
                return null;
            }
            const href = miscIcon.getAttribute('href');
            return href ? href.split('#')[0] : null;
        }

        /**
         * Get the current actions sprite URL from the DOM (for dungeon icons)
         * @returns {string|null} Actions sprite URL or null if not found
         */
        getActionsSpriteUrl() {
            const actionsIcon = document.querySelector('use[href*="actions_sprite"]');
            if (!actionsIcon) {
                return null;
            }
            const href = actionsIcon.getAttribute('href');
            return href ? href.split('#')[0] : null;
        }

        /**
         * Clone SVG symbol from DOM into defs
         * @param {string} symbolId - Symbol ID to clone
         * @param {SVGDefsElement} defsElement - Defs element to append to
         * @returns {boolean} True if symbol was found and cloned
         */
        cloneSymbolToDefs(symbolId, defsElement) {
            // Check if already cloned
            if (defsElement.querySelector(`symbol[id="${symbolId}"]`)) {
                return true;
            }

            // Find the symbol in the game's loaded sprites
            const symbol = document.querySelector(`symbol[id="${symbolId}"]`);
            if (!symbol) {
                return false;
            }

            // Clone and add to our defs
            const clonedSymbol = symbol.cloneNode(true);
            defsElement.appendChild(clonedSymbol);
            return true;
        }

        /**
         * Create a clickable filter icon with count badge
         * @param {string} id - Unique identifier for this filter
         * @param {string} title - Tooltip text
         * @param {string} symbolId - Symbol ID in sprite
         * @param {Function} getEnabled - Function to check if filter is enabled
         * @param {string} spriteType - Sprite type: 'misc', 'actions', 'items' (default: 'actions')
         * @returns {HTMLElement} Filter icon container
         */
        createFilterIcon(id, title, symbolId, getEnabled, spriteType = 'actions') {
            const container = document.createElement('div');
            container.setAttribute('data-filter-id', id);
            container.style.position = 'relative';
            container.style.cursor = 'pointer';
            container.style.userSelect = 'none';
            container.title = title;

            // Get appropriate sprite URL based on type
            let spriteUrl;

            if (spriteType === 'actions') {
                // Try dynamic extraction first, fallback to hardcoded URL
                spriteUrl = this.getActionsSpriteUrl() || SPRITE_URLS.actions;
            } else if (spriteType === 'misc') {
                // Try dynamic extraction first, fallback to hardcoded URL
                spriteUrl = this.getMiscSpriteUrl() || SPRITE_URLS.misc;
            } else if (spriteType === 'items') {
                spriteUrl = this.getItemsSpriteUrl();
            }

            // Create SVG icon
            if (spriteUrl) {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '24');
                svg.setAttribute('height', '24');
                svg.setAttribute('viewBox', '0 0 1024 1024');
                svg.style.display = 'block';
                svg.style.transition = 'opacity 0.2s';

                // Create use element with external sprite reference
                const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                use.setAttribute('href', `${spriteUrl}#${symbolId}`);
                svg.appendChild(use);
                container.appendChild(svg);
            }

            // Create count badge
            const countBadge = document.createElement('span');
            countBadge.setAttribute('data-count-badge', 'true');
            countBadge.style.position = 'absolute';
            countBadge.style.top = '-4px';
            countBadge.style.right = '-8px';
            countBadge.style.fontSize = '11px';
            countBadge.style.fontWeight = 'bold';
            countBadge.style.color = '#fff';
            countBadge.style.textShadow = '0 0 2px #000, 0 0 2px #000';
            countBadge.style.pointerEvents = 'none';
            countBadge.style.transition = 'opacity 0.2s';
            countBadge.textContent = '*0';
            container.appendChild(countBadge);

            // Click handler
            container.addEventListener('click', () => {
                this.handleFilterClick(id);
            });

            // Set initial state
            this.updateIconState(container, getEnabled());

            return container;
        }

        /**
         * Handle filter icon click
         * @param {string} filterId - ID of the filter that was clicked
         */
        handleFilterClick(filterId) {
            if (filterId === 'battle') {
                // Toggle battle filter
                const currentState = this.getBattleFilterEnabled();
                this.state.battle = !currentState;
                storage$1.set(STORAGE_KEYS.battle, this.state.battle, 'settings', true);
            } else {
                // Toggle dungeon filter
                const dungeonHrid = Object.keys(this.dungeonConfig).find(
                    (hrid) => this.dungeonConfig[hrid].id === filterId
                );
                if (dungeonHrid) {
                    const currentState = this.getDungeonFilterEnabled(dungeonHrid);
                    this.state.dungeons[filterId] = !currentState;
                    const key = `${STORAGE_KEYS.dungeonPrefix}${filterId}`;
                    storage$1.set(key, this.state.dungeons[filterId], 'settings', true);
                }
            }

            // Update all icon states
            this.updateAllIconStates();

            // Dispatch custom event to notify other components
            this.dispatchFilterChange(filterId);
        }

        dispatchFilterChange(filterId) {
            document.dispatchEvent(
                new CustomEvent('mwi-task-icon-filter-changed', {
                    detail: {
                        filterId,
                        battleEnabled: this.getBattleFilterEnabled(),
                    },
                })
            );
        }

        /**
         * Update visual state of a filter icon
         * @param {HTMLElement} container - Filter icon container
         * @param {boolean} enabled - Whether filter is enabled
         */
        updateIconState(container, enabled) {
            const svg = container.querySelector('svg');
            const countBadge = container.querySelector('[data-count-badge]');

            // If SVG doesn't exist (sprite not loaded yet), skip update
            if (!svg || !countBadge) {
                return;
            }

            if (enabled) {
                svg.style.opacity = '1.0';
                countBadge.style.display = 'inline';
            } else {
                svg.style.opacity = '0.3';
                countBadge.style.display = 'none';
            }
        }

        /**
         * Update all icon states based on current config
         */
        updateAllIconStates() {
            // Update battle icon
            const battleIcon = this.filterIcons.get('battle');
            if (battleIcon) {
                this.updateIconState(battleIcon, this.getBattleFilterEnabled());
            }

            // Update dungeon icons
            Object.entries(this.dungeonConfig).forEach(([hrid, dungeon]) => {
                const dungeonIcon = this.filterIcons.get(dungeon.id);
                if (dungeonIcon) {
                    this.updateIconState(dungeonIcon, this.getDungeonFilterEnabled(hrid));
                }
            });
        }

        /**
         * Update task counts on all filter icons
         * @param {HTMLElement} panel - Task panel container
         */
        updateCounts(panel) {
            // Find all task items in the panel
            const taskItems = panel.querySelectorAll(GAME.TASK_CARD);

            // Count tasks for each filter
            const counts = {
                battle: 0,
                chimerical_den: 0,
                sinister_circus: 0,
                enchanted_fortress: 0,
                pirate_cove: 0,
            };

            taskItems.forEach((taskItem) => {
                // Check if this is a combat task
                const isCombatTask = this.isTaskCombat(taskItem);

                if (isCombatTask) {
                    counts.battle++;

                    // Check which dungeon this task is for
                    const dungeonType = this.getTaskDungeonType(taskItem);
                    if (dungeonType && counts.hasOwnProperty(dungeonType)) {
                        counts[dungeonType]++;
                    }
                }
            });

            // Update count badges
            this.filterIcons.forEach((icon, filterId) => {
                const count = counts[filterId] || 0;
                const countBadge = icon.querySelector('[data-count-badge]');
                if (countBadge) {
                    countBadge.textContent = `*${count}`;
                }
                this.currentCounts.set(filterId, count);
            });
        }

        /**
         * Check if a task item is a combat task
         * @param {HTMLElement} taskItem - Task item element
         * @returns {boolean} True if this is a combat task
         */
        isTaskCombat(taskItem) {
            // Check for monster icon class added by task-icons.js to all combat tasks
            const monsterIcon = taskItem.querySelector('.mwi-task-icon-monster');
            return monsterIcon !== null;
        }

        /**
         * Get the dungeon type for a combat task
         * @param {HTMLElement} taskItem - Task item element
         * @returns {string|null} Dungeon ID or null if not a dungeon task
         */
        getTaskDungeonType(taskItem) {
            // Look for dungeon badge icons (using class, not ID)
            const badges = taskItem.querySelectorAll('.mwi-task-icon-dungeon svg use');

            if (!badges || badges.length === 0) {
                return null;
            }

            // Check each badge to identify the dungeon
            for (const badge of badges) {
                const href = badge.getAttribute('href') || badge.getAttributeNS('http://www.w3.org/1999/xlink', 'href');

                if (!href) continue;

                // Match href to dungeon config
                for (const [_hrid, dungeon] of Object.entries(this.dungeonConfig)) {
                    if (href.includes(dungeon.spriteId)) {
                        return dungeon.id;
                    }
                }
            }

            return null;
        }

        /**
         * Set up observer to watch for task list changes
         * @param {HTMLElement} panel - Task panel container
         */
        observeTaskList(panel) {
            // Find the task list container
            const taskList = panel.querySelector(GAME.TASK_LIST);
            if (!taskList) {
                console.warn('[TaskIconFilters] Could not find task list');
                return;
            }

            // Disconnect existing observer if any
            if (this.taskListObserver) {
                this.taskListObserver();
            }

            // Create new observer
            this.taskListObserver = createMutationWatcher(
                taskList,
                () => {
                    this.updateCounts(panel);
                },
                {
                    childList: true,
                    subtree: true,
                }
            );
        }

        /**
         * Check if battle filter is enabled
         * @returns {boolean} True if battle icons should be shown
         */
        getBattleFilterEnabled() {
            return this.state.battle !== false;
        }

        /**
         * Check if a specific dungeon filter is enabled
         * @param {string} dungeonHrid - Dungeon action HRID
         * @returns {boolean} True if this dungeon's badges should be shown
         */
        getDungeonFilterEnabled(dungeonHrid) {
            const dungeon = this.dungeonConfig[dungeonHrid];
            if (!dungeon) return false;

            return this.state.dungeons[dungeon.id] === true;
        }

        /**
         * Check if a specific dungeon badge should be shown
         * @param {string} dungeonHrid - Dungeon action HRID
         * @returns {boolean} True if badge should be shown
         */
        shouldShowDungeonBadge(dungeonHrid) {
            // Must have both battle toggle enabled AND specific dungeon toggle enabled
            return this.getBattleFilterEnabled() && this.getDungeonFilterEnabled(dungeonHrid);
        }
    }

    // Export singleton instance
    const taskIconFilters = new TaskIconFilters();

    /**
     * Task Icons
     * Adds visual icon overlays to task cards
     */


    // Sprite URL detection and fallback system
    // Instead of hardcoded URLs, we detect sprite URLs from the game's DOM
    // If detection fails, we try multiple fallback strategies for Steam compatibility
    const FALLBACK_ACTIONS_SPRITE_URLS = [
        '/static/media/actions_sprite.e6388cbc.svg', // Original hardcoded URL
        '/static/media/actions_sprite.svg', // Without webpack hash (if build system changed)
        'actions_sprite.svg', // Relative path
    ];

    // Known webpack hashes for combat_monsters_sprite (update as game updates)
    const FALLBACK_MONSTERS_SPRITE_URLS = [
        '/static/media/combat_monsters_sprite.e6388cbc.svg', // Try same hash as actions_sprite
        '/static/media/combat_monsters_sprite.svg', // Without webpack hash
        'combat_monsters_sprite.svg', // Relative path
    ];

    class TaskIcons {
        constructor() {
            this.initialized = false;
            this.observers = [];
            this.characterSwitchingHandler = null;

            // Cache for parsed game data
            this.itemsByHrid = null;
            this.actionsByHrid = null;
            this.monstersByHrid = null;
            this.timerRegistry = createTimerRegistry();

            // Cache for detected sprite URLs (avoid repeated DOM queries)
            this.cachedSpriteUrls = {
                actions: null,
                items: null,
                monsters: null,
                misc: null,
            };

            // Track if we've already attempted to load sprites
            this.spriteLoadAttempted = {
                actions: false,
                items: false,
                monsters: false,
                misc: false,
            };

            // Track if we're currently fetching a sprite to avoid duplicate requests
            this.spriteFetchInProgress = {
                monsters: false,
            };

            // Store fetched sprite SVG content
            this.fetchedSprites = {
                monsters: null,
            };
        }

        /**
         * Initialize the task icons feature
         */
        initialize() {
            if (this.initialized) {
                return;
            }

            // Load game data from DataManager
            this.loadGameData();

            // Watch for task cards being added/updated
            this.watchTaskCards();

            this.characterSwitchingHandler = () => {
                this.cleanup();
            };

            dataManager$1.on('character_switching', this.characterSwitchingHandler);

            // Listen for filter changes to refresh icons
            this.filterChangeHandler = () => {
                this.refreshAllIcons();
            };
            document.addEventListener('mwi-task-icon-filter-changed', this.filterChangeHandler);

            this.initialized = true;
        }

        /**
         * Load game data from DataManager
         */
        loadGameData() {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) {
                return;
            }

            // Build lookup maps for quick access
            this.itemsByHrid = new Map();
            this.actionsByHrid = new Map();
            this.monstersByHrid = new Map();
            this.locationsByHrid = new Map();

            // Index items
            if (gameData.itemDetailMap) {
                Object.entries(gameData.itemDetailMap).forEach(([hrid, item]) => {
                    this.itemsByHrid.set(hrid, item);
                });
            }

            // Index actions
            if (gameData.actionDetailMap) {
                Object.entries(gameData.actionDetailMap).forEach(([hrid, action]) => {
                    this.actionsByHrid.set(hrid, action);
                });
            }

            // Index monsters
            if (gameData.combatMonsterDetailMap) {
                Object.entries(gameData.combatMonsterDetailMap).forEach(([hrid, monster]) => {
                    this.monstersByHrid.set(hrid, monster);
                });
            }
        }

        /**
         * Watch for task cards in the DOM
         */
        watchTaskCards() {
            // Process existing task cards
            this.processAllTaskCards();

            // Watch for task list appearing
            const unregisterTaskList = domObserver$1.onClass('TaskIcons-TaskList', 'TasksPanel_taskList', () => {
                this.processAllTaskCards();
            });
            this.observers.push(unregisterTaskList);

            // Watch for individual task cards appearing
            const unregisterTask = domObserver$1.onClass('TaskIcons-Task', 'RandomTask_randomTask', () => {
                this.processAllTaskCards();
            });
            this.observers.push(unregisterTask);

            // Watch for monster sprite being loaded into DOM
            // The sprite might be an SVG element or a defs section
            const checkForMonsterSprite = () => {
                const useElements = document.querySelectorAll('use');
                for (const use of useElements) {
                    const href = use.getAttribute('href') || use.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                    if (href && href.includes('combat_monsters_sprite')) {
                        const url = href.split('#')[0];

                        // Cache the URL so we don't lose it
                        this.cachedSpriteUrls.monsters = url;

                        // Sprite just loaded, refresh all icons
                        this.clearAllProcessedMarkers();
                        this.processAllTaskCards();
                        break;
                    }
                }
            };

            // Check periodically for sprite loading (more reliable than trying to watch for it)
            const spriteCheckInterval = setInterval(() => {
                // Only check if we haven't found it yet
                if (!this.cachedSpriteUrls.monsters) {
                    checkForMonsterSprite();
                }
            }, 1000);
            this.timerRegistry.registerInterval(spriteCheckInterval);
            this.observers.push(() => clearInterval(spriteCheckInterval));

            // Watch for task rerolls via WebSocket
            const questsHandler = (data) => {
                if (!data.endCharacterQuests) {
                    return;
                }

                // Wait for game to update DOM before updating icons
                const iconsTimeout = setTimeout(() => {
                    this.clearAllProcessedMarkers();
                    this.processAllTaskCards();
                }, 250);
                this.timerRegistry.registerTimeout(iconsTimeout);
            };

            webSocketHook$1.on('quests_updated', questsHandler);

            this.observers.push(() => {
                webSocketHook$1.off('quests_updated', questsHandler);
            });
        }

        /**
         * Process all task cards in the DOM
         */
        processAllTaskCards() {
            const taskList = document.querySelector(GAME.TASK_LIST);
            if (!taskList) {
                return;
            }

            // Ensure game data is loaded
            if (!this.itemsByHrid || this.itemsByHrid.size === 0) {
                this.loadGameData();
                if (!this.itemsByHrid || this.itemsByHrid.size === 0) {
                    return;
                }
            }

            const taskCards = taskList.querySelectorAll(GAME.TASK_CARD);

            taskCards.forEach((card) => {
                // Get current task name
                const nameElement = card.querySelector(GAME.TASK_NAME);
                if (!nameElement) return;

                const taskName = nameElement.textContent.trim();

                // Check if this card already has icons for this exact task
                const processedTaskName = card.getAttribute('data-mwi-task-processed');

                // Only process if:
                // 1. Card has never been processed, OR
                // 2. Task name has changed (task was rerolled)
                if (processedTaskName !== taskName) {
                    // Remove old icons (if any)
                    this.removeIcons(card);

                    // Add new icons
                    this.addIconsToTaskCard(card);

                    // Mark card as processed with current task name
                    card.setAttribute('data-mwi-task-processed', taskName);
                }
            });
        }

        /**
         * Clear all processed markers to force icon refresh
         */
        clearAllProcessedMarkers() {
            const taskList = document.querySelector(GAME.TASK_LIST);
            if (!taskList) {
                return;
            }

            const taskCards = taskList.querySelectorAll(GAME.TASK_CARD);
            taskCards.forEach((card) => {
                card.removeAttribute('data-mwi-task-processed');
            });
        }

        /**
         * Refresh all icons (called when filters change)
         */
        refreshAllIcons() {
            this.clearAllProcessedMarkers();
            this.processAllTaskCards();
        }

        /**
         * Add icon overlays to a task card
         */
        addIconsToTaskCard(taskCard) {
            // Parse task description to get task type and name
            const taskInfo = this.parseTaskCard(taskCard);
            if (!taskInfo) {
                return;
            }

            // Add appropriate icons based on task type
            if (taskInfo.isCombatTask) {
                this.addMonsterIcon(taskCard, taskInfo);
            } else {
                this.addActionIcon(taskCard, taskInfo);
            }
        }

        /**
         * Parse task card to extract task information
         */
        parseTaskCard(taskCard) {
            const nameElement = taskCard.querySelector(GAME.TASK_NAME);
            if (!nameElement) {
                return null;
            }

            const fullText = nameElement.textContent.trim();

            // Format is "SkillType - TaskName" or "Defeat - MonsterName"
            const match = fullText.match(/^(.+?)\s*-\s*(.+)$/);
            if (!match) {
                return null;
            }

            const [, skillType, taskName] = match;

            const taskInfo = {
                skillType: skillType.trim(),
                taskName: taskName.trim(),
                fullText,
                isCombatTask: skillType.trim() === 'Defeat',
            };

            return taskInfo;
        }

        /**
         * Find action HRID by display name
         */
        findActionHrid(actionName) {
            // Search through actions to find matching name
            for (const [hrid, action] of this.actionsByHrid) {
                if (action.name === actionName) {
                    return hrid;
                }
            }
            return null;
        }

        /**
         * Find monster HRID by display name
         */
        findMonsterHrid(monsterName) {
            // Strip zone tier suffix (e.g., "Grizzly BearZ8" → "Grizzly Bear")
            // Format is: MonsterNameZ# where # is the zone index
            const cleanName = monsterName.replace(/Z\d+$/, '').trim();

            // Search through monsters to find matching name
            for (const [hrid, monster] of this.monstersByHrid) {
                if (monster.name === cleanName) {
                    return hrid;
                }
            }
            return null;
        }

        /**
         * Add action icon to task card
         */
        addActionIcon(taskCard, taskInfo) {
            const actionHrid = this.findActionHrid(taskInfo.taskName);
            if (!actionHrid) {
                return;
            }

            const action = this.actionsByHrid.get(actionHrid);
            if (!action) {
                return;
            }

            // Determine icon name and sprite type
            let iconName;
            let spriteType = 'item'; // Default to items_sprite

            // Check if action produces a specific item (use item sprite)
            if (action.outputItems && action.outputItems.length > 0) {
                const outputItem = action.outputItems[0];
                const itemHrid = outputItem.itemHrid || outputItem.hrid;
                const item = this.itemsByHrid.get(itemHrid);
                if (item) {
                    iconName = itemHrid.split('/').pop();
                    spriteType = 'item';
                }
            }

            // If still no icon, try to find corresponding item for gathering actions
            if (!iconName) {
                // Convert action HRID to item HRID (e.g., /actions/foraging/cow → /items/cow)
                const actionName = actionHrid.split('/').pop();
                const potentialItemHrid = `/items/${actionName}`;
                const potentialItem = this.itemsByHrid.get(potentialItemHrid);

                if (potentialItem) {
                    iconName = actionName;
                    spriteType = 'item';
                } else {
                    // Fall back to action sprite (e.g., for trees in woodcutting)
                    iconName = actionName;
                    spriteType = 'action';
                }
            }

            this.addIconOverlay(taskCard, iconName, spriteType);
        }

        /**
         * Add monster icon to task card
         */
        async addMonsterIcon(taskCard, taskInfo) {
            const monsterHrid = this.findMonsterHrid(taskInfo.taskName);
            if (!monsterHrid) {
                return;
            }

            // Count dungeons if dungeon icons are enabled
            let dungeonCount = 0;
            if (config$1.isFeatureEnabled('taskIconsDungeons')) {
                dungeonCount = this.countDungeonsForMonster(monsterHrid);
            }

            // Calculate icon width based on total count (1 monster + N dungeons)
            const totalIcons = 1 + dungeonCount;
            let iconWidth;
            if (totalIcons <= 2) {
                iconWidth = 30;
            } else if (totalIcons <= 4) {
                iconWidth = 25;
            } else {
                iconWidth = 20;
            }

            // Position monster on the right (ends at 100%)
            const monsterPosition = 100 - iconWidth;
            const iconName = monsterHrid.split('/').pop();
            await this.addIconOverlay(taskCard, iconName, 'monster', `${monsterPosition}%`, `${iconWidth}%`);

            // Add dungeon icons if enabled
            if (config$1.isFeatureEnabled('taskIconsDungeons') && dungeonCount > 0) {
                await this.addDungeonIcons(taskCard, monsterHrid, iconWidth);
            }
        }

        /**
         * Count how many dungeons a monster appears in
         */
        countDungeonsForMonster(monsterHrid) {
            let count = 0;

            for (const [_actionHrid, action] of this.actionsByHrid) {
                if (!action.combatZoneInfo?.isDungeon) continue;

                const dungeonInfo = action.combatZoneInfo.dungeonInfo;
                if (!dungeonInfo) continue;

                let monsterFound = false;

                // Check random spawns
                if (dungeonInfo.randomSpawnInfoMap) {
                    for (const waveSpawns of Object.values(dungeonInfo.randomSpawnInfoMap)) {
                        if (waveSpawns.spawns) {
                            for (const spawn of waveSpawns.spawns) {
                                if (spawn.combatMonsterHrid === monsterHrid) {
                                    monsterFound = true;
                                    break;
                                }
                            }
                        }
                        if (monsterFound) break;
                    }
                }

                // Check fixed spawns
                if (!monsterFound && dungeonInfo.fixedSpawnsMap) {
                    for (const waveSpawns of Object.values(dungeonInfo.fixedSpawnsMap)) {
                        for (const spawn of waveSpawns) {
                            if (spawn.combatMonsterHrid === monsterHrid) {
                                monsterFound = true;
                                break;
                            }
                        }
                        if (monsterFound) break;
                    }
                }

                if (monsterFound) {
                    count++;
                }
            }

            return count;
        }

        /**
         * Add dungeon icons for a monster
         * @param {HTMLElement} taskCard - Task card element
         * @param {string} monsterHrid - Monster HRID
         * @param {number} iconWidth - Width percentage for each icon
         */
        async addDungeonIcons(taskCard, monsterHrid, iconWidth) {
            const monster = this.monstersByHrid.get(monsterHrid);
            if (!monster) return;

            // Find which dungeons this monster appears in
            const dungeonHrids = [];

            for (const [actionHrid, action] of this.actionsByHrid) {
                // Skip non-dungeon actions
                if (!action.combatZoneInfo?.isDungeon) continue;

                const dungeonInfo = action.combatZoneInfo.dungeonInfo;
                if (!dungeonInfo) continue;

                let monsterFound = false;

                // Check random spawns (regular waves)
                if (dungeonInfo.randomSpawnInfoMap) {
                    for (const waveSpawns of Object.values(dungeonInfo.randomSpawnInfoMap)) {
                        if (waveSpawns.spawns) {
                            for (const spawn of waveSpawns.spawns) {
                                if (spawn.combatMonsterHrid === monsterHrid) {
                                    monsterFound = true;
                                    break;
                                }
                            }
                        }
                        if (monsterFound) break;
                    }
                }

                // Check fixed spawns (boss waves)
                if (!monsterFound && dungeonInfo.fixedSpawnsMap) {
                    for (const waveSpawns of Object.values(dungeonInfo.fixedSpawnsMap)) {
                        for (const spawn of waveSpawns) {
                            if (spawn.combatMonsterHrid === monsterHrid) {
                                monsterFound = true;
                                break;
                            }
                        }
                        if (monsterFound) break;
                    }
                }

                if (monsterFound) {
                    dungeonHrids.push(actionHrid);
                }
            }

            // Position dungeons right-to-left, starting from left of monster
            const monsterPosition = 100 - iconWidth;
            let position = monsterPosition - iconWidth; // Start one icon to the left of monster

            for (const dungeonHrid of dungeonHrids) {
                // Check if this dungeon should be shown based on filter settings
                if (!taskIconFilters.shouldShowDungeonBadge(dungeonHrid)) {
                    continue; // Skip this dungeon
                }

                const iconName = dungeonHrid.split('/').pop();
                await this.addIconOverlay(taskCard, iconName, 'dungeon', `${position}%`, `${iconWidth}%`);
                position -= iconWidth; // Move left for next dungeon
            }
        }

        /**
         * Get the current items sprite URL from the DOM
         * @returns {string|null} Items sprite URL or null if not found
         */
        getItemsSpriteUrl() {
            // Search manually to support both href and xlink:href
            const allUseElements = document.querySelectorAll('use');

            for (const use of allUseElements) {
                const href = use.getAttribute('href') || use.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                if (href && href.includes('items_sprite')) {
                    return href.split('#')[0];
                }
            }

            return null;
        }

        /**
         * Get the current combat monsters sprite URL from the DOM
         * @returns {string|null} Monsters sprite URL or null if not found
         */
        async getMonstersSpriteUrl() {
            // Check cache first
            if (this.cachedSpriteUrls.monsters) {
                return this.cachedSpriteUrls.monsters;
            }

            // Try to find it in the DOM first
            // Can't use CSS selector for xlink:href, so search manually
            const allUseElements = document.querySelectorAll('use');
            let monsterIcon = null;

            for (const use of allUseElements) {
                const href = use.getAttribute('href') || use.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                if (href && href.includes('combat_monsters_sprite')) {
                    monsterIcon = use;
                    break;
                }
            }

            if (monsterIcon) {
                const href =
                    monsterIcon.getAttribute('href') || monsterIcon.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                const url = href ? href.split('#')[0] : null;
                // Cache it
                this.cachedSpriteUrls.monsters = url;
                return url;
            }

            // If not in DOM, we can't display monster icons
            // The sprite is only loaded when viewing combat panel
            return null;
        }

        /**
         * Fetch combat_monsters_sprite and inject it into the page
         * @param {Array<string>} detectedHashes - Array of webpack hashes to try
         * @returns {Promise<string|null>} Sprite URL if successful
         */
        async fetchAndInjectMonsterSprite(detectedHashes = []) {
            if (this.spriteFetchInProgress.monsters) {
                return null; // Already fetching, avoid duplicate requests
            }

            this.spriteFetchInProgress.monsters = true;

            // Build fallback URLs using detected hashes + original hardcoded ones
            const fallbackUrls = [
                // Try detected hashes first (from currently loaded sprites)
                ...detectedHashes.map((hash) => `/static/media/combat_monsters_sprite.${hash}.svg`),
                // Then try original hardcoded fallbacks
                ...FALLBACK_MONSTERS_SPRITE_URLS,
            ];

            try {
                // Try each fallback URL until one works
                for (const url of fallbackUrls) {
                    try {
                        const response = await fetch(url);

                        if (!response.ok) {
                            continue;
                        }

                        const svgText = await response.text();

                        // Parse the SVG and inject it into the page
                        const parser = new DOMParser();
                        const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');

                        // Check for parsing errors
                        const parserError = svgDoc.querySelector('parsererror');
                        if (parserError) {
                            continue;
                        }

                        const svgElement = svgDoc.querySelector('svg');

                        // Try documentElement as fallback
                        const rootElement = svgDoc.documentElement;

                        // Use either querySelector result or documentElement (if it's an SVG)
                        const finalElement =
                            svgElement || (rootElement?.tagName?.toLowerCase() === 'svg' ? rootElement : null);

                        if (finalElement) {
                            // Hide the SVG (we only need it for symbol definitions)
                            finalElement.style.display = 'none';
                            finalElement.setAttribute('id', 'mwi-injected-monsters-sprite');

                            // Inject into page body
                            document.body.appendChild(finalElement);

                            // Store the URL for future use
                            this.fetchedSprites.monsters = url;
                            return url;
                        }
                    } catch {
                        // Try next URL
                        continue;
                    }
                }

                return null;
            } finally {
                this.spriteFetchInProgress.monsters = false;
            }
        }

        /**
         * Get the current actions sprite URL from the DOM (for dungeon icons)
         * @returns {string|null} Actions sprite URL or null if not found
         */
        getActionsSpriteUrl() {
            const actionsIcon = document.querySelector('use[href*="actions_sprite"]');
            if (actionsIcon) {
                const href = actionsIcon.getAttribute('href');
                return href ? href.split('#')[0] : null;
            }

            // Fallback to hardcoded URL
            return FALLBACK_ACTIONS_SPRITE_URLS[0];
        }

        /**
         * Get the current misc sprite URL from the DOM
         * @returns {string|null} Misc sprite URL or null if not found
         */
        getMiscSpriteUrl() {
            const miscIcon = document.querySelector('use[href*="misc_sprite"]');
            if (!miscIcon) {
                return null;
            }
            const href = miscIcon.getAttribute('href');
            return href ? href.split('#')[0] : null;
        }

        /**
         * Clone SVG symbol from DOM into defs
         * @param {string} symbolId - Symbol ID to clone
         * @param {SVGDefsElement} defsElement - Defs element to append to
         * @returns {boolean} True if symbol was found and cloned
         */
        cloneSymbolToDefs(symbolId, defsElement) {
            // Check if already cloned
            if (defsElement.querySelector(`symbol[id="${symbolId}"]`)) {
                return true;
            }

            // Find the symbol in the game's loaded sprites
            const symbol = document.querySelector(`symbol[id="${symbolId}"]`);
            if (!symbol) {
                return false;
            }

            // Clone and add to our defs
            const clonedSymbol = symbol.cloneNode(true);
            defsElement.appendChild(clonedSymbol);
            return true;
        }

        /**
         * Add icon overlay to task card
         * @param {HTMLElement} taskCard - Task card element
         * @param {string} iconName - Icon name in sprite (symbol ID)
         * @param {string} type - Icon type (action/monster/dungeon)
         * @param {string} leftPosition - Left position percentage
         * @param {string} widthPercent - Width percentage (default: '30%')
         */
        async addIconOverlay(taskCard, iconName, type, leftPosition = '50%', widthPercent = '30%') {
            // Create container for icon
            const iconDiv = document.createElement('div');
            iconDiv.className = `mwi-task-icon mwi-task-icon-${type}`;
            iconDiv.style.position = 'absolute';
            iconDiv.style.left = leftPosition;
            iconDiv.style.width = widthPercent;
            iconDiv.style.height = '100%';
            iconDiv.style.opacity = '0.3';
            iconDiv.style.pointerEvents = 'none';
            iconDiv.style.zIndex = '0';

            // Get appropriate sprite URL based on icon type
            let spriteUrl;
            if (type === 'monster') {
                // Await monster sprite (might fetch it)
                spriteUrl = await this.getMonstersSpriteUrl();
            } else if (type === 'dungeon' || type === 'action') {
                // Dungeon icons and action icons (trees, etc.) are in actions_sprite
                spriteUrl = this.getActionsSpriteUrl();
            } else {
                // Item icons are in items_sprite (default)
                spriteUrl = this.getItemsSpriteUrl();
            }

            if (!spriteUrl) {
                // Sprite not loaded yet, skip icon
                return;
            }

            // Create SVG element
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');

            // Create use element with external sprite reference
            const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
            // Set both href and xlink:href for browser compatibility
            const spriteReference = `${spriteUrl}#${iconName}`;
            use.setAttribute('href', spriteReference);
            use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', spriteReference);
            svg.appendChild(use);

            iconDiv.appendChild(svg);

            // Ensure task card is positioned relatively
            taskCard.style.position = 'relative';

            // Insert icon before content (so it appears in background)
            const taskContent = taskCard.querySelector(GAME.TASK_CONTENT);
            if (taskContent) {
                taskContent.style.zIndex = '1';
                taskContent.style.position = 'relative';
            }

            taskCard.appendChild(iconDiv);
        }

        /**
         * Remove icons from task card
         */
        removeIcons(taskCard) {
            const existingIcons = taskCard.querySelectorAll('.mwi-task-icon');
            existingIcons.forEach((icon) => icon.remove());
        }

        /**
         * Cleanup
         */
        cleanup() {
            this.observers.forEach((unregister) => unregister());
            this.observers = [];

            // Remove all icons and data attributes
            document.querySelectorAll('.mwi-task-icon').forEach((icon) => icon.remove());
            document.querySelectorAll('[data-mwi-task-processed]').forEach((card) => {
                card.removeAttribute('data-mwi-task-processed');
            });

            // Clear caches
            this.itemsByHrid = null;
            this.actionsByHrid = null;
            this.monstersByHrid = null;

            this.timerRegistry.clearAll();

            this.initialized = false;
        }

        /**
         * Disable and cleanup (called by feature registry during character switch)
         */
        disable() {
            if (this.characterSwitchingHandler) {
                dataManager$1.off('character_switching', this.characterSwitchingHandler);
                this.characterSwitchingHandler = null;
            }

            if (this.filterChangeHandler) {
                document.removeEventListener('mwi-task-icon-filter-changed', this.filterChangeHandler);
                this.filterChangeHandler = null;
            }

            // Run cleanup
            this.cleanup();
        }
    }

    const taskIcons = new TaskIcons();

    /**
     * Task Sorter
     * Sorts tasks in the task board by skill type
     */


    class TaskSorter {
        constructor() {
            this.initialized = false;
            this.sortButton = null;
            this.unregisterObserver = null;
            this.timerRegistry = createTimerRegistry();

            // Task type ordering (combat tasks go to bottom)
            this.TASK_ORDER = {
                Milking: 1,
                Foraging: 2,
                Woodcutting: 3,
                Cheesesmithing: 4,
                Crafting: 5,
                Tailoring: 6,
                Cooking: 7,
                Brewing: 8,
                Alchemy: 9,
                Enhancing: 10,
                Defeat: 99, // Combat tasks at bottom
            };
        }

        /**
         * Initialize the task sorter
         */
        initialize() {
            if (this.initialized) return;

            // Use DOM observer to watch for task panel appearing
            this.watchTaskPanel();

            this.initialized = true;
        }

        /**
         * Watch for task panel to appear
         */
        watchTaskPanel() {
            // Register observer for task panel header (watch for the class name, not the selector)
            this.unregisterObserver = domObserver$1.onClass(
                'TaskSorter',
                'TasksPanel_taskSlotCount', // Just the class name, not [class*="..."]
                (headerElement) => {
                    this.addSortButton(headerElement);
                }
            );
        }

        /**
         * Add sort button to task panel header
         */
        addSortButton(headerElement) {
            // Check if button already exists
            if (this.sortButton && document.contains(this.sortButton)) {
                return;
            }

            // Create sort button
            this.sortButton = document.createElement('button');
            this.sortButton.className = 'Button_button__1Fe9z Button_small__3fqC7';
            this.sortButton.textContent = 'Sort Tasks';
            this.sortButton.style.marginLeft = '8px';
            this.sortButton.setAttribute('data-mwi-task-sort', 'true');
            this.sortButton.addEventListener('click', () => this.sortTasks());

            headerElement.appendChild(this.sortButton);

            // Add task icon filters if enabled
            if (config$1.isFeatureEnabled('taskIcons')) {
                taskIconFilters.addFilterBar(headerElement);
            }

            // Auto-sort if setting is enabled
            if (config$1.getSetting('taskSorter_autoSort')) {
                // Delay slightly to ensure all task cards are rendered
                const autoSortTimeout = setTimeout(() => {
                    this.sortTasks();
                }, 100);
                this.timerRegistry.registerTimeout(autoSortTimeout);
            }
        }

        /**
         * Parse task card to extract skill type and task name
         */
        parseTaskCard(taskCard) {
            const nameElement = taskCard.querySelector('[class*="RandomTask_name"]');
            if (!nameElement) return null;

            const fullText = nameElement.textContent.trim();

            // Format is "SkillType - TaskName"
            const match = fullText.match(/^(.+?)\s*-\s*(.+)$/);
            if (!match) return null;

            const [, skillType, taskName] = match;

            return {
                skillType: skillType.trim(),
                taskName: taskName.trim(),
                fullText,
            };
        }

        /**
         * Check if task is completed (has Claim Reward button)
         */
        isTaskCompleted(taskCard) {
            const claimButton = taskCard.querySelector('button.Button_button__1Fe9z.Button_buy__3s24l');
            return claimButton && claimButton.textContent.includes('Claim Reward');
        }

        /**
         * Get sort order for a task
         */
        getTaskOrder(taskCard) {
            const parsed = this.parseTaskCard(taskCard);
            if (!parsed) {
                return { skillOrder: 999, taskName: '', isCombat: false, monsterSortIndex: 999, isCompleted: false };
            }

            const skillOrder = this.TASK_ORDER[parsed.skillType] || 999;
            const isCombat = parsed.skillType === 'Defeat';
            const isCompleted = this.isTaskCompleted(taskCard);

            // For combat tasks, get monster sort index from game data
            let monsterSortIndex = 999;
            if (isCombat) {
                // Extract monster name from task name (e.g., "Granite GolemZ9" -> "Granite Golem")
                const monsterName = this.extractMonsterName(parsed.taskName);
                if (monsterName) {
                    const monsterHrid = dataManager$1.getMonsterHridFromName(monsterName);
                    if (monsterHrid) {
                        monsterSortIndex = dataManager$1.getMonsterSortIndex(monsterHrid);
                    }
                }
            }

            return {
                skillOrder,
                taskName: parsed.taskName,
                skillType: parsed.skillType,
                isCombat,
                monsterSortIndex,
                isCompleted,
            };
        }

        /**
         * Extract monster name from combat task name
         * @param {string} taskName - Task name (e.g., "Granite Golem Z9")
         * @returns {string|null} Monster name or null if not found
         */
        extractMonsterName(taskName) {
            // Combat task format from parseTaskCard: "[Monster Name]Z[number]" (may or may not have space)
            // Strip the zone suffix "Z\d+" from the end
            const match = taskName.match(/^(.+?)\s*Z\d+$/);
            if (match) {
                return match[1].trim();
            }

            // Fallback: return as-is if no zone suffix found
            return taskName.trim();
        }

        /**
         * Compare two task cards for sorting
         */
        compareTaskCards(cardA, cardB) {
            const orderA = this.getTaskOrder(cardA);
            const orderB = this.getTaskOrder(cardB);

            // First: Sort by completion status (incomplete tasks first, completed tasks last)
            if (orderA.isCompleted !== orderB.isCompleted) {
                return orderA.isCompleted ? 1 : -1;
            }

            // Second: Sort by skill type (combat vs non-combat)
            if (orderA.skillOrder !== orderB.skillOrder) {
                return orderA.skillOrder - orderB.skillOrder;
            }

            // Third: Within combat tasks, sort by zone progression (sortIndex)
            if (orderA.isCombat && orderB.isCombat) {
                if (orderA.monsterSortIndex !== orderB.monsterSortIndex) {
                    return orderA.monsterSortIndex - orderB.monsterSortIndex;
                }
            }

            // Fourth: Within same skill type (or same zone for combat), sort alphabetically by task name
            return orderA.taskName.localeCompare(orderB.taskName);
        }

        /**
         * Sort all tasks in the task board
         */
        sortTasks() {
            const taskList = document.querySelector(GAME.TASK_LIST);
            if (!taskList) {
                return;
            }

            // Get all task cards
            const taskCards = Array.from(taskList.querySelectorAll(GAME.TASK_CARD));
            if (taskCards.length === 0) {
                return;
            }

            // Sort the cards
            taskCards.sort((a, b) => this.compareTaskCards(a, b));

            // Re-append in sorted order
            taskCards.forEach((card) => taskList.appendChild(card));

            // After sorting, React may re-render task cards and remove our icons
            // Clear the processed markers and force icon re-processing
            if (config$1.isFeatureEnabled('taskIcons')) {
                // Use taskIcons module's method to clear markers
                taskIcons.clearAllProcessedMarkers();

                // Trigger icon re-processing
                // Use setTimeout to ensure React has finished any re-rendering
                const iconTimeout = setTimeout(() => {
                    taskIcons.processAllTaskCards();
                }, 100);
                this.timerRegistry.registerTimeout(iconTimeout);
            }
        }

        /**
         * Cleanup
         */
        cleanup() {
            if (this.unregisterObserver) {
                this.unregisterObserver();
                this.unregisterObserver = null;
            }

            if (this.sortButton && document.contains(this.sortButton)) {
                this.sortButton.remove();
            }
            this.sortButton = null;
            this.timerRegistry.clearAll();
            this.initialized = false;
        }

        disable() {
            this.cleanup();
        }
    }

    const taskSorter = new TaskSorter();

    /**
     * Remaining XP Display
     * Shows remaining XP to next level on skill bars in the left navigation panel
     */


    class RemainingXP {
        constructor() {
            this.initialized = false;
            this.updateInterval = null;
            this.unregisterObservers = [];
            this.timerRegistry = createTimerRegistry();
            this.progressBarObservers = new Map(); // Track MutationObservers for each progress bar
        }

        /**
         * Initialize the remaining XP display
         */
        initialize() {
            if (this.initialized) return;

            // Watch for skill buttons appearing
            this.watchSkillButtons();

            // Setup observers for any existing progress bars
            const existingProgressBars = document.querySelectorAll('[class*="currentExperience"]');
            existingProgressBars.forEach((progressBar) => {
                this.setupProgressBarObserver(progressBar);
            });

            this.initialized = true;
        }

        /**
         * Watch for skill buttons in the navigation panel and other skill displays
         */
        watchSkillButtons() {
            // Watch for left navigation bar skills (non-combat skills)
            const unregisterNav = domObserver$1.onClass(
                'RemainingXP-NavSkillBar',
                'NavigationBar_currentExperience',
                (progressBar) => {
                    this.setupProgressBarObserver(progressBar);
                }
            );
            this.unregisterObservers.push(unregisterNav);

            // Wait for character data to be loaded before setting up observers
            const initHandler = () => {
                // Setup observers for all progress bars once character data is ready
                const initialUpdateTimeout = setTimeout(() => {
                    const progressBars = document.querySelectorAll('[class*="currentExperience"]');
                    progressBars.forEach((progressBar) => {
                        this.setupProgressBarObserver(progressBar);
                    });
                }, 500);
                this.timerRegistry.registerTimeout(initialUpdateTimeout);
            };

            dataManager$1.on('character_initialized', initHandler);

            // Check if character data already loaded (in case we missed the event)
            if (dataManager$1.characterData) {
                initHandler();
            }

            this.unregisterObservers.push(() => {
                dataManager$1.off('character_initialized', initHandler);
            });
        }

        /**
         * Setup MutationObserver for a progress bar to watch for style changes
         * @param {HTMLElement} progressBar - The progress bar element
         */
        setupProgressBarObserver(progressBar) {
            // Skip if we're already observing this progress bar
            if (this.progressBarObservers.has(progressBar)) {
                return;
            }

            // Initial update
            this.addRemainingXP(progressBar);

            // Watch for style attribute changes (width percentage updates)
            const unwatch = createMutationWatcher(
                progressBar,
                () => {
                    this.updateSingleSkillBar(progressBar);
                },
                {
                    attributes: true,
                    attributeFilter: ['style'],
                }
            );

            // Store the observer so we can clean it up later
            this.progressBarObservers.set(progressBar, unwatch);
        }

        /**
         * Update a single skill bar with remaining XP
         * @param {HTMLElement} progressBar - The progress bar element
         */
        updateSingleSkillBar(progressBar) {
            // Remove existing XP display for this progress bar
            const progressContainer = progressBar.parentNode;
            if (progressContainer) {
                const existingDisplay = progressContainer.querySelector('.mwi-remaining-xp');
                if (existingDisplay) {
                    existingDisplay.remove();
                }
            }

            // Add updated XP display
            this.addRemainingXP(progressBar);
        }

        /**
         * Add remaining XP display to a skill bar
         * @param {HTMLElement} progressBar - The progress bar element
         */
        addRemainingXP(progressBar) {
            try {
                // Try to find skill name - handle both navigation bar and combat skill displays
                let skillName = null;

                // Check if we're in a sub-skills container (combat skills)
                const subSkillsContainer = progressBar.closest('[class*="NavigationBar_subSkills"]');

                if (subSkillsContainer) {
                    // We're in combat sub-skills - look for label in immediate parent structure
                    // The label should be in a sibling or nearby element, not in the parent navigationLink
                    const navContainer = progressBar.closest('[class*="NavigationBar_nav"]');
                    if (navContainer) {
                        const skillNameElement = navContainer.querySelector('[class*="NavigationBar_label"]');
                        if (skillNameElement) {
                            skillName = skillNameElement.textContent.trim();
                        }
                    }
                } else {
                    // Regular skill (not a sub-skill) - use standard navigation link approach
                    const navLink = progressBar.closest('[class*="NavigationBar_navigationLink"]');
                    if (navLink) {
                        const skillNameElement = navLink.querySelector('[class*="NavigationBar_label"]');
                        if (skillNameElement) {
                            skillName = skillNameElement.textContent.trim();
                        }
                    }
                }

                if (!skillName) return;

                // Calculate remaining XP for this skill using progress bar width (like XP percentage does)
                const remainingXP = this.calculateRemainingXPFromProgressBar(progressBar, skillName);
                if (remainingXP === null) return;

                // Find the progress bar container (parent of the progress bar)
                const progressContainer = progressBar.parentNode;
                if (!progressContainer) return;

                // Check if we already added XP display here (prevent duplicates)
                if (progressContainer.querySelector('.mwi-remaining-xp')) return;

                // Create the remaining XP display
                const xpDisplay = document.createElement('span');
                xpDisplay.className = 'mwi-remaining-xp';
                xpDisplay.textContent = `${numberFormatter(remainingXP)} XP left`;

                // Build style with optional text shadow
                const useBlackBorder = config$1.getSetting('skillRemainingXP_blackBorder', true);
                const textShadow = useBlackBorder
                    ? 'text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 3px #000;'
                    : '';

                xpDisplay.style.cssText = `
                font-size: 11px;
                color: ${config$1.COLOR_REMAINING_XP};
                display: block;
                margin-top: -8px;
                text-align: center;
                width: 100%;
                font-weight: 600;
                pointer-events: none;
                ${textShadow}
            `;

                // Insert after the progress bar
                progressContainer.insertBefore(xpDisplay, progressBar.nextSibling);
            } catch {
                // Silent fail - don't spam console with errors
            }
        }

        /**
         * Calculate remaining XP from progress bar width (real-time, like XP percentage)
         * @param {HTMLElement} progressBar - The progress bar element
         * @param {string} skillName - The skill name (e.g., "Milking", "Combat")
         * @returns {number|null} Remaining XP or null if unavailable
         */
        calculateRemainingXPFromProgressBar(progressBar, skillName) {
            // Convert skill name to HRID
            const skillHrid = `/skills/${skillName.toLowerCase()}`;

            // Get character skills data for level info
            const characterData = dataManager$1.characterData;
            if (!characterData || !characterData.characterSkills) {
                return null;
            }

            // Find the skill to get current level
            const skill = characterData.characterSkills.find((s) => s.skillHrid === skillHrid);
            if (!skill) {
                return null;
            }

            // Get level experience table
            const gameData = dataManager$1.getInitClientData();
            if (!gameData || !gameData.levelExperienceTable) return null;

            const currentLevel = skill.level;
            const nextLevel = currentLevel + 1;

            // Get XP required for current and next level
            const expForCurrentLevel = gameData.levelExperienceTable[currentLevel] || 0;
            const expForNextLevel = gameData.levelExperienceTable[nextLevel];
            if (expForNextLevel === undefined) return null; // Max level

            // Extract percentage from progress bar width (updated by game in real-time)
            const widthStyle = progressBar.style.width;
            if (!widthStyle) return null;

            const percentage = parseFloat(widthStyle.replace('%', ''));
            if (isNaN(percentage)) return null;

            // Calculate XP needed for this level
            const xpNeededForLevel = expForNextLevel - expForCurrentLevel;

            // Calculate current XP within this level based on progress bar
            const currentXPInLevel = (percentage / 100) * xpNeededForLevel;

            // Calculate remaining XP
            const remainingXP = xpNeededForLevel - currentXPInLevel;

            return Math.max(0, Math.ceil(remainingXP));
        }

        /**
         * Disable the remaining XP display
         */
        disable() {
            if (this.updateInterval) {
                clearInterval(this.updateInterval);
                this.updateInterval = null;
            }

            this.timerRegistry.clearAll();

            // Disconnect all progress bar observers
            this.progressBarObservers.forEach((unwatch) => {
                unwatch();
            });
            this.progressBarObservers.clear();

            // Unregister observers
            this.unregisterObservers.forEach((unregister) => unregister());
            this.unregisterObservers = [];

            // Remove all XP displays
            document.querySelectorAll('.mwi-remaining-xp').forEach((el) => el.remove());

            this.initialized = false;
        }
    }

    const remainingXP = new RemainingXP();

    /**
     * House Upgrade Cost Calculator
     * Calculates material and coin costs for house room upgrades
     */


    class HouseCostCalculator {
        constructor() {
            this.isInitialized = false;
        }

        /**
         * Initialize the calculator
         */
        async initialize() {
            if (this.isInitialized) return;

            // Ensure market data is loaded (check in-memory first to avoid storage reads)
            if (!marketAPI.isLoaded()) {
                await marketAPI.fetch();
            }

            this.isInitialized = true;
        }

        /**
         * Get current level of a house room
         * @param {string} houseRoomHrid - House room HRID (e.g., "/house_rooms/brewery")
         * @returns {number} Current level (0-8)
         */
        getCurrentRoomLevel(houseRoomHrid) {
            return dataManager$1.getHouseRoomLevel(houseRoomHrid);
        }

        /**
         * Calculate cost for a single level upgrade
         * @param {string} houseRoomHrid - House room HRID
         * @param {number} targetLevel - Target level (1-8)
         * @returns {Promise<Object>} Cost breakdown
         */
        async calculateLevelCost(houseRoomHrid, targetLevel) {
            const initData = dataManager$1.getInitClientData();
            if (!initData || !initData.houseRoomDetailMap) {
                throw new Error('Game data not loaded');
            }

            const roomData = initData.houseRoomDetailMap[houseRoomHrid];
            if (!roomData) {
                throw new Error(`House room not found: ${houseRoomHrid}`);
            }

            const upgradeCosts = roomData.upgradeCostsMap[targetLevel];
            if (!upgradeCosts) {
                throw new Error(`No upgrade costs for level ${targetLevel}`);
            }

            // Calculate costs
            let totalCoins = 0;
            const materials = [];

            for (const item of upgradeCosts) {
                if (item.itemHrid === '/items/coin') {
                    totalCoins = item.count;
                } else {
                    const marketPrice = await this.getItemMarketPrice(item.itemHrid);
                    materials.push({
                        itemHrid: item.itemHrid,
                        count: item.count,
                        marketPrice: marketPrice,
                        totalValue: marketPrice * item.count,
                    });
                }
            }

            const totalMaterialValue = materials.reduce((sum, m) => sum + m.totalValue, 0);

            return {
                level: targetLevel,
                coins: totalCoins,
                materials: materials,
                totalValue: totalCoins + totalMaterialValue,
            };
        }

        /**
         * Calculate cumulative cost from current level to target level
         * @param {string} houseRoomHrid - House room HRID
         * @param {number} currentLevel - Current level
         * @param {number} targetLevel - Target level (currentLevel+1 to 8)
         * @returns {Promise<Object>} Aggregated costs
         */
        async calculateCumulativeCost(houseRoomHrid, currentLevel, targetLevel) {
            if (targetLevel <= currentLevel) {
                throw new Error('Target level must be greater than current level');
            }

            if (targetLevel > 8) {
                throw new Error('Maximum house level is 8');
            }

            let totalCoins = 0;
            const materialMap = new Map(); // itemHrid -> {itemHrid, count, marketPrice, totalValue}

            // Aggregate costs across all levels
            for (let level = currentLevel + 1; level <= targetLevel; level++) {
                const levelCost = await this.calculateLevelCost(houseRoomHrid, level);

                totalCoins += levelCost.coins;

                // Aggregate materials
                for (const material of levelCost.materials) {
                    if (materialMap.has(material.itemHrid)) {
                        const existing = materialMap.get(material.itemHrid);
                        existing.count += material.count;
                        existing.totalValue += material.totalValue;
                    } else {
                        materialMap.set(material.itemHrid, { ...material });
                    }
                }
            }

            const materials = Array.from(materialMap.values());
            const totalMaterialValue = materials.reduce((sum, m) => sum + m.totalValue, 0);

            return {
                fromLevel: currentLevel,
                toLevel: targetLevel,
                coins: totalCoins,
                materials: materials,
                totalValue: totalCoins + totalMaterialValue,
            };
        }

        /**
         * Get market price for an item (uses 'ask' price for buying materials)
         * @param {string} itemHrid - Item HRID
         * @returns {Promise<number>} Market price
         */
        async getItemMarketPrice(itemHrid) {
            // Use 'ask' mode since house upgrades involve buying materials
            const price = getItemPrice(itemHrid, { mode: 'ask' });

            if (price === null || price === 0) {
                // Fallback to vendor price from game data
                const initData = dataManager$1.getInitClientData();
                const itemData = initData?.itemDetailMap?.[itemHrid];
                return itemData?.sellPrice || 0;
            }

            return price;
        }

        /**
         * Get player's inventory count for an item
         * @param {string} itemHrid - Item HRID
         * @returns {number} Item count in inventory
         */
        getInventoryCount(itemHrid) {
            const inventory = dataManager$1.getInventory();
            if (!inventory) return 0;

            const item = inventory.find((i) => i.itemHrid === itemHrid);
            return item ? item.count : 0;
        }

        /**
         * Get item name from game data
         * @param {string} itemHrid - Item HRID
         * @returns {string} Item name
         */
        getItemName(itemHrid) {
            if (itemHrid === '/items/coin') {
                return 'Gold';
            }

            const initData = dataManager$1.getInitClientData();
            const itemData = initData?.itemDetailMap?.[itemHrid];
            return itemData?.name || 'Unknown Item';
        }

        /**
         * Get house room name from game data
         * @param {string} houseRoomHrid - House room HRID
         * @returns {string} Room name
         */
        getRoomName(houseRoomHrid) {
            const initData = dataManager$1.getInitClientData();
            const roomData = initData?.houseRoomDetailMap?.[houseRoomHrid];
            return roomData?.name || 'Unknown Room';
        }
    }

    const houseCostCalculator = new HouseCostCalculator();

    /**
     * House Upgrade Cost Display
     * UI rendering for house upgrade costs
     */


    class HouseCostDisplay {
        constructor() {
            this.isActive = false;
            this.currentModalContent = null; // Track current modal to detect room switches
            this.isInitialized = false;
            this.currentMaterialsTabs = []; // Track marketplace tabs
            this.cleanupObserver = null; // Marketplace cleanup observer
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Setup settings listeners for feature toggle and color changes
         */
        setupSettingListener() {
            config$1.onSettingChange('houseUpgradeCosts', (value) => {
                if (value) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            config$1.onSettingChange('color_accent', () => {
                if (this.isInitialized) {
                    this.refresh();
                }
            });
        }

        /**
         * Initialize the display system
         */
        initialize() {
            if (!config$1.getSetting('houseUpgradeCosts')) {
                return;
            }

            this.isActive = true;
            this.isInitialized = true;
        }

        /**
         * Augment native costs section with market pricing
         * @param {Element} costsSection - The native HousePanel_costs element
         * @param {string} houseRoomHrid - House room HRID
         * @param {Element} modalContent - The modal content element
         */
        async addCostColumn(costsSection, houseRoomHrid, modalContent) {
            // Remove any existing augmentation first
            this.removeExistingColumn(modalContent);

            const currentLevel = houseCostCalculator.getCurrentRoomLevel(houseRoomHrid);

            // Don't show if already max level
            if (currentLevel >= 8) {
                return;
            }

            try {
                // Add "Cumulative to Level" section
                await this.addCompactToLevel(costsSection, houseRoomHrid, currentLevel);

                // Mark this modal as processed
                this.currentModalContent = modalContent;
            } catch {
                // Silently fail - augmentation is optional
            }
        }

        /**
         * Remove existing augmentations
         * @param {Element} modalContent - The modal content element
         */
        removeExistingColumn(modalContent) {
            // Remove all MWI-added elements
            modalContent
                .querySelectorAll('.mwi-house-pricing, .mwi-house-pricing-empty, .mwi-house-total, .mwi-house-to-level')
                .forEach((el) => el.remove());

            // Restore original grid columns
            const itemRequirementsGrid = modalContent.querySelector('[class*="HousePanel_itemRequirements"]');
            if (itemRequirementsGrid) {
                itemRequirementsGrid.style.gridTemplateColumns = '';
            }
        }

        /**
         * Augment native cost items with market pricing
         * @param {Element} costsSection - Native costs section
         * @param {Object} costData - Cost data from calculator
         */
        async augmentNativeCosts(costsSection, costData) {
            // Find the item requirements grid container
            const itemRequirementsGrid = costsSection.querySelector('[class*="HousePanel_itemRequirements"]');
            if (!itemRequirementsGrid) {
                return;
            }

            // Modify the grid to accept 4 columns instead of 3
            // Native grid is: icon | inventory count | input count
            // We want: icon | inventory count | input count | pricing
            const currentGridStyle = window.getComputedStyle(itemRequirementsGrid).gridTemplateColumns;

            // Add a 4th column for pricing (auto width)
            itemRequirementsGrid.style.gridTemplateColumns = currentGridStyle + ' auto';

            // Find all item containers (these have the icons)
            const itemContainers = itemRequirementsGrid.querySelectorAll('[class*="Item_itemContainer"]');
            if (itemContainers.length === 0) {
                return;
            }

            for (const itemContainer of itemContainers) {
                // Game uses SVG sprites, not img tags
                const svg = itemContainer.querySelector('svg');
                if (!svg) continue;

                // Extract item name from href (e.g., #lumber -> lumber)
                const useElement = svg.querySelector('use');
                const hrefValue = useElement?.getAttribute('href') || '';
                const itemName = hrefValue.split('#')[1];
                if (!itemName) continue;

                // Convert to item HRID
                const itemHrid = `/items/${itemName}`;

                // Find matching material in costData
                let materialData;
                if (itemHrid === '/items/coin') {
                    materialData = {
                        itemHrid: '/items/coin',
                        count: costData.coins,
                        marketPrice: 1,
                        totalValue: costData.coins,
                    };
                } else {
                    materialData = costData.materials.find((m) => m.itemHrid === itemHrid);
                }

                if (!materialData) continue;

                // Skip coins (no pricing needed)
                if (materialData.itemHrid === '/items/coin') {
                    // Add empty cell to maintain grid structure
                    this.addEmptyCell(itemRequirementsGrid, itemContainer);
                    continue;
                }

                // Add pricing as a new grid cell to the right
                this.addPricingCell(itemRequirementsGrid, itemContainer, materialData);
            }
        }

        /**
         * Add empty cell for coins to maintain grid structure
         * @param {Element} grid - The requirements grid
         * @param {Element} itemContainer - The item icon container (badge)
         */
        addEmptyCell(grid, itemContainer) {
            const emptyCell = document.createElement('span');
            emptyCell.className = 'mwi-house-pricing-empty HousePanel_itemRequirementCell__3hSBN';

            // Insert immediately after the item badge
            itemContainer.after(emptyCell);
        }

        /**
         * Add pricing as a new grid cell to the right of the item
         * @param {Element} grid - The requirements grid
         * @param {Element} itemContainer - The item icon container (badge)
         * @param {Object} materialData - Material data with pricing
         */
        addPricingCell(grid, itemContainer, materialData) {
            // Check if already augmented
            const nextSibling = itemContainer.nextElementSibling;
            if (nextSibling?.classList.contains('mwi-house-pricing')) {
                return;
            }

            const inventoryCount = houseCostCalculator.getInventoryCount(materialData.itemHrid);
            const hasEnough = inventoryCount >= materialData.count;
            const amountNeeded = Math.max(0, materialData.count - inventoryCount);

            // Create pricing cell
            const pricingCell = document.createElement('span');
            pricingCell.className = 'mwi-house-pricing HousePanel_itemRequirementCell__3hSBN';
            pricingCell.style.cssText = `
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            color: ${config$1.COLOR_ACCENT};
            padding-left: 8px;
            white-space: nowrap;
        `;

            pricingCell.innerHTML = `
            <span style="color: ${config$1.SCRIPT_COLOR_SECONDARY};">@ ${coinFormatter(materialData.marketPrice)}</span>
            <span style="color: ${config$1.COLOR_ACCENT}; font-weight: bold;">= ${coinFormatter(materialData.totalValue)}</span>
            <span style="color: ${hasEnough ? '#4ade80' : '#f87171'}; margin-left: auto; text-align: right;">${coinFormatter(amountNeeded)}</span>
        `;

            // Insert immediately after the item badge
            itemContainer.after(pricingCell);
        }

        /**
         * Add total cost below native costs section
         * @param {Element} costsSection - Native costs section
         * @param {Object} costData - Cost data
         */
        addTotalCost(costsSection, costData) {
            const totalDiv = document.createElement('div');
            totalDiv.className = 'mwi-house-total';
            totalDiv.style.cssText = `
            margin-top: 12px;
            padding-top: 12px;
            border-top: 2px solid ${config$1.COLOR_ACCENT};
            font-weight: bold;
            font-size: 1rem;
            color: ${config$1.COLOR_ACCENT};
            text-align: center;
        `;
            totalDiv.textContent = `Total Market Value: ${coinFormatter(costData.totalValue)}`;
            costsSection.appendChild(totalDiv);
        }

        /**
         * Add compact "To Level" section
         * @param {Element} costsSection - Native costs section
         * @param {string} houseRoomHrid - House room HRID
         * @param {number} currentLevel - Current level
         */
        async addCompactToLevel(costsSection, houseRoomHrid, currentLevel) {
            const section = document.createElement('div');
            section.className = 'mwi-house-to-level';
            section.style.cssText = `
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid ${config$1.SCRIPT_COLOR_SECONDARY};
        `;

            // Compact header with inline dropdown
            const headerRow = document.createElement('div');
            headerRow.style.cssText = `
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        `;

            const label = document.createElement('span');
            label.style.cssText = `
            color: ${config$1.COLOR_ACCENT};
            font-weight: bold;
            font-size: 0.875rem;
        `;
            label.textContent = 'Cumulative to Level:';

            const dropdown = document.createElement('select');
            dropdown.style.cssText = `
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid ${config$1.SCRIPT_COLOR_SECONDARY};
            color: ${config$1.SCRIPT_COLOR_MAIN};
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
        `;

            // Add options
            for (let level = currentLevel + 1; level <= 8; level++) {
                const option = document.createElement('option');
                option.value = level;
                option.textContent = level;
                dropdown.appendChild(option);
            }

            // Default to next level (currentLevel + 1)
            const defaultLevel = currentLevel + 1;
            dropdown.value = defaultLevel;

            headerRow.appendChild(label);
            headerRow.appendChild(dropdown);
            section.appendChild(headerRow);

            // Cost display container
            const costContainer = document.createElement('div');
            costContainer.className = 'mwi-cumulative-cost-container';
            costContainer.style.cssText = `
            font-size: 0.875rem;
            margin-top: 8px;
            text-align: left;
        `;
            section.appendChild(costContainer);

            // Initial render
            await this.updateCompactCumulativeDisplay(costContainer, houseRoomHrid, currentLevel, parseInt(dropdown.value));

            // Update on change
            dropdown.addEventListener('change', async () => {
                await this.updateCompactCumulativeDisplay(
                    costContainer,
                    houseRoomHrid,
                    currentLevel,
                    parseInt(dropdown.value)
                );
            });

            costsSection.parentElement.appendChild(section);
        }

        /**
         * Update compact cumulative display
         * @param {Element} container - Container element
         * @param {string} houseRoomHrid - House room HRID
         * @param {number} currentLevel - Current level
         * @param {number} targetLevel - Target level
         */
        async updateCompactCumulativeDisplay(container, houseRoomHrid, currentLevel, targetLevel) {
            container.innerHTML = '';

            const costData = await houseCostCalculator.calculateCumulativeCost(houseRoomHrid, currentLevel, targetLevel);

            // Materials list as vertical stack of single-line rows
            const materialsList = document.createElement('div');
            materialsList.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 8px;
        `;

            // Coins first
            if (costData.coins > 0) {
                this.appendMaterialRow(materialsList, {
                    itemHrid: '/items/coin',
                    count: costData.coins,
                    totalValue: costData.coins,
                });
            }

            // Materials
            for (const material of costData.materials) {
                this.appendMaterialRow(materialsList, material);
            }

            container.appendChild(materialsList);

            // Total
            const totalDiv = document.createElement('div');
            totalDiv.style.cssText = `
            margin-top: 12px;
            padding-top: 12px;
            border-top: 2px solid ${config$1.COLOR_ACCENT};
            font-weight: bold;
            font-size: 1rem;
            color: ${config$1.COLOR_ACCENT};
            text-align: center;
        `;
            totalDiv.textContent = `Total Market Value: ${coinFormatter(costData.totalValue)}`;
            container.appendChild(totalDiv);

            // Add Missing Mats Marketplace button if any materials are missing
            const missingMaterials = this.getMissingMaterials(costData);
            if (missingMaterials.length > 0) {
                const button = this.createMissingMaterialsButton(missingMaterials);
                container.appendChild(button);
            }
        }

        /**
         * Append material row as single-line compact format
         * @param {Element} container - The container element
         * @param {Object} material - Material data
         */
        appendMaterialRow(container, material) {
            const itemName = houseCostCalculator.getItemName(material.itemHrid);
            const inventoryCount = houseCostCalculator.getInventoryCount(material.itemHrid);
            const hasEnough = inventoryCount >= material.count;
            const amountNeeded = Math.max(0, material.count - inventoryCount);
            const isCoin = material.itemHrid === '/items/coin';

            const row = document.createElement('div');
            row.style.cssText = `
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.875rem;
            line-height: 1.4;
        `;

            // [inv / req] - left side
            const inventorySpan = document.createElement('span');
            inventorySpan.style.cssText = `
            color: ${hasEnough ? 'white' : '#f87171'};
            min-width: 120px;
            text-align: right;
        `;
            inventorySpan.textContent = `${coinFormatter(inventoryCount)} / ${coinFormatter(material.count)}`;
            row.appendChild(inventorySpan);

            // [Badge] Material Name
            const nameSpan = document.createElement('span');
            nameSpan.style.cssText = `
            color: white;
            min-width: 140px;
        `;
            nameSpan.textContent = itemName;
            row.appendChild(nameSpan);

            // @ price = total (skip for coins)
            if (!isCoin) {
                const pricingSpan = document.createElement('span');
                pricingSpan.style.cssText = `
                color: ${config$1.COLOR_ACCENT};
                min-width: 180px;
            `;
                pricingSpan.textContent = `@ ${coinFormatter(material.marketPrice)} = ${coinFormatter(material.totalValue)}`;
                row.appendChild(pricingSpan);
            } else {
                // Empty spacer for coins
                const spacer = document.createElement('span');
                spacer.style.minWidth = '180px';
                row.appendChild(spacer);
            }

            // Missing: X - right side
            const missingSpan = document.createElement('span');
            missingSpan.style.cssText = `
            color: ${hasEnough ? '#4ade80' : '#f87171'};
            margin-left: auto;
            text-align: right;
        `;
            missingSpan.textContent = `Missing: ${coinFormatter(amountNeeded)}`;
            row.appendChild(missingSpan);

            container.appendChild(row);
        }

        /**
         * Get missing materials from cost data
         * @param {Object} costData - Cost data from calculator
         * @returns {Array} Array of missing materials in marketplace format
         */
        getMissingMaterials(costData) {
            const gameData = dataManager$1.getInitClientData();
            const inventory = dataManager$1.getInventory();
            const missing = [];

            // Process all materials (skip coins)
            for (const material of costData.materials) {
                const inventoryItem = inventory.find((i) => i.itemHrid === material.itemHrid);
                const have = inventoryItem?.count || 0;
                const missingAmount = Math.max(0, material.count - have);

                // Only include if missing > 0
                if (missingAmount > 0) {
                    const itemDetails = gameData.itemDetailMap[material.itemHrid];
                    if (itemDetails) {
                        missing.push({
                            itemHrid: material.itemHrid,
                            itemName: itemDetails.name,
                            missing: missingAmount,
                            isTradeable: itemDetails.isTradable === true,
                        });
                    }
                }
            }

            return missing;
        }

        /**
         * Create missing materials marketplace button
         * @param {Array} missingMaterials - Array of missing material objects
         * @returns {HTMLElement} Button element
         */
        createMissingMaterialsButton(missingMaterials) {
            const button = document.createElement('button');
            button.style.cssText = `
            width: 100%;
            padding: 10px 16px;
            margin-top: 12px;
            background: linear-gradient(180deg, rgba(91, 141, 239, 0.2) 0%, rgba(91, 141, 239, 0.1) 100%);
            color: #ffffff;
            border: 1px solid rgba(91, 141, 239, 0.4);
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        `;
            button.textContent = 'Missing Mats Marketplace';

            // Hover effects
            button.addEventListener('mouseenter', () => {
                button.style.background =
                    'linear-gradient(180deg, rgba(91, 141, 239, 0.35) 0%, rgba(91, 141, 239, 0.25) 100%)';
                button.style.borderColor = 'rgba(91, 141, 239, 0.6)';
                button.style.boxShadow = '0 3px 6px rgba(0, 0, 0, 0.3)';
            });

            button.addEventListener('mouseleave', () => {
                button.style.background =
                    'linear-gradient(180deg, rgba(91, 141, 239, 0.2) 0%, rgba(91, 141, 239, 0.1) 100%)';
                button.style.borderColor = 'rgba(91, 141, 239, 0.4)';
                button.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.2)';
            });

            // Click handler
            button.addEventListener('click', async () => {
                await this.handleMissingMaterialsClick(missingMaterials);
            });

            return button;
        }

        /**
         * Handle missing materials button click
         * @param {Array} missingMaterials - Array of missing material objects
         */
        async handleMissingMaterialsClick(missingMaterials) {
            // Navigate to marketplace
            const success = await this.navigateToMarketplace();
            if (!success) {
                console.error('[HouseCostDisplay] Failed to navigate to marketplace');
                return;
            }

            // Wait for marketplace to settle
            await new Promise((resolve) => {
                const delayTimeout = setTimeout(resolve, 200);
                this.timerRegistry.registerTimeout(delayTimeout);
            });

            // Create custom tabs
            this.createMissingMaterialTabs(missingMaterials);

            // Setup cleanup observer if not already setup
            if (!this.cleanupObserver) {
                this.setupMarketplaceCleanupObserver();
            }
        }

        /**
         * Get game object via React fiber
         * @returns {Object|null} Game component instance
         */
        getGameObject() {
            const gamePageEl = document.querySelector('[class^="GamePage"]');
            if (!gamePageEl) return null;

            const fiberKey = Object.keys(gamePageEl).find((k) => k.startsWith('__reactFiber$'));
            if (!fiberKey) return null;

            return gamePageEl[fiberKey]?.return?.stateNode;
        }

        /**
         * Navigate to marketplace for a specific item
         * @param {string} itemHrid - Item HRID
         * @param {number} enhancementLevel - Enhancement level
         */
        goToMarketplace(itemHrid, enhancementLevel = 0) {
            const game = this.getGameObject();
            if (game?.handleGoToMarketplace) {
                game.handleGoToMarketplace(itemHrid, enhancementLevel);
            }
        }

        /**
         * Navigate to marketplace by clicking navbar
         * @returns {Promise<boolean>} True if successful
         */
        async navigateToMarketplace() {
            // Find marketplace navbar button
            const navButtons = document.querySelectorAll('.NavigationBar_nav__3uuUl');
            const marketplaceButton = Array.from(navButtons).find((nav) => {
                const svg = nav.querySelector('svg[aria-label="navigationBar.marketplace"]');
                return svg !== null;
            });

            if (!marketplaceButton) {
                console.error('[HouseCostDisplay] Marketplace navbar button not found');
                return false;
            }

            // Click button
            marketplaceButton.click();

            // Wait for marketplace to appear
            return await this.waitForMarketplace();
        }

        /**
         * Wait for marketplace panel to appear
         * @returns {Promise<boolean>} True if marketplace appeared
         */
        async waitForMarketplace() {
            const maxAttempts = 50;
            const delayMs = 100;

            for (let i = 0; i < maxAttempts; i++) {
                const tabsContainer = document.querySelector('.MuiTabs-flexContainer[role="tablist"]');
                if (tabsContainer) {
                    const hasMarketListings = Array.from(tabsContainer.children).some((btn) =>
                        btn.textContent.includes('Market Listings')
                    );
                    if (hasMarketListings) {
                        return true;
                    }
                }

                await new Promise((resolve) => {
                    const delayTimeout = setTimeout(resolve, delayMs);
                    this.timerRegistry.registerTimeout(delayTimeout);
                });
            }

            console.error('[HouseCostDisplay] Marketplace did not open within timeout');
            return false;
        }

        /**
         * Create custom tabs for missing materials
         * @param {Array} missingMaterials - Array of missing material objects
         */
        createMissingMaterialTabs(missingMaterials) {
            const tabsContainer = document.querySelector('.MuiTabs-flexContainer[role="tablist"]');
            if (!tabsContainer) {
                console.error('[HouseCostDisplay] Tabs container not found');
                return;
            }

            // Remove existing custom tabs
            this.removeMissingMaterialTabs();

            // Get reference tab
            const referenceTab = Array.from(tabsContainer.children).find((btn) => btn.textContent.includes('My Listings'));
            if (!referenceTab) {
                console.error('[HouseCostDisplay] Reference tab not found');
                return;
            }

            // Enable flex wrapping
            tabsContainer.style.flexWrap = 'wrap';

            // Create tab for each missing material
            this.currentMaterialsTabs = [];
            for (const material of missingMaterials) {
                const tab = this.createCustomTab(material, referenceTab);
                tabsContainer.appendChild(tab);
                this.currentMaterialsTabs.push(tab);
            }
        }

        /**
         * Create custom tab for a material
         * @param {Object} material - Material object
         * @param {HTMLElement} referenceTab - Reference tab to clone
         * @returns {HTMLElement} Custom tab element
         */
        createCustomTab(material, referenceTab) {
            const tab = referenceTab.cloneNode(true);

            // Mark as custom tab
            tab.setAttribute('data-mwi-custom-tab', 'true');
            tab.setAttribute('data-item-hrid', material.itemHrid);

            // Color coding
            const statusColor = material.isTradeable ? '#ef4444' : '#888888';
            const statusText = material.isTradeable ? `Missing: ${formatWithSeparator(material.missing)}` : 'Not Tradeable';

            // Update badge
            const badgeSpan = tab.querySelector('.TabsComponent_badge__1Du26');
            if (badgeSpan) {
                const titleCaseName = material.itemName
                    .split(' ')
                    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                    .join(' ');

                badgeSpan.innerHTML = `
                <div style="text-align: center;">
                    <div>${titleCaseName}</div>
                    <div style="font-size: 0.75em; color: ${statusColor};">
                        ${statusText}
                    </div>
                </div>
            `;
            }

            // Gray out if not tradeable
            if (!material.isTradeable) {
                tab.style.opacity = '0.5';
                tab.style.cursor = 'not-allowed';
            }

            // Remove selected state
            tab.classList.remove('Mui-selected');
            tab.setAttribute('aria-selected', 'false');
            tab.setAttribute('tabindex', '-1');

            // Click handler
            tab.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                if (!material.isTradeable) {
                    return;
                }

                this.goToMarketplace(material.itemHrid, 0);
            });

            return tab;
        }

        /**
         * Remove all missing material tabs
         */
        removeMissingMaterialTabs() {
            const customTabs = document.querySelectorAll('[data-mwi-custom-tab="true"]');
            customTabs.forEach((tab) => tab.remove());
            this.currentMaterialsTabs = [];
        }

        /**
         * Setup marketplace cleanup observer
         */
        setupMarketplaceCleanupObserver() {
            if (!document.body) {
                return;
            }

            this.cleanupObserver = createMutationWatcher(
                document.body,
                (mutations) => {
                    for (const mutation of mutations) {
                        for (const removedNode of mutation.removedNodes) {
                            if (removedNode.nodeType === Node.ELEMENT_NODE) {
                                const hadTabsContainer = removedNode.querySelector(
                                    '.MuiTabs-flexContainer[role="tablist"]'
                                );
                                if (hadTabsContainer) {
                                    this.removeMissingMaterialTabs();
                                    console.log('[HouseCostDisplay] Marketplace closed, cleaned up tabs');
                                }
                            }
                        }
                    }
                },
                {
                    childList: true,
                    subtree: true,
                }
            );
        }

        /**
         * Refresh colors on existing displays
         */
        refresh() {
            // Update pricing cell colors
            document.querySelectorAll('.mwi-house-pricing').forEach((cell) => {
                cell.style.color = config$1.COLOR_ACCENT;
                const boldSpan = cell.querySelector('span[style*="font-weight: bold"]');
                if (boldSpan) {
                    boldSpan.style.color = config$1.COLOR_ACCENT;
                }
            });

            // Update total cost colors
            document.querySelectorAll('.mwi-house-total').forEach((total) => {
                total.style.borderTopColor = config$1.COLOR_ACCENT;
                total.style.color = config$1.COLOR_ACCENT;
            });

            // Update "To Level" label colors
            document.querySelectorAll('.mwi-house-to-level span[style*="font-weight: bold"]').forEach((label) => {
                label.style.color = config$1.COLOR_ACCENT;
            });

            // Update cumulative total colors
            document.querySelectorAll('.mwi-cumulative-cost-container span[style*="font-weight: bold"]').forEach((span) => {
                span.style.color = config$1.COLOR_ACCENT;
            });
        }

        /**
         * Disable the feature
         */
        disable() {
            // Remove all MWI-added elements
            document
                .querySelectorAll('.mwi-house-pricing, .mwi-house-pricing-empty, .mwi-house-total, .mwi-house-to-level')
                .forEach((el) => el.remove());

            // Restore all grid columns
            document.querySelectorAll('[class*="HousePanel_itemRequirements"]').forEach((grid) => {
                grid.style.gridTemplateColumns = '';
            });

            // Clean up marketplace tabs and observer
            this.removeMissingMaterialTabs();
            if (this.cleanupObserver) {
                this.cleanupObserver();
                this.cleanupObserver = null;
            }

            this.timerRegistry.clearAll();

            this.currentModalContent = null;
            this.isActive = false;
            this.isInitialized = false;
        }
    }

    const houseCostDisplay = new HouseCostDisplay();
    houseCostDisplay.setupSettingListener();

    /**
     * House Panel Observer
     * Detects house upgrade modal and injects cost displays
     */


    class HousePanelObserver {
        constructor() {
            this.isActive = false;
            this.cleanupRegistry = createCleanupRegistry();
            this.processedCards = new WeakSet();
        }

        /**
         * Initialize the observer
         */
        async initialize() {
            if (this.isActive) return;

            // Initialize calculator
            await houseCostCalculator.initialize();

            // Initialize display
            houseCostDisplay.initialize();

            // Register modal observer
            this.registerObservers();

            this.isActive = true;
        }

        /**
         * Register DOM observers
         */
        registerObservers() {
            // Watch for house modal appearing
            const unregisterModal = domObserver$1.onClass(
                'HousePanelObserver-Modal',
                'HousePanel_modalContent',
                (modalContent) => {
                    this.handleHouseModal(modalContent);
                }
            );
            this.cleanupRegistry.registerCleanup(unregisterModal);
        }

        /**
         * Handle house modal appearing
         * @param {Element} modalContent - The house panel modal content element
         */
        async handleHouseModal(modalContent) {
            // Wait a moment for content to fully load
            await new Promise((resolve) => {
                const loadTimeout = setTimeout(resolve, 100);
                this.cleanupRegistry.registerTimeout(loadTimeout);
            });

            // Modal shows one room at a time, not a grid
            // Process the currently displayed room
            await this.processModalContent(modalContent);

            // Set up observer for room switching
            this.observeModalChanges(modalContent);
        }

        /**
         * Process the modal content (single room display)
         * @param {Element} modalContent - The house panel modal content
         */
        async processModalContent(modalContent) {
            // Identify which room is currently displayed
            const houseRoomHrid = this.identifyRoomFromModal(modalContent);

            if (!houseRoomHrid) {
                return;
            }

            // Find the costs section to add our column
            const costsSection = modalContent.querySelector('[class*="HousePanel_costs"]');

            if (!costsSection) {
                return;
            }

            // Add our cost display as a column
            await houseCostDisplay.addCostColumn(costsSection, houseRoomHrid, modalContent);
        }

        /**
         * Identify house room HRID from modal header
         * @param {Element} modalContent - The modal content element
         * @returns {string|null} House room HRID
         */
        identifyRoomFromModal(modalContent) {
            const initData = dataManager$1.getInitClientData();
            if (!initData || !initData.houseRoomDetailMap) {
                return null;
            }

            // Get room name from header
            const header = modalContent.querySelector('[class*="HousePanel_header"]');
            if (!header) {
                return null;
            }

            const roomName = header.textContent.trim();

            // Match against room names in game data
            for (const [hrid, roomData] of Object.entries(initData.houseRoomDetailMap)) {
                if (roomData.name === roomName) {
                    return hrid;
                }
            }

            return null;
        }

        /**
         * Observe modal for room switching
         * @param {Element} modalContent - The house panel modal content
         */
        observeModalChanges(modalContent) {
            const observer = createMutationWatcher(
                modalContent,
                (mutations) => {
                    // Check if header changed (indicates room switch)
                    for (const mutation of mutations) {
                        if (mutation.type === 'childList' || mutation.type === 'characterData') {
                            const header = modalContent.querySelector('[class*="HousePanel_header"]');
                            if (header && mutation.target.contains(header)) {
                                // Room switched, reprocess
                                this.processModalContent(modalContent);
                                break;
                            }
                        }
                    }
                },
                {
                    childList: true,
                    subtree: true,
                    characterData: true,
                }
            );
            this.cleanupRegistry.registerCleanup(observer);
        }

        /**
         * Disable the observer
         */
        disable() {
            this.cleanup();
        }

        /**
         * Clean up observers
         */
        cleanup() {
            this.cleanupRegistry.cleanupAll();
            this.cleanupRegistry = createCleanupRegistry();
            this.processedCards = new WeakSet();
            this.isActive = false;
        }
    }

    const housePanelObserver = new HousePanelObserver();

    var settingsCSS = "/* Toolasha Settings UI Styles\n * Modern, compact design\n */\n\n/* CSS Variables */\n:root {\n    --toolasha-accent: #5b8def;\n    --toolasha-accent-hover: #7aa3f3;\n    --toolasha-accent-dim: rgba(91, 141, 239, 0.15);\n    --toolasha-secondary: #8A2BE2;\n    --toolasha-text: rgba(255, 255, 255, 0.9);\n    --toolasha-text-dim: rgba(255, 255, 255, 0.5);\n    --toolasha-bg: rgba(20, 25, 35, 0.6);\n    --toolasha-border: rgba(91, 141, 239, 0.2);\n    --toolasha-toggle-off: rgba(100, 100, 120, 0.4);\n    --toolasha-toggle-on: var(--toolasha-accent);\n}\n\n/* Settings Card Container */\n.toolasha-settings-card {\n    display: flex;\n    flex-direction: column;\n    padding: 12px 16px;\n    font-size: 12px;\n    line-height: 1.3;\n    color: var(--toolasha-text);\n    position: relative;\n    overflow-y: auto;\n    gap: 6px;\n    max-height: calc(100vh - 250px);\n}\n\n/* Top gradient line */\n.toolasha-settings-card::before {\n    display: none;\n}\n\n/* Scrollbar styling */\n.toolasha-settings-card::-webkit-scrollbar {\n    width: 6px;\n}\n\n.toolasha-settings-card::-webkit-scrollbar-track {\n    background: transparent;\n}\n\n.toolasha-settings-card::-webkit-scrollbar-thumb {\n    background: var(--toolasha-accent);\n    border-radius: 3px;\n    opacity: 0.5;\n}\n\n.toolasha-settings-card::-webkit-scrollbar-thumb:hover {\n    opacity: 1;\n}\n\n/* Collapsible Settings Groups */\n.toolasha-settings-group {\n    margin-bottom: 8px;\n}\n\n.toolasha-settings-group-header {\n    cursor: pointer;\n    user-select: none;\n    margin: 10px 0 4px 0;\n    color: var(--toolasha-accent);\n    font-weight: 600;\n    font-size: 13px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-bottom: 1px solid var(--toolasha-border);\n    padding-bottom: 3px;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    transition: color 0.2s ease;\n}\n\n.toolasha-settings-group-header:hover {\n    color: var(--toolasha-accent-hover);\n}\n\n.toolasha-settings-group-header .collapse-icon {\n    font-size: 10px;\n    transition: transform 0.2s ease;\n}\n\n.toolasha-settings-group.collapsed .collapse-icon {\n    transform: rotate(-90deg);\n}\n\n.toolasha-settings-group-content {\n    max-height: 5000px;\n    overflow: hidden;\n    transition: max-height 0.3s ease-out;\n}\n\n.toolasha-settings-group.collapsed .toolasha-settings-group-content {\n    max-height: 0;\n}\n\n/* Section Headers */\n.toolasha-settings-card h3 {\n    margin: 10px 0 4px 0;\n    color: var(--toolasha-accent);\n    font-weight: 600;\n    font-size: 13px;\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    border-bottom: 1px solid var(--toolasha-border);\n    padding-bottom: 3px;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.toolasha-settings-card h3:first-child {\n    margin-top: 0;\n}\n\n.toolasha-settings-card h3 .icon {\n    font-size: 14px;\n}\n\n/* Individual Setting Row */\n.toolasha-setting {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    gap: 10px;\n    margin: 0;\n    padding: 6px 8px;\n    background: var(--toolasha-bg);\n    border: 1px solid var(--toolasha-border);\n    border-radius: 4px;\n    min-height: unset;\n    transition: all 0.2s ease;\n}\n\n.toolasha-setting:hover {\n    background: rgba(30, 35, 45, 0.7);\n    border-color: var(--toolasha-accent);\n}\n\n.toolasha-setting.disabled {\n    opacity: 0.3;\n    pointer-events: none;\n}\n\n.toolasha-setting.not-implemented .toolasha-setting-label {\n    color: #ff6b6b;\n}\n\n.toolasha-setting.not-implemented .toolasha-setting-help {\n    color: rgba(255, 107, 107, 0.7);\n}\n\n.toolasha-setting-label {\n    text-align: left;\n    flex: 1;\n    margin-right: 10px;\n    line-height: 1.3;\n    font-size: 12px;\n}\n\n.toolasha-setting-help {\n    display: block;\n    font-size: 10px;\n    color: var(--toolasha-text-dim);\n    margin-top: 2px;\n    font-style: italic;\n}\n\n.toolasha-setting-input {\n    flex-shrink: 0;\n}\n\n/* Modern Toggle Switch */\n.toolasha-switch {\n    position: relative;\n    width: 38px;\n    height: 20px;\n    flex-shrink: 0;\n    display: inline-block;\n}\n\n.toolasha-switch input {\n    opacity: 0;\n    width: 0;\n    height: 0;\n    position: absolute;\n}\n\n.toolasha-slider {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: var(--toolasha-toggle-off);\n    border-radius: 20px;\n    cursor: pointer;\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    border: 2px solid transparent;\n}\n\n.toolasha-slider:before {\n    content: \"\";\n    position: absolute;\n    height: 12px;\n    width: 12px;\n    left: 2px;\n    bottom: 2px;\n    background: white;\n    border-radius: 50%;\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\n}\n\n.toolasha-switch input:checked + .toolasha-slider {\n    background: var(--toolasha-toggle-on);\n    border-color: var(--toolasha-accent-hover);\n    box-shadow: 0 0 6px var(--toolasha-accent-dim);\n}\n\n.toolasha-switch input:checked + .toolasha-slider:before {\n    transform: translateX(18px);\n}\n\n.toolasha-switch:hover .toolasha-slider {\n    border-color: var(--toolasha-accent);\n}\n\n/* Text Input */\n.toolasha-text-input {\n    padding: 5px 8px;\n    border: 1px solid var(--toolasha-border);\n    border-radius: 3px;\n    background: rgba(0, 0, 0, 0.3);\n    color: var(--toolasha-text);\n    min-width: 100px;\n    font-size: 12px;\n    transition: all 0.2s ease;\n}\n\n.toolasha-text-input:focus {\n    outline: none;\n    border-color: var(--toolasha-accent);\n    box-shadow: 0 0 0 2px var(--toolasha-accent-dim);\n}\n\n/* Number Input */\n.toolasha-number-input {\n    padding: 5px 8px;\n    border: 1px solid var(--toolasha-border);\n    border-radius: 3px;\n    background: rgba(0, 0, 0, 0.3);\n    color: var(--toolasha-text);\n    min-width: 80px;\n    font-size: 12px;\n    transition: all 0.2s ease;\n}\n\n.toolasha-number-input:focus {\n    outline: none;\n    border-color: var(--toolasha-accent);\n    box-shadow: 0 0 0 2px var(--toolasha-accent-dim);\n}\n\n/* Select Dropdown */\n.toolasha-select-input {\n    padding: 5px 8px;\n    border: 1px solid var(--toolasha-border);\n    border-radius: 3px;\n    background: rgba(0, 0, 0, 0.3);\n    color: var(--toolasha-accent);\n    font-weight: 600;\n    min-width: 150px;\n    cursor: pointer;\n    font-size: 12px;\n    -webkit-appearance: none;\n    -moz-appearance: none;\n    appearance: none;\n    background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20width%3D%2220%22%20height%3D%2220%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M5%207l5%205%205-5z%22%20fill%3D%22%235b8def%22%2F%3E%3C%2Fsvg%3E');\n    background-repeat: no-repeat;\n    background-position: right 6px center;\n    background-size: 14px;\n    padding-right: 28px;\n    transition: all 0.2s ease;\n}\n\n.toolasha-select-input:focus {\n    outline: none;\n    border-color: var(--toolasha-accent);\n    box-shadow: 0 0 0 2px var(--toolasha-accent-dim);\n}\n\n.toolasha-select-input option {\n    background: #1a1a2e;\n    color: var(--toolasha-text);\n    padding: 8px;\n}\n\n/* Utility Buttons Container */\n.toolasha-utility-buttons {\n    display: flex;\n    gap: 8px;\n    margin-top: 12px;\n    padding-top: 10px;\n    border-top: 1px solid var(--toolasha-border);\n    flex-wrap: wrap;\n}\n\n.toolasha-utility-button {\n    background: linear-gradient(135deg, var(--toolasha-secondary), #6A1B9A);\n    border: 1px solid rgba(138, 43, 226, 0.4);\n    color: #ffffff;\n    padding: 6px 12px;\n    border-radius: 4px;\n    font-size: 11px;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n}\n\n.toolasha-utility-button:hover {\n    background: linear-gradient(135deg, #9A4BCF, var(--toolasha-secondary));\n    box-shadow: 0 0 10px rgba(138, 43, 226, 0.3);\n    transform: translateY(-1px);\n}\n\n.toolasha-utility-button:active {\n    transform: translateY(0);\n}\n\n/* Sync button - special styling for prominence */\n.toolasha-sync-button {\n    background: linear-gradient(135deg, #047857, #059669) !important;\n    border: 1px solid rgba(4, 120, 87, 0.4) !important;\n    flex: 1 1 auto; /* Allow it to grow and take more space */\n    min-width: 200px; /* Ensure it's wide enough for the text */\n}\n\n.toolasha-sync-button:hover {\n    background: linear-gradient(135deg, #059669, #10b981) !important;\n    box-shadow: 0 0 10px rgba(16, 185, 129, 0.3) !important;\n}\n\n/* Refresh Notice */\n.toolasha-refresh-notice {\n    background: rgba(255, 152, 0, 0.1);\n    border: 1px solid rgba(255, 152, 0, 0.3);\n    border-radius: 4px;\n    padding: 8px 12px;\n    margin-top: 10px;\n    color: #ffa726;\n    font-size: 11px;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.toolasha-refresh-notice::before {\n    content: \"⚠️\";\n    font-size: 14px;\n}\n\n/* Dependency Indicator */\n.toolasha-setting.has-dependency::before {\n    content: \"↳\";\n    position: absolute;\n    left: -4px;\n    color: var(--toolasha-accent);\n    font-size: 14px;\n    opacity: 0.5;\n}\n\n.toolasha-setting.has-dependency {\n    margin-left: 16px;\n    position: relative;\n}\n\n/* Nested setting collapse icons */\n.setting-collapse-icon {\n    flex-shrink: 0;\n    color: var(--toolasha-accent);\n    opacity: 0.7;\n}\n\n.toolasha-setting.dependents-collapsed .setting-collapse-icon {\n    opacity: 1;\n}\n\n.toolasha-setting-label-container:hover .setting-collapse-icon {\n    opacity: 1;\n}\n\n/* Tab Panel Override (for game's settings panel) */\n.TabPanel_tabPanel__tXMJF#toolasha-settings {\n    display: block !important;\n}\n\n.TabPanel_tabPanel__tXMJF#toolasha-settings.TabPanel_hidden__26UM3 {\n    display: none !important;\n}\n";

    /**
     * Settings UI Module
     * Injects Toolasha settings tab into the game's settings panel
     * Based on MWITools Extended approach
     */


    class SettingsUI {
        constructor() {
            this.config = config$1;
            this.settingsPanel = null;
            this.settingsObserver = null;
            this.settingsObserverCleanup = null;
            this.currentSettings = {};
            this.isInjecting = false; // Guard against concurrent injection
            this.characterSwitchHandler = null; // Store listener reference to prevent duplicates
            this.settingsPanelCallbacks = []; // Callbacks to run when settings panel appears
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Initialize the settings UI
         */
        async initialize() {
            // Inject CSS styles (check if already injected)
            if (!document.getElementById('toolasha-settings-styles')) {
                this.injectStyles();
            }

            // Load current settings
            this.currentSettings = await settingsStorage.loadSettings();

            // Set up handler for character switching (ONLY if not already registered)
            if (!this.characterSwitchHandler) {
                this.characterSwitchHandler = () => {
                    this.handleCharacterSwitch();
                };
                dataManager$1.on('character_initialized', this.characterSwitchHandler);
            }

            // Wait for game's settings panel to load
            this.observeSettingsPanel();
        }

        /**
         * Register a callback to be called when settings panel appears
         * @param {Function} callback - Function to call when settings panel is detected
         */
        onSettingsPanelAppear(callback) {
            if (typeof callback === 'function') {
                this.settingsPanelCallbacks.push(callback);
            }
        }

        /**
         * Handle character switch
         * Clean up old observers and re-initialize for new character's settings panel
         */
        handleCharacterSwitch() {
            // Clean up old DOM references and observers (but keep listener registered)
            this.cleanupDOM();

            // Wait for settings panel to stabilize before re-observing
            const reobserveTimeout = setTimeout(() => {
                this.observeSettingsPanel();
            }, 500);
            this.timerRegistry.registerTimeout(reobserveTimeout);
        }

        /**
         * Cleanup DOM elements and observers only (internal cleanup during character switch)
         */
        cleanupDOM() {
            this.timerRegistry.clearAll();

            // Stop observer
            if (this.settingsObserver) {
                this.settingsObserver.disconnect();
                this.settingsObserver = null;
            }

            if (this.settingsObserverCleanup) {
                this.settingsObserverCleanup();
                this.settingsObserverCleanup = null;
            }

            // Remove settings tab
            const tab = document.querySelector('#toolasha-settings-tab');
            if (tab) {
                tab.remove();
            }

            // Remove settings panel
            const panel = document.querySelector('#toolasha-settings');
            if (panel) {
                panel.remove();
            }

            // Clear state
            this.settingsPanel = null;
            this.currentSettings = {};
            this.isInjecting = false;

            // Clear config cache
            this.config.clearSettingsCache();
        }

        /**
         * Inject CSS styles into page
         */
        injectStyles() {
            const styleEl = document.createElement('style');
            styleEl.id = 'toolasha-settings-styles';
            styleEl.textContent = settingsCSS;
            document.head.appendChild(styleEl);
        }

        /**
         * Observe for game's settings panel
         * Uses MutationObserver to detect when settings panel appears
         */
        observeSettingsPanel() {
            // Wait for DOM to be ready before observing
            const startObserver = () => {
                if (!document.body) {
                    const observerDelay = setTimeout(startObserver, 10);
                    this.timerRegistry.registerTimeout(observerDelay);
                    return;
                }

                const onMutation = (_mutations) => {
                    // Look for the settings tabs container
                    const tabsContainer = document.querySelector('div[class*="SettingsPanel_tabsComponentContainer"]');

                    if (tabsContainer) {
                        // Check if our tab already exists before injecting
                        if (!tabsContainer.querySelector('#toolasha-settings-tab')) {
                            this.injectSettingsTab();
                        }

                        // Call registered callbacks for other features
                        this.settingsPanelCallbacks.forEach((callback) => {
                            try {
                                callback();
                            } catch (error) {
                                console.error('[Toolasha Settings] Callback error:', error);
                            }
                        });

                        // Keep observer running - panel might be removed/re-added if user navigates away and back
                    }
                };

                // Observe the main game panel for changes
                const gamePanel = document.querySelector('div[class*="GamePage_gamePanel"]');
                if (gamePanel) {
                    this.settingsObserverCleanup = createMutationWatcher(gamePanel, onMutation, {
                        childList: true,
                        subtree: true,
                    });
                } else {
                    // Fallback: observe entire body if game panel not found (Firefox timing issue)
                    console.warn('[Toolasha Settings] Could not find game panel, observing body instead');
                    this.settingsObserverCleanup = createMutationWatcher(document.body, onMutation, {
                        childList: true,
                        subtree: true,
                    });
                }

                // Store observer reference (for compatibility with existing cleanup path)
                this.settingsObserver = null;

                // Also check immediately in case settings is already open
                const existingTabsContainer = document.querySelector('div[class*="SettingsPanel_tabsComponentContainer"]');
                if (existingTabsContainer && !existingTabsContainer.querySelector('#toolasha-settings-tab')) {
                    this.injectSettingsTab();

                    // Call registered callbacks for other features
                    this.settingsPanelCallbacks.forEach((callback) => {
                        try {
                            callback();
                        } catch (error) {
                            console.error('[Toolasha Settings] Callback error:', error);
                        }
                    });
                }
            };

            startObserver();
        }

        /**
         * Inject Toolasha settings tab into game's settings panel
         */
        async injectSettingsTab() {
            // Guard against concurrent injection
            if (this.isInjecting) {
                return;
            }
            this.isInjecting = true;

            try {
                // Find tabs container (MWIt-E approach)
                const tabsComponentContainer = document.querySelector('div[class*="SettingsPanel_tabsComponentContainer"]');

                if (!tabsComponentContainer) {
                    console.warn('[Toolasha Settings] Could not find tabsComponentContainer');
                    return;
                }

                // Find the MUI tabs flexContainer
                const tabsContainer = tabsComponentContainer.querySelector('[class*="MuiTabs-flexContainer"]');
                const tabPanelsContainer = tabsComponentContainer.querySelector(
                    '[class*="TabsComponent_tabPanelsContainer"]'
                );

                if (!tabsContainer || !tabPanelsContainer) {
                    console.warn('[Toolasha Settings] Could not find tabs or panels container');
                    return;
                }

                // Check if already injected
                if (tabsContainer.querySelector('#toolasha-settings-tab')) {
                    return;
                }

                // Reload current settings from storage to ensure latest values
                this.currentSettings = await settingsStorage.loadSettings();

                // Get existing tabs for reference
                const existingTabs = Array.from(tabsContainer.querySelectorAll('button[role="tab"]'));

                // Create new tab button
                const tabButton = this.createTabButton();

                // Create tab panel
                const tabPanel = this.createTabPanel();

                // Setup tab switching
                this.setupTabSwitching(tabButton, tabPanel, existingTabs, tabPanelsContainer);

                // Append to DOM
                tabsContainer.appendChild(tabButton);
                tabPanelsContainer.appendChild(tabPanel);

                // Store reference
                this.settingsPanel = tabPanel;
            } catch (error) {
                console.error('[Toolasha Settings] Error during tab injection:', error);
            } finally {
                // Always reset the guard flag
                this.isInjecting = false;
            }
        }

        /**
         * Create tab button
         * @returns {HTMLElement} Tab button element
         */
        createTabButton() {
            const button = document.createElement('button');
            button.id = 'toolasha-settings-tab';
            button.setAttribute('role', 'tab');
            button.setAttribute('aria-selected', 'false');
            button.setAttribute('tabindex', '-1');
            button.className = 'MuiButtonBase-root MuiTab-root MuiTab-textColorPrimary';
            button.style.minWidth = '90px';

            const span = document.createElement('span');
            span.className = 'MuiTab-wrapper';
            span.textContent = 'Toolasha';

            button.appendChild(span);

            return button;
        }

        /**
         * Create tab panel with all settings
         * @returns {HTMLElement} Tab panel element
         */
        createTabPanel() {
            const panel = document.createElement('div');
            panel.id = 'toolasha-settings';
            panel.className = 'TabPanel_tabPanel__tXMJF TabPanel_hidden__26UM3';
            panel.setAttribute('role', 'tabpanel');
            panel.style.display = 'none';

            // Create settings card
            const card = document.createElement('div');
            card.className = 'toolasha-settings-card';
            card.id = 'toolasha-settings-content';

            // Add search box at the top
            this.addSearchBox(card);

            // Generate settings from config
            this.generateSettings(card);

            // Add utility buttons
            this.addUtilityButtons(card);

            // Add refresh notice
            this.addRefreshNotice(card);

            panel.appendChild(card);

            // Add change listener
            card.addEventListener('change', (e) => this.handleSettingChange(e));

            // Add click listener for template edit buttons
            card.addEventListener('click', (e) => {
                if (e.target.classList.contains('toolasha-template-edit-btn')) {
                    const settingId = e.target.dataset.settingId;
                    this.openTemplateEditor(settingId);
                }
            });

            return panel;
        }

        /**
         * Generate all settings UI from config
         * @param {HTMLElement} container - Container element
         */
        generateSettings(container) {
            for (const [groupKey, group] of Object.entries(settingsGroups)) {
                // Create collapsible group container
                const groupContainer = document.createElement('div');
                groupContainer.className = 'toolasha-settings-group';
                groupContainer.dataset.group = groupKey;

                // Add section header with collapse toggle
                const header = document.createElement('h3');
                header.className = 'toolasha-settings-group-header';
                header.innerHTML = `
                <span class="collapse-icon">▼</span>
                <span class="icon">${group.icon}</span>
                ${group.title}
            `;
                // Bind toggleGroup method to this instance
                header.addEventListener('click', this.toggleGroup.bind(this, groupContainer));

                // Create content container for this group
                const content = document.createElement('div');
                content.className = 'toolasha-settings-group-content';

                // Add settings in this group
                for (const [settingId, settingDef] of Object.entries(group.settings)) {
                    const settingEl = this.createSettingElement(settingId, settingDef);
                    content.appendChild(settingEl);
                }

                groupContainer.appendChild(header);
                groupContainer.appendChild(content);
                container.appendChild(groupContainer);
            }

            // After all settings are created, set up collapse functionality for parent settings
            this.setupParentCollapseIcons(container);

            // Restore collapse states from IndexedDB storage
            this.restoreCollapseStates(container);
        }

        /**
         * Setup collapse icons for parent settings (settings that have dependents)
         * @param {HTMLElement} container - Settings container
         */
        setupParentCollapseIcons(container) {
            const allSettings = container.querySelectorAll('.toolasha-setting');

            allSettings.forEach((setting) => {
                const settingId = setting.dataset.settingId;

                // Find all dependents of this setting
                const dependents = Array.from(allSettings).filter(
                    (s) => s.dataset.dependencies && s.dataset.dependencies.split(',').includes(settingId)
                );

                if (dependents.length > 0) {
                    // This setting has dependents - show collapse icon
                    const collapseIcon = setting.querySelector('.setting-collapse-icon');
                    if (collapseIcon) {
                        collapseIcon.style.display = 'inline-block';

                        // Add click handler to toggle dependents - bind to preserve this context
                        const labelContainer = setting.querySelector('.toolasha-setting-label-container');
                        labelContainer.style.cursor = 'pointer';
                        labelContainer.addEventListener('click', (e) => {
                            // Don't toggle if clicking the input itself
                            if (e.target.closest('.toolasha-setting-input')) return;

                            this.toggleDependents(setting, dependents);
                        });
                    }
                }
            });
        }

        /**
         * Toggle group collapse/expand
         * @param {HTMLElement} groupContainer - Group container element
         */
        toggleGroup(groupContainer) {
            groupContainer.classList.toggle('collapsed');

            // Save collapse state to IndexedDB storage
            const groupKey = groupContainer.dataset.group;
            const isCollapsed = groupContainer.classList.contains('collapsed');
            this.saveCollapseState('group', groupKey, isCollapsed);
        }

        /**
         * Toggle dependent settings visibility
         * @param {HTMLElement} parentSetting - Parent setting element
         * @param {HTMLElement[]} dependents - Array of dependent setting elements
         */
        toggleDependents(parentSetting, dependents) {
            const collapseIcon = parentSetting.querySelector('.setting-collapse-icon');
            const isCollapsed = parentSetting.classList.contains('dependents-collapsed');

            if (isCollapsed) {
                // Expand
                parentSetting.classList.remove('dependents-collapsed');
                collapseIcon.style.transform = 'rotate(0deg)';
                dependents.forEach((dep) => (dep.style.display = 'flex'));
            } else {
                // Collapse
                parentSetting.classList.add('dependents-collapsed');
                collapseIcon.style.transform = 'rotate(-90deg)';
                dependents.forEach((dep) => (dep.style.display = 'none'));
            }

            // Save collapse state to IndexedDB storage
            const settingId = parentSetting.dataset.settingId;
            const newState = !isCollapsed; // Inverted because we just toggled
            this.saveCollapseState('setting', settingId, newState);
        }

        /**
         * Save collapse state to IndexedDB
         * @param {string} type - 'group' or 'setting'
         * @param {string} key - Group key or setting ID
         * @param {boolean} isCollapsed - Whether collapsed
         */
        async saveCollapseState(type, key, isCollapsed) {
            try {
                const states = await storage$1.getJSON('collapse-states', 'settings', {});

                if (!states[type]) {
                    states[type] = {};
                }
                states[type][key] = isCollapsed;

                await storage$1.setJSON('collapse-states', states, 'settings');
            } catch (e) {
                console.warn('[Toolasha Settings] Failed to save collapse states:', e);
            }
        }

        /**
         * Load collapse state from IndexedDB
         * @param {string} type - 'group' or 'setting'
         * @param {string} key - Group key or setting ID
         * @returns {Promise<boolean|null>} Collapse state or null if not found
         */
        async loadCollapseState(type, key) {
            try {
                const states = await storage$1.getJSON('collapse-states', 'settings', {});
                return states[type]?.[key] ?? null;
            } catch (e) {
                console.warn('[Toolasha Settings] Failed to load collapse states:', e);
                return null;
            }
        }

        /**
         * Restore collapse states from IndexedDB
         * @param {HTMLElement} container - Settings container
         */
        async restoreCollapseStates(container) {
            try {
                // Restore group collapse states
                const groups = container.querySelectorAll('.toolasha-settings-group');
                for (const group of groups) {
                    const groupKey = group.dataset.group;
                    const isCollapsed = await this.loadCollapseState('group', groupKey);
                    if (isCollapsed === true) {
                        group.classList.add('collapsed');
                    }
                }

                // Restore setting collapse states
                const settings = container.querySelectorAll('.toolasha-setting');
                for (const setting of settings) {
                    const settingId = setting.dataset.settingId;
                    const isCollapsed = await this.loadCollapseState('setting', settingId);

                    if (isCollapsed === true) {
                        setting.classList.add('dependents-collapsed');

                        // Update collapse icon rotation
                        const collapseIcon = setting.querySelector('.setting-collapse-icon');
                        if (collapseIcon) {
                            collapseIcon.style.transform = 'rotate(-90deg)';
                        }

                        // Hide dependents
                        const allSettings = container.querySelectorAll('.toolasha-setting');
                        const dependents = Array.from(allSettings).filter(
                            (s) => s.dataset.dependencies && s.dataset.dependencies.split(',').includes(settingId)
                        );
                        dependents.forEach((dep) => (dep.style.display = 'none'));
                    }
                }
            } catch (e) {
                console.warn('[Toolasha Settings] Failed to restore collapse states:', e);
            }
        }

        /**
         * Create a single setting UI element
         * @param {string} settingId - Setting ID
         * @param {Object} settingDef - Setting definition
         * @returns {HTMLElement} Setting element
         */
        createSettingElement(settingId, settingDef) {
            const div = document.createElement('div');
            div.className = 'toolasha-setting';
            div.dataset.settingId = settingId;
            div.dataset.type = settingDef.type || 'checkbox';

            // Add dependency class and store dependency info
            if (settingDef.dependencies) {
                div.classList.add('has-dependency');

                // Handle both array format (legacy, AND logic) and object format (supports OR logic)
                if (Array.isArray(settingDef.dependencies)) {
                    // Legacy format: ['dep1', 'dep2'] means AND logic
                    div.dataset.dependencies = settingDef.dependencies.join(',');
                    div.dataset.dependencyMode = 'all'; // AND logic
                } else if (typeof settingDef.dependencies === 'object') {
                    // New format: {mode: 'any', settings: ['dep1', 'dep2']}
                    div.dataset.dependencies = settingDef.dependencies.settings.join(',');
                    div.dataset.dependencyMode = settingDef.dependencies.mode || 'all'; // 'any' = OR, 'all' = AND
                }
            }

            // Add not-implemented class for red text
            if (settingDef.notImplemented) {
                div.classList.add('not-implemented');
            }

            // Create label container (clickable for collapse if has dependents)
            const labelContainer = document.createElement('div');
            labelContainer.className = 'toolasha-setting-label-container';
            labelContainer.style.display = 'flex';
            labelContainer.style.alignItems = 'center';
            labelContainer.style.flex = '1';
            labelContainer.style.gap = '6px';

            // Add collapse icon if this setting has dependents (will be populated by checkDependents)
            const collapseIcon = document.createElement('span');
            collapseIcon.className = 'setting-collapse-icon';
            collapseIcon.textContent = '▼';
            collapseIcon.style.display = 'none'; // Hidden by default, shown if dependents exist
            collapseIcon.style.cursor = 'pointer';
            collapseIcon.style.fontSize = '10px';
            collapseIcon.style.transition = 'transform 0.2s ease';

            // Create label
            const label = document.createElement('span');
            label.className = 'toolasha-setting-label';
            label.textContent = settingDef.label;

            // Add help text if present
            if (settingDef.help) {
                const help = document.createElement('span');
                help.className = 'toolasha-setting-help';
                help.textContent = settingDef.help;
                label.appendChild(help);
            }

            labelContainer.appendChild(collapseIcon);
            labelContainer.appendChild(label);

            // Create input
            const inputHTML = this.generateSettingInput(settingId, settingDef);
            const inputContainer = document.createElement('div');
            inputContainer.className = 'toolasha-setting-input';
            inputContainer.innerHTML = inputHTML;

            div.appendChild(labelContainer);
            div.appendChild(inputContainer);

            return div;
        }

        /**
         * Generate input HTML for a setting
         * @param {string} settingId - Setting ID
         * @param {Object} settingDef - Setting definition
         * @returns {string} Input HTML
         */
        generateSettingInput(settingId, settingDef) {
            const currentSetting = this.currentSettings[settingId];
            const type = settingDef.type || 'checkbox';

            switch (type) {
                case 'checkbox': {
                    const checked = currentSetting?.isTrue ?? settingDef.default ?? false;
                    return `
                    <label class="toolasha-switch">
                        <input type="checkbox" id="${settingId}" ${checked ? 'checked' : ''}>
                        <span class="toolasha-slider"></span>
                    </label>
                `;
                }

                case 'text': {
                    const value = currentSetting?.value ?? settingDef.default ?? '';
                    return `
                    <input type="text"
                        id="${settingId}"
                        class="toolasha-text-input"
                        value="${value}"
                        placeholder="${settingDef.placeholder || ''}">
                `;
                }

                case 'template': {
                    const value = currentSetting?.value ?? settingDef.default ?? [];
                    // Store as JSON string
                    const jsonValue = JSON.stringify(value);
                    const escapedValue = jsonValue.replace(/"/g, '&quot;');

                    return `
                    <input type="hidden"
                        id="${settingId}"
                        value="${escapedValue}">
                    <button type="button"
                        class="toolasha-template-edit-btn"
                        data-setting-id="${settingId}"
                        style="
                            background: #4a7c59;
                            border: 1px solid #5a8c69;
                            border-radius: 4px;
                            padding: 6px 12px;
                            color: #e0e0e0;
                            cursor: pointer;
                            font-size: 13px;
                            white-space: nowrap;
                            transition: all 0.2s;
                        ">
                        Edit Template
                    </button>
                `;
                }

                case 'number': {
                    const value = currentSetting?.value ?? settingDef.default ?? 0;
                    return `
                    <input type="number"
                        id="${settingId}"
                        class="toolasha-number-input"
                        value="${value}"
                        min="${settingDef.min ?? ''}"
                        max="${settingDef.max ?? ''}"
                        step="${settingDef.step ?? '1'}">
                `;
                }

                case 'select': {
                    const value = currentSetting?.value ?? settingDef.default ?? '';
                    const options = settingDef.options || [];
                    const optionsHTML = options
                        .map((option) => {
                            const optValue = typeof option === 'object' ? option.value : option;
                            const optLabel = typeof option === 'object' ? option.label : option;
                            const selected = optValue === value ? 'selected' : '';
                            return `<option value="${optValue}" ${selected}>${optLabel}</option>`;
                        })
                        .join('');

                    return `
                    <select id="${settingId}" class="toolasha-select-input">
                        ${optionsHTML}
                    </select>
                `;
                }

                case 'color': {
                    const value = currentSetting?.value ?? settingDef.value ?? settingDef.default ?? '#000000';
                    return `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <input type="color"
                            id="${settingId}"
                            class="toolasha-color-input"
                            value="${value}">
                        <input type="text"
                            id="${settingId}_text"
                            class="toolasha-color-text-input"
                            value="${value}"
                            style="width: 80px; padding: 4px; background: #2a2a2a; color: white; border: 1px solid #555; border-radius: 3px;"
                            readonly>
                    </div>
                `;
                }

                case 'slider': {
                    const value = currentSetting?.value ?? settingDef.default ?? 0;
                    return `
                    <div style="display: flex; align-items: center; gap: 12px; width: 100%;">
                        <input type="range"
                            id="${settingId}"
                            class="toolasha-slider-input"
                            value="${value}"
                            min="${settingDef.min ?? 0}"
                            max="${settingDef.max ?? 1}"
                            step="${settingDef.step ?? 0.01}"
                            style="flex: 1;">
                        <span id="${settingId}_value" class="toolasha-slider-value" style="min-width: 50px; color: #aaa; font-size: 0.9em;">${value}</span>
                    </div>
                `;
                }

                default:
                    return `<span style="color: red;">Unknown type: ${type}</span>`;
            }
        }

        /**
         * Add search box to filter settings
         * @param {HTMLElement} container - Container element
         */
        addSearchBox(container) {
            const searchContainer = document.createElement('div');
            searchContainer.className = 'toolasha-search-container';
            searchContainer.style.cssText = `
            margin-bottom: 20px;
            display: flex;
            gap: 8px;
            align-items: center;
        `;

            // Search input
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.className = 'toolasha-search-input';
            searchInput.placeholder = 'Search settings...';
            searchInput.style.cssText = `
            flex: 1;
            padding: 8px 12px;
            background: #2a2a2a;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
        `;

            // Clear button
            const clearButton = document.createElement('button');
            clearButton.textContent = 'Clear';
            clearButton.className = 'toolasha-search-clear';
            clearButton.style.cssText = `
            padding: 8px 16px;
            background: #444;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        `;
            clearButton.style.display = 'none'; // Hidden by default

            // Filter function
            const filterSettings = (query) => {
                const lowerQuery = query.toLowerCase().trim();

                // If query is empty, show everything
                if (!lowerQuery) {
                    // Show all settings
                    document.querySelectorAll('.toolasha-setting').forEach((setting) => {
                        setting.style.display = 'flex';
                    });
                    // Show all groups
                    document.querySelectorAll('.toolasha-settings-group').forEach((group) => {
                        group.style.display = 'block';
                    });
                    clearButton.style.display = 'none';
                    return;
                }

                clearButton.style.display = 'block';

                // Filter settings
                document.querySelectorAll('.toolasha-settings-group').forEach((group) => {
                    let visibleCount = 0;

                    group.querySelectorAll('.toolasha-setting').forEach((setting) => {
                        const label = setting.querySelector('.toolasha-setting-label')?.textContent || '';
                        const help = setting.querySelector('.toolasha-setting-help')?.textContent || '';
                        const searchText = (label + ' ' + help).toLowerCase();

                        if (searchText.includes(lowerQuery)) {
                            setting.style.display = 'flex';
                            visibleCount++;
                        } else {
                            setting.style.display = 'none';
                        }
                    });

                    // Hide group if no visible settings
                    if (visibleCount === 0) {
                        group.style.display = 'none';
                    } else {
                        group.style.display = 'block';
                    }
                });
            };

            // Input event listener
            searchInput.addEventListener('input', (e) => {
                filterSettings(e.target.value);
            });

            // Clear button event listener
            clearButton.addEventListener('click', () => {
                searchInput.value = '';
                filterSettings('');
                searchInput.focus();
            });

            searchContainer.appendChild(searchInput);
            searchContainer.appendChild(clearButton);
            container.appendChild(searchContainer);
        }

        /**
         * Add utility buttons (Reset, Export, Import, Fetch Prices)
         * @param {HTMLElement} container - Container element
         */
        addUtilityButtons(container) {
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'toolasha-utility-buttons';

            // Sync button (at top - most important)
            const syncBtn = document.createElement('button');
            syncBtn.textContent = 'Copy Settings to All Characters';
            syncBtn.className = 'toolasha-utility-button toolasha-sync-button';
            syncBtn.addEventListener('click', () => this.handleSync());

            // Fetch Latest Prices button
            const fetchPricesBtn = document.createElement('button');
            fetchPricesBtn.textContent = '🔄 Fetch Latest Prices';
            fetchPricesBtn.className = 'toolasha-utility-button toolasha-fetch-prices-button';
            fetchPricesBtn.addEventListener('click', () => this.handleFetchPrices(fetchPricesBtn));

            // Reset button
            const resetBtn = document.createElement('button');
            resetBtn.textContent = 'Reset to Defaults';
            resetBtn.className = 'toolasha-utility-button';
            resetBtn.addEventListener('click', () => this.handleReset());

            // Export button
            const exportBtn = document.createElement('button');
            exportBtn.textContent = 'Export Settings';
            exportBtn.className = 'toolasha-utility-button';
            exportBtn.addEventListener('click', () => this.handleExport());

            // Import button
            const importBtn = document.createElement('button');
            importBtn.textContent = 'Import Settings';
            importBtn.className = 'toolasha-utility-button';
            importBtn.addEventListener('click', () => this.handleImport());

            buttonsDiv.appendChild(syncBtn);
            buttonsDiv.appendChild(fetchPricesBtn);
            buttonsDiv.appendChild(resetBtn);
            buttonsDiv.appendChild(exportBtn);
            buttonsDiv.appendChild(importBtn);

            container.appendChild(buttonsDiv);
        }

        /**
         * Add refresh notice
         * @param {HTMLElement} container - Container element
         */
        addRefreshNotice(container) {
            const notice = document.createElement('div');
            notice.className = 'toolasha-refresh-notice';
            notice.textContent = 'Some settings require a page refresh to take effect';
            container.appendChild(notice);
        }

        /**
         * Setup tab switching functionality
         * @param {HTMLElement} tabButton - Toolasha tab button
         * @param {HTMLElement} tabPanel - Toolasha tab panel
         * @param {HTMLElement[]} existingTabs - Existing tab buttons
         * @param {HTMLElement} tabPanelsContainer - Tab panels container
         */
        setupTabSwitching(tabButton, tabPanel, existingTabs, tabPanelsContainer) {
            const switchToTab = (targetButton, targetPanel) => {
                // Hide all panels
                const allPanels = tabPanelsContainer.querySelectorAll('[class*="TabPanel_tabPanel"]');
                allPanels.forEach((panel) => {
                    panel.style.display = 'none';
                    panel.classList.add('TabPanel_hidden__26UM3');
                });

                // Deactivate all buttons
                const allButtons = document.querySelectorAll('button[role="tab"]');
                allButtons.forEach((btn) => {
                    btn.setAttribute('aria-selected', 'false');
                    btn.setAttribute('tabindex', '-1');
                    btn.classList.remove('Mui-selected');
                });

                // Activate target
                targetButton.setAttribute('aria-selected', 'true');
                targetButton.setAttribute('tabindex', '0');
                targetButton.classList.add('Mui-selected');
                targetPanel.style.display = 'block';
                targetPanel.classList.remove('TabPanel_hidden__26UM3');

                // Update title
                const titleEl = document.querySelector('[class*="SettingsPanel_title"]');
                if (titleEl) {
                    if (targetButton.id === 'toolasha-settings-tab') {
                        titleEl.textContent = '⚙️ Toolasha Settings (refresh to apply)';
                    } else {
                        titleEl.textContent = 'Settings';
                    }
                }
            };

            // Click handler for Toolasha tab
            tabButton.addEventListener('click', () => {
                switchToTab(tabButton, tabPanel);
            });

            // Click handlers for existing tabs
            existingTabs.forEach((existingTab, index) => {
                existingTab.addEventListener('click', () => {
                    const correspondingPanel = tabPanelsContainer.children[index];
                    if (correspondingPanel) {
                        switchToTab(existingTab, correspondingPanel);
                    }
                });
            });
        }

        /**
         * Handle setting change
         * @param {Event} event - Change event
         */
        async handleSettingChange(event) {
            const input = event.target;
            if (!input.id) return;

            const settingId = input.id;
            const type = input.closest('.toolasha-setting')?.dataset.type || 'checkbox';

            let value;

            // Get value based on type
            if (type === 'checkbox') {
                value = input.checked;
            } else if (type === 'number' || type === 'slider') {
                value = parseFloat(input.value) || 0;
                // Update the slider value display if it's a slider
                if (type === 'slider') {
                    const valueDisplay = document.getElementById(`${settingId}_value`);
                    if (valueDisplay) {
                        valueDisplay.textContent = value;
                    }
                }
            } else if (type === 'color') {
                value = input.value;
                // Update the text display
                const textInput = document.getElementById(`${settingId}_text`);
                if (textInput) {
                    textInput.value = value;
                }
            } else {
                value = input.value;
            }

            // Save to storage
            await settingsStorage.setSetting(settingId, value);

            // Update local cache immediately
            if (!this.currentSettings[settingId]) {
                this.currentSettings[settingId] = {};
            }
            if (type === 'checkbox') {
                this.currentSettings[settingId].isTrue = value;
            } else {
                this.currentSettings[settingId].value = value;
            }

            // Update config module (for backward compatibility)
            if (type === 'checkbox') {
                this.config.setSetting(settingId, value);
            } else {
                this.config.setSettingValue(settingId, value);
            }

            // Apply color settings immediately if this is a color setting
            if (type === 'color') {
                this.config.applyColorSettings();
            }

            // Update dependencies
            this.updateDependencies();
        }

        /**
         * Update dependency states (enable/disable dependent settings)
         */
        updateDependencies() {
            const settings = document.querySelectorAll('.toolasha-setting[data-dependencies]');

            settings.forEach((settingEl) => {
                const dependencies = settingEl.dataset.dependencies.split(',');
                const mode = settingEl.dataset.dependencyMode || 'all'; // 'all' = AND, 'any' = OR
                let enabled = false;

                if (mode === 'any') {
                    // OR logic: at least one dependency must be met
                    for (const depId of dependencies) {
                        const depInput = document.getElementById(depId);
                        if (depInput && depInput.type === 'checkbox' && depInput.checked) {
                            enabled = true;
                            break; // Found at least one enabled, that's enough
                        }
                    }
                } else {
                    // AND logic (default): all dependencies must be met
                    enabled = true; // Assume enabled, then check all
                    for (const depId of dependencies) {
                        const depInput = document.getElementById(depId);
                        if (depInput && depInput.type === 'checkbox' && !depInput.checked) {
                            enabled = false;
                            break; // Found one disabled, no need to check rest
                        }
                    }
                }

                // Enable or disable
                if (enabled) {
                    settingEl.classList.remove('disabled');
                } else {
                    settingEl.classList.add('disabled');
                }
            });
        }

        /**
         * Handle sync settings to all characters
         */
        async handleSync() {
            // Get character count to show in confirmation
            const characterCount = await this.config.getKnownCharacterCount();

            // If only 1 character (current), no need to sync
            if (characterCount <= 1) {
                alert('You only have one character. Settings are already saved for this character.');
                return;
            }

            // Confirm action
            const otherCharacters = characterCount - 1;
            const message = `This will copy your current settings to ${otherCharacters} other character${otherCharacters > 1 ? 's' : ''}. Their existing settings will be overwritten.\n\nContinue?`;

            if (!confirm(message)) {
                return;
            }

            // Perform sync
            const result = await this.config.syncSettingsToAllCharacters();

            // Show result
            if (result.success) {
                alert(`Settings successfully copied to ${result.count} character${result.count > 1 ? 's' : ''}!`);
            } else {
                alert(`Failed to sync settings: ${result.error || 'Unknown error'}`);
            }
        }

        /**
         * Handle fetch latest prices
         * @param {HTMLElement} button - Button element for state updates
         */
        async handleFetchPrices(button) {
            // Disable button and show loading state
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = '⏳ Fetching...';

            try {
                // Clear cache and fetch fresh data
                const result = await marketAPI.clearCacheAndRefetch();

                if (result) {
                    // Success - clear listing price display cache to force re-render
                    document.querySelectorAll('.mwi-listing-prices-set').forEach((table) => {
                        table.classList.remove('mwi-listing-prices-set');
                    });

                    // Show success state
                    button.textContent = '✅ Updated!';
                    button.style.backgroundColor = '#00ff00';
                    button.style.color = '#000';

                    // Reset button after 2 seconds
                    const resetSuccessTimeout = setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                        button.style.color = '';
                        button.disabled = false;
                    }, 2000);
                    this.timerRegistry.registerTimeout(resetSuccessTimeout);
                } else {
                    // Failed - show error state
                    button.textContent = '❌ Failed';
                    button.style.backgroundColor = '#ff0000';

                    // Reset button after 3 seconds
                    const resetFailureTimeout = setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '';
                        button.disabled = false;
                    }, 3000);
                    this.timerRegistry.registerTimeout(resetFailureTimeout);
                }
            } catch (error) {
                console.error('[SettingsUI] Fetch prices failed:', error);

                // Show error state
                button.textContent = '❌ Error';
                button.style.backgroundColor = '#ff0000';

                // Reset button after 3 seconds
                const resetErrorTimeout = setTimeout(() => {
                    button.textContent = originalText;
                    button.style.backgroundColor = '';
                    button.disabled = false;
                }, 3000);
                this.timerRegistry.registerTimeout(resetErrorTimeout);
            }
        }

        /**
         * Handle reset to defaults
         */
        async handleReset() {
            if (!confirm('Reset all settings to defaults? This cannot be undone.')) {
                return;
            }

            await settingsStorage.resetToDefaults();
            await this.config.resetToDefaults();

            alert('Settings reset to defaults. Please refresh the page.');
            window.location.reload();
        }

        /**
         * Handle export settings
         */
        async handleExport() {
            const json = await settingsStorage.exportSettings();

            // Create download
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `toolasha-settings-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        /**
         * Handle import settings
         */
        async handleImport() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const success = await settingsStorage.importSettings(text);

                    if (success) {
                        alert('Settings imported successfully. Please refresh the page.');
                        window.location.reload();
                    } else {
                        alert('Failed to import settings. Please check the file format.');
                    }
                } catch (error) {
                    console.error('[Toolasha Settings] Import error:', error);
                    alert('Failed to import settings.');
                }
            });

            input.click();
        }

        /**
         * Open template editor modal
         * @param {string} settingId - Setting ID
         */
        openTemplateEditor(settingId) {
            const setting = this.findSettingDef(settingId);
            if (!setting || !setting.templateVariables) {
                return;
            }

            const input = document.getElementById(settingId);
            let currentValue = setting.default;

            // Try to parse stored value
            if (input && input.value) {
                try {
                    const parsed = JSON.parse(input.value);
                    if (Array.isArray(parsed)) {
                        currentValue = parsed;
                    }
                } catch (e) {
                    console.error('[Settings] Failed to parse template value:', e);
                }
            }

            // Ensure currentValue is an array
            if (!Array.isArray(currentValue)) {
                currentValue = setting.default || [];
            }

            // Deep clone to avoid mutating original
            const templateItems = JSON.parse(JSON.stringify(currentValue));

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'toolasha-template-editor-overlay';
            overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100000;
            display: flex;
            align-items: center;
            justify-content: center;
        `;

            // Create modal
            const modal = document.createElement('div');
            modal.className = 'toolasha-template-editor-modal';
            modal.style.cssText = `
            background: #1a1a1a;
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            max-width: 700px;
            width: 90%;
            max-height: 90%;
            overflow-y: auto;
            color: #e0e0e0;
        `;

            // Header
            const header = document.createElement('div');
            header.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #3a3a3a;
            padding-bottom: 10px;
        `;
            header.innerHTML = `
            <h3 style="margin: 0; color: #e0e0e0;">Edit Template</h3>
            <button class="toolasha-template-close-btn" style="
                background: none;
                border: none;
                color: #e0e0e0;
                font-size: 32px;
                cursor: pointer;
                padding: 0;
                line-height: 1;
            ">×</button>
        `;

            // Template list section
            const listSection = document.createElement('div');
            listSection.style.cssText = 'margin-bottom: 20px;';
            listSection.innerHTML =
                '<h4 style="margin: 0 0 10px 0; color: #e0e0e0;">Template Items (drag to reorder):</h4>';

            const listContainer = document.createElement('div');
            listContainer.className = 'toolasha-template-list';
            listContainer.style.cssText = `
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            padding: 10px;
            min-height: 200px;
            max-height: 300px;
            overflow-y: auto;
        `;

            const renderList = () => {
                listContainer.innerHTML = '';
                templateItems.forEach((item, index) => {
                    const itemEl = this.createTemplateListItem(item, index, templateItems, renderList);
                    listContainer.appendChild(itemEl);
                });
            };

            renderList();
            listSection.appendChild(listContainer);

            // Available variables section
            const variablesSection = document.createElement('div');
            variablesSection.style.cssText = 'margin-bottom: 20px;';
            variablesSection.innerHTML = '<h4 style="margin: 0 0 10px 0; color: #e0e0e0;">Add Variable:</h4>';

            const variablesContainer = document.createElement('div');
            variablesContainer.style.cssText = `
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        `;

            for (const variable of setting.templateVariables) {
                const chip = document.createElement('button');
                chip.type = 'button';
                chip.textContent = '+  ' + variable.label;
                chip.title = variable.description;
                chip.style.cssText = `
                background: #2a2a2a;
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 6px 12px;
                color: #e0e0e0;
                cursor: pointer;
                font-size: 13px;
                transition: all 0.2s;
            `;
                chip.onmouseover = () => {
                    chip.style.background = '#3a3a3a';
                    chip.style.borderColor = '#5a5a5a';
                };
                chip.onmouseout = () => {
                    chip.style.background = '#2a2a2a';
                    chip.style.borderColor = '#4a4a4a';
                };
                chip.onclick = () => {
                    templateItems.push({
                        type: 'variable',
                        key: variable.key,
                        label: variable.label,
                    });
                    renderList();
                };
                variablesContainer.appendChild(chip);
            }

            // Add text button
            const addTextBtn = document.createElement('button');
            addTextBtn.type = 'button';
            addTextBtn.textContent = '+ Add Text';
            addTextBtn.style.cssText = `
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            padding: 6px 12px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        `;
            addTextBtn.onmouseover = () => {
                addTextBtn.style.background = '#3a3a3a';
                addTextBtn.style.borderColor = '#5a5a5a';
            };
            addTextBtn.onmouseout = () => {
                addTextBtn.style.background = '#2a2a2a';
                addTextBtn.style.borderColor = '#4a4a4a';
            };
            addTextBtn.onclick = () => {
                const text = prompt('Enter text:');
                if (text !== null && text !== '') {
                    templateItems.push({
                        type: 'text',
                        value: text,
                    });
                    renderList();
                }
            };

            variablesContainer.appendChild(addTextBtn);
            variablesSection.appendChild(variablesContainer);

            // Buttons
            const buttonsSection = document.createElement('div');
            buttonsSection.style.cssText = `
            display: flex;
            gap: 10px;
            justify-content: space-between;
            margin-top: 20px;
        `;

            // Restore to Default button (left side)
            const restoreBtn = document.createElement('button');
            restoreBtn.type = 'button';
            restoreBtn.textContent = 'Restore to Default';
            restoreBtn.style.cssText = `
            background: #6b5b3a;
            border: 1px solid #8b7b5a;
            border-radius: 4px;
            padding: 8px 16px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
        `;
            restoreBtn.onclick = () => {
                if (confirm('Reset template to default? This will discard your current template.')) {
                    // Reset to default
                    templateItems.length = 0;
                    const defaultTemplate = setting.default || [];
                    templateItems.push(...JSON.parse(JSON.stringify(defaultTemplate)));
                    renderList();
                }
            };

            // Right side buttons container
            const rightButtons = document.createElement('div');
            rightButtons.style.cssText = 'display: flex; gap: 10px;';

            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = `
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            padding: 8px 16px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
        `;
            cancelBtn.onclick = () => overlay.remove();

            const saveBtn = document.createElement('button');
            saveBtn.type = 'button';
            saveBtn.textContent = 'Save';
            saveBtn.style.cssText = `
            background: #4a7c59;
            border: 1px solid #5a8c69;
            border-radius: 4px;
            padding: 8px 16px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
        `;
            saveBtn.onclick = () => {
                const input = document.getElementById(settingId);
                if (input) {
                    input.value = JSON.stringify(templateItems);
                    // Trigger change event
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                }
                overlay.remove();
            };

            rightButtons.appendChild(cancelBtn);
            rightButtons.appendChild(saveBtn);

            buttonsSection.appendChild(restoreBtn);
            buttonsSection.appendChild(rightButtons);

            // Assemble modal
            modal.appendChild(header);
            modal.appendChild(listSection);
            modal.appendChild(variablesSection);
            modal.appendChild(buttonsSection);
            overlay.appendChild(modal);

            // Close button handler
            header.querySelector('.toolasha-template-close-btn').onclick = () => overlay.remove();

            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            };

            // Add to page
            document.body.appendChild(overlay);
        }

        /**
         * Create a draggable template list item
         * @param {Object} item - Template item
         * @param {number} index - Item index
         * @param {Array} items - All items
         * @param {Function} renderList - Callback to re-render list
         * @returns {HTMLElement} List item element
         */
        createTemplateListItem(item, index, items, renderList) {
            const itemEl = document.createElement('div');
            itemEl.draggable = true;
            itemEl.dataset.index = index;
            itemEl.style.cssText = `
            background: #1a1a1a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: move;
            transition: all 0.2s;
        `;

            // Drag handle
            const dragHandle = document.createElement('span');
            dragHandle.textContent = '⋮⋮';
            dragHandle.style.cssText = `
            color: #666;
            font-size: 16px;
            cursor: move;
        `;

            // Content
            const content = document.createElement('div');
            content.style.cssText = 'flex: 1; color: #e0e0e0; font-size: 13px;';

            if (item.type === 'variable') {
                content.innerHTML = `<strong style="color: #4a9eff;">${item.label}</strong> <span style="color: #666; font-family: monospace;">${item.key}</span>`;
            } else {
                // Editable text
                const textInput = document.createElement('input');
                textInput.type = 'text';
                textInput.value = item.value;
                textInput.style.cssText = `
                background: #2a2a2a;
                border: 1px solid #4a4a4a;
                border-radius: 3px;
                padding: 4px 8px;
                color: #e0e0e0;
                font-size: 13px;
                width: 100%;
            `;
                textInput.onchange = () => {
                    items[index].value = textInput.value;
                };
                content.appendChild(textInput);
            }

            // Delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.textContent = '×';
            deleteBtn.title = 'Remove';
            deleteBtn.style.cssText = `
            background: #8b0000;
            border: 1px solid #a00000;
            border-radius: 3px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            padding: 4px 8px;
            transition: all 0.2s;
        `;
            deleteBtn.onmouseover = () => {
                deleteBtn.style.background = '#a00000';
            };
            deleteBtn.onmouseout = () => {
                deleteBtn.style.background = '#8b0000';
            };
            deleteBtn.onclick = () => {
                items.splice(index, 1);
                renderList();
            };

            // Drag events
            itemEl.ondragstart = (e) => {
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', index);
                itemEl.style.opacity = '0.5';
            };

            itemEl.ondragend = () => {
                itemEl.style.opacity = '1';
            };

            itemEl.ondragover = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                itemEl.style.borderColor = '#4a9eff';
            };

            itemEl.ondragleave = () => {
                itemEl.style.borderColor = '#4a4a4a';
            };

            itemEl.ondrop = (e) => {
                e.preventDefault();
                itemEl.style.borderColor = '#4a4a4a';

                const dragIndex = parseInt(e.dataTransfer.getData('text/plain'));
                const dropIndex = index;

                if (dragIndex !== dropIndex) {
                    // Remove from old position
                    const [movedItem] = items.splice(dragIndex, 1);
                    // Insert at new position
                    items.splice(dropIndex, 0, movedItem);
                    renderList();
                }
            };

            itemEl.appendChild(dragHandle);
            itemEl.appendChild(content);
            itemEl.appendChild(deleteBtn);

            return itemEl;
        }

        /**
         * Find setting definition by ID
         * @param {string} settingId - Setting ID
         * @returns {Object|null} Setting definition
         */
        findSettingDef(settingId) {
            for (const group of Object.values(settingsGroups)) {
                if (group.settings[settingId]) {
                    return group.settings[settingId];
                }
            }
            return null;
        }

        /**
         * Cleanup for full shutdown (not character switching)
         * Unregisters event listeners and removes all DOM elements
         */
        cleanup() {
            // Clean up DOM elements first
            this.cleanupDOM();

            if (this.characterSwitchHandler) {
                dataManager$1.off('character_initialized', this.characterSwitchHandler);
                this.characterSwitchHandler = null;
            }

            this.timerRegistry.clearAll();
        }
    }

    const settingsUI = new SettingsUI();

    /**
     * Transmute Rates Module
     * Shows transmutation success rate percentages in Item Dictionary modal
     */


    /**
     * TransmuteRates class manages success rate display in Item Dictionary
     */
    class TransmuteRates {
        constructor() {
            this.unregisterHandlers = [];
            this.isInitialized = false;
            this.injectTimeout = null;
            this.nameToHridCache = new Map();
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Setup setting change listener
         */
        setupSettingListener() {
            config$1.onSettingChange('itemDictionary_transmuteRates', (enabled) => {
                if (enabled) {
                    this.initialize();
                } else {
                    this.disable();
                }
            });

            // Listen for base rate inclusion toggle
            config$1.onSettingChange('itemDictionary_transmuteIncludeBaseRate', () => {
                if (this.isInitialized) {
                    this.refreshRates();
                }
            });

            config$1.onSettingChange('color_transmute', () => {
                if (this.isInitialized) {
                    this.refreshRates();
                }
            });
        }

        /**
         * Initialize transmute rates feature
         */
        initialize() {
            if (config$1.getSetting('itemDictionary_transmuteRates') !== true) {
                return;
            }

            if (this.isInitialized) {
                return;
            }

            this.isInitialized = true;

            // Watch for individual source items being added to the dictionary
            const unregister = domObserver$1.onClass('TransmuteRates', 'ItemDictionary_item', (elem) => {
                // When a new source item appears, find the parent section and inject rates
                const section = elem.closest('[class*="ItemDictionary_transmutedFrom"]');

                if (section) {
                    // Debounce to avoid injecting multiple times as items are added
                    clearTimeout(this.injectTimeout);
                    this.injectTimeout = setTimeout(() => {
                        this.injectRates(section);
                    }, 50);
                    this.timerRegistry.registerTimeout(this.injectTimeout);
                }
            });
            this.unregisterHandlers.push(unregister);

            // Check if dictionary is already open
            const existingSection = document.querySelector('[class*="ItemDictionary_transmutedFrom"]');
            if (existingSection) {
                this.injectRates(existingSection);
            }
        }

        /**
         * Inject transmutation success rates into the dictionary
         * @param {HTMLElement} transmutedFromSection - The "Transmuted From" section
         */
        injectRates(transmutedFromSection) {
            // Get current item name from modal title
            const titleElem = document.querySelector('[class*="ItemDictionary_title"]');
            if (!titleElem) {
                return;
            }

            const currentItemName = titleElem.textContent.trim();
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) {
                return;
            }

            // Build name->HRID cache once for O(1) lookups
            if (this.nameToHridCache.size === 0) {
                for (const [hrid, item] of Object.entries(gameData.itemDetailMap)) {
                    this.nameToHridCache.set(item.name, hrid);
                }
            }

            // Find current item HRID by name (O(1) lookup)
            const currentItemHrid = this.nameToHridCache.get(currentItemName);

            if (!currentItemHrid) {
                return;
            }

            // Find all source items in "Transmuted From" list
            const sourceItems = transmutedFromSection.querySelectorAll('[class*="ItemDictionary_item"]');

            for (const sourceItemElem of sourceItems) {
                // Remove any existing rate first (in case React re-rendered this item)
                const existingRate = sourceItemElem.querySelector('.mwi-transmute-rate');
                if (existingRate) {
                    existingRate.remove();
                }

                // Get source item name
                const nameElem = sourceItemElem.querySelector('[class*="Item_name"]');
                if (!nameElem) {
                    continue;
                }

                const sourceItemName = nameElem.textContent.trim();

                // Find source item HRID by name (O(1) lookup)
                const sourceItemHrid = this.nameToHridCache.get(sourceItemName);

                if (!sourceItemHrid) {
                    continue;
                }

                // Get source item's alchemy details
                const sourceItem = gameData.itemDetailMap[sourceItemHrid];
                if (!sourceItem.alchemyDetail || !sourceItem.alchemyDetail.transmuteDropTable) {
                    continue;
                }

                const transmuteSuccessRate = sourceItem.alchemyDetail.transmuteSuccessRate;

                // Find current item in source's drop table
                const dropEntry = sourceItem.alchemyDetail.transmuteDropTable.find(
                    (entry) => entry.itemHrid === currentItemHrid
                );

                if (!dropEntry) {
                    continue;
                }

                // Calculate effective rate based on setting
                const includeBaseRate = config$1.getSetting('itemDictionary_transmuteIncludeBaseRate') !== false;
                const effectiveRate = includeBaseRate
                    ? transmuteSuccessRate * dropEntry.dropRate // Total probability
                    : dropEntry.dropRate; // Conditional probability
                const percentageText = `${(effectiveRate * 100).toFixed((effectiveRate * 100) % 1 === 0 ? 1 : 2)}%`;

                // Create rate element
                const rateElem = document.createElement('span');
                rateElem.className = 'mwi-transmute-rate';
                rateElem.textContent = ` ~${percentageText}`;
                rateElem.style.cssText = `
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                color: ${config$1.COLOR_TRANSMUTE};
                font-size: 0.9em;
                pointer-events: none;
            `;

                // Make parent container position: relative so absolute positioning works
                sourceItemElem.style.position = 'relative';

                // Insert as sibling after item box (outside React's control)
                sourceItemElem.appendChild(rateElem);
            }
        }

        /**
         * Refresh all displayed rates (e.g., after color change)
         */
        refreshRates() {
            // Remove all existing rate displays
            document.querySelectorAll('.mwi-transmute-rate').forEach((elem) => elem.remove());

            // Re-inject if section is visible
            const existingSection = document.querySelector('[class*="ItemDictionary_transmutedFrom"]');
            if (existingSection) {
                this.injectRates(existingSection);
            }
        }

        /**
         * Disable the feature and clean up
         */
        disable() {
            // Clear any pending injection timeouts
            clearTimeout(this.injectTimeout);
            this.timerRegistry.clearAll();

            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];

            // Remove all injected rate displays
            document.querySelectorAll('.mwi-transmute-rate').forEach((elem) => elem.remove());

            // Clear cache
            this.nameToHridCache.clear();

            this.isInitialized = false;
        }
    }

    const transmuteRates = new TransmuteRates();

    // Setup setting listener (always active, even when feature is disabled)
    transmuteRates.setupSettingListener();

    /**
     * Enhancement Session Data Structure
     * Represents a single enhancement tracking session for one item
     */

    /**
     * Session states
     */
    const SessionState = {
        TRACKING: 'tracking', // Currently tracking enhancements
        COMPLETED: 'completed'};

    /**
     * Create a new enhancement session
     * @param {string} itemHrid - Item HRID being enhanced
     * @param {string} itemName - Display name of item
     * @param {number} startLevel - Starting enhancement level
     * @param {number} targetLevel - Target enhancement level (1-20)
     * @param {number} protectFrom - Level to start using protection items (0 = never)
     * @returns {Object} New session object
     */
    function createSession(itemHrid, itemName, startLevel, targetLevel, protectFrom = 0) {
        const now = Date.now();

        return {
            // Session metadata
            id: `session_${now}`,
            state: SessionState.TRACKING,
            itemHrid,
            itemName,
            startLevel,
            targetLevel,
            currentLevel: startLevel,
            protectFrom,

            // Timestamps
            startTime: now,
            lastUpdateTime: now,
            endTime: null,

            // Last attempt tracking (for detecting success/failure)
            lastAttempt: {
                attemptNumber: 0,
                level: startLevel,
                timestamp: now,
            },

            // Attempt tracking (per level)
            // Format: { 1: { success: 5, fail: 3, successRate: 0.625 }, ... }
            attemptsPerLevel: {},

            // Cost tracking
            materialCosts: {}, // Format: { itemHrid: { count: 10, totalCost: 50000 } }
            coinCost: 0,
            coinCount: 0, // Track number of times coins were spent
            protectionCost: 0,
            protectionCount: 0,
            protectionItemHrid: null, // Track which protection item is being used
            totalCost: 0,

            // Statistics
            totalAttempts: 0,
            totalSuccesses: 0,
            totalFailures: 0,
            totalXP: 0, // Total XP gained from enhancements
            longestSuccessStreak: 0,
            longestFailureStreak: 0,
            currentStreak: { type: null, count: 0 }, // 'success' or 'fail'

            // Milestones reached
            milestonesReached: [], // [5, 10, 15, 20]

            // Enhancement predictions (optional - calculated at session start)
            predictions: null, // { expectedAttempts, expectedProtections, ... }
        };
    }

    /**
     * Initialize attempts tracking for a level
     * @param {Object} session - Session object
     * @param {number} level - Enhancement level
     */
    function initializeLevelTracking(session, level) {
        if (!session.attemptsPerLevel[level]) {
            session.attemptsPerLevel[level] = {
                success: 0,
                fail: 0,
                successRate: 0,
            };
        }
    }

    /**
     * Update success rate for a level
     * @param {Object} session - Session object
     * @param {number} level - Enhancement level
     */
    function updateSuccessRate(session, level) {
        const levelData = session.attemptsPerLevel[level];
        if (!levelData) return;

        const total = levelData.success + levelData.fail;
        levelData.successRate = total > 0 ? levelData.success / total : 0;
    }

    /**
     * Record a successful enhancement attempt
     * @param {Object} session - Session object
     * @param {number} previousLevel - Level before enhancement (level that succeeded)
     * @param {number} newLevel - New level after success
     */
    function recordSuccess(session, previousLevel, newLevel) {
        // Initialize tracking if needed for the level that succeeded
        initializeLevelTracking(session, previousLevel);

        // Record success at the level we enhanced FROM
        session.attemptsPerLevel[previousLevel].success++;
        session.totalAttempts++;
        session.totalSuccesses++;

        // Update success rate for this level
        updateSuccessRate(session, previousLevel);

        // Update current level
        session.currentLevel = newLevel;

        // Update streaks
        if (session.currentStreak.type === 'success') {
            session.currentStreak.count++;
        } else {
            session.currentStreak = { type: 'success', count: 1 };
        }

        if (session.currentStreak.count > session.longestSuccessStreak) {
            session.longestSuccessStreak = session.currentStreak.count;
        }

        // Check for milestones
        if ([5, 10, 15, 20].includes(newLevel) && !session.milestonesReached.includes(newLevel)) {
            session.milestonesReached.push(newLevel);
        }

        // Update timestamp
        session.lastUpdateTime = Date.now();

        // Check if target reached
        if (newLevel >= session.targetLevel) {
            session.state = SessionState.COMPLETED;
            session.endTime = Date.now();
        }
    }

    /**
     * Record a failed enhancement attempt
     * @param {Object} session - Session object
     * @param {number} previousLevel - Level that failed (level we tried to enhance from)
     */
    function recordFailure(session, previousLevel) {
        // Initialize tracking if needed for the level that failed
        initializeLevelTracking(session, previousLevel);

        // Record failure at the level we enhanced FROM
        session.attemptsPerLevel[previousLevel].fail++;
        session.totalAttempts++;
        session.totalFailures++;

        // Update success rate for this level
        updateSuccessRate(session, previousLevel);

        // Update streaks
        if (session.currentStreak.type === 'fail') {
            session.currentStreak.count++;
        } else {
            session.currentStreak = { type: 'fail', count: 1 };
        }

        if (session.currentStreak.count > session.longestFailureStreak) {
            session.longestFailureStreak = session.currentStreak.count;
        }

        // Update timestamp
        session.lastUpdateTime = Date.now();
    }

    /**
     * Add material cost to session
     * @param {Object} session - Session object
     * @param {string} itemHrid - Material item HRID
     * @param {number} count - Quantity used
     * @param {number} unitCost - Cost per item (from market)
     */
    function addMaterialCost(session, itemHrid, count, unitCost) {
        if (!session.materialCosts[itemHrid]) {
            session.materialCosts[itemHrid] = {
                count: 0,
                totalCost: 0,
            };
        }

        session.materialCosts[itemHrid].count += count;
        session.materialCosts[itemHrid].totalCost += count * unitCost;

        // Update total cost
        recalculateTotalCost(session);
    }

    /**
     * Add coin cost to session
     * @param {Object} session - Session object
     * @param {number} amount - Coin amount spent
     */
    function addCoinCost(session, amount) {
        session.coinCost += amount;
        session.coinCount += 1;
        recalculateTotalCost(session);
    }

    /**
     * Add protection item cost to session
     * @param {Object} session - Session object
     * @param {string} protectionItemHrid - Protection item HRID
     * @param {number} cost - Protection item cost
     */
    function addProtectionCost(session, protectionItemHrid, cost) {
        session.protectionCost += cost;
        session.protectionCount += 1;

        // Store the protection item HRID if not already set
        if (!session.protectionItemHrid) {
            session.protectionItemHrid = protectionItemHrid;
        }

        recalculateTotalCost(session);
    }

    /**
     * Recalculate total cost from all sources
     * @param {Object} session - Session object
     */
    function recalculateTotalCost(session) {
        const materialTotal = Object.values(session.materialCosts).reduce((sum, m) => sum + m.totalCost, 0);

        session.totalCost = materialTotal + session.coinCost + session.protectionCost;
    }

    /**
     * Get session duration in seconds
     * @param {Object} session - Session object
     * @returns {number} Duration in seconds
     */
    function getSessionDuration(session) {
        const endTime = session.endTime || Date.now();
        return Math.floor((endTime - session.startTime) / 1000);
    }

    /**
     * Finalize session (mark as completed)
     * @param {Object} session - Session object
     */
    function finalizeSession(session) {
        session.state = SessionState.COMPLETED;
        session.endTime = Date.now();
    }

    /**
     * Check if session matches given item and level criteria (for resume logic)
     * @param {Object} session - Session object
     * @param {string} itemHrid - Item HRID
     * @param {number} currentLevel - Current enhancement level
     * @param {number} targetLevel - Target level
     * @param {number} protectFrom - Protection level
     * @returns {boolean} True if session matches
     */
    function sessionMatches(session, itemHrid, currentLevel, targetLevel, protectFrom = 0) {
        // Must be same item
        if (session.itemHrid !== itemHrid) return false;

        // Can only resume tracking sessions (not completed/archived)
        if (session.state !== SessionState.TRACKING) return false;

        // Must match protection settings exactly (Ultimate Tracker requirement)
        if (session.protectFrom !== protectFrom) return false;

        // Must match target level exactly (Ultimate Tracker requirement)
        if (session.targetLevel !== targetLevel) return false;

        // Must match current level (with small tolerance for out-of-order events)
        const levelDiff = Math.abs(session.currentLevel - currentLevel);
        if (levelDiff <= 1) {
            return true;
        }

        return false;
    }

    /**
     * Check if a completed session can be extended
     * @param {Object} session - Session object
     * @param {string} itemHrid - Item HRID
     * @param {number} currentLevel - Current enhancement level
     * @returns {boolean} True if session can be extended
     */
    function canExtendSession(session, itemHrid, currentLevel) {
        // Must be same item
        if (session.itemHrid !== itemHrid) return false;

        // Must be completed
        if (session.state !== SessionState.COMPLETED) return false;

        // Current level should match where session ended (or close)
        const levelDiff = Math.abs(session.currentLevel - currentLevel);
        if (levelDiff <= 1) {
            return true;
        }

        return false;
    }

    /**
     * Extend a completed session to a new target level
     * @param {Object} session - Session object
     * @param {number} newTargetLevel - New target level
     */
    function extendSession(session, newTargetLevel) {
        session.state = SessionState.TRACKING;
        session.targetLevel = newTargetLevel;
        session.endTime = null;
        session.lastUpdateTime = Date.now();
    }

    /**
     * Validate session data integrity
     * @param {Object} session - Session object
     * @returns {boolean} True if valid
     */
    function validateSession(session) {
        if (!session || typeof session !== 'object') return false;

        // Required fields
        if (!session.id || !session.itemHrid || !session.itemName) return false;
        if (typeof session.startLevel !== 'number' || typeof session.targetLevel !== 'number') return false;
        if (typeof session.currentLevel !== 'number') return false;

        // Validate level ranges
        if (session.startLevel < 0 || session.startLevel > 20) return false;
        if (session.targetLevel < 1 || session.targetLevel > 20) return false;
        if (session.currentLevel < 0 || session.currentLevel > 20) return false;

        // Validate costs are non-negative
        if (session.totalCost < 0 || session.coinCost < 0 || session.protectionCost < 0) return false;

        return true;
    }

    /**
     * Enhancement Tracker Storage
     * Handles persistence of enhancement sessions using IndexedDB
     */


    const STORAGE_KEY = 'enhancementTracker_sessions';
    const CURRENT_SESSION_KEY = 'enhancementTracker_currentSession';
    const STORAGE_STORE = 'settings'; // Use existing 'settings' store

    /**
     * Save all sessions to storage
     * @param {Object} sessions - Sessions object (keyed by session ID)
     * @returns {Promise<void>}
     */
    async function saveSessions(sessions) {
        try {
            await storage$1.setJSON(STORAGE_KEY, sessions, STORAGE_STORE, true); // immediate=true for rapid updates
        } catch (error) {
            throw error;
        }
    }

    /**
     * Load all sessions from storage
     * @returns {Promise<Object>} Sessions object (keyed by session ID)
     */
    async function loadSessions() {
        try {
            const sessions = await storage$1.getJSON(STORAGE_KEY, STORAGE_STORE, {});
            return sessions;
        } catch {
            return {};
        }
    }

    /**
     * Save current session ID
     * @param {string|null} sessionId - Current session ID (null if no active session)
     * @returns {Promise<void>}
     */
    async function saveCurrentSessionId(sessionId) {
        try {
            await storage$1.set(CURRENT_SESSION_KEY, sessionId, STORAGE_STORE, true); // immediate=true for rapid updates
        } catch {
            // Silent failure
        }
    }

    /**
     * Load current session ID
     * @returns {Promise<string|null>} Current session ID or null
     */
    async function loadCurrentSessionId() {
        try {
            return await storage$1.get(CURRENT_SESSION_KEY, STORAGE_STORE, null);
        } catch {
            return null;
        }
    }

    /**
     * Enhancement XP Calculations
     * Based on Ultimate Enhancement Tracker formulas
     */


    /**
     * Get base item level from item HRID
     * @param {string} itemHrid - Item HRID
     * @returns {number} Base item level
     */
    function getBaseItemLevel(itemHrid) {
        try {
            const gameData = dataManager$1.getInitClientData();
            const itemData = gameData?.itemDetailMap?.[itemHrid];

            // First try direct level field (works for consumables, resources, etc.)
            if (itemData?.level) {
                return itemData.level;
            }

            // For equipment, check levelRequirements array
            if (itemData?.equipmentDetail?.levelRequirements?.length > 0) {
                // Return the level from the first requirement (highest requirement)
                return itemData.equipmentDetail.levelRequirements[0].level;
            }

            return 0;
        } catch {
            return 0;
        }
    }

    /**
     * Get wisdom buff percentage from all sources
     * Reads from dataManager.characterData (NOT localStorage)
     * @returns {number} Wisdom buff as decimal (e.g., 0.20 for 20%)
     */
    function getWisdomBuff() {
        try {
            // Use dataManager for character data (NOT localStorage)
            const charData = dataManager$1.characterData;
            if (!charData) return 0;

            let totalFlatBoost = 0;

            // 1. Community Buffs
            const communityEnhancingBuffs = charData.communityActionTypeBuffsMap?.['/action_types/enhancing'];
            if (Array.isArray(communityEnhancingBuffs)) {
                communityEnhancingBuffs.forEach((buff) => {
                    if (buff.typeHrid === '/buff_types/wisdom') {
                        totalFlatBoost += buff.flatBoost || 0;
                    }
                });
            }

            // 2. Equipment Buffs
            const equipmentEnhancingBuffs = charData.equipmentActionTypeBuffsMap?.['/action_types/enhancing'];
            if (Array.isArray(equipmentEnhancingBuffs)) {
                equipmentEnhancingBuffs.forEach((buff) => {
                    if (buff.typeHrid === '/buff_types/wisdom') {
                        totalFlatBoost += buff.flatBoost || 0;
                    }
                });
            }

            // 3. House Buffs
            const houseEnhancingBuffs = charData.houseActionTypeBuffsMap?.['/action_types/enhancing'];
            if (Array.isArray(houseEnhancingBuffs)) {
                houseEnhancingBuffs.forEach((buff) => {
                    if (buff.typeHrid === '/buff_types/wisdom') {
                        totalFlatBoost += buff.flatBoost || 0;
                    }
                });
            }

            // 4. Consumable Buffs (from wisdom tea, etc.)
            const consumableEnhancingBuffs = charData.consumableActionTypeBuffsMap?.['/action_types/enhancing'];
            if (Array.isArray(consumableEnhancingBuffs)) {
                consumableEnhancingBuffs.forEach((buff) => {
                    if (buff.typeHrid === '/buff_types/wisdom') {
                        totalFlatBoost += buff.flatBoost || 0;
                    }
                });
            }

            // 5. Achievement Buffs
            totalFlatBoost += dataManager$1.getAchievementBuffFlatBoost('/action_types/enhancing', '/buff_types/wisdom');

            // Return as decimal (flatBoost is already in decimal form, e.g., 0.2 for 20%)
            return totalFlatBoost;
        } catch {
            return 0;
        }
    }

    /**
     * Calculate XP gained from successful enhancement
     * Formula: 1.4 × (1 + wisdom) × enhancementMultiplier × (10 + baseItemLevel)
     * @param {number} previousLevel - Enhancement level before success
     * @param {string} itemHrid - Item HRID
     * @returns {number} XP gained
     */
    function calculateSuccessXP(previousLevel, itemHrid) {
        const baseLevel = getBaseItemLevel(itemHrid);
        const wisdomBuff = getWisdomBuff();

        // Special handling for enhancement level 0 (base items)
        const enhancementMultiplier =
            previousLevel === 0
                ? 1.0 // Base value for unenhanced items
                : previousLevel + 1; // Normal progression

        return Math.floor(1.4 * (1 + wisdomBuff) * enhancementMultiplier * (10 + baseLevel));
    }

    /**
     * Calculate XP gained from failed enhancement
     * Formula: 10% of success XP
     * @param {number} previousLevel - Enhancement level that failed
     * @param {string} itemHrid - Item HRID
     * @returns {number} XP gained
     */
    function calculateFailureXP(previousLevel, itemHrid) {
        return Math.floor(calculateSuccessXP(previousLevel, itemHrid) * 0.1);
    }

    /**
     * Calculate adjusted attempt number from session data
     * This makes tracking resume-proof (doesn't rely on WebSocket currentCount)
     * @param {Object} session - Session object
     * @returns {number} Next attempt number
     */
    function calculateAdjustedAttemptCount(session) {
        let successCount = 0;
        let failCount = 0;

        // Sum all successes and failures across all levels
        for (const level in session.attemptsPerLevel) {
            const levelData = session.attemptsPerLevel[level];
            successCount += levelData.success || 0;
            failCount += levelData.fail || 0;
        }

        // For the first attempt, return 1
        if (successCount === 0 && failCount === 0) {
            return 1;
        }

        // Return total + 1 for the next attempt
        return successCount + failCount + 1;
    }

    /**
     * Calculate enhancement predictions using character stats
     * @param {string} itemHrid - Item HRID being enhanced
     * @param {number} startLevel - Starting enhancement level
     * @param {number} targetLevel - Target enhancement level
     * @param {number} protectFrom - Level to start using protection
     * @returns {Object|null} Prediction data or null if cannot calculate
     */
    function calculateEnhancementPredictions(itemHrid, startLevel, targetLevel, protectFrom) {
        try {
            // Use dataManager for character data (NOT localStorage)
            const charData = dataManager$1.characterData;
            const gameData = dataManager$1.getInitClientData();

            if (!charData || !gameData) {
                return null;
            }

            // Get item level
            const itemData = gameData.itemDetailMap?.[itemHrid];
            if (!itemData) {
                return null;
            }
            const itemLevel = itemData.level || 0;

            // Get enhancing skill level
            const enhancingLevel = charData.characterSkills?.['/skills/enhancing']?.level || 1;

            // Get house level (Observatory)
            const houseRooms = charData.characterHouseRoomMap;
            let houseLevel = 0;
            if (houseRooms) {
                for (const roomHrid in houseRooms) {
                    const room = houseRooms[roomHrid];
                    if (room.houseRoomHrid === '/house_rooms/observatory') {
                        houseLevel = room.level || 0;
                        break;
                    }
                }
            }

            // Get equipment buffs for enhancing
            let toolBonus = 0;
            let speedBonus = 0;
            const equipmentBuffs = charData.equipmentActionTypeBuffsMap?.['/action_types/enhancing'];
            if (Array.isArray(equipmentBuffs)) {
                equipmentBuffs.forEach((buff) => {
                    if (buff.typeHrid === '/buff_types/enhancing_success') {
                        toolBonus += (buff.flatBoost || 0) * 100; // Convert to percentage
                    }
                    if (buff.typeHrid === '/buff_types/enhancing_speed') {
                        speedBonus += (buff.flatBoost || 0) * 100; // Convert to percentage
                    }
                });
            }

            // Add house buffs
            const houseBuffs = charData.houseActionTypeBuffsMap?.['/action_types/enhancing'];
            if (Array.isArray(houseBuffs)) {
                houseBuffs.forEach((buff) => {
                    if (buff.typeHrid === '/buff_types/enhancing_success') {
                        toolBonus += (buff.flatBoost || 0) * 100;
                    }
                    if (buff.typeHrid === '/buff_types/enhancing_speed') {
                        speedBonus += (buff.flatBoost || 0) * 100;
                    }
                });
            }

            // Add achievement buffs
            toolBonus +=
                dataManager$1.getAchievementBuffFlatBoost('/action_types/enhancing', '/buff_types/enhancing_success') * 100;

            // Check for blessed tea
            let hasBlessed = false;
            let guzzlingBonus = 1.0;
            const enhancingTeas = charData.actionTypeDrinkSlotsMap?.['/action_types/enhancing'] || [];
            const activeTeas = enhancingTeas.filter((tea) => tea?.isActive);

            activeTeas.forEach((tea) => {
                if (tea.itemHrid === '/items/blessed_tea') {
                    hasBlessed = true;
                }
            });

            // Get guzzling pouch bonus (drink concentration)
            const consumableBuffs = charData.consumableActionTypeBuffsMap?.['/action_types/enhancing'];
            if (Array.isArray(consumableBuffs)) {
                consumableBuffs.forEach((buff) => {
                    if (buff.typeHrid === '/buff_types/drink_concentration') {
                        guzzlingBonus = 1.0 + (buff.flatBoost || 0);
                    }
                });
            }

            // Calculate predictions
            const result = calculateEnhancement({
                enhancingLevel,
                houseLevel,
                toolBonus,
                speedBonus,
                itemLevel,
                targetLevel,
                protectFrom,
                blessedTea: hasBlessed,
                guzzlingBonus,
            });

            if (!result) {
                return null;
            }

            return {
                expectedAttempts: Math.round(result.attemptsRounded),
                expectedProtections: Math.round(result.protectionCount),
                expectedTime: result.totalTime,
                successMultiplier: result.successMultiplier,
            };
        } catch {
            return null;
        }
    }

    /**
     * Enhancement Tracker
     * Main tracker class for monitoring enhancement attempts, costs, and statistics
     */


    /**
     * EnhancementTracker class manages enhancement tracking sessions
     */
    class EnhancementTracker {
        constructor() {
            this.sessions = {}; // All sessions (keyed by session ID)
            this.currentSessionId = null; // Currently active session ID
            this.isInitialized = false;
        }

        /**
         * Initialize enhancement tracker
         * @returns {Promise<void>}
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            if (!config$1.getSetting('enhancementTracker')) {
                return;
            }

            try {
                // Load sessions from storage
                this.sessions = await loadSessions();
                this.currentSessionId = await loadCurrentSessionId();

                // Validate current session still exists
                if (this.currentSessionId && !this.sessions[this.currentSessionId]) {
                    this.currentSessionId = null;
                    await saveCurrentSessionId(null);
                }

                // Validate all loaded sessions
                for (const [sessionId, session] of Object.entries(this.sessions)) {
                    if (!validateSession(session)) {
                        delete this.sessions[sessionId];
                    }
                }

                this.isInitialized = true;
            } catch {
                // Silent failure
            }
        }

        /**
         * Start a new enhancement session
         * @param {string} itemHrid - Item HRID being enhanced
         * @param {number} startLevel - Starting enhancement level
         * @param {number} targetLevel - Target enhancement level
         * @param {number} protectFrom - Level to start using protection (0 = never)
         * @returns {Promise<string>} New session ID
         */
        async startSession(itemHrid, startLevel, targetLevel, protectFrom = 0) {
            const gameData = dataManager$1.getInitClientData();
            if (!gameData) {
                throw new Error('Game data not available');
            }

            // Get item name
            const itemDetails = gameData.itemDetailMap[itemHrid];
            if (!itemDetails) {
                throw new Error(`Item not found: ${itemHrid}`);
            }

            const itemName = itemDetails.name;

            // Create new session
            const session = createSession(itemHrid, itemName, startLevel, targetLevel, protectFrom);

            // Calculate predictions
            const predictions = calculateEnhancementPredictions(itemHrid, startLevel, targetLevel, protectFrom);
            session.predictions = predictions;

            // Store session
            this.sessions[session.id] = session;
            this.currentSessionId = session.id;

            // Save to storage
            await saveSessions(this.sessions);
            await saveCurrentSessionId(session.id);

            return session.id;
        }

        /**
         * Find a matching previous session that can be resumed
         * @param {string} itemHrid - Item HRID
         * @param {number} currentLevel - Current enhancement level
         * @param {number} targetLevel - Target level
         * @param {number} protectFrom - Protection level
         * @returns {string|null} Session ID if found, null otherwise
         */
        findMatchingSession(itemHrid, currentLevel, targetLevel, protectFrom = 0) {
            for (const [sessionId, session] of Object.entries(this.sessions)) {
                if (sessionMatches(session, itemHrid, currentLevel, targetLevel, protectFrom)) {
                    return sessionId;
                }
            }

            return null;
        }

        /**
         * Resume an existing session
         * @param {string} sessionId - Session ID to resume
         * @returns {Promise<boolean>} True if resumed successfully
         */
        async resumeSession(sessionId) {
            if (!this.sessions[sessionId]) {
                return false;
            }

            const session = this.sessions[sessionId];

            // Can only resume tracking sessions
            if (session.state !== SessionState.TRACKING) {
                return false;
            }

            this.currentSessionId = sessionId;
            await saveCurrentSessionId(sessionId);

            return true;
        }

        /**
         * Find a completed session that can be extended
         * @param {string} itemHrid - Item HRID
         * @param {number} currentLevel - Current enhancement level
         * @returns {string|null} Session ID if found, null otherwise
         */
        findExtendableSession(itemHrid, currentLevel) {
            for (const [sessionId, session] of Object.entries(this.sessions)) {
                if (canExtendSession(session, itemHrid, currentLevel)) {
                    return sessionId;
                }
            }

            return null;
        }

        /**
         * Extend a completed session to a new target level
         * @param {string} sessionId - Session ID to extend
         * @param {number} newTargetLevel - New target level
         * @returns {Promise<boolean>} True if extended successfully
         */
        async extendSessionTarget(sessionId, newTargetLevel) {
            if (!this.sessions[sessionId]) {
                return false;
            }

            const session = this.sessions[sessionId];

            // Can only extend completed sessions
            if (session.state !== SessionState.COMPLETED) {
                return false;
            }

            extendSession(session, newTargetLevel);
            this.currentSessionId = sessionId;

            await saveSessions(this.sessions);
            await saveCurrentSessionId(sessionId);

            return true;
        }

        /**
         * Get current active session
         * @returns {Object|null} Current session or null
         */
        getCurrentSession() {
            if (!this.currentSessionId) return null;
            return this.sessions[this.currentSessionId] || null;
        }

        /**
         * Finalize current session (mark as completed)
         * @returns {Promise<void>}
         */
        async finalizeCurrentSession() {
            const session = this.getCurrentSession();
            if (!session) {
                return;
            }

            finalizeSession(session);
            await saveSessions(this.sessions);

            // Clear current session
            this.currentSessionId = null;
            await saveCurrentSessionId(null);
        }

        /**
         * Record a successful enhancement attempt
         * @param {number} previousLevel - Level before success
         * @param {number} newLevel - New level after success
         * @returns {Promise<void>}
         */
        async recordSuccess(previousLevel, newLevel) {
            const session = this.getCurrentSession();
            if (!session) {
                return;
            }

            recordSuccess(session, previousLevel, newLevel);
            await saveSessions(this.sessions);

            // Check if target reached
            if (session.state === SessionState.COMPLETED) {
                this.currentSessionId = null;
                await saveCurrentSessionId(null);
            }
        }

        /**
         * Record a failed enhancement attempt
         * @param {number} previousLevel - Level that failed
         * @returns {Promise<void>}
         */
        async recordFailure(previousLevel) {
            const session = this.getCurrentSession();
            if (!session) {
                return;
            }

            recordFailure(session, previousLevel);
            await saveSessions(this.sessions);
        }

        /**
         * Track material costs for current session
         * @param {string} itemHrid - Material item HRID
         * @param {number} count - Quantity used
         * @returns {Promise<void>}
         */
        async trackMaterialCost(itemHrid, count) {
            const session = this.getCurrentSession();
            if (!session) return;

            // Get market price
            const priceData = marketAPI.getPrice(itemHrid, 0);
            const unitCost = priceData ? priceData.ask || priceData.bid || 0 : 0;

            addMaterialCost(session, itemHrid, count, unitCost);
            await saveSessions(this.sessions);
        }

        /**
         * Track coin cost for current session
         * @param {number} amount - Coin amount spent
         * @returns {Promise<void>}
         */
        async trackCoinCost(amount) {
            const session = this.getCurrentSession();
            if (!session) return;

            addCoinCost(session, amount);
            await saveSessions(this.sessions);
        }

        /**
         * Track protection item cost for current session
         * @param {string} protectionItemHrid - Protection item HRID
         * @param {number} cost - Protection item cost
         * @returns {Promise<void>}
         */
        async trackProtectionCost(protectionItemHrid, cost) {
            const session = this.getCurrentSession();
            if (!session) return;

            addProtectionCost(session, protectionItemHrid, cost);
            await saveSessions(this.sessions);
        }

        /**
         * Get all sessions
         * @returns {Object} All sessions
         */
        getAllSessions() {
            return this.sessions;
        }

        /**
         * Get session by ID
         * @param {string} sessionId - Session ID
         * @returns {Object|null} Session or null
         */
        getSession(sessionId) {
            return this.sessions[sessionId] || null;
        }

        /**
         * Save sessions to storage (can be called directly)
         * @returns {Promise<void>}
         */
        async saveSessions() {
            await saveSessions(this.sessions);
        }

        /**
         * Disable and cleanup
         */
        disable() {
            this.isInitialized = false;
        }
    }

    const enhancementTracker = new EnhancementTracker();

    /**
     * Enhancement Tracker Floating UI
     * Displays enhancement session statistics in a draggable panel
     * Based on Ultimate Enhancement Tracker v3.7.9
     */


    // UI Style Constants (matching Ultimate Enhancement Tracker)
    const STYLE = {
        colors: {
            primary: '#00ffe7',
            border: 'rgba(0, 255, 234, 0.4)',
            textPrimary: '#e0f7ff',
            textSecondary: '#9b9bff',
            accent: '#ff00d4',
            danger: '#ff0055',
            success: '#00ff99',
            headerBg: 'rgba(15, 5, 35, 0.7)',
            gold: '#FFD700',
        },
        borderRadius: {
            medium: '8px'},
        transitions: {
            fast: 'all 0.15s ease'},
    };

    // Table styling
    const compactTableStyle = `
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    margin: 0;
`;

    const compactHeaderStyle = `
    padding: 4px 6px;
    background: ${STYLE.colors.headerBg};
    border: 1px solid ${STYLE.colors.border};
    color: ${STYLE.colors.textPrimary};
    font-weight: bold;
    text-align: center;
`;

    const compactCellStyle = `
    padding: 3px 6px;
    border: 1px solid rgba(0, 255, 234, 0.2);
    color: ${STYLE.colors.textPrimary};
`;

    /**
     * Enhancement UI Manager
     */
    class EnhancementUI {
        constructor() {
            this.floatingUI = null;
            this.currentViewingIndex = 0; // Index in sessions array
            this.updateDebounce = null;
            this.isDragging = false;
            this.unregisterScreenObserver = null;
            this.pollInterval = null;
            this.isOnEnhancingScreen = false;
            this.isCollapsed = false; // Track collapsed state
            this.updateInterval = null;
            this.timerRegistry = createTimerRegistry();
            this.dragHandle = null;
            this.dragMouseDownHandler = null;
            this.dragMoveHandler = null;
            this.dragUpHandler = null;
        }

        /**
         * Initialize the UI
         */
        initialize() {
            this.createFloatingUI();
            this.updateUI();

            // Set up screen observer for visibility control
            this.setupScreenObserver();

            // Update UI every second during active sessions
            this.updateInterval = setInterval(() => {
                const session = this.getCurrentSession();
                if (session && session.state === SessionState.TRACKING) {
                    this.updateUI();
                }
            }, 1000);
            this.timerRegistry.registerInterval(this.updateInterval);
        }

        /**
         * Set up screen observer to detect Enhancing screen using centralized observer
         */
        setupScreenObserver() {
            // Check if main feature is enabled
            const trackerEnabled = config$1.getSetting('enhancementTracker');

            if (!trackerEnabled) {
                // Main feature disabled, hide tracker
                this.hide();
            } else {
                // Check if setting is enabled (default to false if undefined)
                const showOnlyOnEnhancingScreen = config$1.getSetting('enhancementTracker_showOnlyOnEnhancingScreen');

                if (showOnlyOnEnhancingScreen !== true) {
                    // Setting is disabled or undefined, always show tracker
                    this.isOnEnhancingScreen = true;
                    this.show();
                } else {
                    // Setting enabled, check current screen
                    this.checkEnhancingScreen();
                    this.updateVisibility();
                }
            }

            // Register with centralized DOM observer for enhancing panel detection
            // Note: Enhancing screen uses EnhancingPanel_enhancingPanel, not SkillActionDetail_enhancingComponent
            this.unregisterScreenObserver = domObserver$1.onClass(
                'EnhancementUI-ScreenDetection',
                'EnhancingPanel_enhancingPanel',
                (_node) => {
                    this.checkEnhancingScreen();
                },
                { debounce: false }
            );

            // Poll for both setting changes and panel removal
            this.pollInterval = setInterval(() => {
                const trackerEnabled = config$1.getSetting('enhancementTracker');
                const currentSetting = config$1.getSetting('enhancementTracker_showOnlyOnEnhancingScreen');

                // If main tracker is disabled, always hide
                if (!trackerEnabled) {
                    if (this.floatingUI && this.floatingUI.style.display !== 'none') {
                        this.hide();
                    }
                    return;
                }

                if (currentSetting !== true) {
                    // Setting disabled - always show
                    if (!this.isOnEnhancingScreen) {
                        this.isOnEnhancingScreen = true;
                        this.updateVisibility();
                    }
                } else {
                    // Setting enabled - check if panel exists
                    const panel = document.querySelector('[class*="EnhancingPanel_enhancingPanel"]');
                    const shouldBeOnScreen = !!panel;

                    if (this.isOnEnhancingScreen !== shouldBeOnScreen) {
                        this.isOnEnhancingScreen = shouldBeOnScreen;
                        this.updateVisibility();
                    }
                }
            }, 500);
            this.timerRegistry.registerInterval(this.pollInterval);
        }

        /**
         * Check if currently on Enhancing screen
         */
        checkEnhancingScreen() {
            const enhancingPanel = document.querySelector('[class*="EnhancingPanel_enhancingPanel"]');
            const wasOnEnhancingScreen = this.isOnEnhancingScreen;
            this.isOnEnhancingScreen = !!enhancingPanel;

            if (wasOnEnhancingScreen !== this.isOnEnhancingScreen) {
                this.updateVisibility();
            }
        }

        /**
         * Update visibility based on screen state and settings
         */
        updateVisibility() {
            const trackerEnabled = config$1.getSetting('enhancementTracker');
            const showOnlyOnEnhancingScreen = config$1.getSetting('enhancementTracker_showOnlyOnEnhancingScreen');

            // If main tracker is disabled, always hide
            if (!trackerEnabled) {
                this.hide();
            } else if (showOnlyOnEnhancingScreen !== true) {
                this.show();
            } else if (this.isOnEnhancingScreen) {
                this.show();
            } else {
                this.hide();
            }
        }

        /**
         * Get currently viewed session
         */
        getCurrentSession() {
            const sessions = Object.values(enhancementTracker.getAllSessions());
            if (sessions.length === 0) return null;

            // Ensure index is valid
            if (this.currentViewingIndex >= sessions.length) {
                this.currentViewingIndex = sessions.length - 1;
            }
            if (this.currentViewingIndex < 0) {
                this.currentViewingIndex = 0;
            }

            return sessions[this.currentViewingIndex];
        }

        /**
         * Switch viewing to a specific session by ID
         * @param {string} sessionId - Session ID to view
         */
        switchToSession(sessionId) {
            const sessions = Object.values(enhancementTracker.getAllSessions());
            const index = sessions.findIndex((session) => session.id === sessionId);

            if (index !== -1) {
                this.currentViewingIndex = index;
            }
        }

        /**
         * Create the floating UI panel
         */
        createFloatingUI() {
            if (this.floatingUI && document.body.contains(this.floatingUI)) {
                return this.floatingUI;
            }

            // Main container
            this.floatingUI = document.createElement('div');
            this.floatingUI.id = 'enhancementFloatingUI';
            Object.assign(this.floatingUI.style, {
                position: 'fixed',
                top: '50px',
                right: '50px',
                zIndex: '9998',
                fontSize: '14px',
                padding: '0',
                borderRadius: STYLE.borderRadius.medium,
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.6)',
                overflow: 'hidden',
                width: '350px',
                minHeight: 'auto',
                background: 'rgba(25, 0, 35, 0.92)',
                backdropFilter: 'blur(12px)',
                border: `1px solid ${STYLE.colors.primary}`,
                color: STYLE.colors.textPrimary,
                display: 'flex',
                flexDirection: 'column',
                transition: 'width 0.2s ease',
            });

            // Create header
            const header = this.createHeader();
            this.floatingUI.appendChild(header);

            // Create content area
            const content = document.createElement('div');
            content.id = 'enhancementPanelContent';
            content.style.padding = '15px';
            content.style.flexGrow = '1';
            content.style.overflow = 'auto';
            content.style.transition = 'max-height 0.2s ease, opacity 0.2s ease';
            content.style.maxHeight = '600px';
            content.style.opacity = '1';
            this.floatingUI.appendChild(content);

            // Make draggable
            this.makeDraggable(header);

            // Add to page
            document.body.appendChild(this.floatingUI);

            return this.floatingUI;
        }

        /**
         * Create header with title and navigation
         */
        createHeader() {
            const header = document.createElement('div');
            header.id = 'enhancementPanelHeader';
            Object.assign(header.style, {
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                cursor: 'move',
                padding: '10px 15px',
                background: STYLE.colors.headerBg,
                borderBottom: `1px solid ${STYLE.colors.border}`,
                userSelect: 'none',
                flexShrink: '0',
            });

            // Title with session counter
            const titleContainer = document.createElement('div');
            titleContainer.style.display = 'flex';
            titleContainer.style.alignItems = 'center';
            titleContainer.style.gap = '10px';

            const title = document.createElement('span');
            title.textContent = 'Enhancement Tracker';
            title.style.fontWeight = 'bold';

            const sessionCounter = document.createElement('span');
            sessionCounter.id = 'enhancementSessionCounter';
            sessionCounter.style.fontSize = '12px';
            sessionCounter.style.opacity = '0.7';
            sessionCounter.style.marginLeft = '5px';

            titleContainer.appendChild(title);
            titleContainer.appendChild(sessionCounter);

            // Navigation container
            const navContainer = document.createElement('div');
            Object.assign(navContainer.style, {
                display: 'flex',
                gap: '5px',
                alignItems: 'center',
                marginLeft: 'auto',
            });

            // Previous session button
            const prevButton = this.createNavButton('◀', () => this.navigateSession(-1));

            // Next session button
            const nextButton = this.createNavButton('▶', () => this.navigateSession(1));

            // Collapse button
            const collapseButton = this.createCollapseButton();

            // Clear sessions button
            const clearButton = this.createClearButton();

            navContainer.appendChild(prevButton);
            navContainer.appendChild(nextButton);
            navContainer.appendChild(collapseButton);
            navContainer.appendChild(clearButton);

            header.appendChild(titleContainer);
            header.appendChild(navContainer);

            return header;
        }

        /**
         * Create navigation button
         */
        createNavButton(text, onClick) {
            const button = document.createElement('button');
            button.textContent = text;
            Object.assign(button.style, {
                background: 'none',
                border: 'none',
                color: STYLE.colors.textPrimary,
                cursor: 'pointer',
                fontSize: '14px',
                padding: '2px 8px',
                borderRadius: '3px',
                transition: STYLE.transitions.fast,
            });

            button.addEventListener('mouseover', () => {
                button.style.color = STYLE.colors.accent;
                button.style.background = 'rgba(255, 0, 212, 0.1)';
            });
            button.addEventListener('mouseout', () => {
                button.style.color = STYLE.colors.textPrimary;
                button.style.background = 'none';
            });
            button.addEventListener('click', onClick);

            return button;
        }

        /**
         * Create clear sessions button
         */
        createClearButton() {
            const button = document.createElement('button');
            button.innerHTML = '🗑️';
            button.title = 'Clear all sessions';
            Object.assign(button.style, {
                background: 'none',
                border: 'none',
                color: STYLE.colors.textPrimary,
                cursor: 'pointer',
                fontSize: '14px',
                padding: '2px 8px',
                borderRadius: '3px',
                transition: STYLE.transitions.fast,
                marginLeft: '5px',
            });

            button.addEventListener('mouseover', () => {
                button.style.color = STYLE.colors.danger;
                button.style.background = 'rgba(255, 0, 0, 0.1)';
            });
            button.addEventListener('mouseout', () => {
                button.style.color = STYLE.colors.textPrimary;
                button.style.background = 'none';
            });
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm('Clear all enhancement sessions?')) {
                    this.clearAllSessions();
                }
            });

            return button;
        }

        /**
         * Create collapse button
         */
        createCollapseButton() {
            const button = document.createElement('button');
            button.id = 'enhancementCollapseButton';
            button.innerHTML = '▼';
            button.title = 'Collapse panel';
            Object.assign(button.style, {
                background: 'none',
                border: 'none',
                color: STYLE.colors.textPrimary,
                cursor: 'pointer',
                fontSize: '14px',
                padding: '2px 8px',
                borderRadius: '3px',
                transition: STYLE.transitions.fast,
            });

            button.addEventListener('mouseover', () => {
                button.style.color = STYLE.colors.accent;
                button.style.background = 'rgba(255, 0, 212, 0.1)';
            });
            button.addEventListener('mouseout', () => {
                button.style.color = STYLE.colors.textPrimary;
                button.style.background = 'none';
            });
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggleCollapse();
            });

            return button;
        }

        /**
         * Make element draggable
         */
        makeDraggable(header) {
            let offsetX = 0;
            let offsetY = 0;

            const onMouseMove = (event) => {
                if (this.isDragging) {
                    const newLeft = event.clientX - offsetX;
                    const newTop = event.clientY - offsetY;

                    // Use absolute positioning during drag
                    this.floatingUI.style.left = `${newLeft}px`;
                    this.floatingUI.style.right = 'auto';
                    this.floatingUI.style.top = `${newTop}px`;
                }
            };

            const onMouseUp = () => {
                this.isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                this.dragMoveHandler = null;
                this.dragUpHandler = null;
            };

            const onMouseDown = (event) => {
                this.isDragging = true;

                // Calculate offset from panel's current screen position
                const rect = this.floatingUI.getBoundingClientRect();
                offsetX = event.clientX - rect.left;
                offsetY = event.clientY - rect.top;

                this.dragMoveHandler = onMouseMove;
                this.dragUpHandler = onMouseUp;

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            };

            if (this.dragHandle && this.dragMouseDownHandler) {
                this.dragHandle.removeEventListener('mousedown', this.dragMouseDownHandler);
            }

            this.dragHandle = header;
            this.dragMouseDownHandler = onMouseDown;

            header.addEventListener('mousedown', onMouseDown);
        }

        /**
         * Toggle panel collapse state
         */
        toggleCollapse() {
            this.isCollapsed = !this.isCollapsed;
            const content = document.getElementById('enhancementPanelContent');
            const button = document.getElementById('enhancementCollapseButton');

            if (this.isCollapsed) {
                // Collapsed state
                content.style.maxHeight = '0px';
                content.style.opacity = '0';
                content.style.padding = '0 15px';
                button.innerHTML = '▶';
                button.title = 'Expand panel';
                this.floatingUI.style.width = '250px';

                // Show compact summary after content fades
                const summaryTimeout = setTimeout(() => {
                    this.showCollapsedSummary();
                }, 200);
                this.timerRegistry.registerTimeout(summaryTimeout);
            } else {
                // Expanded state
                this.hideCollapsedSummary();
                content.style.maxHeight = '600px';
                content.style.opacity = '1';
                content.style.padding = '15px';
                button.innerHTML = '▼';
                button.title = 'Collapse panel';
                this.floatingUI.style.width = '350px';
            }
        }

        /**
         * Show compact summary in collapsed state
         */
        showCollapsedSummary() {
            if (!this.isCollapsed) return;

            const session = this.getCurrentSession();
            const sessions = Object.values(enhancementTracker.getAllSessions());

            // Remove any existing summary
            this.hideCollapsedSummary();

            if (sessions.length === 0 || !session) return;

            const gameData = dataManager$1.getInitClientData();
            const itemDetails = gameData?.itemDetailMap?.[session.itemHrid];
            const itemName = itemDetails?.name || 'Unknown Item';

            const totalAttempts = session.totalAttempts;
            const totalSuccess = session.totalSuccesses;
            const successRate = totalAttempts > 0 ? Math.floor((totalSuccess / totalAttempts) * 100) : 0;
            const statusIcon = session.state === SessionState.COMPLETED ? '✅' : '🟢';

            const summary = document.createElement('div');
            summary.id = 'enhancementCollapsedSummary';
            Object.assign(summary.style, {
                padding: '10px 15px',
                fontSize: '12px',
                borderTop: `1px solid ${STYLE.colors.border}`,
                color: STYLE.colors.textPrimary,
            });

            summary.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 4px;">${itemName} → +${session.targetLevel}</div>
            <div style="opacity: 0.8;">${statusIcon} ${totalAttempts} attempts | ${successRate}% rate</div>
        `;

            this.floatingUI.appendChild(summary);
        }

        /**
         * Hide collapsed summary
         */
        hideCollapsedSummary() {
            const summary = document.getElementById('enhancementCollapsedSummary');
            if (summary) {
                summary.remove();
            }
        }

        /**
         * Navigate between sessions
         */
        navigateSession(direction) {
            const sessions = Object.values(enhancementTracker.getAllSessions());
            if (sessions.length === 0) return;

            this.currentViewingIndex += direction;

            // Wrap around
            if (this.currentViewingIndex < 0) {
                this.currentViewingIndex = sessions.length - 1;
            } else if (this.currentViewingIndex >= sessions.length) {
                this.currentViewingIndex = 0;
            }

            this.updateUI();

            // Update collapsed summary if in collapsed state
            if (this.isCollapsed) {
                this.showCollapsedSummary();
            }
        }

        /**
         * Clear all sessions
         */
        async clearAllSessions() {
            // Clear from tracker
            const sessions = enhancementTracker.getAllSessions();
            for (const sessionId of Object.keys(sessions)) {
                delete sessions[sessionId];
            }

            await enhancementTracker.saveSessions();

            this.currentViewingIndex = 0;
            this.updateUI();

            // Hide collapsed summary if shown
            if (this.isCollapsed) {
                this.hideCollapsedSummary();
            }
        }

        /**
         * Update UI content (debounced)
         */
        scheduleUpdate() {
            if (this.updateDebounce) {
                clearTimeout(this.updateDebounce);
            }
            this.updateDebounce = setTimeout(() => this.updateUI(), 100);
            this.timerRegistry.registerTimeout(this.updateDebounce);
        }

        /**
         * Update UI content (immediate)
         */
        updateUI() {
            if (!this.floatingUI || !document.body.contains(this.floatingUI)) {
                return;
            }

            const content = document.getElementById('enhancementPanelContent');
            if (!content) return;

            // Update session counter
            this.updateSessionCounter();

            const sessions = Object.values(enhancementTracker.getAllSessions());

            // No sessions
            if (sessions.length === 0) {
                content.innerHTML = `
                <div style="text-align: center; padding: 40px 20px; color: ${STYLE.colors.textSecondary};">
                    <div style="font-size: 32px; margin-bottom: 10px;">✧</div>
                    <div style="font-size: 14px;">Begin enhancing to populate data</div>
                </div>
            `;
                return;
            }

            const session = this.getCurrentSession();
            if (!session) {
                content.innerHTML = '<div style="text-align: center; color: ${STYLE.colors.danger};">Invalid session</div>';
                return;
            }

            // Remember expanded state before updating
            const detailsId = `cost-details-${session.id}`;
            const detailsElement = document.getElementById(detailsId);
            const wasExpanded = detailsElement && detailsElement.style.display !== 'none';

            // Build UI content
            content.innerHTML = this.generateSessionHTML(session);

            // Restore expanded state after updating
            if (wasExpanded) {
                const newDetailsElement = document.getElementById(detailsId);
                if (newDetailsElement) {
                    newDetailsElement.style.display = 'block';
                }
            }

            // Update collapsed summary if in collapsed state
            if (this.isCollapsed) {
                this.showCollapsedSummary();
            }
        }

        /**
         * Update session counter in header
         */
        updateSessionCounter() {
            const counter = document.getElementById('enhancementSessionCounter');
            if (!counter) return;

            const sessions = Object.values(enhancementTracker.getAllSessions());
            if (sessions.length === 0) {
                counter.textContent = '';
            } else {
                counter.textContent = `(${this.currentViewingIndex + 1}/${sessions.length})`;
            }
        }

        /**
         * Generate HTML for session display
         */
        generateSessionHTML(session) {
            const gameData = dataManager$1.getInitClientData();
            const itemDetails = gameData?.itemDetailMap?.[session.itemHrid];
            const itemName = itemDetails?.name || 'Unknown Item';

            // Calculate stats
            const totalAttempts = session.totalAttempts;
            const totalSuccess = session.totalSuccesses;
            session.totalFailures;
            totalAttempts > 0 ? formatPercentage(totalSuccess / totalAttempts, 1) : '0.0%';

            const duration = getSessionDuration(session);
            const durationText = this.formatDuration(duration);

            // Calculate XP/hour if we have enough data (at least 5 seconds + some XP)
            const xpPerHour = duration >= 5 && session.totalXP > 0 ? Math.floor((session.totalXP / duration) * 3600) : 0;

            // Status display
            const statusColor = session.state === SessionState.COMPLETED ? STYLE.colors.success : STYLE.colors.accent;
            const statusText = session.state === SessionState.COMPLETED ? 'Completed' : 'In Progress';

            // Build HTML
            let html = `
            <div style="margin-bottom: 10px; font-size: 13px;">
                <div style="display: flex; justify-content: space-between;">
                    <span>Item:</span>
                    <strong>${itemName}</strong>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Target:</span>
                    <span>+${session.targetLevel}</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Prot:</span>
                    <span>+${session.protectFrom}</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-top: 5px; color: ${statusColor};">
                    <span>Status:</span>
                    <strong>${statusText}</strong>
                </div>
            </div>
        `;

            // Per-level table
            html += this.generateLevelTable(session);

            // Summary stats
            html += `
            <div style="margin-top: 8px;">
                <div style="display: flex; justify-content: space-between; font-size: 13px;">
                    <div>
                        <span>Total Attempts:</span>
                        <strong> ${totalAttempts}</strong>
                    </div>
                    <div>
                        <span>Prots Used:</span>
                        <strong> ${session.protectionCount || 0}</strong>
                    </div>
                </div>
            </div>`;

            // Predictions (if available)
            if (session.predictions) {
                const predictions = session.predictions;
                const expAtt = predictions.expectedAttempts || 0;
                const expProt = predictions.expectedProtections || 0;
                const actualProt = session.protectionCount || 0;

                // Calculate factors (like Ultimate Tracker)
                const attFactor = expAtt > 0 ? (totalAttempts / expAtt).toFixed(2) : null;
                const protFactor = expProt > 0 ? (actualProt / expProt).toFixed(2) : null;

                html += `
            <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 4px;">
                <div style="color: ${STYLE.colors.textSecondary};">
                    <span>Expected Attempts:</span>
                    <span> ${expAtt}</span>
                </div>
                <div style="color: ${STYLE.colors.textSecondary};">
                    <span>Expected Prots:</span>
                    <span> ${expProt}</span>
                </div>
            </div>`;

                if (attFactor || protFactor) {
                    html += `
            <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 2px; color: ${STYLE.colors.textSecondary};">
                <div>
                    <span>Attempt Factor:</span>
                    <strong> ${attFactor ? attFactor + 'x' : '—'}</strong>
                </div>
                <div>
                    <span>Prot Factor:</span>
                    <strong> ${protFactor ? protFactor + 'x' : '—'}</strong>
                </div>
            </div>`;
                }
            }

            html += `
            <div style="margin-top: 8px; display: flex; justify-content: space-between; font-size: 13px;">
                <span>Total XP Gained:</span>
                <strong>${this.formatNumber(session.totalXP)}</strong>
            </div>

            <div style="margin-top: 8px; display: flex; justify-content: space-between; font-size: 13px;">
                <span>Session Duration:</span>
                <strong>${durationText}</strong>
            </div>

            <div style="margin-top: 8px; display: flex; justify-content: space-between; font-size: 13px;">
                <span>XP/Hour:</span>
                <strong>${xpPerHour > 0 ? this.formatNumber(xpPerHour) : 'Calculating...'}</strong>
            </div>
        `;

            // Material costs
            html += this.generateMaterialCostsHTML(session);

            return html;
        }

        /**
         * Generate per-level breakdown table
         */
        generateLevelTable(session) {
            const levels = Object.keys(session.attemptsPerLevel).sort((a, b) => b - a);

            if (levels.length === 0) {
                return '<div style="text-align: center; padding: 20px; color: ${STYLE.colors.textSecondary};">No attempts recorded yet</div>';
            }

            let rows = '';
            for (const level of levels) {
                const levelData = session.attemptsPerLevel[level];
                const rate = formatPercentage(levelData.successRate, 1);
                const isCurrent = parseInt(level) === session.currentLevel;

                const rowStyle = isCurrent
                    ? `
                background: linear-gradient(90deg, rgba(126, 87, 194, 0.25), rgba(0, 242, 255, 0.1));
                box-shadow: 0 0 12px rgba(126, 87, 194, 0.5), inset 0 0 6px rgba(0, 242, 255, 0.3);
                border-left: 3px solid ${STYLE.colors.accent};
                font-weight: bold;
            `
                    : '';

                rows += `
                <tr style="${rowStyle}">
                    <td style="${compactCellStyle} text-align: center;">${level}</td>
                    <td style="${compactCellStyle} text-align: right;">${levelData.success}</td>
                    <td style="${compactCellStyle} text-align: right;">${levelData.fail}</td>
                    <td style="${compactCellStyle} text-align: right;">${rate}</td>
                </tr>
            `;
            }

            return `
            <table style="${compactTableStyle}">
                <thead>
                    <tr>
                        <th style="${compactHeaderStyle}">Lvl</th>
                        <th style="${compactHeaderStyle}">Success</th>
                        <th style="${compactHeaderStyle}">Fail</th>
                        <th style="${compactHeaderStyle}">%</th>
                    </tr>
                </thead>
                <tbody>
                    ${rows}
                </tbody>
            </table>
        `;
        }

        /**
         * Generate material costs HTML (expandable)
         */
        generateMaterialCostsHTML(session) {
            // Check if there are any costs to display
            const hasMaterials = session.materialCosts && Object.keys(session.materialCosts).length > 0;
            const hasCoins = session.coinCost > 0;
            const hasProtection = session.protectionCost > 0;

            if (!hasMaterials && !hasCoins && !hasProtection) {
                return '';
            }

            const gameData = dataManager$1.getInitClientData();
            const detailsId = `cost-details-${session.id}`;

            let html = '<div style="margin-top: 12px; font-size: 13px;">';

            // Collapsible header
            html += `
            <div style="display: flex; justify-content: space-between; cursor: pointer; font-weight: bold; padding: 5px 0;"
                 onclick="document.getElementById('${detailsId}').style.display = document.getElementById('${detailsId}').style.display === 'none' ? 'block' : 'none'">
                <span>💰 Total Cost (click for details)</span>
                <span style="color: ${STYLE.colors.gold};">${this.formatNumber(session.totalCost)}</span>
            </div>
        `;

            // Expandable details section (hidden by default)
            html += `<div id="${detailsId}" style="display: none; margin-left: 10px; margin-top: 5px;">`;

            // Material costs
            if (hasMaterials) {
                html +=
                    '<div style="margin-bottom: 8px; padding: 5px; background: rgba(0, 255, 234, 0.05); border-radius: 4px;">';
                html +=
                    '<div style="font-weight: bold; margin-bottom: 3px; color: ${STYLE.colors.textSecondary};">Materials:</div>';

                for (const [itemHrid, data] of Object.entries(session.materialCosts)) {
                    const itemDetails = gameData?.itemDetailMap?.[itemHrid];
                    const itemName = itemDetails?.name || itemHrid;
                    const unitCost = Math.floor(data.totalCost / data.count);

                    html += `
                    <div style="display: flex; justify-content: space-between; margin-top: 2px; font-size: 12px;">
                        <span>${itemName}</span>
                        <span>${data.count} × ${this.formatNumber(unitCost)} = <span style="color: ${STYLE.colors.gold};">${this.formatNumber(data.totalCost)}</span></span>
                    </div>
                `;
                }
                html += '</div>';
            }

            // Coin costs
            if (hasCoins) {
                html += `
                <div style="display: flex; justify-content: space-between; margin-top: 2px; padding: 5px; background: rgba(0, 255, 234, 0.05); border-radius: 4px;">
                    <span style="font-weight: bold; color: ${STYLE.colors.textSecondary};">Coins (${session.coinCount || 0}×):</span>
                    <span style="color: ${STYLE.colors.gold};">${this.formatNumber(session.coinCost)}</span>
                </div>
            `;
            }

            // Protection costs
            if (hasProtection) {
                const protectionItemName = session.protectionItemHrid
                    ? gameData?.itemDetailMap?.[session.protectionItemHrid]?.name || 'Protection'
                    : 'Protection';

                html += `
                <div style="display: flex; justify-content: space-between; margin-top: 2px; padding: 5px; background: rgba(0, 255, 234, 0.05); border-radius: 4px;">
                    <span style="font-weight: bold; color: ${STYLE.colors.textSecondary};">${protectionItemName} (${session.protectionCount || 0}×):</span>
                    <span style="color: ${STYLE.colors.gold};">${this.formatNumber(session.protectionCost)}</span>
                </div>
            `;
            }

            html += '</div>'; // Close details
            html += '</div>'; // Close container

            return html;
        }

        /**
         * Format number with commas
         */
        formatNumber(num) {
            return Math.floor(num).toLocaleString();
        }

        /**
         * Format duration (seconds to h:m:s)
         */
        formatDuration(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;

            if (h > 0) {
                return `${h}h ${m}m ${s}s`;
            } else if (m > 0) {
                return `${m}m ${s}s`;
            } else {
                return `${s}s`;
            }
        }

        /**
         * Show the UI
         */
        show() {
            if (this.floatingUI) {
                this.floatingUI.style.display = 'flex';
            }
        }

        /**
         * Hide the UI
         */
        hide() {
            if (this.floatingUI) {
                this.floatingUI.style.display = 'none';
            }
        }

        /**
         * Toggle UI visibility
         */
        toggle() {
            if (this.floatingUI) {
                const isVisible = this.floatingUI.style.display !== 'none';
                if (isVisible) {
                    this.hide();
                } else {
                    this.show();
                }
            }
        }

        /**
         * Cleanup all UI resources
         */
        cleanup() {
            // Clear any pending update debounces
            if (this.updateDebounce) {
                clearTimeout(this.updateDebounce);
                this.updateDebounce = null;
            }

            // Clear poll interval
            if (this.pollInterval) {
                clearInterval(this.pollInterval);
                this.pollInterval = null;
            }

            if (this.updateInterval) {
                clearInterval(this.updateInterval);
                this.updateInterval = null;
            }

            // Unregister DOM observer
            if (this.unregisterScreenObserver) {
                this.unregisterScreenObserver();
                this.unregisterScreenObserver = null;
            }

            if (this.dragMoveHandler) {
                document.removeEventListener('mousemove', this.dragMoveHandler);
                this.dragMoveHandler = null;
            }

            if (this.dragUpHandler) {
                document.removeEventListener('mouseup', this.dragUpHandler);
                this.dragUpHandler = null;
            }

            if (this.dragHandle && this.dragMouseDownHandler) {
                this.dragHandle.removeEventListener('mousedown', this.dragMouseDownHandler);
            }

            this.dragHandle = null;
            this.dragMouseDownHandler = null;

            this.timerRegistry.clearAll();

            // Remove floating UI from DOM
            if (this.floatingUI && this.floatingUI.parentNode) {
                this.floatingUI.parentNode.removeChild(this.floatingUI);
                this.floatingUI = null;
            }

            // Reset state
            this.isOnEnhancingScreen = false;
            this.isCollapsed = false;
            this.currentViewingIndex = 0;
            this.isDragging = false;
        }
    }

    const enhancementUI = new EnhancementUI();

    /**
     * Enhancement Event Handlers
     * Automatically detects and tracks enhancement events from WebSocket messages
     */


    /**
     * Setup enhancement event handlers
     */
    function setupEnhancementHandlers() {
        // Listen for action_completed (when enhancement completes)
        webSocketHook$1.on('action_completed', handleActionCompleted);

        // Listen for wildcard to catch all messages for debugging
        webSocketHook$1.on('*', handleDebugMessage);
    }

    /**
     * Debug handler to log all messages temporarily
     * @param {Object} _data - WebSocket message data
     */
    function handleDebugMessage(_data) {
        // Debug logging removed
    }

    /**
     * Handle action_completed message (detects enhancement results)
     * @param {Object} data - WebSocket message data
     */
    async function handleActionCompleted(data) {
        if (!config$1.getSetting('enhancementTracker')) return;
        if (!enhancementTracker.isInitialized) return;

        const action = data.endCharacterAction;
        if (!action) return;

        // Check if this is an enhancement action
        // Ultimate Enhancement Tracker checks: actionHrid === "/actions/enhancing/enhance"
        if (action.actionHrid !== '/actions/enhancing/enhance') {
            return;
        }

        // Handle the enhancement
        await handleEnhancementResult(action);
    }

    /**
     * Extract protection item HRID from action data
     * @param {Object} action - Enhancement action data
     * @returns {string|null} Protection item HRID or null
     */
    function getProtectionItemHrid(action) {
        // Check if protection is enabled
        if (!action.enhancingProtectionMinLevel || action.enhancingProtectionMinLevel < 2) {
            return null;
        }

        // Extract protection item from secondaryItemHash (Ultimate Tracker method)
        if (action.secondaryItemHash) {
            const parts = action.secondaryItemHash.split('::');
            if (parts.length >= 3 && parts[2].startsWith('/items/')) {
                return parts[2];
            }
        }

        // Fallback: check if there's a direct enhancingProtectionItemHrid field
        if (action.enhancingProtectionItemHrid) {
            return action.enhancingProtectionItemHrid;
        }

        return null;
    }

    /**
     * Parse item hash to extract HRID and level
     * Based on Ultimate Enhancement Tracker's parseItemHash function
     * @param {string} primaryItemHash - Item hash from action
     * @returns {Object} {itemHrid, level}
     */
    function parseItemHash(primaryItemHash) {
        try {
            // Handle different possible formats:
            // 1. "/item_locations/inventory::/items/enhancers_bottoms::0" (level 0)
            // 2. "161296::/item_locations/inventory::/items/enhancers_bottoms::5" (level 5)
            // 3. Direct HRID like "/items/enhancers_bottoms" (no level)

            let itemHrid = null;
            let level = 0; // Default to 0 if not specified

            // Split by :: to parse components
            const parts = primaryItemHash.split('::');

            // Find the part that starts with /items/
            const itemPart = parts.find((part) => part.startsWith('/items/'));
            if (itemPart) {
                itemHrid = itemPart;
            }
            // If no /items/ found but it's a direct HRID
            else if (primaryItemHash.startsWith('/items/')) {
                itemHrid = primaryItemHash;
            }

            // Try to extract enhancement level (last part after ::)
            const lastPart = parts[parts.length - 1];
            if (lastPart && !lastPart.startsWith('/')) {
                const parsedLevel = parseInt(lastPart, 10);
                if (!isNaN(parsedLevel)) {
                    level = parsedLevel;
                }
            }

            return { itemHrid, level };
        } catch {
            return { itemHrid: null, level: 0 };
        }
    }

    /**
     * Get enhancement materials and costs for an item
     * Based on Ultimate Enhancement Tracker's getEnhancementMaterials function
     * @param {string} itemHrid - Item HRID
     * @returns {Array|null} Array of [hrid, count] pairs or null
     */
    function getEnhancementMaterials(itemHrid) {
        try {
            const gameData = dataManager$1.getInitClientData();
            const itemData = gameData?.itemDetailMap?.[itemHrid];

            if (!itemData) {
                return null;
            }

            // Get the costs array
            const costs = itemData.enhancementCosts;

            if (!costs) {
                return null;
            }

            let materials = [];

            // Case 1: Array of objects (current format)
            if (Array.isArray(costs) && costs.length > 0 && typeof costs[0] === 'object') {
                materials = costs.map((cost) => [cost.itemHrid, cost.count]);
            }
            // Case 2: Already in correct format [["/items/foo", 30], ["/items/bar", 20]]
            else if (Array.isArray(costs) && costs.length > 0 && Array.isArray(costs[0])) {
                materials = costs;
            }
            // Case 3: Object format {"/items/foo": 30, "/items/bar": 20}
            else if (typeof costs === 'object' && !Array.isArray(costs)) {
                materials = Object.entries(costs);
            }

            // Filter out any invalid entries
            materials = materials.filter(
                (m) => Array.isArray(m) && m.length === 2 && typeof m[0] === 'string' && typeof m[1] === 'number'
            );

            return materials.length > 0 ? materials : null;
        } catch {
            return null;
        }
    }

    /**
     * Track material costs for current attempt
     * Based on Ultimate Enhancement Tracker's trackMaterialCosts function
     * @param {string} itemHrid - Item HRID
     * @returns {Promise<{materialCost: number, coinCost: number}>}
     */
    async function trackMaterialCosts(itemHrid) {
        const materials = getEnhancementMaterials(itemHrid) || [];
        let materialCost = 0;
        let coinCost = 0;

        for (const [resourceHrid, count] of materials) {
            // Check if this is coins
            if (resourceHrid.includes('/items/coin')) {
                // Track coins for THIS ATTEMPT ONLY
                coinCost = count; // Coins are 1:1 value
                await enhancementTracker.trackCoinCost(count);
            } else {
                // Track material costs
                await enhancementTracker.trackMaterialCost(resourceHrid, count);
                // Add to material cost total
                const priceData = marketAPI.getPrice(resourceHrid, 0);
                const unitCost = priceData ? priceData.ask || priceData.bid || 0 : 0;
                materialCost += unitCost * count;
            }
        }

        return { materialCost, coinCost };
    }

    /**
     * Handle enhancement result (success or failure)
     * @param {Object} action - Enhancement action data
     * @param {Object} _data - Full WebSocket message data
     */
    async function handleEnhancementResult(action, _data) {
        try {
            const { itemHrid, level: newLevel } = parseItemHash(action.primaryItemHash);
            const rawCount = action.currentCount || 0;

            if (!itemHrid) {
                return;
            }

            // Check for item changes on EVERY attempt (not just rawCount === 1)
            let currentSession = enhancementTracker.getCurrentSession();
            let justCreatedNewSession = false;

            // If session exists but is for a different item, finalize and start new session
            if (currentSession && currentSession.itemHrid !== itemHrid) {
                await enhancementTracker.finalizeCurrentSession();
                currentSession = null;

                // Create new session for the new item
                const protectFrom = action.enhancingProtectionMinLevel || 0;
                const targetLevel = action.enhancingMaxLevel || Math.min(newLevel + 5, 20);

                // Infer starting level from current level
                let startLevel = newLevel;
                if (newLevel > 0 && newLevel < Math.max(2, protectFrom)) {
                    startLevel = newLevel - 1;
                }

                const sessionId = await enhancementTracker.startSession(itemHrid, startLevel, targetLevel, protectFrom);
                currentSession = enhancementTracker.getCurrentSession();
                justCreatedNewSession = true; // Flag that we just created this session

                // Switch UI to new session and update display
                enhancementUI.switchToSession(sessionId);
                enhancementUI.scheduleUpdate();
            }

            // On first attempt (rawCount === 1), start session if auto-start is enabled
            // BUT: Ignore if we already have an active session (handles out-of-order events)
            if (rawCount === 1) {
                // Skip early return if we just created a session for item change
                if (!justCreatedNewSession && currentSession && currentSession.itemHrid === itemHrid) {
                    // Already have a session for this item, ignore this late rawCount=1 event
                    return;
                }

                if (!currentSession) {
                    // CRITICAL: On first event, primaryItemHash shows RESULT level, not starting level
                    // We need to infer the starting level from the result
                    const protectFrom = action.enhancingProtectionMinLevel || 0;
                    let startLevel = newLevel;

                    // If result > 0 and below protection threshold, must have started one level lower
                    if (newLevel > 0 && newLevel < Math.max(2, protectFrom)) {
                        startLevel = newLevel - 1; // Successful enhancement (e.g., 0→1)
                    }
                    // Otherwise, started at same level (e.g., 0→0 failure, or protected failure)

                    // Always start new session when tracker is enabled
                    const targetLevel = action.enhancingMaxLevel || Math.min(newLevel + 5, 20);
                    const sessionId = await enhancementTracker.startSession(itemHrid, startLevel, targetLevel, protectFrom);
                    currentSession = enhancementTracker.getCurrentSession();

                    // Switch UI to new session and update display
                    enhancementUI.switchToSession(sessionId);
                    enhancementUI.scheduleUpdate();

                    if (!currentSession) {
                        return;
                    }
                }
            }

            // If no active session, check if we can extend a completed session
            if (!currentSession) {
                // Try to extend a completed session for the same item
                const extendableSessionId = enhancementTracker.findExtendableSession(itemHrid, newLevel);
                if (extendableSessionId) {
                    const newTarget = Math.min(newLevel + 5, 20);
                    await enhancementTracker.extendSessionTarget(extendableSessionId, newTarget);
                    currentSession = enhancementTracker.getCurrentSession();

                    // Switch UI to extended session and update display
                    enhancementUI.switchToSession(extendableSessionId);
                    enhancementUI.scheduleUpdate();
                } else {
                    return;
                }
            }

            // Calculate adjusted attempt count (resume-proof)
            const adjustedCount = calculateAdjustedAttemptCount(currentSession);

            // Track costs for EVERY attempt (including first)
            const { materialCost: _materialCost, coinCost: _coinCost } = await trackMaterialCosts(itemHrid);

            // Get previous level from lastAttempt
            const previousLevel = currentSession.lastAttempt?.level ?? currentSession.startLevel;

            // Check protection item usage BEFORE recording attempt
            // Track protection cost if protection item exists in action data
            // Protection items are consumed when:
            // 1. Level would have decreased (Mirror of Protection prevents decrease, level stays same)
            // 2. Level increased (Philosopher's Mirror guarantees success)
            const protectionItemHrid = getProtectionItemHrid(action);
            if (protectionItemHrid) {
                // Only track if we're at a level where protection might be used
                // (either level stayed same when it could have decreased, or succeeded at high level)
                const protectFrom = currentSession.protectFrom || 0;
                const shouldTrack = previousLevel >= Math.max(2, protectFrom);

                if (shouldTrack && (newLevel <= previousLevel || newLevel === previousLevel + 1)) {
                    // Use market price (like Ultimate Tracker) instead of vendor price
                    const marketPrice = marketAPI.getPrice(protectionItemHrid, 0);
                    let protectionCost = marketPrice?.ask || marketPrice?.bid || 0;

                    // Fall back to vendor price if market price unavailable
                    if (protectionCost === 0) {
                        const gameData = dataManager$1.getInitClientData();
                        const protectionItem = gameData?.itemDetailMap?.[protectionItemHrid];
                        protectionCost = protectionItem?.vendorSellPrice || 0;
                    }

                    await enhancementTracker.trackProtectionCost(protectionItemHrid, protectionCost);
                }
            }

            // Determine result type
            const wasSuccess = newLevel > previousLevel;

            // Failure detection:
            // 1. Level decreased (1→0, 5→4, etc.)
            // 2. Stayed at 0 (0→0 fail)
            // 3. Stayed at non-zero level WITH protection item (protected failure)
            const levelDecreased = newLevel < previousLevel;
            const failedAtZero = previousLevel === 0 && newLevel === 0;
            const protectedFailure = previousLevel > 0 && newLevel === previousLevel && protectionItemHrid !== null;
            const wasFailure = levelDecreased || failedAtZero || protectedFailure;

            const _wasBlessed = wasSuccess && newLevel - previousLevel >= 2; // Blessed tea detection

            // Update lastAttempt BEFORE recording (so next attempt compares correctly)
            currentSession.lastAttempt = {
                attemptNumber: adjustedCount,
                level: newLevel,
                timestamp: Date.now(),
            };

            // Record the result and track XP
            if (wasSuccess) {
                const xpGain = calculateSuccessXP(previousLevel, itemHrid);
                currentSession.totalXP += xpGain;

                await enhancementTracker.recordSuccess(previousLevel, newLevel);
                enhancementUI.scheduleUpdate(); // Update UI after success

                // Check if we've reached target
                if (newLevel >= currentSession.targetLevel) {
                    // Target reached - session will auto-complete on next UI update
                }
            } else if (wasFailure) {
                const xpGain = calculateFailureXP(previousLevel, itemHrid);
                currentSession.totalXP += xpGain;

                await enhancementTracker.recordFailure(previousLevel);
                enhancementUI.scheduleUpdate(); // Update UI after failure
            }
            // Note: If newLevel === previousLevel (and not 0->0), we track costs but don't record attempt
            // This happens with protection items that prevent level decrease
        } catch {
            // Silent failure
        }
    }

    /**
     * Cleanup event handlers
     */
    function cleanupEnhancementHandlers() {
        webSocketHook$1.off('action_completed', handleActionCompleted);
        webSocketHook$1.off('*', handleDebugMessage);
    }

    /**
     * Enhancement Feature Wrapper
     * Manages initialization and cleanup of all enhancement-related components
     * Fixes handler accumulation by coordinating tracker, UI, and handlers
     */


    class EnhancementFeature {
        constructor() {
            this.isInitialized = false;
        }

        /**
         * Initialize all enhancement components
         */
        async initialize() {
            if (this.isInitialized) {
                return;
            }

            this.isInitialized = true;

            // Initialize tracker (async)
            await enhancementTracker.initialize();

            // Setup WebSocket handlers
            setupEnhancementHandlers();

            // Initialize UI
            enhancementUI.initialize();
        }

        /**
         * Cleanup all enhancement components
         */
        disable() {
            // Cleanup WebSocket handlers
            cleanupEnhancementHandlers();

            // Cleanup UI
            enhancementUI.cleanup();

            // Cleanup tracker (has its own disable method)
            if (enhancementTracker.disable) {
                enhancementTracker.disable();
            }

            this.isInitialized = false;
        }
    }

    const enhancementFeature = new EnhancementFeature();

    /**
     * Empty Queue Notification
     * Sends browser notification when action queue becomes empty
     */


    class EmptyQueueNotification {
        constructor() {
            this.wasEmpty = false;
            this.unregisterHandlers = [];
            this.permissionGranted = false;
            this.characterSwitchingHandler = null;
            this.timerRegistry = createTimerRegistry();
        }

        /**
         * Initialize empty queue notification
         */
        async initialize() {
            if (!config$1.getSetting('notifiEmptyAction')) {
                return;
            }

            // Request notification permission
            await this.requestPermission();

            // Listen for action updates
            this.registerWebSocketListeners();

            this.characterSwitchingHandler = () => {
                this.disable();
            };

            dataManager$1.on('character_switching', this.characterSwitchingHandler);
        }

        /**
         * Request browser notification permission
         */
        async requestPermission() {
            if (!('Notification' in window)) {
                console.warn('[Empty Queue Notification] Browser notifications not supported');
                return;
            }

            if (Notification.permission === 'granted') {
                this.permissionGranted = true;
                return;
            }

            if (Notification.permission !== 'denied') {
                try {
                    const permission = await Notification.requestPermission();
                    this.permissionGranted = permission === 'granted';
                } catch (error) {
                    console.warn('[Empty Queue Notification] Permission request failed:', error);
                }
            }
        }

        /**
         * Register WebSocket message listeners
         */
        registerWebSocketListeners() {
            const actionsHandler = (data) => {
                this.checkActionQueue(data);
            };

            webSocketHook$1.on('actions_updated', actionsHandler);

            this.unregisterHandlers.push(() => {
                webSocketHook$1.off('actions_updated', actionsHandler);
            });
        }

        /**
         * Check if action queue is empty and send notification
         * @param {Object} _data - WebSocket data (unused, but kept for handler signature)
         */
        checkActionQueue(_data) {
            if (!config$1.getSetting('notifiEmptyAction')) {
                return;
            }

            if (!this.permissionGranted) {
                return;
            }

            // Get current actions from dataManager (source of truth for all queued actions)
            const allActions = dataManager$1.getCurrentActions();
            const isEmpty = allActions.length === 0;

            // Only notify on transition from not-empty to empty
            if (isEmpty && !this.wasEmpty) {
                this.sendNotification();
            }

            this.wasEmpty = isEmpty;
        }

        /**
         * Send browser notification
         */
        sendNotification() {
            try {
                if (typeof Notification === 'undefined') {
                    console.error('[Empty Queue Notification] Notification API not available');
                    return;
                }

                if (Notification.permission !== 'granted') {
                    console.error('[Empty Queue Notification] Notification permission not granted');
                    return;
                }

                // Use standard Notification API
                const notification = new Notification('Milky Way Idle', {
                    body: 'Your action queue is empty!',
                    icon: 'https://www.milkywayidle.com/favicon.ico',
                    tag: 'empty-queue',
                    requireInteraction: false,
                });

                notification.onclick = () => {
                    window.focus();
                    notification.close();
                };

                notification.onerror = (error) => {
                    console.error('[Empty Queue Notification] Notification error:', error);
                };

                // Auto-close after 5 seconds
                const closeTimeout = setTimeout(() => notification.close(), 5000);
                this.timerRegistry.registerTimeout(closeTimeout);
            } catch (error) {
                console.error('[Empty Queue Notification] Failed to send notification:', error);
            }
        }

        /**
         * Cleanup
         */
        disable() {
            if (this.characterSwitchingHandler) {
                dataManager$1.off('character_switching', this.characterSwitchingHandler);
                this.characterSwitchingHandler = null;
            }

            this.unregisterHandlers.forEach((unregister) => unregister());
            this.unregisterHandlers = [];
            this.wasEmpty = false;
            this.timerRegistry.clearAll();
        }
    }

    const emptyQueueNotification = new EmptyQueueNotification();

    /**
     * UI Library
     * UI enhancements, tasks, skills, house, settings, and misc features
     *
     * Exports to: window.Toolasha.UI
     */


    // Export to global namespace
    const toolashaRoot = window.Toolasha || {};
    window.Toolasha = toolashaRoot;

    if (typeof unsafeWindow !== 'undefined') {
        unsafeWindow.Toolasha = toolashaRoot;
    }

    toolashaRoot.UI = {
        equipmentLevelDisplay,
        alchemyItemDimming,
        skillExperiencePercentage,
        externalLinks,
        taskProfitDisplay,
        taskRerollTracker,
        taskSorter,
        taskIcons,
        remainingXP,
        housePanelObserver,
        settingsUI,
        transmuteRates,
        enhancementFeature,
        emptyQueueNotification,
    };

    console.log('[Toolasha] UI library loaded');

    /**
     * Toolasha Entrypoint
     * Minimal bootstrap script that loads libraries and initializes features
     *
     * Libraries are loaded via @require in userscript header:
     * - Core (core modules, API)
     * - Utils (all utilities)
     * - Market (market, inventory, economy)
     * - Actions (production, gathering, alchemy)
     * - Combat (combat, stats, abilities)
     * - UI (tasks, skills, settings, misc)
     */

    // Environment mismatch detection
    (function checkBuildEnvironment() {
        const buildTarget = window.Toolasha?.__buildTarget;
        const hasScriptManager = typeof GM !== 'undefined' || typeof GM_info !== 'undefined';

        if (buildTarget === 'browser' && !hasScriptManager) {
            alert(
                'Toolasha: Wrong build installed!\n\n' +
                    'You have the BROWSER build installed, but you are running on Steam.\n' +
                    'The browser build requires Tampermonkey and will not work on Steam.\n\n' +
                    'Please install the Steam build instead.'
            );
            throw new Error('[Toolasha] Browser build cannot run on Steam. Install the Steam build.');
        }
        if (buildTarget === 'steam' && hasScriptManager) {
            alert(
                'Toolasha: Wrong build installed!\n\n' +
                    'You have the STEAM build installed, but you are running in a browser.\n' +
                    'The Steam build is unnecessarily large for browser use.\n\n' +
                    'Please install the browser build instead.'
            );
            throw new Error('[Toolasha] Steam build should not run in a browser. Install the browser build.');
        }
    })();

    // Access libraries from global namespace
    const Core = window.Toolasha.Core;
    const Utils = window.Toolasha.Utils;
    const Market = window.Toolasha.Market;
    const Actions = window.Toolasha.Actions;
    const Combat = window.Toolasha.Combat;
    const UI = window.Toolasha.UI;

    // Destructure core modules
    const { storage, config, webSocketHook, domObserver, dataManager, featureRegistry } = Core;

    const { setupScrollTooltipDismissal } = Utils.dom;

    /**
     * Detect if running on Combat Simulator page
     * @returns {boolean} True if on Combat Simulator
     */
    function isCombatSimulatorPage() {
        const url = window.location.href;
        // Only work on test Combat Simulator for now
        return url.includes('shykai.github.io/MWICombatSimulatorTest/dist/');
    }

    /**
     * Register all features from libraries into the feature registry
     */
    function registerFeatures() {
        // Market Features
        const marketFeatures = [
            { key: 'tooltipPrices', name: 'Tooltip Prices', category: 'Market', module: Market.tooltipPrices, async: true },
            {
                key: 'expectedValueCalculator',
                name: 'Expected Value Calculator',
                category: 'Market',
                module: Market.expectedValueCalculator,
                async: true,
            },
            {
                key: 'tooltipConsumables',
                name: 'Tooltip Consumables',
                category: 'Market',
                module: Market.tooltipConsumables,
                async: true,
            },
            {
                key: 'dungeonTokenTooltips',
                name: 'Dungeon Token Tooltips',
                category: 'Inventory',
                module: Market.dungeonTokenTooltips,
                async: true,
            },
            { key: 'marketFilter', name: 'Market Filter', category: 'Market', module: Market.marketFilter, async: false },
            {
                key: 'autoFillPrice',
                name: 'Auto Fill Price',
                category: 'Market',
                module: Market.autoFillPrice,
                async: false,
            },
            {
                key: 'autoClickMax',
                name: 'Auto Click Max',
                category: 'Market',
                module: Market.autoClickMax,
                async: false,
            },
            {
                key: 'itemCountDisplay',
                name: 'Item Count Display',
                category: 'Market',
                module: Market.itemCountDisplay,
                async: false,
            },
            {
                key: 'listingPriceDisplay',
                name: 'Listing Price Display',
                category: 'Market',
                module: Market.listingPriceDisplay,
                async: false,
            },
            {
                key: 'estimatedListingAge',
                name: 'Estimated Listing Age',
                category: 'Market',
                module: Market.estimatedListingAge,
                async: false,
            },
            {
                key: 'marketOrderTotals',
                name: 'Market Order Totals',
                category: 'Market',
                module: Market.marketOrderTotals,
                async: false,
            },
            {
                key: 'marketHistoryViewer',
                name: 'Market History Viewer',
                category: 'Market',
                module: Market.marketHistoryViewer,
                async: false,
            },
            {
                key: 'philoCalculator',
                name: 'Philo Calculator',
                category: 'Market',
                module: Market.philoCalculator,
                async: false,
            },
            { key: 'tradeHistory', name: 'Trade History', category: 'Market', module: Market.tradeHistory, async: false },
            {
                key: 'tradeHistoryDisplay',
                name: 'Trade History Display',
                category: 'Market',
                module: Market.tradeHistoryDisplay,
                async: false,
            },
            { key: 'networth', name: 'Net Worth', category: 'Economy', module: Market.networthFeature, async: false },
            {
                key: 'inventoryBadgeManager',
                name: 'Inventory Badge Manager',
                category: 'Inventory',
                module: Market.inventoryBadgeManager,
                async: false,
            },
            {
                key: 'inventorySort',
                name: 'Inventory Sort',
                category: 'Inventory',
                module: Market.inventorySort,
                async: false,
            },
            {
                key: 'inventoryBadgePrices',
                name: 'Inventory Badge Prices',
                category: 'Inventory',
                module: Market.inventoryBadgePrices,
                async: false,
            },
        ];

        // Actions Features
        const actionsFeatures = [
            {
                key: 'actionTimeDisplay',
                name: 'Action Time Display',
                category: 'Actions',
                module: Actions.actionTimeDisplay,
                async: false,
            },
            {
                key: 'quickInputButtons',
                name: 'Quick Input Buttons',
                category: 'Actions',
                module: Actions.quickInputButtons,
                async: false,
            },
            { key: 'outputTotals', name: 'Output Totals', category: 'Actions', module: Actions.outputTotals, async: false },
            {
                key: 'maxProduceable',
                name: 'Max Produceable',
                category: 'Actions',
                module: Actions.maxProduceable,
                async: false,
            },
            {
                key: 'gatheringStats',
                name: 'Gathering Stats',
                category: 'Actions',
                module: Actions.gatheringStats,
                async: false,
            },
            {
                key: 'requiredMaterials',
                name: 'Required Materials',
                category: 'Actions',
                module: Actions.requiredMaterials,
                async: false,
            },
            {
                key: 'missingMaterialsButton',
                name: 'Missing Materials Button',
                category: 'Actions',
                module: Actions.missingMaterialsButton,
                async: false,
            },
            {
                key: 'alchemyProfitDisplay',
                name: 'Alchemy Profit Display',
                category: 'Alchemy',
                module: Actions.alchemyProfitDisplay,
                async: false,
            },
        ];

        // Combat Features
        const combatFeatures = [
            {
                key: 'abilityBookCalculator',
                name: 'Ability Book Calculator',
                category: 'Combat',
                module: Combat.abilityBookCalculator,
                async: false,
            },
            { key: 'zoneIndices', name: 'Zone Indices', category: 'Combat', module: Combat.zoneIndices, async: false },
            { key: 'combatScore', name: 'Combat Score', category: 'Profile', module: Combat.combatScore, async: false },
            {
                key: 'characterCardButton',
                name: 'Character Card Button',
                category: 'Profile',
                module: Combat.characterCardButton,
                async: false,
            },
            {
                key: 'dungeonTracker',
                name: 'Dungeon Tracker',
                category: 'Combat',
                module: Combat.dungeonTracker,
                async: false,
            },
            {
                key: 'dungeonTrackerUI',
                name: 'Dungeon Tracker UI',
                category: 'Combat',
                module: Combat.dungeonTrackerUI,
                async: false,
            },
            {
                key: 'dungeonTrackerChatAnnotations',
                name: 'Dungeon Tracker Chat',
                category: 'Combat',
                module: Combat.dungeonTrackerChatAnnotations,
                async: false,
            },
            {
                key: 'combatSummary',
                name: 'Combat Summary',
                category: 'Combat',
                module: Combat.combatSummary,
                async: false,
            },
            { key: 'combatStats', name: 'Combat Stats', category: 'Combat', module: Combat.combatStats, async: false },
        ];

        // UI Features
        const uiFeatures = [
            {
                key: 'equipmentLevelDisplay',
                name: 'Equipment Level Display',
                category: 'UI',
                module: UI.equipmentLevelDisplay,
                async: false,
            },
            {
                key: 'alchemyItemDimming',
                name: 'Alchemy Item Dimming',
                category: 'UI',
                module: UI.alchemyItemDimming,
                async: false,
            },
            {
                key: 'skillExperiencePercentage',
                name: 'Skill Experience Percentage',
                category: 'UI',
                module: UI.skillExperiencePercentage,
                async: false,
            },
            { key: 'externalLinks', name: 'External Links', category: 'UI', module: UI.externalLinks, async: false },
            {
                key: 'taskProfitDisplay',
                name: 'Task Profit Display',
                category: 'Tasks',
                module: UI.taskProfitDisplay,
                async: false,
            },
            {
                key: 'taskRerollTracker',
                name: 'Task Reroll Tracker',
                category: 'Tasks',
                module: UI.taskRerollTracker,
                async: false,
            },
            { key: 'taskSorter', name: 'Task Sorter', category: 'Tasks', module: UI.taskSorter, async: false },
            { key: 'taskIcons', name: 'Task Icons', category: 'Tasks', module: UI.taskIcons, async: false },
            { key: 'skillRemainingXP', name: 'Remaining XP', category: 'Skills', module: UI.remainingXP, async: false },
            {
                key: 'housePanelObserver',
                name: 'House Panel Observer',
                category: 'House',
                module: UI.housePanelObserver,
                async: false,
            },
            {
                key: 'transmuteRates',
                name: 'Transmute Rates',
                category: 'Dictionary',
                module: UI.transmuteRates,
                async: false,
            },
            {
                key: 'enhancementFeature',
                name: 'Enhancement Tracker',
                category: 'Enhancement',
                module: UI.enhancementFeature,
                async: false,
            },
            {
                key: 'emptyQueueNotification',
                name: 'Empty Queue Notification',
                category: 'Notifications',
                module: UI.emptyQueueNotification,
                async: false,
            },
        ];

        // Combine all features
        const allFeatures = [...marketFeatures, ...actionsFeatures, ...combatFeatures, ...uiFeatures];

        // Convert to feature registry format
        const features = allFeatures.map((feature) => ({
            key: feature.key,
            name: feature.name,
            category: feature.category,
            initialize: () => feature.module.initialize(),
            async: feature.async,
        }));

        // Replace feature registry's features array
        featureRegistry.replaceFeatures(features);
    }

    if (isCombatSimulatorPage()) {
        // Initialize combat sim integration only
        Combat.combatSimIntegration.initialize();

        // Skip all other initialization
    } else {
        // CRITICAL: Install WebSocket hook FIRST, before game connects
        webSocketHook.install();

        // CRITICAL: Start centralized DOM observer SECOND, before features initialize
        domObserver.start();

        // Set up scroll listener to dismiss stuck tooltips
        setupScrollTooltipDismissal();

        // Initialize network alert (must be early, before market features)
        Market.networkAlert.initialize();

        // Start capturing client data from localStorage (for Combat Sim export)
        webSocketHook.captureClientDataFromLocalStorage();

        // Register all features from libraries
        registerFeatures();

        // Initialize action panel observer (special case - not a regular feature)
        Actions.initActionPanelObserver();

        // Initialize storage and config THIRD (async)
        (async () => {
            try {
                // Initialize storage (opens IndexedDB)
                await storage.initialize();

                // Initialize config (loads settings from storage)
                await config.initialize();

                // Add beforeunload handler to flush all pending writes
                window.addEventListener('beforeunload', () => {
                    storage.flushAll();
                });

                // Initialize Data Manager immediately
                // Don't wait for localStorageUtil - it handles missing data gracefully
                dataManager.initialize();
            } catch (error) {
                console.error('[Toolasha] Storage/config initialization failed:', error);
                // Initialize anyway
                dataManager.initialize();
            }
        })();

        // Setup character switch handler once (NOT inside character_initialized listener)
        featureRegistry.setupCharacterSwitchHandler();

        dataManager.on('character_initialized', (_data) => {
            // Skip full initialization during character switches
            // The character_switched handler in feature-registry already handles reinitialization
            if (_data._isCharacterSwitch) {
                return;
            }

            // Initialize all features using the feature registry
            setTimeout(async () => {
                try {
                    // Reload config settings with character-specific data
                    await config.loadSettings();
                    config.applyColorSettings();

                    // Initialize Settings UI after character data is loaded
                    await UI.settingsUI.initialize().catch((error) => {
                        console.error('[Toolasha] Settings UI initialization failed:', error);
                    });

                    await featureRegistry.initializeFeatures();

                    // Health check after initialization
                    setTimeout(async () => {
                        const failedFeatures = featureRegistry.checkFeatureHealth();

                        // Note: Settings tab health check removed - tab only appears when user opens settings panel

                        if (failedFeatures.length > 0) {
                            console.warn(
                                '[Toolasha] Health check found failed features:',
                                failedFeatures.map((f) => f.name)
                            );

                            setTimeout(async () => {
                                await featureRegistry.retryFailedFeatures(failedFeatures);

                                // Final health check
                                const stillFailed = featureRegistry.checkFeatureHealth();
                                if (stillFailed.length > 0) {
                                    console.warn(
                                        '[Toolasha] These features could not initialize:',
                                        stillFailed.map((f) => f.name)
                                    );
                                    console.warn(
                                        '[Toolasha] Try refreshing the page or reopening the relevant game panels'
                                    );
                                }
                            }, 1000);
                        }
                    }, 500); // Wait 500ms after initialization to check health
                } catch (error) {
                    console.error('[Toolasha] Feature initialization failed:', error);
                }
            }, 100);
        });

        // Expose minimal user-facing API
        const targetWindow = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;

        targetWindow.Toolasha.version = '0.14.3';

        // Feature toggle API (for users to manage settings via console)
        targetWindow.Toolasha.features = {
            list: () => config.getFeaturesByCategory(),
            enable: (key) => config.setFeatureEnabled(key, true),
            disable: (key) => config.setFeatureEnabled(key, false),
            toggle: (key) => config.toggleFeature(key),
            status: (key) => config.isFeatureEnabled(key),
            info: (key) => config.getFeatureInfo(key),
        };
    }

    /**
     * Toolasha Dev Entrypoint
     * Bundles libraries and entrypoint into a single file for local testing.
     */

    // Environment mismatch detection
    (function checkBuildEnvironment() {
        const buildTarget = window.Toolasha?.__buildTarget;
        const hasScriptManager = typeof GM !== 'undefined' || typeof GM_info !== 'undefined';

        if (buildTarget === 'browser' && !hasScriptManager) {
            alert(
                'Toolasha: Wrong build installed!\n\n' +
                    'You have the BROWSER build installed, but you are running on Steam.\n' +
                    'The browser build requires Tampermonkey and will not work on Steam.\n\n' +
                    'Please install the Steam build instead.'
            );
            throw new Error('[Toolasha] Browser build cannot run on Steam. Install the Steam build.');
        }
        if (buildTarget === 'steam' && hasScriptManager) {
            alert(
                'Toolasha: Wrong build installed!\n\n' +
                    'You have the STEAM build installed, but you are running in a browser.\n' +
                    'The Steam build is unnecessarily large for browser use.\n\n' +
                    'Please install the browser build instead.'
            );
            throw new Error('[Toolasha] Steam build should not run in a browser. Install the browser build.');
        }
    })();

})();
